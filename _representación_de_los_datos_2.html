<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.17">
<meta name="keywords" content="computer, architecture">
<meta name="author" content="Cándido Aramburu">
<title>Estructura de Computadores  (240306)</title>
<style>
@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";
@import "https://cdn.jsdelivr.net/gh/asciidoctor/asciidoctor@2.0/data/stylesheets/asciidoctor-default.css";



h1, h2, h3, h4, h5, h6, #toctitle,
.sidebarblock > .content > .title {
  color: rgba(221, 72, 20, 0.8);
}



</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<!-- Change some CSS.
<style>
.imageblock{
  &.text-center > .title {
    text-align: center !important;
  }
}
</style>

-->

<style type="text/css"> .imageblock > .title { text-align: center; } </style>

<style>.toc-current{font-weight: bold;} .toc-root{font-family: "Open Sans","DejaVu Sans",sans-serif;
                       font-size: 0.9em;} #content{display: flex; flex-direction: column; flex: 1 1 auto;}
             .nav-footer{text-align: center; margin-top: auto;}
             .nav-footer > p > a {white-space: nowrap;}</style>
</head>
<body id="_representación_de_los_datos_2" class="book">
<div id="header">
<h1>Estructura de Computadores  (240306)</h1>
<div class="details">
<span id="author" class="author">Cándido Aramburu</span><br>
<span id="email" class="email"><a href="mailto:candido@unavarra.es">candido@unavarra.es</a></span><br>
<span id="revdate">2022-09-04</span>
</div>
<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<p><span class="toc-root"><a href="eecc_book.html">Estructura de Computadores  (240306)</a></span></p><ul class="sectlevel0">
<li><a href="_i_arquitectura_del_repertorio_de_instrucciones_isa_computadora_von_neumann_datos_instrucciones_programación.html">I Arquitectura del Repertorio de Instrucciones (ISA): computadora von Neumann, datos, instrucciones, programación.</a>
</li>
<li><a href="_ii_unidades_básicas_procesador_central_unidad_de_memoria_mecanismos_entradasalida.html">II Unidades Básicas: Procesador Central, Unidad de Memoria, Mecanismos Entrada/Salida.</a>
</li>
<li><a href="_iii_ejercicios_de_teoría.html">III Ejercicios de Teoría</a>
</li>
<li><a href="_iv_autoevaluación_teoría.html">IV Autoevaluación Teoría</a>
</li>
<li><a href="_v_guiones_de_prácticas_programación_ensamblador_x86.html">V Guiones de Prácticas: Programación Ensamblador x86</a>
<ul class="sectlevel1">
<li><a href="_introducción_a_la_programación_en_lenguaje_ensamblador_att_x86_32.html">12. Introducción a la Programación en Lenguaje Ensamblador AT&amp;T x86-32</a>
</li>
<li><a href="_representación_de_los_datos_2.html"><span class="toc-current">13. Representación de los Datos</span></a>
<ul class="sectlevel2">
<li><a href="_representación_de_los_datos_2.html#_introducción_16">13.1. Introducción</a>
<ul class="sectlevel3">
<li><a href="_representación_de_los_datos_2.html#_objetivos_4">13.1.1. Objetivos</a>
</li>
<li><a href="_representación_de_los_datos_2.html#_módulos_fuente">13.1.2. Módulos fuente</a>
</li>
<li><a href="_representación_de_los_datos_2.html#_requisitos_4">13.1.3. Requisitos</a>
</li>
</ul>
</li>
<li><a href="_representación_de_los_datos_2.html#_leeme_2">13.2. LEEME</a>
</li>
<li><a href="_representación_de_los_datos_2.html#_cuestiones_3">13.3. Cuestiones</a>
</li>
<li><a href="_representación_de_los_datos_2.html#_registros_internos_de_la_cpu">13.4. Registros internos de la CPU</a>
</li>
<li><a href="_representación_de_los_datos_2.html#_tamaño_de_los_datos_y_variables">13.5. Tamaño de los datos y variables</a>
<ul class="sectlevel3">
<li><a href="_representación_de_los_datos_2.html#_algoritmo_3">13.5.1. Algoritmo</a>
</li>
<li><a href="_representación_de_los_datos_2.html#_edición_del_módulo_fuente_datos_size_s">13.5.2. Edición del Módulo fuente: datos_size.s</a>
</li>
<li><a href="_representación_de_los_datos_2.html#_compilación_3">13.5.3. Compilación</a>
</li>
<li><a href="_representación_de_los_datos_2.html#_ejecución_3">13.5.4. Ejecución</a>
</li>
<li><a href="_representación_de_los_datos_2.html#_análisis_del_módulo_fuente_2">13.5.5. Análisis del módulo fuente</a>
</li>
<li><a href="_representación_de_los_datos_2.html#_ejecución_paso_a_paso_2">13.5.6. Ejecución paso a paso</a>
</li>
</ul>
</li>
<li><a href="_representación_de_los_datos_2.html#_tamaño_de_los_operandos">13.6. Tamaño de los Operandos</a>
<ul class="sectlevel3">
<li><a href="_representación_de_los_datos_2.html#_edición_del_módulo_fuente_datos_sufijos_s">13.6.1. Edición del Módulo fuente: datos_sufijos.s</a>
</li>
<li><a href="_representación_de_los_datos_2.html#_compilación_4">13.6.2. Compilación</a>
</li>
<li><a href="_representación_de_los_datos_2.html#_ejecución_4">13.6.3. Ejecución</a>
</li>
<li><a href="_representación_de_los_datos_2.html#_análisis_del_módulo_fuente_3">13.6.4. Análisis del módulo fuente</a>
</li>
<li><a href="_representación_de_los_datos_2.html#_deducción_del_tamaño_del_operando_en_una_instrucción">13.6.5. Deducción del tamaño del operando en una instrucción</a>
</li>
<li><a href="_representación_de_los_datos_2.html#_ejecución_paso_a_paso_3">13.6.6. Ejecución paso a paso</a>
</li>
</ul>
</li>
<li><a href="_representación_de_los_datos_2.html#_modos_de_direccionamiento_3">13.7. Modos de Direccionamiento</a>
<ul class="sectlevel3">
<li><a href="_representación_de_los_datos_2.html#_edición_del_módulo_fuente_datos_direccionamiento_s">13.7.1. Edición del Módulo fuente: datos_direccionamiento.s</a>
</li>
<li><a href="_representación_de_los_datos_2.html#_compilación_5">13.7.2. Compilación</a>
</li>
<li><a href="_representación_de_los_datos_2.html#_ejecución_5">13.7.3. Ejecución</a>
</li>
<li><a href="_representación_de_los_datos_2.html#_análisis_del_módulo_fuente_4">13.7.4. Análisis del módulo fuente</a>
</li>
<li><a href="_representación_de_los_datos_2.html#_ejecución_paso_a_paso_4">13.7.5. Ejecución paso a paso</a>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="_operaciones_aritméticas_y_lógicas.html">14. Operaciones Aritméticas y Lógicas</a>
</li>
<li><a href="_instrucciones_de_saltos_condicionales.html">15. Instrucciones de Saltos Condicionales</a>
</li>
<li><a href="_llamadas_al_sistema_operativo_kernel.html">16. LLamadas al Sistema Operativo (Kernel)</a>
</li>
<li><a href="_subrutinas_2.html">17. Subrutinas</a>
</li>
<li><a href="_imágenes_bit_map_portable.html">18. Imágenes: Bit Map Portable</a>
</li>
</ul>
</li>
<li><a href="_vi_hojas_de_referencia_rápida.html">VI Hojas de Referencia Rápida</a>
</li>
<li><a href="_vii_autoevaluación_prácticas.html">VII Autoevaluación Prácticas</a>
</li>
<li><a href="_viii_apéndices.html">VIII Apéndices</a>
</li>
<li><a href="_ix_bibliografía.html">IX Bibliografía</a>
</li>
<li><a href="_x_glosario.html">X Glosario</a>
</li>
<li><a href="_xi_colofón.html">XI Colofón</a>
</li>
<li><a href="_index.html">Index</a>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_representación_de_los_datos_2">13. Representación de los Datos</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_introducción_16">13.1. Introducción</h3>
<div class="sect3">
<h4 id="_objetivos_4">13.1.1. Objetivos</h4>
<div class="ulist">
<ul>
<li>
<p>Programación:</p>
<div class="ulist">
<ul>
<li>
<p>Desarrollar programas que almacenen y procesen distintos tipos de datos como enteros con signo, caracteres, arrays, strings de distintos tamaños como 1 byte, 2 bytes, 4 bytes, etc..</p>
</li>
<li>
<p>Empleo de los sufijos de los mnemónicos: analizar el tamaño de los operandos según el sufijo del mnemónico empleado, el tamaño del operando registro y el tipo de operando en memoria.</p>
</li>
<li>
<p>Emplear distintos tipos de modos de direccionamiento (inmediato, directo, indirecto, indexado) de acceso a los operandos</p>
</li>
<li>
<p>Empleo de Macros mediante directivas.</p>
</li>
<li>
<p>Concepto de llamada al sistema operativo.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Análisis:</p>
<div class="ulist">
<ul>
<li>
<p>Comprobación del tipo de alineamiento <em>little endian</em> de los datos almacenados en memoria</p>
</li>
<li>
<p>Analizar el contenido de la memoria como números con signo, caracteres, arrays y strings: tipos y tamaños de los operandos numéricos y de los operandos alfanuméricos</p>
</li>
<li>
<p>Realizar la operación de desensamblaje para comprobar el lenguaje máquina del módulo ejecutable cargado en la memoria principal</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_módulos_fuente">13.1.2. Módulos fuente</h4>
<div class="ulist">
<ul>
<li>
<p><strong>datos_size.s</strong></p>
<div class="ulist">
<ul>
<li>
<p>Declaración del tamaño de los operandos:</p>
<div class="ulist">
<ul>
<li>
<p>Mediante las directivas  (.byte, .2byte, .short, etc ..)</p>
</li>
</ul>
</div>
</li>
<li>
<p>Declaración de arrays de datos numéricos mediante directivas (.short,.int, etc ..)</p>
</li>
<li>
<p>Declaración de datos alfanuméricos mediante:</p>
<div class="ulist">
<ul>
<li>
<p>Directivas del ensamblador (.ascii, .asciiz, .string, etc)</p>
</li>
</ul>
</div>
</li>
<li>
<p>Empleo de Macros</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>datos_sufijos.s</strong></p>
<div class="ulist">
<ul>
<li>
<p>Acceso a los operandos mediante instrucciones con los sufijos  (b,w,l,q)</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>datos_direccionamiento.s</strong></p>
</li>
<li>
<p>Diferentes Modos de direccionamiento de los operandos: inmediato, directo, indirecto, indexado</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_requisitos_4">13.1.3. Requisitos</h4>
<div class="ulist">
<ul>
<li>
<p>Teoría: representación de datos, formato de instrucciones y repertorio  ISA de la arquitectura X86.</p>
<div class="ulist">
<ul>
<li>
<p>Almacenamiento con alineamiento interno de bytes "little endian"</p>
</li>
</ul>
</div>
</li>
<li>
<p>Práctica previa: Introducción a la programación en lenguaje ensamblador AT&amp;T x86-32</p>
</li>
<li>
<p>Conceptos del lenguaje de programación C:</p>
<div class="ulist">
<ul>
<li>
<p>Punteros, array, string y operación de casting.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_leeme_2">13.2. LEEME</h3>
<div class="ulist">
<ul>
<li>
<p>Lectura del guión de prácticas  y del capítulo 3 del Libro Programming from the Ground-Up.</p>
</li>
<li>
<p><a href="_apéndice_prácticas.html#prac_apu">Apuntes y Libro de Texto</a></p>
</li>
<li>
<p><a href="_apéndice_prácticas.html#prac_doc_mem">Documentación Memoria</a>: Contenido y Formato de la Memoria</p>
</li>
<li>
<p><a href="_apéndice_prácticas.html#prac_eval">Evaluación</a>: sistema de evaluación</p>
</li>
<li>
<p><a href="_apéndice_prácticas.html#prac_plat_des">Plataforma de Desarrollo</a> : configuración de la computadora personal</p>
</li>
<li>
<p><a href="_apéndice_prácticas.html#prac_prog">Programación</a> : metodología</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_cuestiones_3">13.3. Cuestiones</h3>
<div class="ulist">
<ul>
<li>
<p><a href="_apéndice_prácticas.html#prac_eval">"Autoevaluación de Prácticas"</a> opcional: <a href="_prácticas_cuestionario.html#prac_cues">Prácticas: Cuestionario</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_registros_internos_de_la_cpu">13.4. Registros internos de la CPU</h3>
<div class="ulist">
<ul>
<li>
<p>La arquitecura amd64 dispone de:</p>
<div class="ulist">
<ul>
<li>
<p>16 registros de propósito general (RPG) de 64 bits cada uno: rax,rbx,rcx,rdx,rsi,rdi,rsp, etc</p>
</li>
<li>
<p>1 registros de estado de 64 bits: rflags</p>
</li>
</ul>
</div>
</li>
<li>
<p>El acceso a los registros de propósito general puede ser <em>parcial</em>:</p>
<div class="ulist">
<ul>
<li>
<p>Registro RAX: es un registro de 64 bits</p>
</li>
<li>
<p>Registro EAX: son los 32 bits de menor peso de RAX</p>
</li>
<li>
<p>Registro AX:  son los 16 bits de menor peso de RAX</p>
</li>
<li>
<p>Registro AL:  son los  8 bits de menor peso de RAX</p>
</li>
<li>
<p>Registro AH:  es el byte con los bits de las posiciones 8:15 de RAX</p>
</li>
</ul>
</div>
</li>
<li>
<p>En las <a href="_programación_ensamblador_att_x86.html#registros_32">"Hojas de Referencia Rápida"</a> están representados todos los nombres de los difererentes grupos de bits de cada registro de propósito general.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_tamaño_de_los_datos_y_variables">13.5. Tamaño de los datos y variables</h3>
<div class="sect3">
<h4 id="_algoritmo_3">13.5.1. Algoritmo</h4>
<div class="ulist">
<ul>
<li>
<p>No se desarrolla ningún algoritmo. Unicamente el bloque de código de salida.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_edición_del_módulo_fuente_datos_size_s">13.5.2. Edición del Módulo fuente: datos_size.s</h4>
<div class="ulist">
<ul>
<li>
<p>Descargar el módulo fuente "datos_size.s" de miaulario y añadir los comentarios apropiados.</p>
<div class="listingblock">
<div class="content">
<pre>### Programa: datos_size.s
### Descripción: declarar y acceder a distintos tamaños de operandos
### Compilación: gcc -m32 -g -o datos_size datos_size.s

	## MACROS
	.equ SYS_EXIT,	1
	.equ SUCCESS,	0

	## VARIABLES LOCALES
	.data

da1:	.byte   0x0A
da2:	.2byte  0x0A0B
da4:	.4byte  0x0A0B0C0D
men1:	.ascii  "hola"
lista:  .int    1,2,3,4,5

	## INSTRUCCIONES
	.global _start
	.text
_start:
	mov $SYS_EXIT, %eax
	mov $SUCCESS,  %ebx
	int $0x80

	.end</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_compilación_3">13.5.3. Compilación</h4>
<div class="ulist">
<ul>
<li>
<p>Seguir los pasos del proceso de <a href="_apéndice_prácticas.html#compilacion">compilación</a> común a todas las sesiones.</p>
<div class="ulist">
<ul>
<li>
<p><code>gcc -nostartfiles -m32 -g -o datos_size datos_size.s</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejecución_3">13.5.4. Ejecución</h4>
<div class="ulist">
<ul>
<li>
<p><code>./datos_size</code></p>
</li>
<li>
<p><code>echo $?</code></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_análisis_del_módulo_fuente_2">13.5.5. Análisis del módulo fuente</h4>
<div class="ulist">
<ul>
<li>
<p>Leer en las hojas de referencia rápida el <a href="_programación_ensamblador_att_x86.html#programa_minimalista">Programa Ejemplo Minimalista</a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_estructura_2">Estructura</h5>
<div class="ulist">
<ul>
<li>
<p>La estructura del programa esta formada por los siguientes elementos:</p>
<div class="ulist">
<ul>
<li>
<p>Cabecera</p>
</li>
<li>
<p>Definición de Macros</p>
</li>
<li>
<p>Sección de Datos</p>
</li>
<li>
<p>Sección de Instrucciones</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_definición_de_macros">Definición de Macros</h5>
<div class="ulist">
<ul>
<li>
<p>Macro:</p>
<div class="ulist">
<ul>
<li>
<p>La construcción macro se utiliza en el programa fuente para sustituir datos utilizados en el programa fuente por símbolos de texto que faciliten la lectura del código fuente.</p>
</li>
<li>
<p>Para ello empleamos la directiva "EQU" cuya sintaxis es: <code>.EQU  SÍMBOLO, dato</code></p>
</li>
<li>
<p>El preprocesador en la primera fase de la compilación sustituirá el texto SIMBOLO que aparece a lo largo de la sección de datos e instrucciones por el dato asociado.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Macros empleadas</p>
<div class="ulist">
<ul>
<li>
<p>SYS_EXIT : código de la llamada al sistema para finalizar el programa y devolver el control al Sistema Operativo. En la arquitectura i386 su valor es 1.</p>
</li>
<li>
<p>SUCCESS  : código empleado por los programas para indicar que su ejecución se ha realizado con normalidad. Su valor es 0.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_sección_de_datos">Sección de Datos</h5>
<div class="ulist">
<ul>
<li>
<p>Interpretar las etiquetas y directivas de reserva de memoria e inicialización para los datos utilizando la <a href="_programación_ensamblador_att_x86.html#directivas_as">tabla de directivas</a>: identificar las variables ordinarias, strings y arrays.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_sección_de_instrucciones">Sección de Instrucciones</h5>
<div class="ulist">
<ul>
<li>
<p>Determinar la instrucción de entrada al programa.</p>
</li>
<li>
<p>Determinar el bloque de salida del programa.</p>
</li>
</ul>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
Si un objeto de memoria es inicializado con un número entero que es representado con menos dígitos que el tamaño del objeto, los digitos de mayor peso tendrán de valor cero. Por ejemplo:  <code>.4byte 0xFF</code> equivale a <code>.4byte 0x000000FF</code>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ejecución_paso_a_paso_2">13.5.6. Ejecución paso a paso</h4>
<div class="sect4">
<h5 id="_observaciones">Observaciones</h5>
<div class="ulist">
<ul>
<li>
<p>El depurador al visualizar el contenido de los registros:</p>
<div class="ulist">
<ul>
<li>
<p>únicamente visualiza el número de bytes del tamaño de los operandos..aunque los registros "r-x" son de 64 bits.</p>
</li>
<li>
<p>con números enteros con signo no visualiza los ceros de mayor peso, es decir, ni el signo ni la extensión de signo de los números positivos.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_operaciones_2">Operaciones</h5>
<div class="ulist">
<ul>
<li>
<p>Compilar el programa con la opción de generación de la tabla de símbolos requerida por el depurador y generar el módulo binario ejecutable:</p>
<div class="ulist">
<ul>
<li>
<p><code>gcc -nostartfiles -m32 -g  -o datos_size datos_size.s</code> que se corresponde con  <code>gcc -nostartfiles -m32 -g  -o modulo_ejecutable modulo_fuente.s</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>Abrir el depurador GDB, cargar el módulo binario ejecutable y comprobar que se carga la tabla de símbolos junto al módulo binario ejecutable.</p>
<div class="ulist">
<ul>
<li>
<p><code>gdb</code></p>
</li>
<li>
<p><code>file datos_size</code></p>
</li>
<li>
<p><code>info sources</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>Configurar el fichero para el logging histórico de los comandos.</p>
<div class="ulist">
<ul>
<li>
<p><code>set trace-commands on</code></p>
</li>
<li>
<p><code>set logging file datos_size_gdb_asm.txt</code></p>
</li>
<li>
<p><code>set logging on</code></p>
</li>
<li>
<p><code>shell ls -l datos_size_gdb_asm.txt</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>Activar un punto de ruptura en la instrucción de entrada al programa.</p>
<div class="ulist">
<ul>
<li>
<p><code>b _start</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>Ejecutar el programa deteniéndolo en la primera instrucción del programa.</p>
<div class="ulist">
<ul>
<li>
<p><code>run</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>Análisis del contenido de la memoria principal mediante el depurador GDB:</p>
<div class="listingblock">
<div class="content">
<pre>//Alineamiento de los bytes de un dato
x /tb &amp;da1
x /xh &amp;da2
x /xw &amp;da4
x /5xb &amp;da4	-&gt; Alineamiento little endian

//Alineamiento de los bytes de un string
x /5cb &amp;men1	-&gt; Alineamiento en secuencia
x /5xb &amp;men1

//Volcado de un string
p /s (char *)&amp;men1	-&gt; imprime una cadena de caracteres desde la primera dirección hasta encontrar el caracter NULL.

//Volcado de un array
x /5xw &amp;lista		-&gt; contenido de 5 elementos de lista
p /a &amp;lista		-&gt; dirección del array lista
p /a &amp;lista+1          	-&gt; el depurador informa que es necesario realizar algún tipo de casting (declaración dinámica)
p /a (void *)&amp;lista+1  	-&gt; se incrementa en 1 byte
p /a (int  *)&amp;lista+1   -&gt; se incrementa en  1*4 bytes apuntando al segundo elemento del array
p lista                	-&gt; el depurador informa que es necesario realizar un casting
p (int)lista	       	-&gt; primer elemento del array
p (int *)&amp;lista		-&gt; dirección del array lista
p (int [5])lista	-&gt; contenido de cinco elementos de lista
p *((int *)&amp;lista+1)	-&gt; segundo elemento de lista
x /dw (int *)&amp;lista+1	-&gt; segundo elemento de lista
p *(int *)&amp;lista@5 	-&gt; array artificial de 5 elementos de tipo int a partir de la dirección  &amp;lista.

//volcado de una instrucción
p &amp;_start
x /i &amp;_start		-&gt; desensambla: convierte el código máquina en código ensamblador.

//Desensamblar: Conversión del código máquina en ensamblador
disas /r _start
layout split</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>comando eXaminar <strong>x</strong>: vuelca el contenido de una <strong>dirección</strong> de memoria</p>
<div class="ulist">
<ul>
<li>
<p>formato /nvt : "t" es el <em>tamaño</em> de variable en memoria , "v" el código del <em>valor</em> del contenido de memoria a visualizar y "n" el <em>número</em> de veces que hay que volcar secuencialmente grupos de bytes en memoria de tamaño "t" comenzando en  la dirección <em>&amp;variable</em></p>
</li>
<li>
<p><code>help x</code> : formatos d (decimal) ,x (hexadecimal),t (binario) ,o (octal) ,c (character) ,a (address),i (instruction),etc</p>
</li>
<li>
<p>La sintaxis del argumento del comando examinar es la misma que en lenguaje de programación de C.</p>
</li>
</ul>
</div>
</li>
<li>
<p>operador <strong>&amp;</strong> : se utiliza como prefijo de una etiqueta para evaluar la dirección de memoria a la que hace referencia una etiqueta</p>
</li>
<li>
<p>operador <strong>*</strong> : se utiliza para evaluar el contenido de una posición de memoria mediante la indirección de un puntero</p>
</li>
<li>
<p>operación de <strong>casting</strong>:</p>
<div class="ulist">
<ul>
<li>
<p><a href="_lenguaje_de_programación_c_2.html#prog_C">Apéndice Programación Lenguaje C</a></p>
</li>
<li>
<p>El casting consiste en definir o redifinir el tipo de variable. Se utiliza como prefijo de la variable a redefinir y va entre paréntesis.</p>
</li>
<li>
<p>la etiqueta "lista" está definida en la sección de datos mediante la directiva ".int". Esta directiva reserva memoria para inicializar los datos a partir de la dirección &amp;lista pero NO es una declaración de tipo por lo que el depurador NO tiene información sobre el tipo de elementos del array lista y por ello es necesario realizar declaraciones en modo casting.</p>
</li>
<li>
<p>Ej. (char *): el tipo <code>char *</code> es un puntero a un entero de 1 byte.</p>
</li>
</ul>
</div>
</li>
<li>
<p>comando Print <strong>p</strong>: Evalua el argumento del comando y el valor resultante lo imprime en pantalla</p>
<div class="ulist">
<ul>
<li>
<p>La sintaxis del argumento del comando examinar es la misma que en lenguaje de programación de C.</p>
</li>
<li>
<p>Ej. p /a &amp;lista : evalua &amp;lista cuyo valor resulante se imprime con formato tipo "a" (address)</p>
</li>
<li>
<p>formatos de impresión: los mismos que eXaminar: <code>help x</code></p>
</li>
<li>
<p>operador @: <strong>dirección</strong>@<strong>n</strong>: array artificial: evalua la expresión a la izda de @ y debe ser una dirección de memoria. Crea una array artificial de longitud el valor del parámetro a la derecha del operador @.</p>
</li>
</ul>
</div>
</li>
<li>
<p>comando <strong>disas</strong> : desensambla el código binario traduciéndolo a código ensamblador.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tamaño_de_los_operandos">13.6. Tamaño de los Operandos</h3>
<div class="sect3">
<h4 id="_edición_del_módulo_fuente_datos_sufijos_s">13.6.1. Edición del Módulo fuente: datos_sufijos.s</h4>
<div class="ulist">
<ul>
<li>
<p>Descargar el módulo fuente "datos_sufijos.s" de miaulario y añadir los comentarios apropiados.</p>
<div class="listingblock">
<div class="content">
<pre>### Programa: datos_sufijos.s
### Descripción: utilizar distintos sufijos para los mnemónicos indicado distintos tamaños de operandos
### Compilación: gcc -nostartfiles -m32 -g -o datos_sufijos datos_sufijos.s

	## MACROS
	.equ SYS_EXIT,	1
	.equ SUCCESS,	0

	## VARIABLES LOCALES
	.data

da1:	.byte   0x0A
da2:	.2byte  0x0A0B
da4:	.4byte  0x0A0B0C0D
saludo:	.ascii  "hola"
lista:  .int    1,2,3,4,5

	## INSTRUCCIONES
	.global _start
	.text
_start:

	## Reset de Registros
	xor  %eax,%eax
	xor  %ebx,%ebx
	xor  %ecx,%ecx
	xor  %edx,%edx

	## Carga de datos
	## mov da1,da4		ERROR: por referenciar las dos direcciones efectivas de los dos operandos a la memoria principal
	mov  da4,%eax
	movl da4,%ebx
	movw da4,%cx
	movb da4,%dl

	## Reset de Registros
	xor  %eax,%eax
	xor  %ebx,%ebx
	xor  %ecx,%ecx
	xor  %edx,%edx

	## Carga de datos
	mov  da4,%al		#aplica el tamaño de AL
	## movw  da4,%al	ERROR: incoherencia entre -w y AL
	movb da4,%ebx  	        #AVISO, NO error: incoherencia entre el regisro BL y el sufijo



	mov  da1,%ecx
	mov  da4,%dx

	## Reset de Registros
	xor  %eax,%eax
	xor  %ebx,%ebx
	xor  %ecx,%ecx
	xor  %edx,%edx

	## Carga de datos

        mov  da1,%al

	## inc da1     	ERROR: por ser la dirección efectiva del operando una referencia a la memoria principal no restringe el tamaño del operando. Al no especificar tampoco sufijo el ensamblador no reconoce el tamaño del operando.
	incb da1
	incw da2
	incl da4

## salida
	mov $SYS_EXIT, %eax
	mov $SUCCESS,  %ebx
	int $0x80

	.end</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_compilación_4">13.6.2. Compilación</h4>
<div class="ulist">
<ul>
<li>
<p>Seguir los pasos de la <a href="_apéndice_prácticas.html#compilacion_asm">compilación </a> de un módulo en lenguaje ensamblador.</p>
<div class="ulist">
<ul>
<li>
<p><code>gcc -nostartfiles -m32 -g -o datos_sufijos datos_sufijos.s</code></p>
</li>
<li>
<p><strong>Aviso:</strong> empleando <em>%bl</em> en lugar de <em>%ebx</em> debido <em>b</em> como sufijo</p>
<div class="ulist">
<ul>
<li>
<p>Es un aviso de la sintaxis de la instrucción <code>movb da4,%ebx</code>, NO es un error.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejecución_4">13.6.3. Ejecución</h4>
<div class="ulist">
<ul>
<li>
<p><code>./datos_sufijos</code></p>
</li>
<li>
<p><code>echo $?</code></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_análisis_del_módulo_fuente_3">13.6.4. Análisis del módulo fuente</h4>
<div class="ulist">
<ul>
<li>
<p>Sufijos de los mnemónicos indicando distintos tamaños de los operandos: b,w,l</p>
<div class="ulist">
<ul>
<li>
<p><code>movw da4,%cx</code>  : el sufijo "w" de 2 bytes y el registro destino CX de dos bytes.</p>
</li>
<li>
<p><code>movw da4,%al</code>  : el sufijo "w" impone una transferencia de 2 bytes a un registro destino AL de 1 byte &#8594; error en el ensamblaje.</p>
</li>
<li>
<p><code>movb da4,%ebx</code> : el sufijo "b" no es coherente con el registro destino EBX de 4 bytes y el ensamblaje se produce con BL.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Sin sufijo:</p>
<div class="ulist">
<ul>
<li>
<p><code>xor  %eax,%eax</code> : operandos fuente y destino EAX de 4 bytes</p>
</li>
<li>
<p><code>mov  da4,%al</code>  : el registro destino AL limita la transferencia a 1 byte y no hay contradicción con el sufijo ya que éste no existe.</p>
</li>
<li>
<p><code>mov  da1,%ecx</code> : de los dos operandos, registro y memoria, es el registro quien prioriza el tamaño de la transferencia.</p>
</li>
<li>
<p><code>inc da1</code>       : Al ser la dirección efectiva del operando una referencia a la memoria principal no restringe el tamaño del operando. Al no especificar tampoco un sufijo el ensamblador no reconoce el tamaño del operando &#8594; error en el ensamblaje</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_deducción_del_tamaño_del_operando_en_una_instrucción">13.6.5. Deducción del tamaño del operando en una instrucción</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Diferencia entre la referencia a un operando en memoria o registro</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Un operando referenciado mediante una dirección de memoria no tiene un tamaño específico para el assembler.</p>
</li>
<li>
<p>En cambio el nombre de un registro si es asociado a un tamaño de operando por el assembler.</p>
</li>
</ol>
</div>
</li>
<li>
<p>En una instrucción con un único operando en memoria el tamaño es deducido por el assembler gracias al sufijo del mnemónico, por lo tanto en este caso si el mnemónico no tiene sufijo el assembler no traducirá la instrucción.</p>
</li>
<li>
<p>En una instrucción con dos operandos, uno en memoria y otro en un registro, es el operando en el registro o el sufijo quienes especifican el tamaño de los dos operandos fuente y destino:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Si el mnemónico tiene sufijo, es dicho sufijo quien especifica el tamaño de los operandos fuente y destino.</p>
</li>
<li>
<p>Si el mnemónico no tiene sufijo, es el tamaño del registro quien especifica el tamaño de los operandos fuente y destino.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Casos de error</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>En el caso de que el mnemónico tenga un sufijo mayor que el tamaño del registro destino.</p>
</li>
<li>
<p>En el caso de que el mnemónico no tenga sufijo y el tamaño del registro fuente sea mayor que el registro destino.</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_ejecución_paso_a_paso_3">13.6.6. Ejecución paso a paso</h4>
<div class="ulist">
<ul>
<li>
<p>Compilar el programa con la opción de generación de la tabla de símbolos requerida por el depurador y generar el módulo binario ejecutable:</p>
<div class="ulist">
<ul>
<li>
<p><code>gcc -nostartfiles -m32 -g  -o datos_sufijo datos_sufijo.s</code> donde modulo_fuente se sustituye por el nombre del archivo que se desea compilar.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Abrir el depurador GDB, cargar el módulo binario ejecutable y comprobar que se carga la tabla de símbolos junto al módulo binario ejecutable.</p>
<div class="ulist">
<ul>
<li>
<p><code>gdb</code></p>
</li>
<li>
<p><code>file modulo_ejecutable</code></p>
</li>
<li>
<p><code>info sources</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>Configurar el fichero para el logging histórico de los comandos.</p>
<div class="ulist">
<ul>
<li>
<p><code>set trace-commands on</code></p>
</li>
<li>
<p><code>set logging file datos_sufijo_gdb_asm.txt</code></p>
</li>
<li>
<p><code>set logging on</code></p>
</li>
<li>
<p><code>shell ls -l datos_sufijo_gdb_asm.txt</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>Activar un punto de ruptura en la instrucción de entrada al programa.</p>
<div class="ulist">
<ul>
<li>
<p><code>b _start</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>Ejecutar el programa deteniéndolo en la primera instrucción del programa.</p>
<div class="ulist">
<ul>
<li>
<p><code>run</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>abrir la ventana de visualización de los registros</p>
<div class="ulist">
<ul>
<li>
<p><code>layout regs</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>Análisis del contenido de la memoria principal mediante el depurador GDB.</p>
<div class="ulist">
<ul>
<li>
<p>Ejecutar el programa paso a paso analizando el resultado de la ejecución de cada instrucción</p>
</li>
<li>
<p><code>n</code></p>
</li>
<li>
<p>RET, RET, RET, &#8230;&#8203;.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_modos_de_direccionamiento_3">13.7. Modos de Direccionamiento</h3>
<div class="sect3">
<h4 id="_edición_del_módulo_fuente_datos_direccionamiento_s">13.7.1. Edición del Módulo fuente: datos_direccionamiento.s</h4>
<div class="ulist">
<ul>
<li>
<p>Descargar el módulo fuente "datos_direccionamiento.s" de miaulario y añadir los comentarios apropiados.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>### Program:     datos_direccionamiento.s
### Descripción: Emplear estructuras de datos con diferentes direccionamientos
### Compilación: gcc -m32 -g -o datos_direccionamiento datos_direccionamiento.s
###		 sin la opción startfiles al utilizar el punto de entrada referenciado con la etiqueta "main"

	## MACROS
	.equ SYS_EXIT,	1
	.equ SUCCESS,	0

	## VARIABLES LOCALES
	.data

	.align 4				     # Alineamiento con direcciones de MP múltiplos de 4
da2:	.2byte  0x0A0B,0b0000111101011100,-21,0xFFFF # Array da2 de elementos de 2 bytes
	.align 4
lista:  .word    1,2,3,4,5	# Array lista de elementos de 2 bytes
	.align 8
buffer:	.space  100		# Array buffer de 100 bytes
	.align 2
saludo:
	.string "Hola"		# Array saludo de elementos de 1 byte por ser caracteres

	## INSTRUCCIONES
	.global main
	.text
main:

	## RESET

	xor  %eax,%eax
	xor  %ebx,%ebx
	xor  %ecx,%ecx
	xor  %edx,%edx
	xor  %esi,%esi
        xor  %edi,%edi

	## ALGORITMO sum1toN

	## Direccionamiento inmediato
	mov $4,%si
	## Direccionamiento indexado
bucle:	add lista(,%esi,2),%di
	## Direccionamiento a registro
	dec %si
	## Direccionamiento relativo al PC
	jns bucle


	## EJERCICIOS SOBRE DIRECCIONAMIENTO

	## Direccionamiento indirecto
	lea buffer,%eax		#inicializo el puntero EAX
	## mov da2,(%eax) ERROR: la dirección efectiva de los dos operandos hacen referencia a la memoria principal
	mov da2,%bx
	mov %bx, (%eax)
	## Direccionamiento directo
	incw da2
	## Direccionamiento indexado
	lea  da2,%ebx
	## inc 2(%ebx) ERROR: dirección efectiva a memoria y no hay sufijo
	incw 2(%ebx)

	mov $3,%esi
	mov da2(,%esi,2),%ebx

	## SALIDA

	mov $SYS_EXIT, %eax
	mov $SUCCESS,  %ebx
	int $0x80

	.end</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compilación_5">13.7.2. Compilación</h4>
<div class="ulist">
<ul>
<li>
<p>Seguir los pasos de la <a href="_apéndice_prácticas.html#compilacion_asm">compilación </a> de un módulo en lenguaje ensamblador.</p>
<div class="ulist">
<ul>
<li>
<p>El punto de entrada no es "_start".</p>
</li>
<li>
<p><code>gcc -nostartfiles -m32 -g -o datos_direccionamiento datos_direccionamiento.s</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejecución_5">13.7.3. Ejecución</h4>
<div class="ulist">
<ul>
<li>
<p><code>./datos_direccionamiento</code></p>
</li>
<li>
<p><code>echo $?</code></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_análisis_del_módulo_fuente_4">13.7.4. Análisis del módulo fuente</h4>
<div class="ulist">
<ul>
<li>
<p>Alineación de datos mediante la directiva <code>.align n</code> asigna una dirección de memoria múltiplo de <em>n</em> al siguiente dato declarado.</p>
</li>
</ul>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
NO está permitido que en el caso de una instrucción con dos operandos, ambos estén en la memoria principal. Uno o los dos operandos han de estar en los registros de propósito general.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_ejecución_paso_a_paso_4">13.7.5. Ejecución paso a paso</h4>
<div class="ulist">
<ul>
<li>
<p>Compilar el programa con la opción de generación de la tabla de símbolos requerida por el depurador y generar el módulo binario ejecutable:</p>
<div class="ulist">
<ul>
<li>
<p><code>gcc -nostartfiles -m32 -g  -o datos_direccionamiento datos_direccionamiento.s</code> donde modulo_fuente se sustituye por el nombre del archivo que se desea compilar.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Abrir el depurador GDB, cargar el módulo binario ejecutable y comprobar que se carga la tabla de símbolos junto al módulo binario ejecutable.</p>
<div class="ulist">
<ul>
<li>
<p><code>gdb</code></p>
</li>
<li>
<p><code>file datos_direccionamiento</code></p>
</li>
<li>
<p><code>info sources</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>Configurar el fichero para el logging histórico de los comandos.</p>
<div class="ulist">
<ul>
<li>
<p><code>set trace-commands on</code></p>
</li>
<li>
<p><code>set logging file datos_direccionamiento_gdb_asm.txt</code></p>
</li>
<li>
<p><code>set logging on</code></p>
</li>
<li>
<p><code>shell ls -l datos_direccionamiento_gdb_asm.txt</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>Activar un punto de ruptura en la instrucción de entrada al programa.</p>
<div class="ulist">
<ul>
<li>
<p><code>b _start</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>Ejecutar el programa deteniéndolo en la primera instrucción del programa.</p>
<div class="ulist">
<ul>
<li>
<p><code>run</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>Array <em>da2</em></p>
<div class="ulist">
<ul>
<li>
<p>Imprimir la dirección de memoria del array <em>da2</em> y el contenido del primer elemento: <code>x /xh &amp;da2</code></p>
</li>
<li>
<p>4 elementos de 2bytes del array da2: <code>x /4xh &amp;da2</code></p>
</li>
<li>
<p><code>p /x (short[4])da2</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>Array <em>lista</em></p>
<div class="ulist">
<ul>
<li>
<p><code>ptype lista</code></p>
</li>
<li>
<p><code>p (short[5])lista</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>Array <em>buffer</em></p>
<div class="ulist">
<ul>
<li>
<p><code>ptype buffer</code></p>
</li>
<li>
<p>Imprimir la dirección de memoria del array <em>buffer</em> y comprobar su alineamiento: <code>p &amp;buffer</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>String</p>
<div class="ulist">
<ul>
<li>
<p><code>ptype saludo</code> : no debug info &#8594; no admite referencia elemento array expresión <em>saludo[n]</em></p>
</li>
<li>
<p><code>p /c (char[5])saludo</code>   :casting array</p>
</li>
<li>
<p><code>x /5c (char *)&amp;saludo</code>  :casting puntero</p>
</li>
<li>
<p><code>p /c *(char *)&amp;saludo</code>  :casting puntero e indirección</p>
</li>
<li>
<p><code>p /s (char *)&amp;saludo</code>   :casting puntero y formato string</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph nav-footer">
<p>← Previous: <a href="_introducción_a_la_programación_en_lenguaje_ensamblador_att_x86_32.html">Introducción a la Programación en Lenguaje Ensamblador AT&amp;T x86-32</a> | ↑ Up: <a href="_v_guiones_de_prácticas_programación_ensamblador_x86.html">V Guiones de Prácticas: Programación Ensamblador x86</a> | ⌂ Home: <a href="eecc_book.html">Estructura de Computadores  (240306)</a> | Next: <a href="_operaciones_aritméticas_y_lógicas.html">Operaciones Aritméticas y Lógicas</a> →</p>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2022-09-04 21:51:14 +0200
</div>
</div>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]],
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },
  TeX: { equationNumbers: { autoNumber: "none" } }
})
MathJax.Hub.Register.StartupHook("AsciiMath Jax Ready", function () {
  MathJax.InputJax.AsciiMath.postfilterHooks.Add(function (data, node) {
    if ((node = data.script.parentNode) && (node = node.parentNode) && node.classList.contains("stemblock")) {
      data.math.root.display = "block"
    }
    return data
  })
})
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
</body>
</html>