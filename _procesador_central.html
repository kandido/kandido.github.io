<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.17">
<meta name="keywords" content="computer, architecture">
<meta name="author" content="Cándido Aramburu">
<title>Estructura de Computadores  (240306)</title>
<style>
@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";
@import "https://cdn.jsdelivr.net/gh/asciidoctor/asciidoctor@2.0/data/stylesheets/asciidoctor-default.css";



h1, h2, h3, h4, h5, h6, #toctitle,
.sidebarblock > .content > .title {
  color: rgba(221, 72, 20, 0.8);
}



</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
pre.rouge table td { padding: 5px; }
pre.rouge table pre { margin: 0; }
pre.rouge .cm {
  color: #999988;
  font-style: italic;
}
pre.rouge .cp {
  color: #999999;
  font-weight: bold;
}
pre.rouge .c1 {
  color: #999988;
  font-style: italic;
}
pre.rouge .cs {
  color: #999999;
  font-weight: bold;
  font-style: italic;
}
pre.rouge .c, pre.rouge .ch, pre.rouge .cd, pre.rouge .cpf {
  color: #999988;
  font-style: italic;
}
pre.rouge .err {
  color: #a61717;
  background-color: #e3d2d2;
}
pre.rouge .gd {
  color: #000000;
  background-color: #ffdddd;
}
pre.rouge .ge {
  color: #000000;
  font-style: italic;
}
pre.rouge .gr {
  color: #aa0000;
}
pre.rouge .gh {
  color: #999999;
}
pre.rouge .gi {
  color: #000000;
  background-color: #ddffdd;
}
pre.rouge .go {
  color: #888888;
}
pre.rouge .gp {
  color: #555555;
}
pre.rouge .gs {
  font-weight: bold;
}
pre.rouge .gu {
  color: #aaaaaa;
}
pre.rouge .gt {
  color: #aa0000;
}
pre.rouge .kc {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kd {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kn {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kp {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kr {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kt {
  color: #445588;
  font-weight: bold;
}
pre.rouge .k, pre.rouge .kv {
  color: #000000;
  font-weight: bold;
}
pre.rouge .mf {
  color: #009999;
}
pre.rouge .mh {
  color: #009999;
}
pre.rouge .il {
  color: #009999;
}
pre.rouge .mi {
  color: #009999;
}
pre.rouge .mo {
  color: #009999;
}
pre.rouge .m, pre.rouge .mb, pre.rouge .mx {
  color: #009999;
}
pre.rouge .sa {
  color: #000000;
  font-weight: bold;
}
pre.rouge .sb {
  color: #d14;
}
pre.rouge .sc {
  color: #d14;
}
pre.rouge .sd {
  color: #d14;
}
pre.rouge .s2 {
  color: #d14;
}
pre.rouge .se {
  color: #d14;
}
pre.rouge .sh {
  color: #d14;
}
pre.rouge .si {
  color: #d14;
}
pre.rouge .sx {
  color: #d14;
}
pre.rouge .sr {
  color: #009926;
}
pre.rouge .s1 {
  color: #d14;
}
pre.rouge .ss {
  color: #990073;
}
pre.rouge .s, pre.rouge .dl {
  color: #d14;
}
pre.rouge .na {
  color: #008080;
}
pre.rouge .bp {
  color: #999999;
}
pre.rouge .nb {
  color: #0086B3;
}
pre.rouge .nc {
  color: #445588;
  font-weight: bold;
}
pre.rouge .no {
  color: #008080;
}
pre.rouge .nd {
  color: #3c5d5d;
  font-weight: bold;
}
pre.rouge .ni {
  color: #800080;
}
pre.rouge .ne {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nf, pre.rouge .fm {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nl {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nn {
  color: #555555;
}
pre.rouge .nt {
  color: #000080;
}
pre.rouge .vc {
  color: #008080;
}
pre.rouge .vg {
  color: #008080;
}
pre.rouge .vi {
  color: #008080;
}
pre.rouge .nv, pre.rouge .vm {
  color: #008080;
}
pre.rouge .ow {
  color: #000000;
  font-weight: bold;
}
pre.rouge .o {
  color: #000000;
  font-weight: bold;
}
pre.rouge .w {
  color: #bbbbbb;
}
pre.rouge {
  background-color: #f8f8f8;
}
</style>
<!-- Change some CSS.
<style>
.imageblock{
  &.text-center > .title {
    text-align: center !important;
  }
}
</style>

-->

<style type="text/css"> .imageblock > .title { text-align: center; } </style>

<style>.toc-current{font-weight: bold;} .toc-root{font-family: "Open Sans","DejaVu Sans",sans-serif;
                       font-size: 0.9em;} #content{display: flex; flex-direction: column; flex: 1 1 auto;}
             .nav-footer{text-align: center; margin-top: auto;}
             .nav-footer > p > a {white-space: nowrap;}</style>
</head>
<body id="_procesador_central" class="book">
<div id="header">
<h1>Estructura de Computadores  (240306)</h1>
<div class="details">
<span id="author" class="author">Cándido Aramburu</span><br>
<span id="email" class="email"><a href="mailto:candido@unavarra.es">candido@unavarra.es</a></span><br>
<span id="revdate">2022-09-14</span>
</div>
<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<p><span class="toc-root"><a href="eecc_book.html">Estructura de Computadores  (240306)</a></span></p><ul class="sectlevel0">
<li><a href="_i_arquitectura_del_repertorio_de_instrucciones_isa_computadora_von_neumann_datos_instrucciones_programación.html">I Arquitectura del Repertorio de Instrucciones (ISA): computadora von Neumann, datos, instrucciones, programación.</a>
</li>
<li><a href="_ii_unidades_básicas_procesador_central_unidad_de_memoria_mecanismos_entradasalida.html">II Unidades Básicas: Procesador Central, Unidad de Memoria, Mecanismos Entrada/Salida.</a>
<ul class="sectlevel1">
<li><a href="_procesador_central.html"><span class="toc-current">7. Procesador Central</span></a>
<ul class="sectlevel2">
<li><a href="_procesador_central.html#_temario_7">7.1. Temario</a>
</li>
<li><a href="_procesador_central.html#_refs_2">7.2. Refs</a>
</li>
<li><a href="_procesador_central.html#_introducción_7">7.3. Introducción</a>
</li>
<li><a href="_procesador_central.html#_conjunto_de_instrucciones">7.4. Conjunto de Instrucciones</a>
<ul class="sectlevel3">
<li><a href="_procesador_central.html#_arquitectura_isa">7.4.1. Arquitectura (ISA)</a>
</li>
<li><a href="_procesador_central.html#_ejemplos_intel_x86_motorola_68000_mips_arm">7.4.2. Ejemplos: Intel x86, Motorola 68000, MIPS, ARM</a>
</li>
</ul>
</li>
<li><a href="_procesador_central.html#_la_computadora_desde_el_punto_de_vista_del_programador">7.5. La Computadora desde el punto de vista del programador</a>
<ul class="sectlevel3">
<li><a href="_procesador_central.html#_niveles_o_capas_de_abstracción">7.5.1. Niveles o Capas de Abstracción</a>
</li>
<li><a href="_procesador_central.html#_compatibilidad_software">7.5.2. Compatibilidad Software</a>
</li>
</ul>
</li>
<li><a href="_procesador_central.html#_fases_de_ejecución_de_una_instrucción">7.6. Fases de Ejecución de una Instrucción</a>
<ul class="sectlevel3">
<li><a href="_procesador_central.html#_estructura">7.6.1. Estructura</a>
</li>
<li><a href="_procesador_central.html#_ciclo_diagrama_fases">7.6.2. Ciclo / Diagrama / Fases</a>
</li>
<li><a href="_procesador_central.html#_ejemplo_máquina_ias_de_von_neumann">7.6.3. Ejemplo: máquina IAS de Von-Neumann</a>
</li>
</ul>
</li>
<li><a href="_procesador_central.html#_microarquitectura_unidades_funcionales">7.7. Microarquitectura: Unidades Funcionales</a>
<ul class="sectlevel3">
<li><a href="_procesador_central.html#_introducción_8">7.7.1. Introducción</a>
</li>
<li><a href="_procesador_central.html#_implementación_del_ciclo_de_instrucción">7.7.2. Implementación del ciclo de instrucción</a>
</li>
<li><a href="_procesador_central.html#_estructura_de_la_cpu">7.7.3. Estructura de la CPU</a>
</li>
<li><a href="_procesador_central.html#_fase_de_captación">7.7.4. Fase de Captación</a>
</li>
<li><a href="_procesador_central.html#_perspectiva_de_la_cpu">7.7.5. Perspectiva de la CPU</a>
</li>
<li><a href="_procesador_central.html#_unidad_de_control_microprogramada">7.7.6. Unidad de Control Microprogramada</a>
</li>
</ul>
</li>
<li><a href="_procesador_central.html#_arquitecturas_ciscrisc">7.8. Arquitecturas CISC/RISC</a>
<ul class="sectlevel3">
<li><a href="_procesador_central.html#_introducción_9">7.8.1. Introducción</a>
</li>
<li><a href="_procesador_central.html#_tabla_comparativa">7.8.2. Tabla Comparativa</a>
</li>
</ul>
</li>
<li><a href="_procesador_central.html#_instruction_level_parallelism_ilp">7.9. Instruction Level Parallelism (ILP)</a>
<ul class="sectlevel3">
<li><a href="_procesador_central.html#_vliw_vs_superscalar">7.9.1. VLIW vs Superscalar</a>
</li>
<li><a href="_procesador_central.html#_pipeline_segmentacion">7.9.2. Pipeline (Segmentacion)</a>
</li>
</ul>
</li>
<li><a href="_procesador_central.html#_ejercicios">7.10. Ejercicios</a>
</li>
<li><a href="_procesador_central.html#_imagenes">7.11. Imagenes</a>
</li>
</ul>
</li>
<li><a href="_mecanismos_de_entradasalida.html">8. Mecanismos de Entrada/Salida</a>
</li>
<li><a href="_unidad_de_memoria.html">9. Unidad de Memoria</a>
</li>
</ul>
</li>
<li><a href="_iii_ejercicios_de_teoría.html">III Ejercicios de Teoría</a>
</li>
<li><a href="_iv_autoevaluación_teoría.html">IV Autoevaluación Teoría</a>
</li>
<li><a href="_v_guiones_de_prácticas_programación_ensamblador_x86.html">V Guiones de Prácticas: Programación Ensamblador x86</a>
</li>
<li><a href="_vi_hojas_de_referencia_rápida.html">VI Hojas de Referencia Rápida</a>
</li>
<li><a href="_vii_autoevaluación_prácticas.html">VII Autoevaluación Prácticas</a>
</li>
<li><a href="_viii_apéndices.html">VIII Apéndices</a>
</li>
<li><a href="_ix_bibliografía.html">IX Bibliografía</a>
</li>
<li><a href="_x_glosario.html">X Glosario</a>
</li>
<li><a href="_xi_colofón.html">XI Colofón</a>
</li>
<li><a href="_index.html">Index</a>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_procesador_central">7. Procesador Central</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_temario_7">7.1. Temario</h3>
<div class="olist arabic">
<ol class="arabic" start="7">
<li>
<p>Conjunto de instrucciones</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Arquitecturas CISC, RISC y VLIW</p>
</li>
<li>
<p>Fases de ejecución de una instrucción</p>
</li>
<li>
<p>Ruta de datos</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_refs_2">7.2. Refs</h3>
<div class="ulist">
<ul>
<li>
<p>Apuntes : Tema 2: Arquitectura von Neumann (unidad de control)</p>
</li>
<li>
<p>Libro de Texto: Estructura y Organización de Computadores .William Stalling. Capítulo 12.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_introducción_7">7.3. Introducción</h3>
<div class="ulist">
<ul>
<li>
<p>El objetivo principal de la CPU es la implementación del <em>ciclo de instrucción</em>. Es el soporte hardware para poder llevar a cabo todas las operaciones que conllevan las intrucciones de un programa.</p>
</li>
<li>
<p>Unidad Central de Proceso (CPU) o Procesador.</p>
<div class="ulist">
<ul>
<li>
<p>Nombres: Procesador, microprocesador (El componente electrónico básico es el transistor con un tamaño en sus origenes del orden de la micra ), ..</p>
</li>
<li>
<p>Central porque la computadora tiene varios procesadores: Por ejemplo el controlador de la memoria y  los controladores de los periféricos.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Arquitectura Von-Neumann.</p>
<div class="ulist">
<ul>
<li>
<p>La CPU es una de las unidades básicas que conforman la arquitectura Von-Neumann (CPU-MP-IO) y Buses.</p>
</li>
</ul>
</div>
</li>
<li>
<p><em>Microarquitectura</em></p>
<div class="ulist">
<ul>
<li>
<p>Las unidades básicas de la CPU son: Unidad de Control (UC), y la Ruta de Datos (ALU,FPU,MMU,Registros y circuitos de enrutamiento como multiplexores, conmutadores,  etc).</p>
</li>
</ul>
</div>
</li>
<li>
<p>El ciclo de instrucción puede ser secuencial o segmentado, permitiendo el solapamiento en el tiempo de la ejecución de más de una instrucción (técnicas de paralelismo a nivel de instrucción, ILP)</p>
</li>
<li>
<p>La CPU se puede  ver desde el punto de vista del programador o desde el punto de vista del diseñador electrónico.</p>
</li>
<li>
<p>Desde el punto de vista del <em>programador</em> interesa conocer:</p>
<div class="ulist">
<ul>
<li>
<p>La Arquitectura del Repertorio  de Instrucciones (ISA)</p>
</li>
<li>
<p>Registros: registros de propósito general accesibles por el programador (acumulador, registro índice, punteros pila, etc), registro de estado,  registros de coma flotante, registros multimedia, resgistros de segmentación de memoria, registros no accesibles como el contador de programa, tamaño de los registros, etc</p>
</li>
<li>
<p>Modos de Funcionamiento de la CPU: modo superusuario, modo usuario, modo interrupción</p>
</li>
</ul>
</div>
</li>
<li>
<p>Técnicas HW de optimización de la ejecución de un programa <strong>(Performance)</strong></p>
<div class="ulist">
<ul>
<li>
<p><a href="https://en.wikipedia.org/wiki/Instruction_pipelining">Segmenación-Pipelining</a>: organizar el ciclo de instrucción en fases o segmentos y ejecutarlos en paralelo.</p>
</li>
<li>
<p><a href="https://es.wikipedia.org/wiki/Ejecuci%C3%B3n_fuera_de_orden">Ejecución fuera de Orden OoO</a>: Run time</p>
</li>
<li>
<p><a href="https://es.wikipedia.org/wiki/Renombre_de_registros">Renombre de Registros</a>: Compiler &amp; Run time</p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Branch_predictor">Branch Predictor</a>: Run time</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_conjunto_de_instrucciones">7.4. Conjunto de Instrucciones</h3>
<div class="sect3">
<h4 id="_arquitectura_isa">7.4.1. Arquitectura (ISA)</h4>
<div class="ulist">
<ul>
<li>
<p>Recordatorio de la primera parte de la asignatura:</p>
<div class="ulist">
<ul>
<li>
<p>Temas: arquitectura von neumann, representación de datos, operaciones aritmetico-lógicas, representación de las instrucciones y programación en lenguaje ensamblador.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Instruction Set Arquitecture (ISA)</p>
<div class="ulist">
<ul>
<li>
<p>La arquitectura del repertorio de instrucciones define: códigos de operación, tipos de operando, modos de direccionamiento, etc</p>
</li>
<li>
<p>Son las instrucciones máquina ejecutables directamente por la CPU en código binario.: <em>lenguaje máquina</em></p>
</li>
<li>
<p>La instrucción a ejecutar está almacenada en código binario en el registro RI de la Unidad de Control.</p>
</li>
</ul>
</div>
</li>
<li>
<p>El repertorio de instrucciones está especificado en el manual del programador de la CPU:</p>
<div class="ulist">
<ul>
<li>
<p>Programamos en <em>lenguaje Ensamblador</em> en lugar de en <em>lenguaje máquina</em></p>
</li>
<li>
<p>El manual contiene la definición de la Arquitectura del Repertorio de Instrucciones.</p>
<div class="ulist">
<ul>
<li>
<p>el listado y descripción de todas las instrucciones ejecutables por el microprocesador</p>
<div class="ulist">
<ul>
<li>
<p>categorías de las instrucciones: transferencia(mov), control(jmpz,loop),aritméticas(add), lógicas(xor), i/o (in/oout)</p>
<div class="ulist">
<ul>
<li>
<p>Mnemónicos del código de operación</p>
</li>
</ul>
</div>
</li>
<li>
<p>Modos de direccionamiento: inmediato, directo, indirecto, desplazamiento</p>
</li>
<li>
<p>Tipos de datos: entero, real, alfanumérico</p>
</li>
</ul>
</div>
</li>
<li>
<p>Formatos binarios</p>
<div class="ulist">
<ul>
<li>
<p>De las instrucciones: campos de operación, operando, modo direccionamiento</p>
</li>
<li>
<p>De los datos: complemento a 2, coma flotante</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplos_intel_x86_motorola_68000_mips_arm">7.4.2. Ejemplos: Intel x86, Motorola 68000, MIPS, ARM</h4>
<div class="ulist">
<ul>
<li>
<p>Ver <a href="_lenguajes_de_programación_en_ensamblador.html#leng_asm">Apéndice Lenguajes Ensamblador</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_la_computadora_desde_el_punto_de_vista_del_programador">7.5. La Computadora desde el punto de vista del programador</h3>
<div class="sect3">
<h4 id="_niveles_o_capas_de_abstracción">7.5.1. Niveles o Capas de Abstracción</h4>
<div class="ulist">
<ul>
<li>
<p>El programador  se abstrae (en parte) de la implementación del Hardware gracias al Sistema Operativo. El programador interactua con el Sistema Operativo para acceder a los recursos HW de la computadora.</p>
</li>
<li>
<p>Abstracción de la Máquina : mediante las instrucciones ISA / especificaciones ABI</p>
<div class="ulist">
<ul>
<li>
<p><strong>ABI</strong> : "Application Binary Interface" . Es un documento que especifica las características binarias del software, es decir, el nivel más bajo del software. Por ejemplo especifica el convenio de llamadas a subrutinas, cómo está estructurada la pila, cómo realizar las llamadas al sistema, el formato binario del módulo objeto ejecutable, etc &#8230;&#8203; El compilador, linker y loader han de conocer la interfaz ABI con todo detalle.</p>
</li>
<li>
<p>Desde el punto de vista del programador de aplicaciones de bajo nivel: La interfaz con la máquina son las llamadas al sistema (ABI) y el repertorio "user ISA"</p>
</li>
</ul>
</div>
</li>
<li>
<p>Abstracción a niveles superiores</p>
<div class="ulist">
<ul>
<li>
<p>La interfaz con la librería son los prototipos de las funciones de la librería (Application Programming Interface - <strong>API</strong>)</p>
</li>
</ul>
</div>
</li>
<li>
<p>Esquema con las Interfaces de las aplicaciones desarrolladas en <strong>lenguajes de bajo nivel</strong>:</p>
</li>
</ul>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/ditaa/svg/eNqtlM1qhDAUhfd9iiwVo32BUshkfirVGkyly8FKaAOpkWiFQl6o6-669cWaVFCGGR079IKSyOfJyfFGz19U3pUGi0ofgqiqBC_yhsuyngXnFL3BBiLhaOnM0uPzOTDizwD_jm6spu8DROP9e83UrKI-lF4OAkCT7eMTSjfLtT0frcy-HfpRN-xtj3Mhatd41X0G-myibc_oBdFfDlJu3eUgqZgyH7yVU6BjE64Ub7lgL6x2JxWdtYGYGolJ8J6pkgnQfYGH7rsQTLoXbac9arnR5tB29mb7Y5jYugUgpOhvhyTDEEUZ3JIMxnEGA1snwZTs4GYboR2FR8Ro_w6l66GvCIZhCmNkrlUKg1Ov9drhdQKwLBslhTBRT7vFefHafcI4IAEkUjW1GdLgH870_H_nB8Fq5UU=" alt="Diagram">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Desde el punto de vista del sistema operativo S.O.:</p>
<div class="ulist">
<ul>
<li>
<p>La interfaz con la máquina es <strong>ISA (system isa y user isa)</strong></p>
</li>
<li>
<p>La interfaz con el programador es <strong>ABI</strong></p>
</li>
</ul>
</div>
</li>
<li>
<p>Desde el punto de vista del programador</p>
<div class="ulist">
<ul>
<li>
<p>si no hay S.O. la interfaz con la máquina será equivalente a la del S.O.</p>
</li>
<li>
<p>si hay S.O. y librerías la interfaz con la máquina:</p>
<div class="ulist">
<ul>
<li>
<p>en lenguaje C : <strong>API</strong> y <strong>ABI</strong> específicos de C</p>
</li>
<li>
<p>en lenguaje ASM: <strong>API &#169;</strong> y <strong>ABI</strong> específico de asm</p>
<div class="ulist">
<ul>
<li>
<p>La programación de bajo nivel requiere tener algunos conocimientos del Hardware de la máquina no siendo posible su completa abstracción. Por lo tanto es necesario estudiar la CPU desde el punto de vista del programador.</p>
</li>
<li>
<p>¿Cual sería el esquema de niveles o capas visto por los siguientes niveles de abstracción superiores?</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Escritorio</p>
</li>
<li>
<p>Lenguaje de Programación Java</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_compatibilidad_software">7.5.2. Compatibilidad Software</h4>
<div class="sect4">
<h5 id="_compatibilidad">Compatibilidad</h5>
<div class="ulist">
<ul>
<li>
<p>Cada procesador tiene su repertorio de instrucciones</p>
</li>
<li>
<p>Si dos procesadores tienen el mismo repertorio de instrucciones, es decir, la misma arquitectura, el módulo fuente en lenguaje ensamblador será compatible para los dos procesadores aunque la estructura interna de la CPU sea diferente: Ejemplo: Intel IA64 y AMD64</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_ejemplos_3">Ejemplos</h5>
<div class="ulist">
<ul>
<li>
<p>El programador necesita conocer el trío ARCH-KERNEL-LIBC</p>
<div class="ulist">
<ul>
<li>
<p>Arch se refiere a la arquitectura de la computadora &#8594; ISA</p>
</li>
<li>
<p>Kernel: núcleo del sistema operativo. Implementa las llamadas del sistema</p>
</li>
<li>
<p>Libc: librería para el programador de aplicaciones. Implementa las llamadas al sistema</p>
</li>
<li>
<p>Tanto el Kernel como la Librería tienen asociados sus interfaces de nivel alto (API) como de nivel bajo (ABI)</p>
</li>
</ul>
</div>
</li>
<li>
<p>Ejemplos arch/kernel/libc</p>
<div class="ulist">
<ul>
<li>
<p>amd64-linux-gnu</p>
</li>
<li>
<p>arm-linux-gnueabi</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_fases_de_ejecución_de_una_instrucción">7.6. Fases de Ejecución de una Instrucción</h3>
<div class="sect3">
<h4 id="_estructura">7.6.1. Estructura</h4>
<div class="imageblock text-center">
<div class="content">
<img src="./images/von_neumann/ias_architecture.png" alt="ias architecture">
</div>
<div class="title">Figure 30. IAS_Architecture</div>
</div>
</div>
<div class="sect3">
<h4 id="_ciclo_diagrama_fases">7.6.2. Ciclo / Diagrama / Fases</h4>
<div class="imageblock text-center">
<div class="content">
<img src="./images/cpu/12_5.jpg" alt="12 5">
</div>
<div class="title">Figure 31. Diagrama de Estados</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Fases del ciclo de instrucción</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Fetch Instruction : FI</p>
<div class="ulist">
<ul>
<li>
<p>Inicialmente hay que volcar al bus de direcciones de memoria el contenido del Contador de Programa (PC)</p>
</li>
<li>
<p>Captar la instrucción</p>
</li>
<li>
<p>PC &#8592; PC+1</p>
</li>
</ul>
</div>
</li>
<li>
<p>Instruction Decode : ID</p>
<div class="ulist">
<ul>
<li>
<p>interpretar la instrucción</p>
</li>
</ul>
</div>
</li>
<li>
<p>Fetch Operand      : OF</p>
<div class="ulist">
<ul>
<li>
<p>captar datos, captar los operandos</p>
</li>
<li>
<p>resolver la dirección efectiva</p>
</li>
</ul>
</div>
</li>
<li>
<p>Execute  Instruction : EI</p>
<div class="ulist">
<ul>
<li>
<p>procesar la instrucción con los datos</p>
</li>
</ul>
</div>
</li>
<li>
<p>Write Operand: WO</p>
<div class="ulist">
<ul>
<li>
<p>almacencar el resultado</p>
</li>
<li>
<p>resolver la dirección efectiva</p>
</li>
</ul>
</div>
</li>
<li>
<p>Interruption       : II</p>
<div class="ulist">
<ul>
<li>
<p>El programa puede ser interrumpido por la prioridad de ejecutar otro programa de atención a periféricos, etc..Una vez atendida la interrupción el programa continua con el siguiente ciclo de instrucción.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Next Instruction   : NI</p>
</li>
</ol>
</div>
</li>
<li>
<p>Ciclo de instrucción</p>
<div class="ulist">
<ul>
<li>
<p>Después de la fase de captación de la instrucción (FI) le sigue la fase de Ejecución (EI) ó la Fase de determinación de la Dirección Efectiva del Operando y Obtención del operando (OF)</p>
</li>
<li>
<p>Después de la fase de ejecución puede haber un ciclo de atención a una interrupción.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_máquina_ias_de_von_neumann">7.6.3. Ejemplo: máquina IAS de Von-Neumann</h4>
<div class="ulist">
<ul>
<li>
<p>Tema 2: <a href="../von_neumann/upna_von_neumann.html">Arquitectura Von-Neumann</a></p>
</li>
<li>
<p>Cada instrucción de la computadora IAS se ejecuta siguiendo una secuencia de fases. Dicha secuencia se repite para cada instrucción y se conoce como el ciclo de instrucción de la unidad central de proceso (CPU).</p>
</li>
<li>
<p>La unidad de control es la unidad de la CPU que implementa cada fase del ciclo de instrucción.</p>
</li>
<li>
<p>La unidad de control controla la ruta de datos de la CPU mediante microordenes.</p>
</li>
<li>
<p>Internamente está formada por el circuito generador de microordenes y por los registros : contador de programa y registro de instrucción.</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_diagrama_de_microoperaciones">Diagrama de Microoperaciones</h5>
<div class="ulist">
<ul>
<li>
<p>Microoperaciones: operaciones realizadas por la CPU internamente, al ejecutar una Instrucción Máquina.</p>
<div class="ulist">
<ul>
<li>
<p>Ejemplos: escribir en el registro MAR, orden de lectura a la MPrincipal, leer de MBR, interpretar de IR, incrementar PC, etc</p>
</li>
<li>
<p>Ejecución Síncrona con el reloj de la CPU:</p>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/ditaa/svg/eNpTUICBEAVbBUP9NC4bXSzAjotLARVog8W1KRdFN7gGiaRIdLgYXEa56GgYIwzWRk3Z2khpkSJRABJsgwo=" alt="Diagram">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Flancos de reloj: Cambio de nivel 0&#8594;1 (positivos) o  1&#8594;0 (negativos)</p>
</li>
<li>
<p>IAS no es síncrona: una microoperación no comienza con ningún patrón de tiempos.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Descripción de las micro-operaciones: Register Transfer Language (RTL)</p>
<div class="imageblock text-center">
<div class="content">
<img src="./images/von_neumann/ias_operation.png" alt="ias operation">
</div>
<div class="title">Figure 32. IAS Operation</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Operación de la máquina IAS:</p>
<div class="ulist">
<ul>
<li>
<p>El ciclo de instrucción tiene dos FASES</p>
</li>
<li>
<p>La primera fase es común a todas las instrucciones.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Ejemplos de instrucciones</p>
<div class="ulist">
<ul>
<li>
<p>X: referencia del operando</p>
</li>
<li>
<p>AC &#8592; M(X)</p>
</li>
<li>
<p>GOTO M(X,0:19): salto incondicional a la dirección X. X apunta a dos instrucciones. X,0:19 es la referencia de la Instrucción de la izda.</p>
</li>
<li>
<p>If AC&gt;0 goto M(X,0:19): salto condicional</p>
</li>
<li>
<p>AC &#8592; AC+M(x).</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_microarquitectura_unidades_funcionales">7.7. Microarquitectura: Unidades Funcionales</h3>
<div class="sect3">
<h4 id="_introducción_8">7.7.1. Introducción</h4>
<div class="ulist">
<ul>
<li>
<p>Se conoce con el nombre microarquitectura a la arquitectura interna del microprocesador.</p>
<div class="ulist">
<ul>
<li>
<p>La microarquitectura es el diseño e implementación del ciclo de instrucción del conjunto de instrucciones definido por ISA.</p>
</li>
<li>
<p>Ejemplos</p>
<div class="ulist">
<ul>
<li>
<p>Intel: 8051, x86</p>
</li>
<li>
<p>AMD: x86</p>
</li>
<li>
<p>ARM: Cortex</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_implementación_del_ciclo_de_instrucción">7.7.2. Implementación del ciclo de instrucción</h4>
<div class="ulist">
<ul>
<li>
<p>¿Cómo implementar el ciclo de instrucción?</p>
<div class="ulist">
<ul>
<li>
<p>Mediante un Circuito Electrónico Digital secuencial: Máquina de estados finitos FSM que implementa la secuencia del diagrama de estados y que recibe el nombre de Unidad de Control.</p>
</li>
<li>
<p>La Unidad de Control es una secuencia de estados que van realizando las distintas fases del ciclo de instrucción.</p>
</li>
<li>
<p>Las distintas fases del ciclo de instrucción utilizan distintas unidades funcionales como: registros, ALU, etc</p>
</li>
<li>
<p>La interpretación de distintas instrucciones máquina dará lugar a diferentes secuencias de estados en la Unidad de Control.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_estructura_de_la_cpu">7.7.3. Estructura de la CPU</h4>
<div class="ulist">
<ul>
<li>
<p>Tres recursos básicos: Unidad de Control, <strong>Unidad de Ejecución</strong> y Registros.</p>
</li>
<li>
<p>Dos Bloques básicos de la CPU</p>
<div class="ulist">
<ul>
<li>
<p>Unidad de Control (UC) y  la Ruta de Datos (DataPath).</p>
</li>
</ul>
</div>
</li>
<li>
<p>La unidad de control esta formada por</p>
<div class="ulist">
<ul>
<li>
<p>generador de las microoperaciones que implementan el ciclo de instrucción</p>
</li>
<li>
<p>registros: registro de instrucción IR, registro contador de programa PC</p>
</li>
</ul>
</div>
</li>
<li>
<p>La Ruta de Datos esta formada por</p>
<div class="ulist">
<ul>
<li>
<p><strong>Unidad de Ejecución UE :</strong></p>
<div class="ulist">
<ul>
<li>
<p>Unidad Aritmetico Lógica ALU: cálculos números enteros</p>
</li>
<li>
<p>Unidad de Punto Flotante FPU: cálculos números reales</p>
</li>
<li>
<p>Unidad Load/Store LSU: cálculos de la dirección efectiva y acceso a la memoria principal</p>
<div class="ulist">
<ul>
<li>
<p>Memory Management Unit (MMU): cálculo de la dirección efectiva FISICA de la MP. Traduce las direcciones virtuales de memoria utilizadas por la cpu  en direcciones físicas de la memoria principal.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>los Registros</p>
<div class="ulist">
<ul>
<li>
<p>Registros de propósito general GPR accesibles por el programador</p>
</li>
<li>
<p>Registros de estado SR</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_fase_de_captación">7.7.4. Fase de Captación</h4>
<div class="ulist">
<ul>
<li>
<p>Ejemplo: Microoperaciones de la Fase de captación del ciclo de instrucción.</p>
<div class="ulist">
<ul>
<li>
<p>Se realiza la lectura de una instrucción mediante las siguientes acciones que son activadas por la Unidad de control:</p>
<div class="ulist">
<ul>
<li>
<p>El Contador de Programa (PC) o Instruction Pointer (IP) contiene la dirección de referencia de la instrucción a captar</p>
</li>
<li>
<p>El Memory Address Register (MAR) se carga con el contenido del (PC)</p>
</li>
<li>
<p>El bus de direcciones del sistema se carga con el contenido de MAR</p>
</li>
<li>
<p>Se vuelca  el contenido de la dirección apuntada al Buffer i/o de memoria, de ahí al bus de datos transfiriendose así al Memory Buffer Register (MBR)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/cpu/12_6.jpg" alt="12 6">
</div>
<div class="title">Figure 33. Flujo de Datos. Ciclo de Captación</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Secuencia de las microordenes en el ejemplo:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>MAR &#8594; address bus</p>
</li>
<li>
<p>UC &#8594; control bus</p>
</li>
<li>
<p>data bus &#8594; MBR</p>
</li>
<li>
<p>MBR &#8594; IR y UC &#8594; PC</p>
</li>
<li>
<p>al finalizar la ejecución: PC &#8594; MAR</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_perspectiva_de_la_cpu">7.7.5. Perspectiva de la CPU</h4>
<div class="ulist">
<ul>
<li>
<p>Divimos la CPU en 5 unidades:</p>
<div class="ulist">
<ul>
<li>
<p>Unidad de Control (UC)</p>
</li>
<li>
<p>Unidad de Ejecución (UE)</p>
</li>
<li>
<p>Registros : de Propósito General (rax,mmx,sse,xmm,..), control (usuario,superusuario,paginación,interrupción,&#8230;&#8203;) y status (rflags, ..).</p>
<div class="ulist">
<ul>
<li>
<p>Los registros de control no son accesibles por el usuario, son accesibles por el sistema operativo.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Memoria Cache L0</p>
</li>
<li>
<p>Memory Management Unit (MMU)</p>
</li>
<li>
<p>Reloj para sincronizar las tareas: facilita el diseño del Hardware.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_unidad_de_control">Unidad de Control</h5>
<div class="ulist">
<ul>
<li>
<p>The control unit (sometimes called the fetch / decode unit) is responsible for retrieving individual instructions from their location in memory, then translating them into commands that the CPU can understand.   These commands are commonly referred to as machine-language instructions, but are sometimes called <strong>micro-operations</strong>, or UOPs.  When the translation is complete, the control unit sends the UOPs to the execution unit for processing.</p>
</li>
<li>
<p>Señales de control de la UC</p>
<div class="ulist">
<ul>
<li>
<p>Señales digitales binarias</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_unidad_de_ejecucion_eu">Unidad de Ejecucion (EU)</h5>
<div class="ulist">
<ul>
<li>
<p>The execution unit is responsible for performing the third step of the instruction cycle, namely, executing, or performing the operation that was specified by the instruction.</p>
</li>
<li>
<p>Incluye: ALU+FPU+LSU+RPG</p>
<div class="ulist">
<ul>
<li>
<p>Operaciones: Aritméticas, Lógicas, Transferencia,</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_ruta_de_datos">Ruta de Datos</h5>
<div class="ulist">
<ul>
<li>
<p>Es la ruta  que realizan los datos ( instrucciones, campos del formato de instrucciones, operando, dirección, etc &#8230;&#8203;) a través del procesador, internamente al procesador, dirigidos por la Unidad de Control.</p>
</li>
<li>
<p>Es necesario interconectar las distintas unidades y subunidades de la CPU para poder transferir y procesar los bits y conjuntos de bits entre ellas.</p>
</li>
<li>
<p>Los microcomandos de la UC en forma de señal transportan y procesan dichos datos.</p>
<div class="ulist">
<ul>
<li>
<p>Ejemplos de microcomandos: abrir puerta, conectar bus, multiplexar datos, etc &#8230;&#8203;microordenes de control del hardware</p>
</li>
<li>
<p>Dicho transporte y procesamiento  dependerá de la interpretación de la instrucción en ejecución y del diseño de la  microarquitectura.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Los componentes básicos de la Ruta de Datos son :</p>
<div class="ulist">
<ul>
<li>
<p>Unidades de transporte: BUS, conmutador, multiplexor, etc</p>
</li>
<li>
<p>Unidad de memoria: cálculo de la dirección efectiva, interfaz con la memoria externa</p>
</li>
<li>
<p>Unidades de procesamiento: ALU</p>
</li>
<li>
<p>Unidades de almacenamiento: registros</p>
</li>
</ul>
</div>
</li>
<li>
<p>RTL: Register Transfer Language</p>
<div class="ulist">
<ul>
<li>
<p>Lenguaje para indicar las acciones de transporte, procesamiento y almacenamiento.</p>
<div class="ulist">
<ul>
<li>
<p>AC &#8592; [PC]+ M[CS:SP]</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Esquema de la Ruta de Datos</p>
<div class="imageblock text-center">
<div class="content">
<img src="./images/cpu/datapath.jpg" alt="datapath">
</div>
<div class="title">Figure 34. Datapath</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Líneas gruesas: bus de datos</p>
</li>
<li>
<p>Líneas finas:   bus de control &#8594; chip select, microorden sumar, cargar registro, etc ..</p>
</li>
</ul>
</div>
</li>
<li>
<p>Ver <em>applet</em> de la ruta de datos del apartado Imágenes</p>
</li>
<li>
<p>Diseño del datapath</p>
<div class="ulist">
<ul>
<li>
<p>determinar que microunidades son necesarias</p>
</li>
<li>
<p>cómo conectarlas</p>
</li>
<li>
<p>Qué microseñales accionar y cuándo en cada microoperación. Paralelismo a nivel de microoperaciones</p>
</li>
<li>
<p>ubicación y temporización de los datos según la secuencia del diagrama de estados de la UC</p>
<div class="ulist">
<ul>
<li>
<p>AC &#8592; [PC]+ M[CS:SP] &#8658; microoperaciones asociadas y diagrama de tiempos</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_unidad_de_control_microprogramada">7.7.6. Unidad de Control Microprogramada</h4>
<div class="ulist">
<ul>
<li>
<p>Unidad de Control Microprogramada vs Cableada</p>
</li>
<li>
<p>Microcableada: El secuenciados o FSM de la unidad de control ejecuta <em>directamente</em> las instrucciones en código máquina almacenadas en la memoria principal</p>
</li>
<li>
<p>Microprogramada:</p>
<div class="ulist">
<ul>
<li>
<p>Las instrucciones máquina (ISA) almacenadas en la memoria principal y cuya secuencia consituye el <strong>código máquina</strong> del programa del usuario no son ejecutadas directamente por la UC. En su lugar cada instrucción en código máquina es traducida en una secuencia de <strong>microinstrucciones</strong> y cada microinstrucción genera las microoperaciones o microseñales de la unidad de control que conforman el ciclo de instrucción.</p>
</li>
<li>
<p>La secuencia de microinstrucciones asociadas a una microinstrucción constituye el <strong>microcódigo</strong> que se encuentra almacenada en una memoria de sólo lectura (Read Only Memory ROM) interna de la Unidad de control.</p>
</li>
<li>
<p>Cambiando o añadiendo microcódigo a nuestra Unidad de Control conseguimos nuevas arquitecturas ISA de una manera más flexible que con la unidad de control cableada.</p>
<div class="ulist">
<ul>
<li>
<p><a href="http://en.wikipedia.org/wiki/Microcode">microcode</a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_arquitecturas_ciscrisc">7.8. Arquitecturas CISC/RISC</h3>
<div class="sect3">
<h4 id="_introducción_9">7.8.1. Introducción</h4>
<div class="ulist">
<ul>
<li>
<p>CISC: Complex Instruction Set Computer</p>
</li>
<li>
<p>RISC: Reduced Instruction Set Computer</p>
</li>
<li>
<p>CISC y RISC son dos filosofías de diseño de un computador, dos arquitecturas.</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_cisc">CISC</h5>
<div class="ulist">
<ul>
<li>
<p>Ejemplos: Motorola 68k, Intel x86.</p>
</li>
<li>
<p>Instrucciones de varios bytes y no uniformes.</p>
</li>
<li>
<p>Necesita un HW complejo que ocupa mucho espacio y necesita muchos ciclos de reloj.</p>
</li>
<li>
<p>La arquitectura del lenguaje ensamblador está próxima a un lenguaje de alto nivel cómo el lenguaje C por lo que facilita la tarea a los compiladores y a los programadores de lenguaje ensamblador.</p>
</li>
<li>
<p>En cambio complica el diseño e implementación de elementos hardware como la CPU.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_risc">RISC</h5>
<div class="ulist">
<ul>
<li>
<p>Ejemplos: PowerPC, ARM, MIPS and SPARC</p>
</li>
<li>
<p>Apuesta por un Hardware sencillo por lo que las instrucciones han de ser sencillas, regulares.</p>
<div class="ulist">
<ul>
<li>
<p>Un HW sencillo es rápido y ocupa poca área del chip.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Inconveniente: Gran número de accesos a memoria para capturar las instrucciones, los operandos y  el resultado.</p>
<div class="ulist">
<ul>
<li>
<p>Solución: incrementar la memoria interna: el número de Registros internos y la memoria caché. Para lo cual hay espacio debido al HW sencillo.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_cuestiones">Cuestiones</h5>
<div class="ulist">
<ul>
<li>
<p>Qué arquitectura optimiza el tamaño de bytes del programa</p>
</li>
<li>
<p>Qué arquitectura optimiza el tiempo de ejecución del cada instrucción</p>
</li>
<li>
<p>Qué arquitectura optimiza el tamaño y coste de fabricación de la CPU</p>
</li>
<li>
<p>Qué arquitectura optimiza el consumo</p>
</li>
<li>
<p>Qué arquitectura optimiza el número de capturas a memoria. ¿Existe indepencia entre captura y ejecución de instrucciones?</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_sw">SW</h5>
<div class="ulist">
<ul>
<li>
<p>Un programa ensamblador de una arquitectura RISC tiene más instrucciones que un CISC</p>
</li>
<li>
<p>Cada instrucción RISC se ejecuta en menor tiempo que una CISC.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_tabla_comparativa">7.8.2. Tabla Comparativa</h4>
<div class="ulist">
<ul>
<li>
<p><a href="http://cs.stanford.edu/people/eroberts/courses/soco/projects/risc/risccisc/">RISC vs CISC</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_instruction_level_parallelism_ilp">7.9. Instruction Level Parallelism (ILP)</h3>
<div class="ulist">
<ul>
<li>
<p><a href="http://en.wikipedia.org/wiki/Instruction-level_parallelism">wikipedia</a></p>
<div class="ulist">
<ul>
<li>
<p>Instruction-level parallelism (ILP) es la medida de cuantas instrucciones de un programa pueden ser ejecutadas simultáneamente. El solapamiento de la ejecución de las instrucciones recibe el nombre de instruction level parallelism (ILP)</p>
</li>
<li>
<p>Son dos los mecanismos para conseguir el ILP</p>
<div class="ulist">
<ul>
<li>
<p>Hardware</p>
</li>
<li>
<p>Software</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Técnicas de diseño de microarquitecturas que persiguen un solape ILP</p>
<div class="ulist">
<ul>
<li>
<p>VLIW</p>
</li>
<li>
<p>Superscalar</p>
</li>
<li>
<p>Pipelining (Segmentación)</p>
</li>
<li>
<p>Out-of-order execution</p>
</li>
<li>
<p>etc</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_vliw_vs_superscalar">7.9.1. VLIW vs Superscalar</h4>
<div class="sect4">
<h5 id="_vliw">VLIW</h5>
<div class="ulist">
<ul>
<li>
<p>Very Long Instruction Words</p>
</li>
<li>
<p>La CPU contiene múltiples Unidades de Ejecución</p>
</li>
<li>
<p>Una palabra contiene tantas instrucciones como unidades de ejecución.</p>
<div class="ulist">
<ul>
<li>
<p>A la palabra se le denomina Instruction Word, la cual contiene múltiples instrucciones máquina.</p>
</li>
<li>
<p>El <em>compilador</em> crea las Instrucciones Word con las múltiples instrucciones <strong>asignando</strong> a cada una de ellas una Unidad de Ejecución distinta.</p>
<div class="ulist">
<ul>
<li>
<p>Múltiples Instrucciones en Paralelo</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_superscalar">Superscalar</h5>
<div class="ulist">
<ul>
<li>
<p>La arquitectura superescalar significa que la CPU tiene múltiples Unidades de Ejecución (UE), no confundir con múltiples núcleos (core), y es la <em>propia CPU</em> la que <strong>asigna</strong> en tiempo de ejecución los recursos de la máquina a las distintas instrucciones .</p>
</li>
<li>
<p>Dicha arquitectura permite la ejecución simultánea de múltiples instrucciones.</p>
</li>
<li>
<p>Una CPU superscalar n-way significa que puede ejecutar simultáneamente n instrucciones.</p>
</li>
<li>
<p>Superscalar no significa multinúcleo. Un único núcleo es superscalar.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_comparativa_superscalar_vliw">Comparativa Superscalar-VLIW</h5>
<div class="ulist">
<ul>
<li>
<p>One of the great debates in computer architecture is static vs. dynamic. <strong>static</strong> typically means "let&#8217;s make our compiler take care of this", while <strong>dynamic</strong> typically means "let&#8217;s build some hardware that takes care of this". Each side has its advantages and disadvantages. the compiler approach has the benefit of time: a compiler can spend all day analyzing the heck out of a piece of code. however, the conclusions that a compiler can reach are limited, because it doesn&#8217;t know what the values of all the variables will be when the program is actually run. As you can imagine, if we go for the hardware approach, we get the other end of the stick. there is a limit on the amount of analysis we can do in hardware, because our resources are much more limited. on the other hand, we can analyze the program when it actually runs, so we have complete knowledge of all the program&#8217;s variables.</p>
</li>
<li>
<p><strong>VLIW</strong> approaches typically fall under the "static" category, where the compiler does all the work.</p>
</li>
<li>
<p><strong>Superscalar</strong> approaches typically fall under the "dynamic" category, where special hardware on the processor does all the work. consider the following code sequence:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">sw</span> <span class="err">$</span><span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">(</span><span class="err">$</span><span class="mi">2</span><span class="p">)</span>
<span class="n">lw</span> <span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">(</span><span class="err">$</span><span class="mi">5</span><span class="p">)</span>

<span class="err">$</span> <span class="n">significa</span> <span class="n">direccionamiento</span> <span class="n">directo</span>
<span class="p">()</span> <span class="n">direccionamiento</span> <span class="n">indirecto</span> <span class="n">indexado</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>suppose  we can run two memory operations in <strong>parallel</strong> [but only if they have <strong>no dependencies</strong>, of course]. are there dependencies between these two instructions? well, it depends on the values of $5 and $2. if $5 is 0, and $2 is 4, then they depend on each other: we must run the store before the load.</p>
<div class="ulist">
<ul>
<li>
<p>in a VLIW approach, our compiler decides which instructions are safe to run in parallel. there&#8217;s no way our compiler can tell for sure if there is a dependence here. so we must stay on the safe side, and dictate that the store must always run before the load. if this were a bigger piece of code, we could analyze the code and try to build a proof that shows there is no dependence. [modern parallelizing compilers actually do this!]</p>
</li>
<li>
<p>if we decide on a SUPERSCALAR approach, we have a piece of hardware on our processor that decides whether we can run instructions in parallel. the problem is easier, because this dependence check will happen in a piece of hardware on our processor, as the code is run. so we will know what the values of $2 and $5 are. this means that we will always know if it is safe to run these two instructions in parallel.</p>
<div class="ulist">
<ul>
<li>
<p>Hopefully you see some of the tradeoffs involved. dynamic approaches have more program information available to them, but the amount of resources available for analysis are very limited. for example, if we want our superscalar processor to search the code for independent instructions, things start to get really hairy. static approaches have less program information available to them, but they can spend lots of resources on analysis. for example, it&#8217;s relatively easy for a compiler to search the code for independent instructions.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_pipeline_segmentacion">7.9.2. Pipeline (Segmentacion)</h4>
<div class="ulist">
<ul>
<li>
<p>Pipeline: cauce o tubería.</p>
</li>
<li>
<p>Ejemplo de Lavado de coches</p>
<div class="ulist">
<ul>
<li>
<p>Fases: Humedecer - Enjabonar - Cepillar - Aclarar - Secar - Abrillantar</p>
</li>
</ul>
</div>
</li>
<li>
<p>Máquina Secuencial</p>
<div class="ulist">
<ul>
<li>
<p>Cola de coches ante la máquina</p>
</li>
<li>
<p>Si un coche está en cualquiera de las fases no entra el siguiente coche.</p>
</li>
<li>
<p>El intervalo de tiempo de salida de coches será la suma de todas las fases. ¿Cada cuanto tiempo sale un coche del lavadero?</p>
</li>
<li>
<p><strong>Througput (Producción)</strong>: Número de coches de salida por unidad de tiempo</p>
</li>
</ul>
</div>
</li>
<li>
<p>Segmentación frente a Secuencial.</p>
<div class="ulist">
<ul>
<li>
<p>En lugar de tener una máquina que realice todas la fases tenemos máquinas independientes que realizan cada fase.</p>
</li>
<li>
<p>El intervalo de tiempo de salida de coches será el de la duración de la fase de mayor duración.</p>
</li>
<li>
<p>El througput, del número de coches atendidos por unidad de tiempo, aumenta.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Flujo de Instrucciones con segmentación en 2 etapas</p>
</li>
</ul>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/cpu/12_9.jpg" alt="12 9">
</div>
<div class="title">Figure 35. Segmentación en 2 etapas</div>
</div>
<div class="ulist">
<ul>
<li>
<p>En caso de que los tiempos de cada etapa sean distintos o halla penalización por saltos en el flujo , se producirán tiempos de espera.</p>
</li>
</ul>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/cpu/12_10.jpg" alt="12 10">
</div>
<div class="title">Figure 36. Diagrama de tiempos con segmentación de 6 etapas</div>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/cpu/12_11.jpg" alt="12 11">
</div>
<div class="title">Figure 37. Diagrama de tiempos. Salto incondicional</div>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/cpu/12_12.jpg" alt="12 12">
</div>
<div class="title">Figure 38. Flujo de instrucciones con segmentación de 6 etapas</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ejercicios">7.10. Ejercicios</h3>
<div class="ulist">
<ul>
<li>
<p>Capítulo 12 del libro de texto William Stalling.</p>
</li>
<li>
<p>Capítulo 13 del libro de texto William Stalling</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_imagenes">7.11. Imagenes</h3>
<div class="ulist">
<ul>
<li>
<p><a href="./images/cpu/images_cpu.html">Imagenes</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="paragraph nav-footer">
<p>↑ Up: <a href="_ii_unidades_básicas_procesador_central_unidad_de_memoria_mecanismos_entradasalida.html">II Unidades Básicas: Procesador Central, Unidad de Memoria, Mecanismos Entrada/Salida.</a> | ⌂ Home: <a href="eecc_book.html">Estructura de Computadores  (240306)</a> | Next: <a href="_mecanismos_de_entradasalida.html">Mecanismos de Entrada/Salida</a> →</p>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2022-09-14 15:29:34 +0200
</div>
</div>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]],
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },
  TeX: { equationNumbers: { autoNumber: "none" } }
})
MathJax.Hub.Register.StartupHook("AsciiMath Jax Ready", function () {
  MathJax.InputJax.AsciiMath.postfilterHooks.Add(function (data, node) {
    if ((node = data.script.parentNode) && (node = node.parentNode) && node.classList.contains("stemblock")) {
      data.math.root.display = "block"
    }
    return data
  })
})
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
</body>
</html>