<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.17">
<meta name="keywords" content="computer, architecture">
<meta name="author" content="Cándido Aramburu">
<title>Estructura de Computadores  (240306)</title>
<style>
@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";
@import "https://cdn.jsdelivr.net/gh/asciidoctor/asciidoctor@2.0/data/stylesheets/asciidoctor-default.css";



h1, h2, h3, h4, h5, h6, #toctitle,
.sidebarblock > .content > .title {
  color: rgba(221, 72, 20, 0.8);
}



</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
pre.rouge table td { padding: 5px; }
pre.rouge table pre { margin: 0; }
pre.rouge .cm {
  color: #999988;
  font-style: italic;
}
pre.rouge .cp {
  color: #999999;
  font-weight: bold;
}
pre.rouge .c1 {
  color: #999988;
  font-style: italic;
}
pre.rouge .cs {
  color: #999999;
  font-weight: bold;
  font-style: italic;
}
pre.rouge .c, pre.rouge .ch, pre.rouge .cd, pre.rouge .cpf {
  color: #999988;
  font-style: italic;
}
pre.rouge .err {
  color: #a61717;
  background-color: #e3d2d2;
}
pre.rouge .gd {
  color: #000000;
  background-color: #ffdddd;
}
pre.rouge .ge {
  color: #000000;
  font-style: italic;
}
pre.rouge .gr {
  color: #aa0000;
}
pre.rouge .gh {
  color: #999999;
}
pre.rouge .gi {
  color: #000000;
  background-color: #ddffdd;
}
pre.rouge .go {
  color: #888888;
}
pre.rouge .gp {
  color: #555555;
}
pre.rouge .gs {
  font-weight: bold;
}
pre.rouge .gu {
  color: #aaaaaa;
}
pre.rouge .gt {
  color: #aa0000;
}
pre.rouge .kc {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kd {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kn {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kp {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kr {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kt {
  color: #445588;
  font-weight: bold;
}
pre.rouge .k, pre.rouge .kv {
  color: #000000;
  font-weight: bold;
}
pre.rouge .mf {
  color: #009999;
}
pre.rouge .mh {
  color: #009999;
}
pre.rouge .il {
  color: #009999;
}
pre.rouge .mi {
  color: #009999;
}
pre.rouge .mo {
  color: #009999;
}
pre.rouge .m, pre.rouge .mb, pre.rouge .mx {
  color: #009999;
}
pre.rouge .sa {
  color: #000000;
  font-weight: bold;
}
pre.rouge .sb {
  color: #d14;
}
pre.rouge .sc {
  color: #d14;
}
pre.rouge .sd {
  color: #d14;
}
pre.rouge .s2 {
  color: #d14;
}
pre.rouge .se {
  color: #d14;
}
pre.rouge .sh {
  color: #d14;
}
pre.rouge .si {
  color: #d14;
}
pre.rouge .sx {
  color: #d14;
}
pre.rouge .sr {
  color: #009926;
}
pre.rouge .s1 {
  color: #d14;
}
pre.rouge .ss {
  color: #990073;
}
pre.rouge .s, pre.rouge .dl {
  color: #d14;
}
pre.rouge .na {
  color: #008080;
}
pre.rouge .bp {
  color: #999999;
}
pre.rouge .nb {
  color: #0086B3;
}
pre.rouge .nc {
  color: #445588;
  font-weight: bold;
}
pre.rouge .no {
  color: #008080;
}
pre.rouge .nd {
  color: #3c5d5d;
  font-weight: bold;
}
pre.rouge .ni {
  color: #800080;
}
pre.rouge .ne {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nf, pre.rouge .fm {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nl {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nn {
  color: #555555;
}
pre.rouge .nt {
  color: #000080;
}
pre.rouge .vc {
  color: #008080;
}
pre.rouge .vg {
  color: #008080;
}
pre.rouge .vi {
  color: #008080;
}
pre.rouge .nv, pre.rouge .vm {
  color: #008080;
}
pre.rouge .ow {
  color: #000000;
  font-weight: bold;
}
pre.rouge .o {
  color: #000000;
  font-weight: bold;
}
pre.rouge .w {
  color: #bbbbbb;
}
pre.rouge {
  background-color: #f8f8f8;
}
</style>
<!-- Change some CSS.
<style>
.imageblock{
  &.text-center > .title {
    text-align: center !important;
  }
}
</style>

-->

<style type="text/css"> .imageblock > .title { text-align: center; } </style>

<style>.toc-current{font-weight: bold;} .toc-root{font-family: "Open Sans","DejaVu Sans",sans-serif;
                       font-size: 0.9em;} #content{display: flex; flex-direction: column; flex: 1 1 auto;}
             .nav-footer{text-align: center; margin-top: auto;}
             .nav-footer > p > a {white-space: nowrap;}</style>
</head>
<body id="_procesador_central" class="book">
<div id="header">
<h1>Estructura de Computadores  (240306)</h1>
<div class="details">
<span id="author" class="author">Cándido Aramburu</span><br>
<span id="email" class="email"><a href="mailto:candido@unavarra.es">candido@unavarra.es</a></span><br>
<span id="revdate">2022-11-03</span>
</div>
<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<p><span class="toc-root"><a href="eecc_book.html">Estructura de Computadores  (240306)</a></span></p><ul class="sectlevel0">
<li><a href="_i_arquitectura_del_repertorio_de_instrucciones_isa_computadora_von_neumann_datos_instrucciones_programación.html">I Arquitectura del Repertorio de Instrucciones (ISA): computadora von Neumann, datos, instrucciones, programación.</a>
</li>
<li><a href="_ii_unidades_básicas_procesador_central_unidad_de_memoria_mecanismos_entradasalida.html">II Unidades Básicas: Procesador Central, Unidad de Memoria, Mecanismos Entrada/Salida.</a>
<ul class="sectlevel1">
<li><a href="_procesador_central.html"><span class="toc-current">7. Procesador Central</span></a>
<ul class="sectlevel2">
<li><a href="_procesador_central.html#_temario_7">7.1. Temario</a>
</li>
<li><a href="_procesador_central.html#_refs">7.2. Refs</a>
</li>
<li><a href="_procesador_central.html#_introducción_7">7.3. Introducción</a>
</li>
<li><a href="_procesador_central.html#_computadora_desde_el_punto_de_vista_del_programador_i">7.4. Computadora desde el punto de vista del Programador (I)</a>
<ul class="sectlevel3">
<li><a href="_procesador_central.html#_conjunto_de_instrucciones">7.4.1. Conjunto de Instrucciones</a>
</li>
<li><a href="_procesador_central.html#_ejemplos_intel_x86_motorola_68000_mips_arm">7.4.2. Ejemplos: Intel x86, Motorola 68000, MIPS, ARM</a>
</li>
</ul>
</li>
<li><a href="_procesador_central.html#_microarquitectura_unidades_funcionales_desde_la_perspectiva_hw">7.5. Microarquitectura: Unidades Funcionales desde la perspectiva HW</a>
<ul class="sectlevel3">
<li><a href="_procesador_central.html#_introducción_8">7.5.1. Introducción</a>
</li>
<li><a href="_procesador_central.html#_fases_de_ejecución_de_una_instrucción">7.5.2. Fases de Ejecución de una Instrucción</a>
</li>
<li><a href="_procesador_central.html#_ejemplo_máquina_ias_de_von_neumann">7.5.3. Ejemplo: máquina IAS de Von-Neumann</a>
</li>
<li><a href="_procesador_central.html#_implementación_del_ciclo_de_instrucción_cpu">7.5.4. Implementación del ciclo de instrucción: CPU</a>
</li>
<li><a href="_procesador_central.html#_unidad_de_control_microprogramada">7.5.5. Unidad de Control Microprogramada</a>
</li>
</ul>
</li>
<li><a href="_procesador_central.html#_ejemplos_de_cpu_ias_y_4004_de_intel">7.6. Ejemplos de CPU: IAS y 4004 de Intel</a>
<ul class="sectlevel3">
<li><a href="_procesador_central.html#_ias_2">7.6.1. IAS</a>
</li>
<li><a href="_procesador_central.html#_intel_4004">7.6.2. Intel 4004</a>
</li>
</ul>
</li>
<li><a href="_procesador_central.html#_la_computadora_desde_el_punto_de_vista_del_programador_ii">7.7. La Computadora desde el punto de vista del programador (II)</a>
<ul class="sectlevel3">
<li><a href="_procesador_central.html#_niveles_o_capas_de_abstracción">7.7.1. Niveles o Capas de Abstracción</a>
</li>
<li><a href="_procesador_central.html#_compatibilidad_software">7.7.2. Compatibilidad Software</a>
</li>
</ul>
</li>
<li><a href="_procesador_central.html#_personal_pc_laptop_t560">7.8. Personal PC: Laptop T560</a>
<ul class="sectlevel3">
<li><a href="_procesador_central.html#_linux_commands">7.8.1. linux commands</a>
</li>
<li><a href="_procesador_central.html#_apps">7.8.2. apps</a>
</li>
<li><a href="_procesador_central.html#_web_info">7.8.3. Web info</a>
</li>
<li><a href="_procesador_central.html#_operating_system">7.8.4. Operating system</a>
</li>
<li><a href="_procesador_central.html#_platform">7.8.5. Platform</a>
</li>
<li><a href="_procesador_central.html#_cpu">7.8.6. cpu</a>
</li>
</ul>
</li>
<li><a href="_procesador_central.html#_instruction_level_parallelism_ilp">7.9. Instruction Level Parallelism (ILP)</a>
<ul class="sectlevel3">
<li><a href="_procesador_central.html#_vliw_vs_superscalar">7.9.1. VLIW vs Superscalar</a>
</li>
<li><a href="_procesador_central.html#_pipeline_segmentacion">7.9.2. Pipeline (Segmentacion)</a>
</li>
</ul>
</li>
<li><a href="_procesador_central.html#_arquitecturas_ciscrisc">7.10. Arquitecturas CISC/RISC</a>
<ul class="sectlevel3">
<li><a href="_procesador_central.html#_introducción_10">7.10.1. Introducción</a>
</li>
<li><a href="_procesador_central.html#_cisc">7.10.2. CISC</a>
</li>
<li><a href="_procesador_central.html#_risc">7.10.3. RISC</a>
</li>
<li><a href="_procesador_central.html#_cuestiones">7.10.4. Cuestiones</a>
</li>
<li><a href="_procesador_central.html#_sw">7.10.5. SW</a>
</li>
<li><a href="_procesador_central.html#_tabla_comparativa">7.10.6. Tabla Comparativa</a>
</li>
</ul>
</li>
<li><a href="_procesador_central.html#_arm_cortex_a76cortex_a55">7.11. ARM Cortex-A76/Cortex-A55</a>
<ul class="sectlevel3">
<li><a href="_procesador_central.html#_intro_2">7.11.1. Intro</a>
</li>
<li><a href="_procesador_central.html#_teléfono_huawei_p30_pro">7.11.2. Teléfono Huawei P30 Pro</a>
</li>
<li><a href="_procesador_central.html#_isa_cortex_a76cortex_a55">7.11.3. ISA Cortex-A76/Cortex-A55</a>
</li>
<li><a href="_procesador_central.html#_multicore">7.11.4. Multicore</a>
</li>
<li><a href="_procesador_central.html#_microarquitectura_cortex_a76">7.11.5. Microarquitectura Cortex-A76</a>
</li>
<li><a href="_procesador_central.html#_microarquitectura_cortex_a55">7.11.6. Microarquitectura Cortex-A55</a>
</li>
</ul>
</li>
<li><a href="_procesador_central.html#_ejercicios">7.12. Ejercicios</a>
</li>
</ul>
</li>
<li><a href="_mecanismos_de_entradasalida.html">8. Mecanismos de Entrada/Salida</a>
</li>
<li><a href="_unidad_de_memoria.html">9. Unidad de Memoria</a>
</li>
</ul>
</li>
<li><a href="_iii_ejercicios_de_teoría.html">III Ejercicios de Teoría</a>
</li>
<li><a href="_iv_autoevaluación_teoría.html">IV Autoevaluación Teoría</a>
</li>
<li><a href="_v_guiones_de_prácticas_programación_ensamblador_x86.html">V Guiones de Prácticas: Programación Ensamblador x86</a>
</li>
<li><a href="_vi_hojas_de_referencia_rápida.html">VI Hojas de Referencia Rápida</a>
</li>
<li><a href="_vii_autoevaluación_prácticas.html">VII Autoevaluación Prácticas</a>
</li>
<li><a href="_viii_apéndices.html">VIII Apéndices</a>
</li>
<li><a href="_ix_bibliografía.html">IX Bibliografía</a>
</li>
<li><a href="_x_glosario.html">X Glosario</a>
</li>
<li><a href="_xi_colofón.html">XI Colofón</a>
</li>
<li><a href="_index.html">Index</a>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_procesador_central">7. Procesador Central</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_temario_7">7.1. Temario</h3>
<div class="olist arabic">
<ol class="arabic" start="7">
<li>
<p>Arquitectura y organización de las Computadora IAS de Von Neumann y 4004 de Intel.</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Repaso</p>
</li>
</ol>
</div>
</li>
<li>
<p>Arquitectura y organización de la CPU</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Conjunto de instrucciones</p>
</li>
<li>
<p>Arquitecturas CISC, RISC y VLIW</p>
</li>
<li>
<p>Fases de ejecución de una instrucción</p>
</li>
<li>
<p>Ruta de datos</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_refs">7.2. Refs</h3>
<div class="ulist">
<ul>
<li>
<p>Apuntes : Tema 2: Arquitectura von Neumann (unidad de control)</p>
</li>
<li>
<p>Libro de Texto: Estructura y Organización de Computadores .William Stalling. Capítulo 12.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_introducción_7">7.3. Introducción</h3>
<div class="ulist">
<ul>
<li>
<p>A modo de repaso y como introducción al tema se va a ver la computadora Von Neumann del año 1951 como arquitectura de referencia hasta nuestros días y el primer procesador integrado comercial de Intel, la cpu 4004, a en el año 1971. El resto de CPUs hasta nuestros días son una evolución de dichos procesadores.</p>
</li>
<li>
<p>El objetivo principal de la CPU es la implementación del <em>ciclo de instrucción</em>. Es el soporte hardware para poder llevar a cabo todas las operaciones que conllevan las intrucciones de un programa.</p>
</li>
<li>
<p>Unidad Central de Proceso (CPU) o Procesador.</p>
<div class="ulist">
<ul>
<li>
<p>Nombres: Procesador, microprocesador (El componente electrónico básico es el transistor con un tamaño en sus origenes del orden de la micra ), ..</p>
</li>
<li>
<p>Central porque la computadora tiene varios procesadores: Por ejemplo el controlador de la memoria y  los controladores de los periféricos.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Arquitectura Von-Neumann.</p>
<div class="ulist">
<ul>
<li>
<p>La CPU es una de las unidades básicas que conforman la arquitectura Von-Neumann (CPU-MP-IO) y Buses.</p>
</li>
</ul>
</div>
</li>
<li>
<p>La CPU se puede  ver desde el punto de vista del programador o desde el punto de vista del diseñador de procesadores (microarquitectura)</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Desde el punto de vista del <em>programador</em> interesa conocer:</p>
<div class="ulist">
<ul>
<li>
<p>La Arquitectura del Repertorio  de Instrucciones (ISA). Hoy en días los procesadores se pueden clasificar según su la complejidad o sencillez de la ISA en arquitecturas CISC y RISC. Ejemplo de la arquitectura ISA CISC (Complex Instruction Set Computer) es la arquitectura de Intel x86 ampliamente utilizada en ordenadores personales y ejemplo de la arquitectura ISA RISC (Complex Instruction Set Computer) son los procesadores ARM ampliamente utilizados en los teléfonos móviles.</p>
</li>
<li>
<p>Registros: registros de propósito general accesibles por el programador (acumulador, registro índice, punteros pila, etc), registro de estado,  registros de coma flotante, registros multimedia, resgistros de segmentación de memoria, registros no accesibles como el contador de programa, tamaño de los registros, etc</p>
</li>
<li>
<p>Modos de Funcionamiento de la CPU: modo superusuario, modo usuario, modo interrupción. Los distintos modos de funcionamiento permiten proteger el buen funcioamiento de la cpu según se realicen tareas de usuario, de administrador, de compartición de recursos, etc ..</p>
</li>
</ul>
</div>
</li>
<li>
<p>Desde el punto de vista de la <em>Microarquitectura</em> u organización interna de la CPU.</p>
<div class="ulist">
<ul>
<li>
<p>Las unidades básicas de la CPU son: Unidad de Control (UC), y la Ruta de Datos (ALU,FPU,MMU,Registros y circuitos de enrutamiento como multiplexores, conmutadores,  etc).</p>
</li>
<li>
<p>La microarquitectura de la CPU puede implementar más de una ruta de datos permitiendo así la ejecución simultánea de más de una instrucción. Los procesadores que utilizan dicha tecnología se denominan procesadores superescalares.</p>
</li>
<li>
<p>El ciclo de instrucción puede ser secuencial o segmentado, permitiendo el solapamiento en el tiempo de la ejecución de más de una instrucción (técnicas de paralelismo a nivel de instrucción, ILP)</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>Técnicas HW de optimización de la ejecución de un programa <strong>(Performance)</strong></p>
<div class="ulist">
<ul>
<li>
<p>El objetivo básico a la hora de diseñar nuevas versiones de la CPU es incrementar su rendimiento, es decir, el número de instrucciones que se ejecutan por unidad de tiempo y por ende el tiempo de ejecución de los programas. Diversas técnicas han sido desarrolladas a nivel de la microarquitectura de la computadora con tal objetivo, como:</p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Instruction_pipelining">Segmenación-Pipelining</a>: organizar el ciclo de instrucción en fases o segmentos y ejecutarlos en paralelo.</p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Superscalar_processor">superscalar processor</a></p>
</li>
<li>
<p><a href="https://es.wikipedia.org/wiki/Ejecuci%C3%B3n_fuera_de_orden">Ejecución fuera de Orden OoO</a>: Run time</p>
</li>
<li>
<p><a href="https://es.wikipedia.org/wiki/Renombre_de_registros">Renombre de Registros</a>: Compiler &amp; Run time</p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Branch_predictor">Branch Predictor</a>: Run time</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_computadora_desde_el_punto_de_vista_del_programador_i">7.4. Computadora desde el punto de vista del Programador (I)</h3>
<div class="sect3">
<h4 id="_conjunto_de_instrucciones">7.4.1. Conjunto de Instrucciones</h4>
<div class="sect4">
<h5 id="_arquitectura_isa">Arquitectura (ISA)</h5>
<div class="ulist">
<ul>
<li>
<p>Recordatorio de la primera parte de la asignatura:</p>
<div class="ulist">
<ul>
<li>
<p>Temas: arquitectura von neumann, representación de datos, operaciones aritmetico-lógicas, representación de las instrucciones y programación en lenguaje ensamblador.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Instruction Set Arquitecture (ISA)</p>
<div class="ulist">
<ul>
<li>
<p>La arquitectura del repertorio de instrucciones define: códigos de operación, tipos de operando, modos de direccionamiento, etc</p>
</li>
<li>
<p>Son las instrucciones máquina ejecutables directamente por la CPU en código binario.: <em>lenguaje máquina</em></p>
</li>
<li>
<p>La instrucción a ejecutar está almacenada en código binario en el registro RI de la Unidad de Control.</p>
</li>
</ul>
</div>
</li>
<li>
<p>El repertorio de instrucciones está especificado en el manual del programador de la CPU:</p>
<div class="ulist">
<ul>
<li>
<p>Programamos en <em>lenguaje Ensamblador</em> en lugar de en <em>lenguaje máquina</em></p>
</li>
<li>
<p>El manual contiene la definición de la Arquitectura del Repertorio de Instrucciones.</p>
<div class="ulist">
<ul>
<li>
<p>el listado y descripción de todas las instrucciones ejecutables por el microprocesador</p>
<div class="ulist">
<ul>
<li>
<p>categorías de las instrucciones: transferencia(mov), control(jmpz,loop),aritméticas(add), lógicas(xor), i/o (in/oout)</p>
<div class="ulist">
<ul>
<li>
<p>Mnemónicos del código de operación</p>
</li>
</ul>
</div>
</li>
<li>
<p>Modos de direccionamiento: inmediato, directo, indirecto, desplazamiento</p>
</li>
<li>
<p>Tipos de datos: entero, real, alfanumérico</p>
</li>
</ul>
</div>
</li>
<li>
<p>Formatos binarios</p>
<div class="ulist">
<ul>
<li>
<p>De las instrucciones: campos de operación, operando, modo direccionamiento</p>
</li>
<li>
<p>De los datos: complemento a 2, coma flotante</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplos_intel_x86_motorola_68000_mips_arm">7.4.2. Ejemplos: Intel x86, Motorola 68000, MIPS, ARM</h4>
<div class="ulist">
<ul>
<li>
<p>Ver <a href="_lenguajes_de_programación_en_ensamblador.html#leng_asm">Apéndice Lenguajes Ensamblador</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_microarquitectura_unidades_funcionales_desde_la_perspectiva_hw">7.5. Microarquitectura: Unidades Funcionales desde la perspectiva HW</h3>
<div class="sect3">
<h4 id="_introducción_8">7.5.1. Introducción</h4>
<div class="ulist">
<ul>
<li>
<p>Se conoce con el nombre microarquitectura a la arquitectura interna del microprocesador.</p>
<div class="ulist">
<ul>
<li>
<p>La microarquitectura es el diseño e implementación del ciclo de instrucción del conjunto de instrucciones definido por ISA.</p>
</li>
<li>
<p>Ejemplos</p>
<div class="ulist">
<ul>
<li>
<p>IAS</p>
</li>
<li>
<p>Intel: 4004, 8008, 8051, x86</p>
</li>
<li>
<p>AMD: x86</p>
</li>
<li>
<p>ARM: Cortex</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>El prefijo micro (microelectrónica, microprocesador, microarquitectura, microbus, microprograma, microcódigo, micro-operación, etc) está relacionado con el tamaño de los transistores, de los primeros circuitos integrados o chips, que eran del orden de decenas de MICROMETROS. Todo lo que ocurre en el entorno de la computadora en esa dimensión suele llevar el prefijo micro</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_fases_de_ejecución_de_una_instrucción">7.5.2. Fases de Ejecución de una Instrucción</h4>
<div class="sect4">
<h5 id="_estructura">Estructura</h5>
<div class="imageblock text-center">
<div class="content">
<img src="./images/von_neumann/ias_architecture.png" alt="ias architecture">
</div>
<div class="title">Figure 33. IAS_Architecture</div>
</div>
</div>
<div class="sect4">
<h5 id="_ciclo_diagrama_fases">Ciclo / Diagrama / Fases</h5>
<div class="imageblock text-center">
<div class="content">
<img src="./images/cpu/12_5.jpg" alt="12 5">
</div>
<div class="title">Figure 34. Diagrama de Estados</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Ciclos: El Ciclo de instrucción es una secuencia de Fases ó Ciclos de Máquina. Cada ciclo de máquina se puede ejecutar en uno o más ciclos de reloj de la CPU.</p>
</li>
<li>
<p>Fases del ciclo de instrucción ó Ciclos máquina:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Fetch Instruction : FI</p>
<div class="ulist">
<ul>
<li>
<p>Inicialmente hay que volcar al bus de direcciones de memoria el contenido del Contador de Programa (PC)</p>
</li>
<li>
<p>Captar la instrucción</p>
</li>
<li>
<p>PC &#8592; PC+1</p>
</li>
</ul>
</div>
</li>
<li>
<p>Instruction Decode : ID</p>
<div class="ulist">
<ul>
<li>
<p>interpretar la instrucción</p>
</li>
</ul>
</div>
</li>
<li>
<p>Fetch Operand      : OF</p>
<div class="ulist">
<ul>
<li>
<p>captar datos, captar los operandos</p>
</li>
<li>
<p>resolver la dirección efectiva</p>
</li>
</ul>
</div>
</li>
<li>
<p>Execute  Instruction : EI</p>
<div class="ulist">
<ul>
<li>
<p>procesar la instrucción con los datos</p>
</li>
</ul>
</div>
</li>
<li>
<p>Write Operand: WO</p>
<div class="ulist">
<ul>
<li>
<p>almacencar el resultado</p>
</li>
<li>
<p>resolver la dirección efectiva</p>
</li>
</ul>
</div>
</li>
<li>
<p>Interruption       : II</p>
<div class="ulist">
<ul>
<li>
<p>El programa puede ser interrumpido por la prioridad de ejecutar otro programa de atención a periféricos, etc..Una vez atendida la interrupción el programa continua con el siguiente ciclo de instrucción.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Next Instruction   : NI</p>
</li>
</ol>
</div>
</li>
<li>
<p>Ciclo de instrucción</p>
<div class="ulist">
<ul>
<li>
<p>Después de la fase de captación de la instrucción (FI) le sigue la fase de Ejecución (EI) ó la Fase de determinación de la Dirección Efectiva del Operando y Obtención del operando (OF)</p>
</li>
<li>
<p>Después de la fase de ejecución puede haber un ciclo de atención a una interrupción.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_diagrama_de_microoperaciones">Diagrama de Microoperaciones</h5>
<div class="ulist">
<ul>
<li>
<p>Microoperaciones: operaciones realizadas por la CPU internamente, al ejecutar una Instrucción Máquina.</p>
<div class="ulist">
<ul>
<li>
<p>Ejemplos: escribir en el registro MAR, orden de lectura a la MPrincipal, leer de MBR, interpretar de IR, incrementar PC, etc</p>
</li>
<li>
<p>Ejecución Síncrona con el reloj de la CPU:</p>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/ditaa/svg/eNpTUICBEAVbBUP9NC4bXSzAjotLARVog8W1KRdFN7gGiaRIdLgYXEa56GgYIwzWRk3Z2khpkSJRABJsgwo=" alt="Diagram">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Flancos de reloj: Cambio de nivel 0&#8594;1 (positivos) o  1&#8594;0 (negativos)</p>
</li>
<li>
<p>IAS no es síncrona: una microoperación no comienza con ningún patrón de tiempos.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Descripción de las micro-operaciones: Register Transfer Language (RTL)</p>
<div class="imageblock text-center">
<div class="content">
<img src="./images/von_neumann/ias_operation.png" alt="ias operation">
</div>
<div class="title">Figure 35. IAS Operation</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Operación de la máquina IAS:</p>
<div class="ulist">
<ul>
<li>
<p>El ciclo de instrucción tiene dos FASES</p>
</li>
<li>
<p>La primera fase es común a todas las instrucciones.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Ejemplos de instrucciones</p>
<div class="ulist">
<ul>
<li>
<p>X: referencia del operando</p>
</li>
<li>
<p>AC &#8592; M(X)</p>
</li>
<li>
<p>GOTO M(X,0:19): salto incondicional a la dirección X. X apunta a dos instrucciones. X,0:19 es la referencia de la Instrucción de la izda.</p>
</li>
<li>
<p>If AC&gt;0 goto M(X,0:19): salto condicional</p>
</li>
<li>
<p>AC &#8592; AC+M(x).</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_máquina_ias_de_von_neumann">7.5.3. Ejemplo: máquina IAS de Von-Neumann</h4>
<div class="ulist">
<ul>
<li>
<p>Tema 2: <a href="../von_neumann/upna_von_neumann.html">Arquitectura Von-Neumann</a></p>
</li>
<li>
<p>Cada instrucción de la computadora IAS se ejecuta siguiendo una secuencia de fases. Dicha secuencia se repite para cada instrucción y se conoce como el ciclo de instrucción de la unidad central de proceso (CPU).</p>
</li>
<li>
<p>La unidad de control es la unidad de la CPU que implementa cada fase del ciclo de instrucción.</p>
</li>
<li>
<p>La unidad de control controla la ruta de datos de la CPU mediante microordenes.</p>
</li>
<li>
<p>Internamente está formada por el circuito generador de microordenes y por los registros : contador de programa y registro de instrucción.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_implementación_del_ciclo_de_instrucción_cpu">7.5.4. Implementación del ciclo de instrucción: CPU</h4>
<div class="sect4">
<h5 id="_cómo_implementar_el_ciclo_de_instrucción">¿Cómo implementar el ciclo de instrucción?</h5>
<div class="ulist">
<ul>
<li>
<p>Mediante un Circuito Electrónico Digital secuencial: Máquina de estados finitos FSM que implementa la secuencia del diagrama de estados y que recibe el nombre de Unidad de Control.</p>
</li>
<li>
<p>La Unidad de Control es una secuencia de estados que van realizando las distintas fases del ciclo de instrucción.</p>
</li>
<li>
<p>Las distintas fases del ciclo de instrucción utilizan distintas unidades funcionales como: registros, ALU, etc</p>
</li>
<li>
<p>La interpretación de distintas instrucciones máquina dará lugar a diferentes secuencias de estados en la Unidad de Control.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_estructura_de_la_cpu">Estructura de la CPU</h5>
<div class="ulist">
<ul>
<li>
<p>Tres recursos básicos: Unidad de Control, <strong>Unidad de Ejecución</strong> y Registros.</p>
</li>
<li>
<p>Dos Bloques básicos de la CPU</p>
<div class="ulist">
<ul>
<li>
<p>Unidad de Control (UC) y  la Ruta de Datos (DataPath).</p>
</li>
</ul>
</div>
</li>
<li>
<p>La unidad de control esta formada por</p>
<div class="ulist">
<ul>
<li>
<p>generador de las microoperaciones que implementan el ciclo de instrucción</p>
</li>
<li>
<p>registros: registro de instrucción IR, registro contador de programa PC</p>
</li>
</ul>
</div>
</li>
<li>
<p>La Ruta de Datos esta formada por</p>
<div class="ulist">
<ul>
<li>
<p><strong>Unidad de Ejecución UE :</strong></p>
<div class="ulist">
<ul>
<li>
<p>Unidad Aritmetico Lógica ALU: cálculos números enteros</p>
</li>
<li>
<p>Unidad de Punto Flotante FPU: cálculos números reales</p>
</li>
<li>
<p>Unidad Load/Store LSU: cálculos de la dirección efectiva y acceso a la memoria principal</p>
<div class="ulist">
<ul>
<li>
<p>Memory Management Unit (MMU): cálculo de la dirección efectiva FISICA de la MP. Traduce las direcciones virtuales de memoria utilizadas por la cpu  en direcciones físicas de la memoria principal.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>los Registros</p>
<div class="ulist">
<ul>
<li>
<p>Registros de propósito general GPR accesibles por el programador</p>
</li>
<li>
<p>Registros de estado SR</p>
</li>
<li>
<p>Registros : de Propósito General (rax,mmx,sse,xmm,..), control (usuario,superusuario,paginación,interrupción,&#8230;&#8203;) y status (rflags, ..).</p>
<div class="ulist">
<ul>
<li>
<p>Los registros de control no son accesibles por el usuario, son accesibles por el sistema operativo.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Memoria interna</p>
<div class="ulist">
<ul>
<li>
<p>Memoria Cache L0</p>
</li>
<li>
<p>Memory Management Unit (MMU)</p>
</li>
</ul>
</div>
</li>
<li>
<p>Sincronismo</p>
<div class="ulist">
<ul>
<li>
<p>Reloj para sincronizar las tareas: facilita el diseño del Hardware.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_intel">Intel</h5>
<div class="ulist">
<ul>
<li>
<p>Intel nomina a las distintas Unidades o Circuitos electrónicos que componen la CPU según su implicación en cada fase del ciclo de instrucción con los siguiente es nombres:</p>
<div class="ulist">
<ul>
<li>
<p>Address Unit (AU) : se encarga de obtener la dirección efectiva de la instrucción o dato</p>
</li>
<li>
<p>Bus Unit (BU): se encarga de acceder a los buses de comunicacióń con la memoria principal</p>
</li>
<li>
<p>Instruction Unit (IU): se encarga de interprertar y gestionar la instrucción a ejecutar</p>
</li>
<li>
<p>Execution Unit (EU): se encarga de procesar la instrucción o instrucciones en curso.</p>
</li>
<li>
<p>El Control Unit es el encargado de utilizar y sincronizar las unidades UA-UB-IU-EU para llevar a cabo correctamente los ciclos de instrucción.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_unidad_de_control">Unidad de Control</h5>
<div class="ulist">
<ul>
<li>
<p>The control unit (sometimes called the fetch / decode unit) is responsible for retrieving individual instructions from their location in memory, then translating them into commands that the CPU can understand.   These commands are commonly referred to as machine-language instructions, but are sometimes called <strong>micro-operations</strong>, or UOPs.  When the translation is complete, the control unit sends the UOPs to the execution unit for processing.</p>
</li>
<li>
<p>Señales de control de la UC</p>
<div class="ulist">
<ul>
<li>
<p>Señales digitales binarias</p>
</li>
</ul>
</div>
</li>
<li>
<p>Ejemplo: Microoperaciones de la Fase de captación del ciclo de instrucción.</p>
<div class="ulist">
<ul>
<li>
<p>Se realiza la lectura de una instrucción mediante las siguientes acciones que son activadas por la Unidad de control:</p>
<div class="ulist">
<ul>
<li>
<p>El Contador de Programa (PC) o Instruction Pointer (IP) contiene la dirección de referencia de la instrucción a captar</p>
</li>
<li>
<p>El Memory Address Register (MAR) se carga con el contenido del (PC)</p>
</li>
<li>
<p>El bus de direcciones del sistema se carga con el contenido de MAR</p>
</li>
<li>
<p>Se vuelca  el contenido de la dirección apuntada al Buffer i/o de memoria, de ahí al bus de datos transfiriendose así al Memory Buffer Register (MBR)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/cpu/12_6.jpg" alt="12 6">
</div>
<div class="title">Figure 36. Flujo de Datos. Ciclo de Captación</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Secuencia de las microordenes en el ejemplo:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>MAR &#8594; address bus</p>
</li>
<li>
<p>UC &#8594; control bus</p>
</li>
<li>
<p>data bus &#8594; MBR</p>
</li>
<li>
<p>MBR &#8594; IR y UC &#8594; PC</p>
</li>
<li>
<p>al finalizar la ejecución: PC &#8594; MAR</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_unidad_de_ejecucion_eu">Unidad de Ejecucion (EU)</h5>
<div class="ulist">
<ul>
<li>
<p>The execution unit is responsible for performing the third step of the instruction cycle, namely, executing, or performing the operation that was specified by the instruction.</p>
</li>
<li>
<p>Incluye: ALU+FPU+LSU+RPG</p>
<div class="ulist">
<ul>
<li>
<p>Operaciones: Aritméticas, Lógicas, Transferencia,</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_ruta_de_datos">Ruta de Datos</h5>
<div class="ulist">
<ul>
<li>
<p>Es la ruta  que realizan los datos ( instrucciones, campos del formato de instrucciones, operando, dirección, etc &#8230;&#8203;) a través del procesador, internamente al procesador, dirigidos por la Unidad de Control.</p>
</li>
<li>
<p>Es necesario interconectar las distintas unidades y subunidades de la CPU para poder transferir y procesar los bits y conjuntos de bits entre ellas.</p>
</li>
<li>
<p>Los microcomandos de la UC en forma de señal transportan y procesan dichos datos.</p>
<div class="ulist">
<ul>
<li>
<p>Ejemplos de microcomandos: abrir puerta, conectar bus, multiplexar datos, etc &#8230;&#8203;microordenes de control del hardware</p>
</li>
<li>
<p>Dicho transporte y procesamiento  dependerá de la interpretación de la instrucción en ejecución y del diseño de la  microarquitectura.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Los componentes básicos de la Ruta de Datos son :</p>
<div class="ulist">
<ul>
<li>
<p>Unidades de transporte: BUS, conmutador, multiplexor, etc</p>
</li>
<li>
<p>Unidad de memoria: cálculo de la dirección efectiva, interfaz con la memoria externa</p>
</li>
<li>
<p>Unidades de procesamiento: ALU</p>
</li>
<li>
<p>Unidades de almacenamiento: registros</p>
</li>
</ul>
</div>
</li>
<li>
<p>RTL: Register Transfer Language</p>
<div class="ulist">
<ul>
<li>
<p>Lenguaje para indicar las acciones de transporte, procesamiento y almacenamiento.</p>
<div class="ulist">
<ul>
<li>
<p>AC &#8592; [PC]+ M[CS:SP]</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Esquema de la Ruta de Datos</p>
<div class="imageblock text-center">
<div class="content">
<img src="./images/cpu/datapath.jpg" alt="datapath">
</div>
<div class="title">Figure 37. Datapath</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Líneas gruesas: bus de datos</p>
</li>
<li>
<p>Líneas finas:   bus de control &#8594; chip select, microorden sumar, cargar registro, etc ..</p>
</li>
</ul>
</div>
</li>
<li>
<p>Ver <em>applet</em> de la ruta de datos del apartado Imágenes</p>
</li>
<li>
<p>Diseño del datapath</p>
<div class="ulist">
<ul>
<li>
<p>determinar que microunidades son necesarias</p>
</li>
<li>
<p>cómo conectarlas</p>
</li>
<li>
<p>Qué microseñales accionar y cuándo en cada microoperación. Paralelismo a nivel de microoperaciones</p>
</li>
<li>
<p>ubicación y temporización de los datos según la secuencia del diagrama de estados de la UC</p>
<div class="ulist">
<ul>
<li>
<p>AC &#8592; [PC]+ M[CS:SP] &#8658; microoperaciones asociadas y diagrama de tiempos</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_unidad_de_control_microprogramada">7.5.5. Unidad de Control Microprogramada</h4>
<div class="ulist">
<ul>
<li>
<p>Unidad de Control Microprogramada vs Cableada</p>
</li>
<li>
<p>Microcableada: El secuenciados o FSM de la unidad de control ejecuta <em>directamente</em> las instrucciones en código máquina almacenadas en la memoria principal</p>
</li>
<li>
<p>Microprogramada:</p>
<div class="ulist">
<ul>
<li>
<p>Las instrucciones máquina (ISA) almacenadas en la memoria principal y cuya secuencia consituye el <strong>código máquina</strong> del programa del usuario no son ejecutadas directamente por la UC. En su lugar cada instrucción en código máquina es traducida en una secuencia de <strong>microinstrucciones</strong> y cada microinstrucción genera las microoperaciones o microseñales de la unidad de control que conforman el ciclo de instrucción.</p>
</li>
<li>
<p>La secuencia de microinstrucciones asociadas a una microinstrucción constituye el <strong>microcódigo</strong> que se encuentra almacenada en una memoria de sólo lectura (Read Only Memory ROM) interna de la Unidad de control.</p>
</li>
<li>
<p>Cambiando o añadiendo microcódigo a nuestra Unidad de Control conseguimos nuevas arquitecturas ISA de una manera más flexible que con la unidad de control cableada.</p>
<div class="ulist">
<ul>
<li>
<p><a href="http://en.wikipedia.org/wiki/Microcode">microcode</a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Aunque se sigue utilizando el nombre de CPU, hoy en día la función de las primeras CPU las realizan los núcleos o Cores. Las CPU de hoy en día además del procesador central o core también integran otro tipo de funciones como memoria caché, controladores E/S, etc por lo que realmente se debieran de llamar Sistemas Integrados (system on chip, etc ).
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ejemplos_de_cpu_ias_y_4004_de_intel">7.6. Ejemplos de CPU: IAS y 4004 de Intel</h3>
<div class="sect3">
<h4 id="_ias_2">7.6.1. IAS</h4>
<div class="ulist">
<ul>
<li>
<p><a href="https://es.wikipedia.org/wiki/IAS_machine" class="bare">https://es.wikipedia.org/wiki/IAS_machine</a></p>
</li>
<li>
<p>Development Programmer&#8217;s View of Computer Architecture:</p>
<div class="listingblock">
<div class="content">
<pre>ISA:
  - instrucciones: códigos de operación y modos de direccionamiento
  - formato de datos
  - formato de instrucciones
  - organización de la memoria
  - registros</pre>
</div>
</div>
</li>
<li>
<p>Microarchitecture: HW (no electronics, functional units) View of Computer Architecture</p>
<div class="listingblock">
<div class="content">
<pre>Ciclo de Instrucción
 FI-ID-EI
Unidades
 CU
  uoperations bus
  udata bus
 AU
  PC
 BU
  MAR
  MBR
 IU
  IR, IBR
 EU
  ALU
  AC, QC</pre>
</div>
</div>
</li>
<li>
<p>Platform architecture</p>
<div class="listingblock">
<div class="content">
<pre>CPU
MEMORY
memory BUS: address, data, control (R/W)</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_intel_4004">7.6.2. Intel 4004</h4>
<div class="sect4">
<h5 id="_introducción_9">introducción</h5>
<div class="ulist">
<ul>
<li>
<p>Intel: Intel fue fundada el 18 de julio de 1968 como Integrated Electronics Corporation</p>
</li>
<li>
<p>El primer microprocesador integrado i4004 formó parte de la familia "4001, 4002, 4003, &amp; 4004 Micro Computer Set" <strong>MCS-4 chipset</strong>.</p>
</li>
<li>
<p><a href="https://es.wikipedia.org/wiki/Intel_4004" class="bare">https://es.wikipedia.org/wiki/Intel_4004</a></p>
</li>
<li>
<p>Miscellaneous</p>
<div class="listingblock">
<div class="content">
<pre>Fecha: Diciembre 1971
Coste: 60$
Tecnología: nodo 10 um
Arquitectura de 4 bits</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_isa">ISA</h5>
<div class="ulist">
<ul>
<li>
<p>Development Programmer&#8217;s View of Computer Architecture:</p>
<div class="ulist">
<ul>
<li>
<p>ISA:</p>
<div class="listingblock">
<div class="content">
<pre>  - instrucciones: códigos de operación y modos de direccionamiento
  --- El conjunto de instrucciones está formado por 46 instrucciones
  --- Modos de direccionamiento: directo, indirecto, inmediato.
  - formato de datos
  --- Datos de 4 bits de ancho
  - formato de instrucciones
  --- 41 instrucciones son de 8 bits de ancho y 5 de 16 bits de ancho.
  - organización de la memoria
  --- datos e instrucciones separados en memorias diferentes -&gt; Arquitectura Harvard, no Neumann.
  - registros
  --- 16 registros de proposito general
  --- 3 registros de 12 bits para apuntar a distintos frames del stack</pre>
</div>
</div>
</li>
<li>
<p>tools</p>
<div class="listingblock">
<div class="content">
<pre>assembly language
assembler translate</pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_microarquitectura">Microarquitectura</h5>
<div class="ulist">
<ul>
<li>
<p>Microarchitecture: HW (no electronics, functional units) View of Computer Architecture</p>
<div class="listingblock">
<div class="content">
<pre>Architecture Size : 4 bits
Ciclo de Instrucción
 FI-ID-EI
Unidades
 CU
  uoperations bus
  udata bus -&gt; 4 bits
 AU
  PC -&gt; 12 bits
  stack pointers -&gt; 12 bits
 BU
  memory Address_bus/Data_bus -&gt;
    ATENCIÓN: un único bus para las direcciones y para los datos -&gt; bus compartido, por lo que son necesarios ciclos diferentes en el tiempo.
    direcciones de 12 bits y bus de direcciones de 4 bits:  (multiplexación temporal de 3 ciclos de 4 bits para completar la dirección)
  MAR/MBR : un único registro con doble funcionalidad -&gt; 4 bits
  4 bancos de memoria: Memory Bank -&gt; memory control bus (chip_select, R/W) de la unidad de control
 IU
  IR, IBR
 EU
  ALU
  AC, QC
 Registers
  RPG (General-Purpose Registers)
  Stack
Clock Frequency: 740KHz
Chipset MSC-4</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_memoria">Memoria</h5>
<div class="ulist">
<ul>
<li>
<p>(Se verá en el tema siguiente sobre la unidad de memoria)</p>
</li>
<li>
<p>Organización de la memoria</p>
<div class="ulist">
<ul>
<li>
<p>Bus compartido data/address:un único bus de datos y direcciones de 4 bits.</p>
</li>
<li>
<p>Address multiplexing &#8594; dirección de 12bits=4bits/ciclo x 3ciclos, es decir, la unidad de control necesita 3 ciclos de reloj para completar los 12 bits de direcciones.</p>
</li>
<li>
<p>Tanto la memoria de programa en ROM como de programa en RAM tienen capacidad de 2<sup>12</sup> Bytes, 4KBytes</p>
</li>
<li>
<p>En cambio la memoria de datos en RAM tiene otro tipo de direccionamiento y capacidad de 5120 bits</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Chipset</strong>: constelación de chips.</p>
<div class="listingblock">
<div class="content">
<pre>the i4004 microprocessor chip, which integrates the instruction sequencer, instruction decoder, subroutine stack, ALU, and sixteen 4 bit data registers. This was the first single-chip microprocessor in history.
the i4001 ROM chip combines a 256x8 bit mask-programmable ROM and four software-controllable input/output ports.
the i4002 RAM chip with 320 bits of RAM (4 registers of 20 words of 4 bit) and four software-controllable output ports:
  Bus compartido para datos y direcciones
the i4003 output expander, basically a 10-bit serial-in parallel-out shift-register.</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>A minimal MCS4 system consists of one i4004 CPU and one i4001 ROM chip (and a few external components like the two-phase clock generator), while the largest system  sixteen ROM chips (4 KBytes) and sixteen 4002 RAM chips (640 Bytes).</p>
<div class="ulist">
<ul>
<li>
<p>A diferencia de las arquitecturas actuales, se observa que el chipset incluye la memoria y esta es controlada por la propia CPU a través de instrucciones de gestión de memoria como las instrucciones DCL y SRC que se utilizaban para seleccionar el banco de memoria primero y la dirección del dato después antes de proceder a realizar operaciones con dicho dato.</p>
</li>
<li>
<p>La organización de la memoria RAM en bancos/chips/registro/palabra es como sigue (se verá en el tema siguiente sobre la unidad de memoria):</p>
</li>
</ul>
</div>
</li>
<li>
<p>el objetivo de los Bancos de Memoria es incrementar la capacidad de memoria por encima de la limitación del Contador de Programa y del Bus de Direcciones.</p>
<div class="listingblock">
<div class="content">
<pre>A cada banco (línea CM de la cpu 4004) se pueden conectar hasta 4 chips RAM 4002
El sistema se puede configurar que tenga 4 o 8 bancos.
Por lo tanto el máximo de chips que admite el sistema es de 32.
Cuando se selecciona una instrucción o dato de memoria RAM, se selecciona uno de los bancos,  para el banco seleccionado se selecciona uno de los chips y para el chip seleccionado la palabra (instrucción o dato) de uno de los 4 registros del chip.</pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_la_computadora_desde_el_punto_de_vista_del_programador_ii">7.7. La Computadora desde el punto de vista del programador (II)</h3>
<div class="sect3">
<h4 id="_niveles_o_capas_de_abstracción">7.7.1. Niveles o Capas de Abstracción</h4>
<div class="ulist">
<ul>
<li>
<p>El programador de sistemas se abstrae (en parte) de la implementación del Hardware gracias al Kernel del Sistema Operativo. El programador interactua con el Sistema Operativo para acceder a los recursos HW de la computadora.</p>
</li>
<li>
<p>El programador que desarrolla aplicaciones como compiladores, linkers, recursos del kernel como los drivers de los controladores , gestores del kernel de acceso al hw como configuración de la CPU, de la memoria, etc.. necesitan conocer el Hardware a nivel funcional y no a nivel físico o electrónico y esto se consigue mediante la capa más baja a nivel software, es decir, el lenguaje máquina que consigue abstraer la capa física o electrónica de la computadora.</p>
</li>
<li>
<p>Abstracción de la Máquina : mediante las instrucciones ISA / especificaciones ABI</p>
<div class="ulist">
<ul>
<li>
<p><strong>ABI</strong> : "Application Binary Interface" . Es un documento que especifica las características binarias del software, es decir, el nivel más bajo del software. Por ejemplo especifica el convenio de llamadas a subrutinas, cómo está estructurada la pila, cómo realizar las llamadas al sistema, el formato binario del módulo objeto ejecutable, etc &#8230;&#8203; El compilador, linker y loader han de conocer la interfaz ABI con todo detalle.</p>
</li>
<li>
<p>Desde el punto de vista del programador de aplicaciones de bajo nivel: La interfaz con la máquina son las llamadas al sistema (ABI) y el repertorio "user ISA"</p>
</li>
</ul>
</div>
</li>
<li>
<p>Abstracción a niveles superiores</p>
<div class="ulist">
<ul>
<li>
<p>La interfaz con la librería son los prototipos de las funciones de la librería (Application Programming Interface - <strong>API</strong>)</p>
</li>
</ul>
</div>
</li>
<li>
<p>Esquema con las Interfaces de las aplicaciones desarrolladas en <strong>lenguajes de bajo nivel</strong>:</p>
</li>
</ul>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/ditaa/svg/eNqtlM1qhDAUhfd9iiwVo32BUshkfirVGkyly8FKaAOpkWiFQl6o6-669cWaVFCGGR079IKSyOfJyfFGz19U3pUGi0ofgqiqBC_yhsuyngXnFL3BBiLhaOnM0uPzOTDizwD_jm6spu8DROP9e83UrKI-lF4OAkCT7eMTSjfLtT0frcy-HfpRN-xtj3Mhatd41X0G-myibc_oBdFfDlJu3eUgqZgyH7yVU6BjE64Ub7lgL6x2JxWdtYGYGolJ8J6pkgnQfYGH7rsQTLoXbac9arnR5tB29mb7Y5jYugUgpOhvhyTDEEUZ3JIMxnEGA1snwZTs4GYboR2FR8Ro_w6l66GvCIZhCmNkrlUKg1Ov9drhdQKwLBslhTBRT7vFefHafcI4IAEkUjW1GdLgH870_H_nB8Fq5UU=" alt="Diagram">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Desde el punto de vista del sistema operativo S.O.:</p>
<div class="ulist">
<ul>
<li>
<p>La interfaz con la máquina es <strong>ISA (system isa y user isa)</strong></p>
</li>
<li>
<p>La interfaz con el programador es <strong>ABI</strong></p>
</li>
</ul>
</div>
</li>
<li>
<p>Desde el punto de vista del programador</p>
<div class="ulist">
<ul>
<li>
<p>si no hay S.O. la interfaz con la máquina será equivalente a la del S.O.</p>
</li>
<li>
<p>si hay S.O. y librerías la interfaz con la máquina:</p>
<div class="ulist">
<ul>
<li>
<p>en lenguaje C : <strong>API</strong> y <strong>ABI</strong> específicos de C</p>
</li>
<li>
<p>en lenguaje ASM: <strong>API &#169;</strong> y <strong>ABI</strong> específico de asm</p>
<div class="ulist">
<ul>
<li>
<p>La programación de bajo nivel requiere tener algunos conocimientos del Hardware de la máquina no siendo posible su completa abstracción. Por lo tanto es necesario estudiar la CPU desde el punto de vista del programador.</p>
</li>
<li>
<p>¿Cual sería el esquema de niveles o capas visto por los siguientes niveles de abstracción superiores?</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Escritorio</p>
</li>
<li>
<p>Lenguaje de Programación Java</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_compatibilidad_software">7.7.2. Compatibilidad Software</h4>
<div class="sect4">
<h5 id="_compatibilidad">Compatibilidad</h5>
<div class="ulist">
<ul>
<li>
<p>Cada procesador tiene su repertorio de instrucciones</p>
</li>
<li>
<p>Si dos procesadores tienen el mismo repertorio de instrucciones, es decir, la misma arquitectura, el módulo fuente en lenguaje ensamblador será compatible para los dos procesadores aunque la estructura interna de la CPU sea diferente: Ejemplo: Intel IA64 y AMD64</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_ejemplos_2">Ejemplos</h5>
<div class="ulist">
<ul>
<li>
<p>El programador necesita conocer el trío ARCH-KERNEL-LIBC</p>
<div class="ulist">
<ul>
<li>
<p>Arch se refiere a la arquitectura de la computadora &#8594; ISA</p>
</li>
<li>
<p>Kernel: núcleo del sistema operativo. Implementa las llamadas del sistema</p>
</li>
<li>
<p>Libc: librería para el programador de aplicaciones. Implementa las llamadas al sistema</p>
</li>
<li>
<p>Tanto el Kernel como la Librería tienen asociados sus interfaces de nivel alto (API) como de nivel bajo (ABI)</p>
</li>
</ul>
</div>
</li>
<li>
<p>Ejemplos arch/kernel/libc</p>
<div class="ulist">
<ul>
<li>
<p>amd64-linux-gnu</p>
</li>
<li>
<p>arm-linux-gnueabi</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_personal_pc_laptop_t560">7.8. Personal PC: Laptop T560</h3>
<div class="imageblock text-center">
<div class="content">
<img src="./images/laptop_T560/laptop_view_up.jpg" alt="laptop view up">
</div>
<div class="title">Figure 38. Laptop_T560: Vista interna</div>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/laptop_T560/plataforma_hardisk_off.jpg" alt="plataforma hardisk off">
</div>
<div class="title">Figure 39. plataforma_hardisk_off</div>
</div>
<div class="sect3">
<h4 id="_linux_commands">7.8.1. linux commands</h4>
<div class="ulist">
<ul>
<li>
<p>HW &#8592; Kernel &#8594; File system (/proc, /sys /dev ) &#8592; linux command &#8594; user system info</p>
</li>
<li>
<p>list</p>
<div class="listingblock">
<div class="content">
<pre>sudo lshw  --help
 man lshw
sudo hwinfo  --help
 man hwinfo
sudo dmidecode --help
 man hwinfo
sudo inxi</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_apps">7.8.2. apps</h4>
<div class="ulist">
<ul>
<li>
<p><code>cpu-x</code></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_web_info">7.8.3. Web info</h4>
<div class="ulist">
<ul>
<li>
<p>wikipedia</p>
</li>
<li>
<p>intel</p>
<div class="ulist">
<ul>
<li>
<p><a href="https://ark.intel.com/content/www/us/en/ark.html" class="bare">https://ark.intel.com/content/www/us/en/ark.html</a></p>
</li>
<li>
<p><a href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html" class="bare">https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html</a></p>
</li>
</ul>
</div>
</li>
<li>
<p><a href="https://www.cpu-world.com/" class="bare">https://www.cpu-world.com/</a></p>
</li>
<li>
<p><a href="https://agner.org/" class="bare">https://agner.org/</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_operating_system">7.8.4. Operating system</h4>
<div class="ulist">
<ul>
<li>
<p><code>uname -a</code></p>
<div class="listingblock">
<div class="content">
<pre>Ubuntu/GNU/linux 20.04
kernel linux 5.4.0-131-generic</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_platform">7.8.5. Platform</h4>
<div class="sect4">
<h5 id="_comandos">comandos</h5>
<div class="ulist">
<ul>
<li>
<p>listado</p>
<div class="listingblock">
<div class="content">
<pre>sudo lshw -X
sudo lshw | more
sudo lshw &gt; miplataforma.txt
sudo lshw -html
sudo lshw -short
sudo dmidecode -system
uname -a
arch
sudo cpu-x
inxi
inxi -c 0 -ACdGMNSz</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_informe_lenovo_thinkpad_t560">informe Lenovo Thinkpad T560</h5>
<div class="ulist">
<ul>
<li>
<p>listado de características básicas</p>
<div class="listingblock">
<div class="content">
<pre>modelo computadora: 20F1S0H400 (LENOVO_MT_20F1_BU_Think_FM_ThinkPad L560)
modelo CPU : Intel(R) Core(TM) i5-6300U CPU @ 2.40GHz
Arquitectura CPU: x86_64 -&gt; comando arch
Word width : 64
Capacidad de Memoria: 12GiB System Memory -&gt; 4+8
Chipset or PCH: Sunrise Point-LP
  USB 3.0 xHCI Controller
  SATA Controller [AHCI mode]
  PCI Express Root Port
  LPC Controller
  HD Audio
Graphics: Skylake GT2 [HD Graphics 520]
Network:
  Wireless 8260
  Ethernet Connection I219-LM
Frecuencia reloj : 2.40 GHz

Memoria Cache
	64KiB L1 cache
	64KiB L1 cache
	512KiB L2 cache
	3MiB L3 cache</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_cpu">7.8.6. cpu</h4>
<div class="imageblock text-center">
<div class="content">
<img src="./images/laptop_T560/cpu_package.jpg" alt="cpu package">
</div>
<div class="title">Figure 40. cpu_package</div>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/laptop_T560/skylake-family-table.jpg" alt="skylake family table">
</div>
<div class="title">Figure 41. skylake-family-table</div>
</div>
<div class="sect4">
<h5 id="_comandos_2">comandos</h5>
<div class="ulist">
<ul>
<li>
<p>list</p>
<div class="listingblock">
<div class="content">
<pre> sudo lshw -C cpu
 lscpu
 sudo dmidecode -t processor
 cpuid
 cat /proc/cpuinfo
sudo cpu-x</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_web_info_2">web info</h5>
<div class="ulist">
<ul>
<li>
<p><a href="https://www.cpu-world.com/CPUs/Core_i5/Intel-Core%20i5-6300U%20Mobile%20processor.html">cpu-world</a></p>
</li>
<li>
<p><a href="https://ark.intel.com/content/www/es/es/ark/products/series/88393/6th-generation-intel-core-i5-processors.html">Intel: procesadores core i5 6ª generación</a></p>
<div class="ulist">
<ul>
<li>
<p><a href="https://ark.intel.com/content/www/es/es/ark/products/88190/intel-core-i56300u-processor-3m-cache-up-to-3-00-ghz.html">Intel: Core i5-6300U</a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_informe">informe</h5>
<div class="ulist">
<ul>
<li>
<p>listado de características básicas</p>
<div class="listingblock">
<div class="content">
<pre>modelo CPU: Intel(R) Core(TM) i5-6300U CPU @ 2.40GHz
Arquitectura: x86_64
Socket(s):                       1  -&gt; Soldado o
Byte Order:                      Little Endian
Address sizes:                   39 bits physical, 48 bits virtual
Número de núcleos: 2
Número de hebras: 2 por núcleo
Frecuencia:
   clock: 100MHz  -&gt; frecuencia de la Placa Base
   2.4GHz -&gt; marketing
   600 MHz -&gt; frecuencia de la cpu en el momento de ejecución del comando
   Multiplicador : valor máximo 24 -&gt; freq_cpu=24xFreq_motherboard -&gt; el multiplicador es dinámico, cambia continuamente de valor.
Microarquitectura: Skylake 14 nm -&gt; Skylake-U
Package: BGA
Virtualization:   VT-x  -&gt; cpu soporta Intel Virtualization
Flags :
  lm : long mode -&gt; funcionamiento de la CPU en modo 64 bits
  x86_64 : arquitectura -&gt; word width
  SSE, AVX -&gt; Extensión de la ISA base con más instrucciones
  vmx: virtualización enabled by BIOS
CPUIDs	406E3 -&gt; código identificador de la CPU -&gt; necesario para actualizar el microcódigo
Maximum operating temperature  	100°C
Thermal Design Power   	15 Watt  _&gt; consumo</pre>
</div>
</div>
</li>
<li>
<p>Intel Core&#8482; i5-6300U &#8594; significado del código comercial</p>
<div class="ulist">
<ul>
<li>
<p>para realizar búsquedas en Google utilizo el nombre comercial "i5-6300U"</p>
</li>
<li>
<p>Inter Corporation</p>
</li>
<li>
<p>brand: core</p>
</li>
<li>
<p>family: i5</p>
</li>
<li>
<p>Generación 6ª: 6</p>
<div class="ulist">
<ul>
<li>
<p>versión: 6000</p>
</li>
</ul>
</div>
</li>
<li>
<p>segmento notebook (portátiles): U</p>
</li>
</ul>
</div>
</li>
<li>
<p>Fecha: 2015 3º cuatrimestre.</p>
</li>
<li>
<p>El frecuencia de la CPU es el ciclo de reloj de los ciclos máquina del ciclo de instrucción.</p>
<div class="ulist">
<ul>
<li>
<p>la duración de los ciclos de instrucción y sus fases se expresan en ciclos de reloj, no en MHz.</p>
</li>
</ul>
</div>
</li>
<li>
<p>A destacar el codename de la microarquitectura: <strong>Skylake-U</strong></p>
<div class="ulist">
<ul>
<li>
<p>nos da información de todos los recursos hardware de la CPU.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_nivel_de_integracion_cpu_chipset">nivel de integracion: cpu-chipset</h5>
<div class="imageblock text-center">
<div class="content">
<img src="./images/laptop_T560/esquema_chipset100_cpu6gen.png" alt="esquema chipset100 cpu6gen">
</div>
<div class="title">Figure 42. Esquema CPU Chipset discreto</div>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/laptop_T560/esquema_skylake-u-mobile-diagram.png" alt="esquema skylake u mobile diagram" width="100%"">
</div>
<div class="title">Figure 43. Esquema CPU Chipset integrado, scaledwidth=</div>
</div>
<div class="ulist">
<ul>
<li>
<p>On chip (integración de módulos en el mismo chip): <strong>la integración de módulos en el mismo chip es importante</strong></p>
<div class="listingblock">
<div class="content">
<pre>Cores -&gt; 2 núcleos
x87 FPU on chip  -&gt; Float Point Unit : procesa números reales a diferencia de la ALU que procesa enteros
Chipset or PCH (Platform Hub)</pre>
</div>
</div>
</li>
</ul>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
La cpu y el chipset están en el mismo chip pero en "dies" diferentes. Cada uno integrado en un substrato de silicio diferente.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_socket">Socket</h5>
<div class="ulist">
<ul>
<li>
<p>socket: <a href="https://globalamericaninc.com/types-of-cpu-sockets/" class="bare">https://globalamericaninc.com/types-of-cpu-sockets/</a></p>
<div class="ulist">
<ul>
<li>
<p><a href="https://www.cpu-world.com/CPUs/Core_i5/Intel-Core%20i5-6300U%20Mobile%20processor.html">cpu-world</a></p>
<div class="ulist">
<ul>
<li>
<p>Package : 1356-ball micro-FCBGA</p>
</li>
<li>
<p>Socket BGA1356 &#8594;  BGA &#8594; soldado a la placa base &#8594; no actualizable</p>
</li>
<li>
<p>los 1356 pines del chip pertenecen a todos los módulos integrados en el mismo chip:  los 2 núcleos y a los controladores del chipset.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>sudo hwinfo | grep -i socket</code> &#8594; "U3E1"  &#8594; ¿no encuentro info?</p>
</li>
<li>
<p><code>sudo dmidecode -t processor | grep -i socket</code> &gt; Socket designation: "U3E1"</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_datos_erróneos">Datos erróneos</h5>
<div class="ulist">
<ul>
<li>
<p><code>sudo lshw -C cpu</code> &#8594; size: 975MHz</p>
</li>
<li>
<p><code>sudo dmidecode -t processor | grep -i freq</code> &#8594; me dice que la frecuencia máxima son 8GHz</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_instruction_level_parallelism_ilp">7.9. Instruction Level Parallelism (ILP)</h3>
<div class="ulist">
<ul>
<li>
<p><a href="http://en.wikipedia.org/wiki/Instruction-level_parallelism">wikipedia</a></p>
<div class="ulist">
<ul>
<li>
<p>Instruction-level parallelism (ILP) es la medida de cuantas instrucciones de un programa pueden ser ejecutadas simultáneamente. El solapamiento de la ejecución de las instrucciones recibe el nombre de instruction level parallelism (ILP)</p>
</li>
<li>
<p>Son dos los mecanismos para conseguir el ILP</p>
<div class="ulist">
<ul>
<li>
<p>Hardware</p>
</li>
<li>
<p>Software</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Técnicas de diseño de microarquitecturas que persiguen un solape ILP</p>
<div class="ulist">
<ul>
<li>
<p>VLIW</p>
</li>
<li>
<p>Superscalar</p>
</li>
<li>
<p>Pipelining (Segmentación)</p>
</li>
<li>
<p>Out-of-order execution</p>
</li>
<li>
<p>etc</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_vliw_vs_superscalar">7.9.1. VLIW vs Superscalar</h4>
<div class="sect4">
<h5 id="_vliw">VLIW</h5>
<div class="ulist">
<ul>
<li>
<p>Very Long Instruction Words</p>
</li>
<li>
<p>La CPU contiene múltiples Unidades de Ejecución</p>
</li>
<li>
<p>Una palabra contiene tantas instrucciones como unidades de ejecución.</p>
<div class="ulist">
<ul>
<li>
<p>A la palabra se le denomina Instruction Word, la cual contiene múltiples instrucciones máquina.</p>
</li>
<li>
<p>El <em>compilador</em> crea las Instrucciones Word con las múltiples instrucciones <strong>asignando</strong> a cada una de ellas una Unidad de Ejecución distinta.</p>
<div class="ulist">
<ul>
<li>
<p>Múltiples Instrucciones en Paralelo</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_superscalar">Superscalar</h5>
<div class="ulist">
<ul>
<li>
<p>La arquitectura superescalar significa que la CPU tiene múltiples Rutas de Datos (múltiples Unidades de Ejecución (UE) y enrutamiento ), no confundir con múltiples núcleos (core), y es la <em>propia CPU</em> la que <strong>asigna</strong> en tiempo de ejecución distintas UEs y otros recursos de la máquina a las distintas instrucciones .</p>
</li>
<li>
<p>Dicha arquitectura permite la ejecución simultánea de múltiples instrucciones.</p>
</li>
<li>
<p>Una CPU superscalar <strong>n-way</strong> significa que puede ejecutar simultáneamente n instrucciones.</p>
</li>
<li>
<p>Superscalar no significa multinúcleo. Un único núcleo es superscalar.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_comparativa_superscalar_vliw">Comparativa Superscalar-VLIW</h5>
<div class="ulist">
<ul>
<li>
<p>One of the great debates in computer architecture is static vs. dynamic. <strong>static</strong> typically means "let&#8217;s make our compiler take care of this", while <strong>dynamic</strong> typically means "let&#8217;s build some hardware that takes care of this". Each side has its advantages and disadvantages. the compiler approach has the benefit of time: a compiler can spend all day analyzing the heck out of a piece of code. however, the conclusions that a compiler can reach are limited, because it doesn&#8217;t know what the values of all the variables will be when the program is actually run. As you can imagine, if we go for the hardware approach, we get the other end of the stick. there is a limit on the amount of analysis we can do in hardware, because our resources are much more limited. on the other hand, we can analyze the program when it actually runs, so we have complete knowledge of all the program&#8217;s variables.</p>
</li>
<li>
<p><strong>VLIW</strong> approaches typically fall under the "static" category, where the compiler does all the work.</p>
</li>
<li>
<p><strong>Superscalar</strong> approaches typically fall under the "dynamic" category, where special hardware on the processor does all the work. consider the following code sequence:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">sw</span> <span class="err">$</span><span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">(</span><span class="err">$</span><span class="mi">2</span><span class="p">)</span>
<span class="n">lw</span> <span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">(</span><span class="err">$</span><span class="mi">5</span><span class="p">)</span>

<span class="err">$</span> <span class="n">significa</span> <span class="n">direccionamiento</span> <span class="n">directo</span>
<span class="p">()</span> <span class="n">direccionamiento</span> <span class="n">indirecto</span> <span class="n">indexado</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>suppose  we can run two memory operations in <strong>parallel</strong> [but only if they have <strong>no dependencies</strong>, of course]. are there dependencies between these two instructions? well, it depends on the values of $5 and $2, es decir, del contenido de las direcciones de memoria 5 y 2. Si el contenido de la dirección $5 is 0, y el contenido de la dirección $2 is 4, then they <strong>depend</strong> on each other: we must run the store before the load y <strong>no</strong> se pueden ejecutar en paralelo.</p>
<div class="ulist">
<ul>
<li>
<p>in a <strong>VLIW</strong> approach, our compiler decides which instructions are safe to run in parallel. there&#8217;s no way our compiler can tell for sure if there is a dependence here. so we must stay on the safe side, and dictate that the store must always run before the load. if this were a bigger piece of code, we could analyze the code and try to build a proof that shows there is no dependence. [modern parallelizing compilers actually do this!]</p>
</li>
<li>
<p>if we decide on a <strong>SUPERSCALAR</strong> approach, we have a piece of hardware on our processor that decides whether we can run instructions in parallel. the problem is easier, because this dependence check will happen in a piece of hardware on our processor, as the code is run. so we will know what the values of $2 and $5 are. this means that we will always know if it is safe to run these two instructions in parallel. Por lo tanto unas veces las dos instrucciones serán ejecutadas en paralelo y otras no.</p>
<div class="ulist">
<ul>
<li>
<p>Hopefully you see some of the tradeoffs involved. dynamic approaches have more program information available to them, but the amount of resources available for analysis are very limited. for example, if we want our superscalar processor to search the code for independent instructions, things start to get really hairy. static approaches have less program information available to them, but they can spend lots of resources on analysis. for example, it&#8217;s relatively easy for a compiler to search the code for independent instructions.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_pipeline_segmentacion">7.9.2. Pipeline (Segmentacion)</h4>
<div class="ulist">
<ul>
<li>
<p>Pipeline: cauce o tubería. Segmentación en serie.</p>
</li>
<li>
<p>Ejemplo de Lavado de coches</p>
<div class="ulist">
<ul>
<li>
<p>Fases: Humedecer - Enjabonar - Cepillar - Aclarar - Secar - Abrillantar</p>
</li>
</ul>
</div>
</li>
<li>
<p>Máquina Secuencial</p>
<div class="ulist">
<ul>
<li>
<p>Cola de coches ante la máquina</p>
</li>
<li>
<p>Si un coche está en cualquiera de las fases no entra el siguiente coche.</p>
</li>
<li>
<p>El intervalo de tiempo de salida de coches será la suma de todas las fases. ¿Cada cuanto tiempo sale un coche del lavadero?</p>
</li>
<li>
<p><strong>Througput (Producción)</strong>: Número de coches de salida por unidad de tiempo</p>
</li>
</ul>
</div>
</li>
<li>
<p>Segmentación frente a Secuencial.</p>
<div class="ulist">
<ul>
<li>
<p>En lugar de tener una máquina que realice todas la fases tenemos máquinas independientes que realizan cada fase.</p>
</li>
<li>
<p>El intervalo de tiempo de salida de coches será el de la duración de la fase de mayor duración.</p>
</li>
<li>
<p>El througput, del número de coches atendidos por unidad de tiempo, aumenta.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Flujo de Instrucciones con segmentación en 2 etapas</p>
</li>
</ul>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/cpu/12_9.jpg" alt="12 9" width="960" height="600">
</div>
<div class="title">Figure 44. Segmentación en 2 etapas</div>
</div>
<div class="ulist">
<ul>
<li>
<p>En caso de que los tiempos de cada etapa sean distintos o halla penalización por saltos en el flujo , se producirán tiempos de espera.</p>
</li>
</ul>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/cpu/12_10.jpg" alt="12 10" width="960" height="600">
</div>
<div class="title">Figure 45. Diagrama de tiempos con segmentación de 6 etapas</div>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/cpu/12_11.jpg" alt="12 11" width="960" height="600">
</div>
<div class="title">Figure 46. Diagrama de tiempos. Salto incondicional</div>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/cpu/12_12.jpg" alt="12 12" width="960" height="600">
</div>
<div class="title">Figure 47. Flujo de instrucciones con segmentación de 6 etapas</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Un salto obliga a vaciar la tubería &#8594; nueva microrden para la Unidad de Control &#8594; empty pipe</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_arquitecturas_ciscrisc">7.10. Arquitecturas CISC/RISC</h3>
<div class="sect3">
<h4 id="_introducción_10">7.10.1. Introducción</h4>
<div class="ulist">
<ul>
<li>
<p>CISC: Complex Instruction Set Computer</p>
</li>
<li>
<p>RISC: Reduced Instruction Set Computer</p>
</li>
<li>
<p>CISC y RISC son dos filosofías de diseño de un computador, dos arquitecturas.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_cisc">7.10.2. CISC</h4>
<div class="ulist">
<ul>
<li>
<p>Ejemplos: Motorola 68k, Intel x86.</p>
</li>
<li>
<p>El objetivo fué conseguir programas que ocupasen poca memoria DRAM, ya que en los inicios la memoria era costosa. Había que conseguir instrucciones que realizasen operaciones complejas para que el programa no fuese muy largo.</p>
</li>
<li>
<p>El repertorio abarca Instrucciones de varios bytes y no uniformes.</p>
</li>
<li>
<p>Necesita un HW complejo que ocupa mucho espacio y necesita muchos ciclos de reloj.</p>
</li>
<li>
<p>La arquitectura del lenguaje ensamblador está próxima a un lenguaje de alto nivel cómo el lenguaje C por lo que facilita la tarea a los compiladores y a los programadores de lenguaje ensamblador.</p>
</li>
<li>
<p>En cambio complica el diseño e implementación de elementos hardware como la CPU.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_risc">7.10.3. RISC</h4>
<div class="ulist">
<ul>
<li>
<p>Ejemplos: PowerPC, ARM, MIPS and SPARC</p>
</li>
<li>
<p>El origen fue diseñar un microprocesador con bajo presupuesto por lo que la apuesta fue una microarquitectura con un Hardware sencillo que ejecutase instrucciones también sencillas, regulares.</p>
<div class="ulist">
<ul>
<li>
<p>Un HW sencillo es rápido y ocupa poca área del chip. Es fácil incrementar el número de etapas pipeline.</p>
</li>
<li>
<p>La consecuencia fue un micro de bajo consumo que más adelante se haría con todo el mercado de telefonía móvil.</p>
</li>
<li>
<p>El repertorio de instrucciones es reducido con pocos códigos de operación y direccionamientos sencillos, lo que daría lugar a programas con un gran número de instrucciones máquina.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Inconveniente:</p>
<div class="ulist">
<ul>
<li>
<p>Requiere de más capacidad de memoria para almacenar programas extensos. Deja de ser un inconveniente si se abaratan las unidades de memoria DRAM.</p>
</li>
<li>
<p>Gran número de accesos a memoria para capturar las instrucciones, los operandos y  el resultado. Deja de ser un inconveniente si se utilizan memorias de latencia reducida.</p>
</li>
<li>
<p>Solución: incrementar la memoria interna: el número de Registros internos y la memoria caché. Para lo cual hay espacio debido al core de area reducida</p>
</li>
</ul>
</div>
</li>
<li>
<p>Core de área reducida permite:</p>
<div class="ulist">
<ul>
<li>
<p>incrementar la capacidad de memoria interna ultrarápida.</p>
</li>
<li>
<p>incrementar el número de vías de la arquitectura superescalar.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_cuestiones">7.10.4. Cuestiones</h4>
<div class="ulist">
<ul>
<li>
<p>Qué arquitectura optimiza el tamaño de bytes del programa</p>
</li>
<li>
<p>Qué arquitectura optimiza el tiempo de ejecución del cada instrucción</p>
</li>
<li>
<p>Qué arquitectura optimiza el tamaño y coste de fabricación de la CPU</p>
</li>
<li>
<p>Qué arquitectura optimiza el consumo</p>
</li>
<li>
<p>Qué arquitectura optimiza el número de capturas a memoria. ¿Existe indepencia entre captura y ejecución de instrucciones?</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_sw">7.10.5. SW</h4>
<div class="ulist">
<ul>
<li>
<p>Un programa ensamblador de una arquitectura RISC tiene más instrucciones que un CISC</p>
</li>
<li>
<p>Cada instrucción RISC se ejecuta en menor tiempo que una CISC.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_tabla_comparativa">7.10.6. Tabla Comparativa</h4>
<div class="ulist">
<ul>
<li>
<p><a href="http://cs.stanford.edu/people/eroberts/courses/soco/projects/risc/risccisc/">RISC vs CISC</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_arm_cortex_a76cortex_a55">7.11. ARM Cortex-A76/Cortex-A55</h3>
<div class="sect3">
<h4 id="_intro_2">7.11.1. Intro</h4>
<div class="ulist">
<ul>
<li>
<p><a href="https://en.wikipedia.org/wiki/Arm_(company" class="bare">https://en.wikipedia.org/wiki/Arm_(company</a>)</p>
</li>
<li>
<p>ARM : Acorn (bellota) RISC Machine &#8594; Advanced RISC Machines</p>
</li>
<li>
<p>Arquitectura RISC.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_teléfono_huawei_p30_pro">7.11.2. Teléfono Huawei P30 Pro</h4>
<div class="ulist">
<ul>
<li>
<p>El teléfono Huawei P30 Pro modelo VOG-L29 incorpora un System On Chip (SoC) Huawei <strong>Kirin 980</strong>. El SoC integra tanto los cores como el chipset.</p>
<div class="listingblock">
<div class="content">
<pre>August 31, 2018
Kirin 980 is a 64-bit high-performance mobile ARM LTE SoC designed by HiSilicon and introduced in late 2018. Fabricated on TSMC's 7 nm process, the 980 incorporates four big Cortex-A76 cores operating at up to 2.6 GHz along with four little Cortex-A55 cores operating at up to 1.8 GHz. This SoC has an LTE modem supporting 1.4 Gbps download (Cat21), incorporates an ARM Mali-G76, and supports LPDDR4X-4266 memory.</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_isa_cortex_a76cortex_a55">7.11.3. ISA Cortex-A76/Cortex-A55</h4>
<div class="ulist">
<ul>
<li>
<p>Arquitectura  ISA ARMv8.2-A</p>
<div class="listingblock">
<div class="content">
<pre>64 bits
ver manual ISA ARMv8.2-A de la compañia ARM</pre>
</div>
</div>
</li>
<li>
<p>Microarquitectura</p>
<div class="ulist">
<ul>
<li>
<p><a href="https://en.wikipedia.org/wiki/Comparison_of_Armv8-A_processors" class="bare">https://en.wikipedia.org/wiki/Comparison_of_Armv8-A_processors</a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_multicore">7.11.4. Multicore</h4>
<div class="ulist">
<ul>
<li>
<p>8 núcleos</p>
</li>
<li>
<p>arquitectura heterogénea big.LITTLE: 2 tipos de core &gt; 4+4</p>
<div class="ulist">
<ul>
<li>
<p>big cores : alto rendimiento y consumo moderado &#8594; Cortex-A76</p>
</li>
<li>
<p>LITTLE.cores: rendimiento moderado y bajo consumo &#8594; Cortex-A55</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_microarquitectura_cortex_a76">7.11.5. Microarquitectura Cortex-A76</h4>
<div class="ulist">
<ul>
<li>
<p><a href="https://en.wikipedia.org/wiki/Comparison_of_Armv8-A_processors" class="bare">https://en.wikipedia.org/wiki/Comparison_of_Armv8-A_processors</a></p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/ARM_Cortex-A76" class="bare">https://en.wikipedia.org/wiki/ARM_Cortex-A76</a></p>
<div class="listingblock">
<div class="content">
<pre>The Cortex-A76 frontend is a 4-wide decode out-of-order superscalar design. It can fetch 4 instructions per cycle. And[clarification needed] rename and dispatch 4 Mops, and 8 µops per cycle. The out-of-order window size is 128 entries. The backend is 8 execution ports with a pipeline depth of 13 stages and the execution latencies of 11 stages</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>superscalar : ruta de datos de 4 vías (4-way)</p>
</li>
<li>
<p>pipeline: 13 etapas</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_microarquitectura_cortex_a55">7.11.6. Microarquitectura Cortex-A55</h4>
<div class="ulist">
<ul>
<li>
<p><a href="https://en.wikipedia.org/wiki/ARM_Cortex-A55" class="bare">https://en.wikipedia.org/wiki/ARM_Cortex-A55</a></p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Comparison_of_Armv8-A_processors" class="bare">https://en.wikipedia.org/wiki/Comparison_of_Armv8-A_processors</a></p>
<div class="ulist">
<ul>
<li>
<p>superscalar: ruta de datos de 2 vías (2-way)</p>
</li>
<li>
<p>pipeline: 8 etapas</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ejercicios">7.12. Ejercicios</h3>
<div class="ulist">
<ul>
<li>
<p>Capítulo 12 del libro de texto William Stalling.</p>
</li>
<li>
<p>Capítulo 13 del libro de texto William Stalling</p>
</li>
<li>
<p><a href="../ejercicios/ejercicios.html">Ejercicios</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="paragraph nav-footer">
<p>↑ Up: <a href="_ii_unidades_básicas_procesador_central_unidad_de_memoria_mecanismos_entradasalida.html">II Unidades Básicas: Procesador Central, Unidad de Memoria, Mecanismos Entrada/Salida.</a> | ⌂ Home: <a href="eecc_book.html">Estructura de Computadores  (240306)</a> | Next: <a href="_mecanismos_de_entradasalida.html">Mecanismos de Entrada/Salida</a> →</p>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2022-09-14 15:29:34 +0200
</div>
</div>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]],
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },
  TeX: { equationNumbers: { autoNumber: "none" } }
})
MathJax.Hub.Register.StartupHook("AsciiMath Jax Ready", function () {
  MathJax.InputJax.AsciiMath.postfilterHooks.Add(function (data, node) {
    if ((node = data.script.parentNode) && (node = node.parentNode) && node.classList.contains("stemblock")) {
      data.math.root.display = "block"
    }
    return data
  })
})
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
</body>
</html>