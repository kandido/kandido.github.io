= Sistemas Digitales (2ª Parte)
// classic AsciiDoctor attributes
//:stem: latexmath
:stem:
:background-color="#ff0000":
:icons: font
:imagesdir: images
:customcss: styles/myCustomCSS.css
// Despite the warning of the documentation, https://github.com/asciidoctor/asciidoctor-reveal.js, highlight.js syntax highlighting WORKS, BUT, you need to explicitly set the highlighter using the below attribute
// see http://discuss.asciidoctor.org/Highlighting-source-code-for-reveal-js-backend-td2750.html
:source-highlighter: highlight.js
:highlightjs-languages: vhdl
:source-language: vhdl 
//:source-highlighter: rouge
//:source-highlighter: pygments
// revealjs attributes
:revealjs_theme: white
:revealjs_slideNumber: true
// Al actualizar el slide no cambia de transpa y no se va al inicio
:revealjs_hash: true   
:revealjs_history: true


:revealjs_center: true
:revealjs_width: "100%"
:revealjs_height: "100%"
:revealjs_margin: 0

//:revealjs_minScale: 1,
//:revealjs_maxScale: 1

// plugins copiados de tutoriales/asciidoctor-revealjs/../primer.js
:revealjs_plugins_configuration: revealjs-plugins-conf.js
:revealjs_plugins: revealjs-plugins.js

//:scrollable: no pirula

//:revealjs_history: true para go to file no pirula

//:doctype: book
//:lang: es
//:encode: ISO-8859-1
//:ascii-ids:
:show-link-uri:
:asciidoctor-fetch-kroki:
:experimental:

:ruta-transpas: home/candido/Dropbox/apuntes/apuntes_sistemas_digitales/upna/apuntes_repositorio/transpas_ssdd

:ruta-apuntes: home/candido/Dropbox/apuntes

== Transparencias en Formato PDF

* link:./PDF/ssdd2_slides.pdf[Transparencias PDF]
* Si hay algún error de forma en el documento PDF que dificulte su interpretación, por favor, enviar un mensaje para su correción. Gracias.


== Indice

[%hardbreaks]
Parte 1ª : link:ssdd.html[Sistemas Digitales: Primera Parte]
Tema 7: <<Tema7_Seq, Circuitos Secuenciales.>>
Tema 8: <<Tema8_Fam, Circuitos Digitales Integrados. Familias Lógicas.>>
Tema 9: <<Tema9_Mem, Memorias.>>
Tema 10: <<Tema10_PLD, Dispositivos de Lógica Programable (PLD).>>
Tema 11: <<Tema11_Dac, Convertidores Analógico/Digitales DAC/ADC.>>



[#Tema7_Seq]
[.columns, state=txikiago]
== Tema 7 : Circuitos Secuenciales

[.column]
Introducción a los Sistemas Secuenciales: +
- - Ejemplo +
- - Celdas de Memoria: R S, J K, T y D +
Análisis y diseño de circuitos secuenciales síncronos: +
- - Análisis de circuitos secuenciales síncronos. +
- - Tablas de transiciones y diagramas de estados: Máquina de Mealy y Máquina de Moore. +
- - Síntesis de sistemas secuenciales síncronos. +
Circuitos biestables: +
- - Definición de sistema secuencial. +
- -Tipos y características: Asíncronos y síncronos. +
- - Biestables: R S, J K, T y D +
- - Tiempos característicos en biestables.


[.column]
Registros de desplazamiento: +
- - Concepto de registro. +
- - Registros de desplazamiento. Entrada serie, salida serie. Entrada serie, salida paralelo. Entrada
paralelo, salida serie. Entrada paralelo, salida paralelo. Bidireccional. +
- - Aplicaciones de los registros. Generador de secuencia.
Contadores: +
- - Contadores digitales y sus aplicaciones. +
- - Contadores asíncronos. Contador de décadas. +
- - Contadores síncronos. Acarreo en serie y paralelo. +
- - Contador reversible. +
- - Contadores basados en registros de desplazamiento: en anillo, Johnson, con protección.

=== Introducción a los Sistemas Digitales Secuenciales

* Diseñar el controlador digital de un ascensor para un edificio de 2 plantas
** Motor del ascensor: El eje del motor eléctrico tiene un engranaje sobre el que se acopla una cadena unida al ascensor.
** Si el motor gira a la izda el ascensor sube y si gira a la derecha el ascensor baja.
** En cada planta hay botón para solicitar el servicio del ascensor.
** Dentro del ascensor hay un botón por planta para solicitar el destino del ascensor.
** En cada planta hay un sensor para detectar la llegada del ascensor.


=== Controlador Digital de un Ascensor

* Dibujar un esquema con los componentes del sistema: plantas del edificio, motor, cadena, ascensor, botones.
* Definir y codificar las entradas lógicas del controlador digital.
* Definir y codificar las salidas lógicas del controlador digital.
* Definir y codificar los estados del sistema.
* Dibujar el diagrama de estados del sistema (estados, transiciones, entradas, salidas).
* Desarrollar las 3 tablas: 
** transición de estados , excitación de biestables (pej JK) y funciones de salida.



[state=txikiago]
=== Unidades de Memoria: Biestables

* Una celda de memoria es un dispositivo capaz de almacenar un bit (estados lógicos 0 y 1) y sobre el que se pueden realizar distintas operaciones como:
** escribir el estado cero, escribir el estado uno, invertir su estado, no cambiar el estado, etc ..
** leer el estado
* Las celdas de memoria tienen 2 terminales de entrada para las operaciones de escritura y 2 terminales de salida para las operaciones de lectura. Además si son síncronas tienen 1 terminal para la señal de reloj.
* Las celdas de memoria que admiten dos estados estables reciben el nombre de Biestables.
* Sincronismo:
** Los biestables que realizan la operación de escritura de forma síncrona, respondiendo a la entrada en el instante de pendiente positiva o negativa de una señal reloj, reciben el nombre de *Flip-Flop*.
* Los biestables que realizan la operación de escritura inmediatamente después de un cambio en la entrada reciben el nombre de *Latch*.

[.columns,state=taula]
=== Tipos de Biestables

[.column]
--
.Flip-Flop S-R
[width=50%]
|===
| Clk | S | R | latexmath:[Q_{n+1}] | latexmath:[\overline Q_{n+1}] | Operación
| &#x2191; | 0 | 0 | latexmath:[Q_n] | latexmath:[\overline Q_n] | No cambia
| &#x2191; | 0 | 1 | 0 | 1 | RESET
| &#x2191; | 1 | 0 | 1 | 0 | SET
| &#x2191; | 1 |1 | *X* | *X* | Indeterminado
| Resto | X | X | latexmath:[Q_n] | latexmath:[\overline Q_n] | No cambia
|===
--

[.column]
--
.Flip-Flop J-K
[width=50%]
|===
| Clk | J | K | latexmath:[Q_{n+1}] | latexmath:[\overline Q_{n+1}] | Operación
| &#x2191; | 0 | 0 | latexmath:[Q_n] | latexmath:[\overline Q_n] | No cambia
| &#x2191; | 0 | 1 | 0 | 1 | RESET
| &#x2191; | 1 | 0 | 1 | 0 | SET
| &#x2191; | 1 |1 | latexmath:[\overline Q_n] | latexmath:[ Q_n] | Inversión
| Resto | X | X | latexmath:[Q_n] | latexmath:[\overline Q_n] | No cambia
|===
--



[.columns,state=taula]
=== Tipos de Biestables

[.column]
--
.Flip-Flop D (Data)
[width=50%]
|===
| Clk | D | latexmath:[Q_{n+1}] | latexmath:[\overline Q_{n+1}] | Operación
| &#x2191; | 0 | 0 | 1 | RESET
| &#x2191; | 1 | 1 | 0 | SET
| Resto | X | latexmath:[Q_n] | latexmath:[\overline Q_n] | No cambia
|===
--

[.column]
--
.Flip-Flop T (Toogle)
[width=50%]
|===
| Clk | T | latexmath:[Q_{n+1}] | latexmath:[\overline Q_{n+1}] | Operación
| &#x2191; | 0 | latexmath:[Q_n] | latexmath:[\overline Q_n] | No cambia
| &#x2191; | 1 | latexmath:[\overline Q_n] | latexmath:[ Q_n] | Inversión
| Resto | X | latexmath:[Q_n] | latexmath:[\overline Q_n] | No cambia
|===
--

=== Símbolos de los biestables

* S-R, J-K, D, T.
** Sincronismo con la pendiente + ó - del reloj.

image::tema7_flip-flop_tipos.svg[]

=== Cronogramas: Señales binarias de escritura y lectura de biestables


image::tema7_flip-flop_crono.svg[]


[state="txikiago"]
=== Controlador del Ascensor para 2 plantas

. Definir estados
** Estados: Ascensor en planta baja PB, en planta alta PA , subiendo SUB, bajando BAJ
. Definir entradas
** botón destino planta baja (BDB), botón destino  planta alta (BDA)
** botón llamada desde planta baja (BLB), botón llamada desde planta baja (BLB)
** sensores: planta baja SB y planta alta SA
. Definir salidas
** motor subiendo: MS
** motor bajando: MB
** motor parador: MP

[state="txikiago"]
=== C. Ascensor: Diagrama de estados

* El diagrama es una representación gráfica de las transiciones entre estados y las entradas y salidas del sistema.
* Máquina tipo *MOORE*: las salidas únicamente dependen del estado de la máquina digital -> salidas síncronas
** Representar los estados con círculos: dentro del círculo el estado y la salida del sistema correspondiente.
** Representar las transiciones entre estados mediante: Flecha entre dos estados y sobre la flecha el valor de las entradas.
* Máquina tipo *MEALY*: las salidas en un instante dependen del estado de la máquina digital y de la entrada en ese mismo instánte
** Representar los estados con círculos: dentro del círculo el estado.
** Representar las transiciones entre estados mediante: Flecha entre dos estados y sobre la flecha el valor de las entradas y su salida correspondiente


=== C. Ascensor: Diagrama de Bloques Mealy

image::tema7_ascen2_diag_block_mealy.svg[]

=== C. Ascensor: Diagrama de Bloques Moore

image::tema7_ascen2_diag_block.svg[]


[.columns, state=txikiago]
=== C. Ascensor: Transición entre estados

[.column]
[.text-left%hardbreaks]
Cuando el motor se para en una planta:
--el sensor de dicha planta se resetea, se desactiva.
Transición *PB->PB*:.
--si se pulsa un botón para bajar([naranja]#bdb# y/ó [naranja]#blb#) ó no se pulsa ningún botón.
--las entradas [naranja]#sa# y [naranja]#sb# no afectan.
Transición *PA->PA*:.
--si se pulsa un botón para subir([naranja]#bda# y/ó [naranja]#bla#) ó no se pulsa ningún botón.
--las entradas [naranja]#sa# y [naranja]#sb# no afectan.

[.column]
[.text-left%hardbreaks]
Transición *PB->SUB*:.
--si se pulsa un botón para subir([naranja]#bda# y/ó [naranja]#bla#) y no se pulsa simultáneamente algún botón de bajar([naranja]#bdb# ó [naranja]#blb#).
--las entradas [naranja]#sa# y [naranja]#sb# no afectan.
Transición *SUB->SUB*:.
--mientras [naranja]#sa# esté desactivado.
--no afectan ni los botones ni [naranja]#sb#.
Transición *SUB->PA*:.
--si se activa [naranja]#sa#
--el resto de entradas no afecta

[.column]
[.text-left%hardbreaks]
Transición *PA->BAJ*:.
--si se pulsa un botón para bajar([naranja]#bdb# y/ó [naranja]#blb#)y no se pulsa simultáneamente algún botón de subir([naranja]#bda# ó [naranja]#bla#).
--las entradas [naranja]#sa# y [naranja]#sb# no afectan.
Transición *BAJ->BAJ*:.
--mientras [naranja]#sb# esté desactivado.
--no afectan ni los botones ni [naranja]#sa#
Transición *BAJ->PB*:.
--si se activa [naranja]#sb#
--el resto de entradas no afecta

=== C. Ascensor: Diagrama de estados Moore


image::tema7_ascen2_diag_seq.svg[]

=== C. Ascensor: Diagrama de estados Mealy


image::tema7_ascen2_diag_seq_mealy.svg[]



[.columns, state=txikiago]
=== C. Ascensor: Codificación

[.column]
--
Entradas del sistema: +
--Cada entrada 1 bit : sa,sb,bdb,blb,bda y bla +
Salidas del sistema: +
--Para codificar las 3 salidas (MS,MB y MP) hacen falta 2 bits -> Z1,Z0 +
--Código de salida *Z1Z0* -> 00 (MP), 01 (MS), 10 (MB)
Estados del Sistema: +
--Memoria -> celdas biestables flip-flop JK +
--Para 4 estados son necesarias 2 celdas Q1 y Q0 -> señales de excitación J1,K1,J0,K0 +
--Códigos de los estados -> *Q1Q0* -> 00(PB), 01(SUB), 10(BAJ), 11(PA) +
Excitación de los biestables: +
--Para 2 biestables JK -> Para el biestable Q1 -> J1K1 y para el biestable Q0 -> J0K0
--

[.column]
--
.Tabla transición JK
[width=50%]
|===
|latexmath:[Q_n->Q_{n+1}] | *J* | *K*
|0 -> 0 | 0 | x
|0 -> 1 | 1 | x
|1 -> 0 | x | 1
|1 -> 1 | x | 0
|===
--

=== C. Ascensor: Tablas de Estados, Excitación de Biestables y Salidas

* Convertir el diagrama de estados en 3 tablas
* MEMORIA: Es necesario escribir el estado SIGUIENTE [verde]#q1q0# en los 2 biestables JK en función de:
** El estado actual : [naranja]#q1q0#
** Las entradas del sistema: [naranja]#sa,sb,bdb,blb,bda y bla#
* Las señales de escritura de los biestables son J1 y K1 para el biestable Q1 y J0 y K0 para el biestable Q0. Por lo tanto es necesario diseñar un CIRCUITO COMBINACIONAL para cada señal de escritura de la memoria:
** J1(q1,q0,sa,sb,bdb,blb,bda,bla) ; K1(q1,q0,sa,sb,bdb,blb,bda,bla)
** J0(q1,q0,sa,sb,bdb,blb,bda,bla) ; K0(q1,q0,sa,sb,bdb,blb,bda,bla)


=== C. Ascensor: Tablas de Estados, Excitación de Biestables y Salidas


image::tema7_ascen2_tablas_plantilla.svg[]

[.columns,state=taula]
=== C. Ascensor: Tablas de Estados, Excitación de Biestables y Salidas

[.column]
--
.Transición *PB->PB*
[width=10%]
|===
|sa|sb|bdb|blb|bda|bla|PB->PB
| X | X | X | 1 | X | X | 1
| X | X | 1 | X | X | X | 1
| X | X | 0 | 0 | 0 | 0 | 1
|===

--si se pulsa un botón para bajar([naranja]#bdb# y/ó [naranja]#blb#) ó no se pulsa ningún botón. +
--las entradas [naranja]#sa# y [naranja]#sb# no afectan.
--


[.column]
--
.Transición *PB->SUB*
[width=10%]
|===
|sa|sb|bdb|blb|bda|bla|PB->SUB
| X | X | 0 | 0 | 1 | X | 1
| X | X | 0 | 0 | X | 1 | 1
|===

--si se pulsa un botón para subir([naranja]#bda# y/ó [naranja]#bla#) y no se pulsa simultáneamente algún botón de bajar([naranja]#bdb# ó [naranja]#blb#). +
--las entradas [naranja]#sa# y [naranja]#sb# no afectan.
--

[.columns,state=taula]
=== C. Ascensor: Tablas de Estados, Excitación de Biestables y Salidas

[.column]
--
.Transición *SUB->SUB*
[width=10%]
|===
|sa|sb|bdb|blb|bda|bla|SUB->SUB
| 0 | X | X | X | X | X | 1
|===

--mientras [naranja]#sa# esté desactivado. +
--no afectan ni los botones ni [naranja]#sb#.
--


[.column]
--
.Transición *SUB->PA*
[width=10%]
|===
|sa|sb|bdb|blb|bda|bdl|SUB->PA
| 1 | X | X | X | X | X | 1
|===

--si se activa [naranja]#sa# +
--el resto de entradas no afecta
--



=== C. Ascensor: Tablas de Estados, Excitación de Biestables y Salidas

image::tema7_ascen2_tablas.svg[]

=== C. Ascensor: Ecuaciones Lógicas


* latexmath:[J_1= \overline q_1 \cdot q_0 \cdot sa]
* latexmath:[K_1= q_1 \cdot \overline q_0 \cdot sb ]
* latexmath:[J_0 = \overline q_1 \cdot \overline q_0 \cdot \overline {bdb} \cdot \overline {blb} \cdot (bda  + bla)]
* latexmath:[K_0 = q_1 \cdot q_0 \cdot \overline {bda} \cdot \overline {bla} \cdot (bdb  + blb)]
* latexmath:[Z_1 = q_1 \cdot \overline q_0]
* latexmath:[Z_0 = q_0 \cdot \overline q_1]

=== C. Ascensor: Biestables con entradas asíncronas

* A los biestables se les puede añadir dos entradas más para realizar el PRESET (escribir un 1) y el RESET (escribir un 0) en cualquier momento (asíncrona).

image::tema7_flip-flop_async.svg[]

=== C. Ascensor: Reset

* Añadimos al controlador digital (driver) del ascensor una señal de Reset
* Al activar la señal de Reset con un *1* (lógica positiva) el controlador digital se reinicia en el *estado* Planta Baja (PB) denominado *estado de inicio* (start)
* Utilizaremos flip-flops JK con entradas asíncronas.

=== C. Ascensor: Esquema Eléctrico

image::tema7_ascen2_esquema_elect.svg[]

[.columns,state=txikiago]
=== C. Ascensor: Descripción VHDL

[.column%hardbreaks]
Alternativas de la descripción de la arquitectura.
--Arquitectura abstracta: describir el Diagrama de la secuencia de estados -> Arquitectura tipo BEHAVIORAL
--Arquitectura física: describir el Esquema Eléctrico resultado del diseño manual -> Arquitectura tipo RTL
*Caso 1*: Descripción del Diagrama de la secuencia de estados.
--Consiste en describir literalmente cada estado, las transiciones entre estados en función de las entradas y describir las salidas en función únicamente del estado (FSM Moore) o en función del estado y de las entradas (FSM Mealy).
--Hay que describir que los estados se sinteticen en un bloque de memoria.
--Hay que describir el sincronismo de las transiciones entre estados.

[.column]
--
*Caso 2*: Descripción del Esquema Eléctrico resultado del diseño manual +
--descripción de dos circuitos combinacionales : el de salida y el de excitación de los biestables. +
--descripción de los biestables: +
---se tienen que sintetizar como dispositivos con memoria. +
---describir las transiciones entre estados del biestable. +
---describir el sincronismo de las transiciones +

NOTE:  Los dos casos se corresponden a la misma ENTIDAD.
--

[.columns,state=txikiago]
=== Descripción VHDL: Síntesis de Circuitos con Memoria.

[.column]
--
Para conseguir que la descripción VHDL de un circuito se sintetice con memoria es necesario que la descripción de la relación entre la salida y la entrada del circuito *NO* contemple todas las situaciones posibles. De esta forma cuando la entrada no este contemplada en la descripción la salida no cambiará y será necesario haberla tenido *MEMORIZADA* para que continue igual que antes de dicha entrada. 


[source,vhdl]
----
entity  ej_mem is
  port(
    SW: in bit_vector(0 downto 0);
    LEDR: out bit_vector(0 downto 0)
  );
end entity;

architecture beh of ej_mem is
begin
  process (SW(0))
  begin
    if (SW(0) = '0') then
      LEDR(0) <= '1';
    end if;
  end process;
end architecture;

----
--

[.column]
--
La sentencia secuencial *IF* no contempla los casos SW(0) distintos de cero y habrá que memorizarlos. Si asignamos al interruptor SW(0) el valor '1' el estado (encendido/apagado) del led LEDR(0) no debe de cambiar. +
El compilador del sintetizador Quartus informa que sintetizará memoria (inferring latch(es)): +

----
Warning (10631): VHDL Process Statement 
inferring latch(es) for signal or variable "LEDR", 
which holds its previous value 
Info (10041): Inferred latch for "LEDR[0]" 
----
--

=== C. Ascensor: Descripción VHDL de la Entidad

* Descripción de la entidad
** 8 entradas : los 4 botones, los 2 sensores, el reloj y la señal de reset de la memoria.
** Los 4 *botones* y los 2 *sensores* los simulamos con los conmutadores SW -> SW(5 downto 0)
** El *reloj* lo simulamos con un botón KEY -> KEY(0)
** La señal de *reset* se activa con un botón KEY -> KEY(1)

CAUTION: los botones si *NO* se pulsan dan un *1* a su salida -> lógica negativa

** SalidaS: 
*** para visualizar el estado del ascensor utilizamos dos *display* de 7 segmentos HEX1 y HEX0.
*** para visualizar el estado del reloj utilizamos el *led* rojo LEDR(9)

[state=txikiago]
=== C. Ascensor: Descripción VHDL de la Arquitectura tipo RTL: Descripción del Esquema Electrico (Memoria y Sincronismo)


Descripción de los biestables Q1 y Q0 +
--Utilizaremos biestables JK disparados por el flanco negativo de un reloj y con señal asíncrona de reset. +
 +
Sincronismo: +
--Entrada asíncrona: Reset .Se activa independientemente de cualquier otra señal. +
--Entrada síncrona JK: A la salida Q se le asignará un valor determinado por la entrada JK cuando llegue un flanco negativo de la señal de reloj. +
--Para detectar el flanco negativo utilizaremos la función *falling_edge(signal)* definida en la librería ieee. +
 +
Describimos la tabla funcional del biestable mediante las sentencias: [naranja]#IF-THEN-ELSIF-END IF# -> [naranja]#PROCESS()# +
--En la sentencia [naranja]#IF# es opcional el [naranja]#ELSE# y el [naranja]#ELSIF#: esto permite NO describir todos los casos -> *MEMORIA* + 
--El proceso será sensible a la señal asíncrona de reset y a la señal de reloj CLK. Si no hay eventos en la señal RESET ni eventos en CLK(flancos positivos o negativos) -> no se ejecuta el proceso y la salida del biestable no cambia -> *MEMORIA* +
--La señal de RESET tiene prioridad sobre JK: Si se activa la señal de reset el estado siguiente es el estado de inicio (PB) y si no se activa entonces actua la señal JK -> Un primer [naranja]#IF-ELSE#:  +
--Si no Reset: JK escribe en la celda de memoria con el disparo de un flanco negativo del reloj CLK ->  Un segundo [naranja]#IF#  -> por lo que si flanco positivo *MEMORIA*: +
--Si flanco negativo de CLK: Escritura mediante la entrada jk (01,10,11). El caso JK(00) no se describe y se sintetizará como *MEMORIA* -> Un tercer [naranja]#IF-ELSIF# 


=== Descripción VHDL de los biestables JK con entrada asíncrona de reset.


* Código VHDL
+

[source,VHDL]
----
-- Biestable JK por flanco negativo con entrada asíncrona de reset
biestable0:process (clk,reset)
  begin
    if ( reset = '1') then
        q0 <= '0';
    else
      if (falling_edge(clk)) then
         if j0k0 = "10" then
              q0 <= '1';
         elsif j0k0 = "01" then
              q0 <= '0';
         elsif j0k0 = "11" then
              q0 <= not q0;
         end if;
     end if;
  end if;
end process biestable0;
----


=== C. Ascensor: Descripción VHDL Completa
 
[source,vhdl]
----
-- Ascensor de 2 plantas: Planta Baja y Planta Alta
-- Entradas: Switches SW 0-5 -> sensores sa, sb y botones bdb, blb, bda, bla
-- Salidas: Leds LEDR 0-1 -> código z0z1
-- Reloj: botón KEY(0)
-- Reset: botón KEY(1)
--  falling_edge (signal) : función que devuelve TRUE si hay un evento en signal de '1' a '0'
--                          definida en la librería ieee para señales std_logic

library ieee;
use ieee.std_logic_1164.all;

entity ascen2 is
    port (
        SW: in std_logic_vector(5 downto 0);
        KEY: in std_logic_vector(1 downto 0);
        LEDR: out std_logic_vector(9 downto 0);
        HEX0:  out std_logic_vector(6 downto 0);
        HEX1:  out std_logic_vector(6 downto 0)

    );
end ascen2;

architecture rtl of ascen2 is

-- Circuitos diseñados manualmente
-- cc salida z1z0=q1q0
-- cc excitacion biestables:
-- j1=~q1q0sa  k1=q1~q0sb
-- j0=~q1~q0~bdb~blb(bda+bla)
-- k0=q1q0~bda~bla(bdb+blb)
signal j0,k0,j1,k1,q0,q1,z0,z1,clk,reset: std_logic;
signal j0k0,j1k1,q1q0,z1z0: std_logic_vector(1 downto 0);
signal sa,sb,bdb,blb,bda,bla: std_logic;

begin
--  Componentes de los buses
    j0k0 <= j0 & k0;
    j1k1 <= j1 & k1;
    q1q0 <= q1 & q0;
    z1z0 <= z1 & z0;

--  Señales externas de entrada
    clk <= KEY(0);
    reset <= not KEY(1);
    sa <= SW(5);sb <= SW(4);bdb <= SW(3);blb <= SW(2);bda <= SW(1);bla <= SW(0);

-- cc de excitación de biestables
    j0 <= (not q1) and (not q0) and (not bdb) and (not blb) and (bda or bla);
    k0 <= q1 and q0 and (not bda) and (not bla) and (bdb or blb);
    j1 <= (not q1) and q0 and sa;
    k1 <= q1 and (not q0) and sb;

-- cc de salida
    z1 <= q1;
    z0 <= q0;

-- Memoria : 2 biestables JK
    biestable0:process (clk,reset)
    begin
        if ( reset = '1') then
            q0 <= '0';
        else
            if (falling_edge(clk)) then
                if j0k0 = "10" then
                    q0 <= '1';
                elsif j0k0 = "01" then
                    q0 <= '0';
                elsif j0k0 = "11" then
                    q0 <= not q0;
                end if;
            end if;
        end if;
    end process biestable0;

    biestable1:process (clk,reset)
    begin
     if ( reset = '1') then
            q1 <= '0';
        else
            if (falling_edge(clk)) then
                if j1k1 = "10" then
                    q1 <= '1';
                elsif j1k1 = "01" then
                    q1 <= '0';
                elsif j1k1 = "11" then
                    q1 <= not q1;
                end if;
            end if;
        end if;
    end process biestable1;


-- Visualización de la salida
    LEDR(0) <= z1z0(0);
    LEDR(1) <= z1z0(1);

-- Visualización de la entrada: reloj
   LEDR(9) <= clk;

-- Visualización de los estados
    decod7seg:process (q1q0)
    begin
       case q1q0 is
            when "00" =>
                HEX1 <= "0001100";
                HEX0 <= "0000011";
            when "01" =>
                HEX1 <= "0010010";
                HEX0 <= "1000001";
            when "10" =>
                HEX1 <= "0000011";
                HEX0 <= "0001000";
             when "11" =>
                HEX1 <= "0001100";
                HEX0 <= "0001000";
       end case;
    end process decod7seg;

end rtl;
----

[state=txikiago]
=== C. Ascensor: Descripción VHDL de la Arquitectura tipo BEHAVIORAL

* En este caso no es necesario realizar ningún diseño previo manual
* Se describe literalmente el *Diagrama de Secuencia de Estados*
* Es necesario definir un nuevo tipo de señal: el de los estados. Para la declaración de un tipo de señales definido por el DISEÑADOR se utiliza la palabra clave *TYPE*
+

[source,vhdl]
----
type tipo_estado is (pb,sub,baj,pa);  -- tipo enumeración : ESTADOS
signal estado_actual : tipo_estado := pb; -- estado inicial
signal estado_siguiente: tipo_estado := pb ; -- estado inicial
----

** Mediante la asignación [naranja]#:= pb# inicializamos el valor de las señales [naranja]#estado_actual# y [naranja]#estado_siguiente#. De esta manera queda definido el estado inicial nada más encender el controlador del ascensor.

[state=txikiago]
=== C. Ascensor: Descripción VHDL de la Arquitectura tipo BEHAVIORAL

* Es necesario describir la TABLA de TRANSICIONES:
** Estando en el *estado_actual=XX * si se activan las *entradas=YY* entonces se *transita* al *estado_siguiente=ZZ*
** La transición se ejecuta solo si se da algún *evento en las entradas*

* Es necesario describir la escritura en la MEMORIA del *estado_actual*: actualización del nuevo estado
** después de la transición es necesario que : *estado_actual <- estado_siguiente*
** la actualización del estado se da *síncronamente* con el flanco del reloj (*negativo* en este caso)

=== C. Ascensor: Descripción VHDL de las Transiciones y de la Salida

Para describir "Estando en el *estado_actual=XX* ..." -> sentencia [naranja]#CASE# +
Para describir "Si se activan las *entradas=YY* entonces *estado_siguiente=ZZ* " -> sentencia [naranja]#IF-ELSIF#  +
Para describir las salidas MOORE solo hay que tener en cuenta el estado_actual.  -> sentencia concurrente [naranja]#<=# +
Para describir que la transición se da solo si hay algún *evento en las entradas* -> el [naranja]#process(SW)# depende de las entradas SW
 
[source,vhdl]
----
-- Diagrama de Transiciones Moore
    process (SW,clk)
    begin
       case estado_actual is
            when pb =>
                if (bdb='1' or blb='1' ) then
                    estado_siguiente <= pb;
                elsif ( bdb='0' and blb='0' and bda='0' and bla='0') then
                    estado_siguiente <= pb;
                elsif (bda='1' or bla='1' ) then
                   estado_siguiente <= sub;
                end if;
                z0 <= '0';
                z1 <= '0';
            when sub =>
                if (sa='1') then
                    estado_siguiente <= pa;
                else
                   estado_siguiente <= sub;
                end if;
                z0 <= '1';
                z1 <= '0';
           when pa =>
                if (bda='1' or bla='1' ) then
                   estado_siguiente <= pa;
                elsif ( bdb='0' and blb='0' and bda='0' and bla='0') then
                    estado_siguiente <= pa;
                elsif (bdb='1' or blb='1' ) then
                   estado_siguiente <= baj;
                end if;
                z0 <= '1';
                z1 <= '1';
           when baj =>
                if (sb='1') then
                    estado_siguiente <= pb;
                else
                   estado_siguiente <= baj;
                end if;
                z0 <= '0';
                z1 <= '1';
       end case;
    end process;
----

Si la transición sólo depende de las entradas ¿por qué ponemos que el proceso depende de la señal CLK?: la respuesta en la descripción de la memoria.

=== C. Ascensor: Descripción VHDL de la Memoria

Para describir *estado_actual <- estado_siguiente* sincronamente: [naranja]#IF(falling_edge(CLK))# +
Hay cambio de estado dependiendo tanto de las entradas síncronas como asíncronas: +
--Para describir *estado_actual <- estado_inicial* si *entrada=reset* : [naranja]#IF(reset='1')# +
Los [naranja]#IF# al ser secuenciales van en el cuerpo de un [naranja]#process# +
--El [naranja]#process()# será sensible a la entrada asíncrona *reset* y  al reloj *clk* +
 
[source,vhdl]
----
-- Memoria : 2 celdas de memoria síncrona
    memoria:process (clk,reset)
    begin
        if ( reset = '1') then
            -- actualizar el estado asíncronamente
            estado_actual<= pb;
        else
            -- actualizar el estado sincronamente
            if (falling_edge(clk)) then
                estado_actual <= estado_siguiente;
            end if;
        end if;
    end process memoria;
----
** Observar que el process se ejecutará si hay un evento en clk, es decir, tanto si hay flanco positivo o negativo...en cambio el IF del process solo se ejecuta en el flanco negativo del reloj clk.

=== C. Ascensor: Descripción VHDL de la Memoria

* ¿Puede darse el caso de que el estado_siguiente no esté definido? Sí. Al arrancar el sistema mediante el encendido del controlador el estado del sistema será el estado de inicio. Si no cambiamos las entradas no se ejecutará [naranja]#process(SW)# por lo que estado_siguiente *NO* estará definido y al producirse el disparo del reloj clk se ejecutará [naranja]#process(clk,reset)# con la señal estado_siguiente sin definir.
** Dos soluciones posibles: 
... Inicializar el estado_siguiente al arrancar el sistema con la declaración [naranja]#signal estado_siguiente: tipo_estado := *pb*;# que asigna el valor *pb* a la señal estado_siguiente.
... Definir el estado_siguiente al producirse el disparo de reloj activando el [naranja]#process(SW,*clk*)# añadiendo la señal clk a la lista de señales sensibles del process.


=== C. Ascensor: Descripción VHDL Completa
 
[source,vhdl]
----
-- Ascensor de 2 plantas: Planta Baja y Planta Alta
-- Entradas: Switches SW 0-5 -> sensores sa, sb y botones bdb, blb, bda, bla
-- Salidas: Leds LEDR 0-1 -> código z0z1
-- Estados: Leds LEDR 8-9 -> código q0q1
-- Reloj : botón KEY(0)
--  falling_edge (signal) : función que devuelve TRUE si hay un evento en signal de '1' a '0'
--                          definida en la librería ieee para señales std_logic

-- FSM Moore

library ieee;
use ieee.std_logic_1164.all;

entity ascen2 is
    port (
        SW: in std_logic_vector(5 downto 0);
        KEY: in std_logic_vector(1 downto 0);
        LEDR: out std_logic_vector(9 downto 0);
        HEX0:  out std_logic_vector(6 downto 0);
        HEX1:  out std_logic_vector(6 downto 0)

    );
end ascen2;

architecture behavioral of ascen2 is

signal clk,reset,z0,z1: std_logic;
signal sa,sb,bdb,blb,bda,bla: std_logic;

type tipo_estado is (pb,sub,baj,pa);  -- tipo enumeración : ESTADOS
signal estado_actual : tipo_estado := pb; -- estado inicial
signal estado_siguiente: tipo_estado ;

begin
--  Señales externas de entrada
    clk <= KEY(0);
    reset <= not KEY(1);
    sa <= SW(5);sb <= SW(4);bdb <= SW(3);blb <= SW(2);bda <= SW(1);bla <= SW(0);

-- Diagrama de Transiciones Moore
    process (SW,clk)
    begin
       case estado_actual is
            when pb =>
                if (bdb='1' or blb='1' ) then
                    estado_siguiente <= pb;
                elsif ( bdb='0' and blb='0' and bda='0' and bla='0') then
                    estado_siguiente <= pb;
                elsif (bda='1' or bla='1' ) then
                   estado_siguiente <= sub;
                end if;
                z0 <= '0';
                z1 <= '0';
            when sub =>
                if (sa='1') then
                    estado_siguiente <= pa;
                else
                   estado_siguiente <= sub;
                end if;
                z0 <= '1';
                z1 <= '0';
           when pa =>
                if (bda='1' or bla='1' ) then
                   estado_siguiente <= pa;
                elsif ( bdb='0' and blb='0' and bda='0' and bla='0') then
                    estado_siguiente <= pa;
                elsif (bdb='1' or blb='1' ) then
                   estado_siguiente <= baj;
                end if;
                z0 <= '1';
                z1 <= '1';
           when baj =>
                if (sb='1') then
                    estado_siguiente <= pb;
                else
                   estado_siguiente <= baj;
                end if;
                z0 <= '0';
                z1 <= '1';
       end case;
    end process;

-- Memoria : 2 celdas de memoria síncrona
    memoria:process (clk,reset)
    begin
        if ( reset = '1') then
            -- actualizar el estado asíncronamente
            estado_actual<= pb;
        else
            -- actualizar el estado sincronamente
            if (falling_edge(clk)) then
                estado_actual <= estado_siguiente;
            end if;
        end if;
    end process memoria;



-- Visualización de la salida
    LEDR(0) <= z0;
    LEDR(1) <= z1;

-- Visualización de la entrada: reloj
   LEDR(9) <= clk;

-- Visualización de los estados
    decod7seg:process (estado_actual)
    begin
       case estado_actual is
            when pb =>
                HEX1 <= "0001100";
                HEX0 <= "0000011";
            when sub =>
                HEX1 <= "0010010";
                HEX0 <= "1000001";
            when baj =>
                HEX1 <= "0000011";
                HEX0 <= "0001000";
             when pa =>
                HEX1 <= "0001100";
                HEX0 <= "0001000";
       end case;
    end process decod7seg;

end behavioral;

----

=== Secuenciadores Digitales

* Con el diseño del Secuenciador Digital o Controlador Digital del Ascensor se ha expuesto toda la teoría y práctica relacionada con las herramientas y metodología del diseño de los Circuitos Secuenciales Digitales.

* Se recomienda realizar los ejercicios recomendados del libro de problemas y especialmente la obtención del *Diagrama de Estados* partiendo de cero.

=== Contadores


=== Registros


[#Tema8_Fam]
== Tema 8: Circuitos Digitales Integrados. Familias Lógicas.

[#Tema9_Mem]
== Tema 9: Memorias.

[#Tema10_PLD]
== Tema 10: Dispositivos de Lógica Programable (PLD).

[#Tema11_Dac]
== Tema 11: Convertidores Analógico/Digiales DAC/ADC.

