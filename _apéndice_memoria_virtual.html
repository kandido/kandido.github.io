<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.17">
<meta name="keywords" content="computer, architecture">
<meta name="author" content="Cándido Aramburu">
<title>Estructura de Computadores  (240306)</title>
<style>
@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";
@import "https://cdn.jsdelivr.net/gh/asciidoctor/asciidoctor@2.0/data/stylesheets/asciidoctor-default.css";



h1, h2, h3, h4, h5, h6, #toctitle,
.sidebarblock > .content > .title {
  color: rgba(221, 72, 20, 0.8);
}



</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
pre.rouge table td { padding: 5px; }
pre.rouge table pre { margin: 0; }
pre.rouge .cm {
  color: #999988;
  font-style: italic;
}
pre.rouge .cp {
  color: #999999;
  font-weight: bold;
}
pre.rouge .c1 {
  color: #999988;
  font-style: italic;
}
pre.rouge .cs {
  color: #999999;
  font-weight: bold;
  font-style: italic;
}
pre.rouge .c, pre.rouge .ch, pre.rouge .cd, pre.rouge .cpf {
  color: #999988;
  font-style: italic;
}
pre.rouge .err {
  color: #a61717;
  background-color: #e3d2d2;
}
pre.rouge .gd {
  color: #000000;
  background-color: #ffdddd;
}
pre.rouge .ge {
  color: #000000;
  font-style: italic;
}
pre.rouge .gr {
  color: #aa0000;
}
pre.rouge .gh {
  color: #999999;
}
pre.rouge .gi {
  color: #000000;
  background-color: #ddffdd;
}
pre.rouge .go {
  color: #888888;
}
pre.rouge .gp {
  color: #555555;
}
pre.rouge .gs {
  font-weight: bold;
}
pre.rouge .gu {
  color: #aaaaaa;
}
pre.rouge .gt {
  color: #aa0000;
}
pre.rouge .kc {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kd {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kn {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kp {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kr {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kt {
  color: #445588;
  font-weight: bold;
}
pre.rouge .k, pre.rouge .kv {
  color: #000000;
  font-weight: bold;
}
pre.rouge .mf {
  color: #009999;
}
pre.rouge .mh {
  color: #009999;
}
pre.rouge .il {
  color: #009999;
}
pre.rouge .mi {
  color: #009999;
}
pre.rouge .mo {
  color: #009999;
}
pre.rouge .m, pre.rouge .mb, pre.rouge .mx {
  color: #009999;
}
pre.rouge .sa {
  color: #000000;
  font-weight: bold;
}
pre.rouge .sb {
  color: #d14;
}
pre.rouge .sc {
  color: #d14;
}
pre.rouge .sd {
  color: #d14;
}
pre.rouge .s2 {
  color: #d14;
}
pre.rouge .se {
  color: #d14;
}
pre.rouge .sh {
  color: #d14;
}
pre.rouge .si {
  color: #d14;
}
pre.rouge .sx {
  color: #d14;
}
pre.rouge .sr {
  color: #009926;
}
pre.rouge .s1 {
  color: #d14;
}
pre.rouge .ss {
  color: #990073;
}
pre.rouge .s, pre.rouge .dl {
  color: #d14;
}
pre.rouge .na {
  color: #008080;
}
pre.rouge .bp {
  color: #999999;
}
pre.rouge .nb {
  color: #0086B3;
}
pre.rouge .nc {
  color: #445588;
  font-weight: bold;
}
pre.rouge .no {
  color: #008080;
}
pre.rouge .nd {
  color: #3c5d5d;
  font-weight: bold;
}
pre.rouge .ni {
  color: #800080;
}
pre.rouge .ne {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nf, pre.rouge .fm {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nl {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nn {
  color: #555555;
}
pre.rouge .nt {
  color: #000080;
}
pre.rouge .vc {
  color: #008080;
}
pre.rouge .vg {
  color: #008080;
}
pre.rouge .vi {
  color: #008080;
}
pre.rouge .nv, pre.rouge .vm {
  color: #008080;
}
pre.rouge .ow {
  color: #000000;
  font-weight: bold;
}
pre.rouge .o {
  color: #000000;
  font-weight: bold;
}
pre.rouge .w {
  color: #bbbbbb;
}
pre.rouge {
  background-color: #f8f8f8;
}
</style>
<!-- Change some CSS.
<style>
.imageblock{
  &.text-center > .title {
    text-align: center !important;
  }
}
</style>

-->

<style type="text/css"> .imageblock > .title { text-align: center; } </style>

<style>.toc-current{font-weight: bold;} .toc-root{font-family: "Open Sans","DejaVu Sans",sans-serif;
                       font-size: 0.9em;} #content{display: flex; flex-direction: column; flex: 1 1 auto;}
             .nav-footer{text-align: center; margin-top: auto;}
             .nav-footer > p > a {white-space: nowrap;}</style>
</head>
<body id="_apéndice_memoria_virtual" class="book">
<div id="header">
<h1>Estructura de Computadores  (240306)</h1>
<div class="details">
<span id="author" class="author">Cándido Aramburu</span><br>
<span id="email" class="email"><a href="mailto:candido@unavarra.es">candido@unavarra.es</a></span><br>
<span id="revdate">2023-10-04</span>
</div>
<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<p><span class="toc-root"><a href="eecc_book.html">Estructura de Computadores  (240306)</a></span></p><ul class="sectlevel0">
<li><a href="_i_arquitectura_del_repertorio_de_instrucciones_isa_computadora_von_neumann_datos_instrucciones_programación.html">I Arquitectura del Repertorio de Instrucciones (ISA): computadora von Neumann, datos, instrucciones, programación.</a>
</li>
<li><a href="_ii_unidades_básicas_procesador_central_unidad_de_memoria_mecanismos_entradasalida.html">II Unidades Básicas: Procesador Central, Unidad de Memoria, Mecanismos Entrada/Salida.</a>
</li>
<li><a href="_iii_ejercicios_de_teoría.html">III Ejercicios de Teoría</a>
</li>
<li><a href="_iv_autoevaluación_teoría.html">IV Autoevaluación Teoría</a>
</li>
<li><a href="_v_guiones_de_prácticas_programación_ensamblador_x86.html">V Guiones de Prácticas: Programación Ensamblador x86</a>
</li>
<li><a href="_vi_hojas_de_referencia_rápida.html">VI Hojas de Referencia Rápida</a>
</li>
<li><a href="_vii_autoevaluación_prácticas.html">VII Autoevaluación Prácticas</a>
</li>
<li><a href="_viii_apéndices.html">VIII Apéndices</a>
<ul class="sectlevel1">
<li><a href="_arquitectura_de_una_computadora.html">21. Arquitectura de una Computadora</a>
</li>
<li><a href="_rtl_register_transfer_language.html">22. RTL Register Transfer Language</a>
</li>
<li><a href="_programas_ensamblador_iassim.html">23. Programas ensamblador IASSim</a>
</li>
<li><a href="_simulador_iassim_2.html">24. Simulador IASSim</a>
</li>
<li><a href="_lenguajes_de_programación_de_alto_y_bajo_nivel.html">25. Lenguajes de programación de Alto y Bajo Nivel</a>
</li>
<li><a href="_lenguajes_de_programación_en_ensamblador.html">26. Lenguajes de programación en Ensamblador</a>
</li>
<li><a href="_toolchain_cadena_de_herramientas_en_el_proceso_de_compilación.html">27. Toolchain: Cadena de Herramientas en el proceso de compilación</a>
</li>
<li><a href="_practicando_la_programación_desde_el_principio.html">28. Practicando la Programación desde el Principio</a>
</li>
<li><a href="_llamadas_al_sistema_operativo_2.html">29. Llamadas al Sistema Operativo</a>
</li>
<li><a href="_pila.html">30. Pila</a>
</li>
<li><a href="_programas_en_lenguaje_ensamblador_propuestas.html">31. Programas en Lenguaje Ensamblador: Propuestas</a>
</li>
<li><a href="_apéndice_unidad_cpu.html">32. Apéndice: Unidad CPU</a>
</li>
<li><a href="_apéndice_unidad_de_memoria_dram.html">33. Apéndice: Unidad de Memoria DRAM</a>
</li>
<li><a href="_apéndice_memoria_virtual.html"><span class="toc-current">34. Apéndice: Memoria Virtual</span></a>
<ul class="sectlevel2">
<li><a href="_apéndice_memoria_virtual.html#apendice_memvirtual">34.1. Bibliografia</a>
</li>
<li><a href="_apéndice_memoria_virtual.html#_sistemas_operativos_gestión_de_la_memoria">34.2. Sistemas Operativos: Gestión de la Memoria</a>
<ul class="sectlevel3">
<li><a href="_apéndice_memoria_virtual.html#_sistemas_multiproceso">34.2.1. Sistemas Multiproceso</a>
</li>
<li><a href="_apéndice_memoria_virtual.html#_gestión_de_la_memoria_fisica">34.2.2. Gestión de la Memoria Fisica</a>
</li>
<li><a href="_apéndice_memoria_virtual.html#_gestión_mediante_la_memoria_virtual">34.2.3. Gestión mediante la Memoria Virtual</a>
</li>
</ul>
</li>
<li><a href="_apéndice_memoria_virtual.html#apendice_segmentos_secciones">34.3. Memoria Virtual Segmentada</a>
<ul class="sectlevel3">
<li><a href="_apéndice_memoria_virtual.html#_interpretación_de_la_segmentación">34.3.1. Interpretación de la segmentación</a>
</li>
<li><a href="_apéndice_memoria_virtual.html#_secciones">34.3.2. Secciones</a>
</li>
<li><a href="_apéndice_memoria_virtual.html#_enlace_de_secciones">34.3.3. Enlace de Secciones</a>
</li>
<li><a href="_apéndice_memoria_virtual.html#_segmentos_lógicos">34.3.4. Segmentos lógicos</a>
</li>
<li><a href="_apéndice_memoria_virtual.html#_evolución_memoria_intel_8086_80286">34.3.5. Evolución memoria Intel 8086-80286</a>
</li>
</ul>
</li>
<li><a href="_apéndice_memoria_virtual.html#_memoria_virtual_paginada">34.4. Memoria Virtual Paginada</a>
<ul class="sectlevel3">
<li><a href="_apéndice_memoria_virtual.html#_fundamento">34.4.1. Fundamento</a>
</li>
<li><a href="_apéndice_memoria_virtual.html#_concepto_de_memoria_virtual_paginada">34.4.2. Concepto de Memoria Virtual Paginada</a>
</li>
<li><a href="_apéndice_memoria_virtual.html#_fragmentación">34.4.3. Fragmentación</a>
</li>
<li><a href="_apéndice_memoria_virtual.html#_mmu">34.4.4. MMU</a>
</li>
<li><a href="_apéndice_memoria_virtual.html#_virtual_memory_cached">34.4.5. Virtual Memory Cached</a>
</li>
<li><a href="_apéndice_memoria_virtual.html#_tabla_de_paginas">34.4.6. Tabla de paginas</a>
</li>
<li><a href="_apéndice_memoria_virtual.html#_multilevel_paging">34.4.7. Multilevel paging</a>
</li>
<li><a href="_apéndice_memoria_virtual.html#_intel_evolución_memoria_virtual">34.4.8. Intel: Evolución memoria virtual</a>
</li>
<li><a href="_apéndice_memoria_virtual.html#_glosario">34.4.9. Glosario</a>
</li>
<li><a href="_apéndice_memoria_virtual.html#_traducción_dirección_virtual_a_fisica">34.4.10. Traducción: dirección virtual a fisica</a>
</li>
<li><a href="_apéndice_memoria_virtual.html#_translation_lookaside_buffer">34.4.11. Translation Lookaside Buffer</a>
</li>
<li><a href="_apéndice_memoria_virtual.html#_ejercicio">34.4.12. Ejercicio</a>
</li>
<li><a href="_apéndice_memoria_virtual.html#_intel_core_i7">34.4.13. Intel Core i7</a>
</li>
</ul>
</li>
<li><a href="_apéndice_memoria_virtual.html#_sistemas_operativos_gestión_de_la_memoria_2">34.5. Sistemas Operativos: Gestión de la Memoria</a>
<ul class="sectlevel3">
<li><a href="_apéndice_memoria_virtual.html#_protección">34.5.1. Protección</a>
</li>
<li><a href="_apéndice_memoria_virtual.html#_paginación_bajo_demanda">34.5.2. Paginación Bajo Demanda</a>
</li>
<li><a href="_apéndice_memoria_virtual.html#_reemplazo_2">34.5.3. Reemplazo</a>
</li>
<li><a href="_apéndice_memoria_virtual.html#_vm_tool">34.5.4. VM Tool</a>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="_lenguaje_de_programación_c_2.html">35. Lenguaje de Programación C</a>
</li>
<li><a href="_fpu_x87.html">36. FPU x87</a>
</li>
<li><a href="_estructura_de_computadores_2022_primer_parcial_teoría.html">37. Estructura de Computadores 2022: Primer Parcial Teoría</a>
</li>
<li><a href="_estructura_de_computadores_2022_primer_parcial_prácticas.html">38. Estructura de Computadores 2022: Primer Parcial Prácticas</a>
</li>
<li><a href="_estructura_de_computadores_2022_segundo_parcial_prácticas.html">39. Estructura de Computadores 2022: Segundo Parcial Prácticas</a>
</li>
<li><a href="_nominación_de_los_ficheros_del_examen.html">40. Nominación de los ficheros del examen</a>
</li>
<li><a href="_exámenes_de_cursos_anteriores.html">41. Exámenes de Cursos Anteriores</a>
</li>
<li><a href="_miaulario_videoconferencia.html">42. Miaulario: Videoconferencia</a>
</li>
</ul>
</li>
<li><a href="_ix_bibliografía.html">IX Bibliografía</a>
</li>
<li><a href="_x_glosario.html">X Glosario</a>
</li>
<li><a href="_xi_colofón.html">XI Colofón</a>
</li>
<li><a href="_index.html">Index</a>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_apéndice_memoria_virtual">34. Apéndice: Memoria Virtual</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="apendice_memvirtual">34.1. Bibliografia</h3>
<div class="ulist">
<ul>
<li>
<p>Computer Organization and Architecture: Designing for Performance. William Stalling, Cap8 Sistemas Operativos: 8.3 Gestión de la Memoria</p>
<div class="ulist">
<ul>
<li>
<p>Sistema Operativo:  Gestión de la Memoria</p>
</li>
</ul>
</div>
</li>
<li>
<p>Computer Systems A Programmer’s Perspective, Randal E. Bryant. Capítulo 9. Virtual Memory</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_sistemas_operativos_gestión_de_la_memoria">34.2. Sistemas Operativos: Gestión de la Memoria</h3>
<div class="sect3">
<h4 id="_sistemas_multiproceso">34.2.1. Sistemas Multiproceso</h4>
<div class="ulist">
<ul>
<li>
<p>En un sistema multitarea hay más de un proceso ejecutándose y residente en la memoria principal.</p>
</li>
<li>
<p>La memoria principal es un recurso compartido por todos los procesos. En un entorno multiproceso, es necesario gestionar el recurso compartido para asignar regiones de memoria física a cada proceso, para proteger espacios de memoria entre los distintos procesos, etc</p>
</li>
<li>
<p>Históricamente la memoria principal era muy limitada frente al tamaño de los programas.</p>
</li>
<li>
<p>Técnicas de gestión de la memoria en sistemas operativos: swapping, particionamiento, memoria virtual, segmentación, paginación. .</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_gestión_de_la_memoria_fisica">34.2.2. Gestión de la Memoria Fisica</h4>
<div class="sect4">
<h5 id="_memoria_principal_3">Memoria Principal</h5>
<div class="ulist">
<ul>
<li>
<p>La memoria principal es la memoria física externa a la CPU e implementada en tecnología SDRAM con una capacidad típica en el año 2010 de 4GB.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_swapping">Swapping</h5>
<div class="ulist">
<ul>
<li>
<p>Significa intercambio.</p>
</li>
<li>
<p>Los programas se almacenan en el disco duro como módulos objeto ejecutables.</p>
</li>
<li>
<p>Los módulos ejecutables deben cargarse en memoria para ser ejecutados, convirtiéndose en procesos.</p>
</li>
<li>
<p>La memoria es <em>limitada</em> por lo que no puede almacenar todos los procesos requeridos por el usuario.</p>
</li>
<li>
<p>Una solución es que los procesos utilicen tanto la memoria principal como el disco duro. En memoria  residen los procesos  que son ejecutados en un momento dado y cuando uno de dichos procesos  no requiere de la CPU (espera a un evento i/o)(no está en estado <em>ready</em>) se intercambia con el disco duro por un proceso que si requiere de la CPU (está en estado ready). La transferencia del proceso hacia la memoira principal se denomina swap-in y la transferencia hacia el disco duro swap-out.</p>
</li>
<li>
<p>Se <strong>intercambia todo</strong> el proceso.</p>
</li>
<li>
<p>Hay un intercambio  de procesos completos entre la memoria  y el disco duro. Este es el concepto de swap para algunos sistemas operativos como Solaris y el que se toma por definición. En Linux tiene otro significado.</p>
</li>
<li>
<p>Al trasladar un proceso de memoria al disco duro se genera un <strong>hueco en la memoria</strong>. La existencia de múltiples huecos dispersados por la memoria se le denomina <em>fragmentación externa</em>.</p>
</li>
<li>
<p>El inconveniente es que el swapping requiere de un operación i/o con el disco duro ralentizando el rendimiento de la computadora.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_particionamiento_fragmentación">Particionamiento (Fragmentación)</h5>
<div class="ulist">
<ul>
<li>
<p><strong>La clave</strong>:</p>
<div class="ulist">
<ul>
<li>
<p>Sin memoria virtual el código de los procesos en la memoria física ha de ser <strong>contiguo</strong>.</p>
</li>
<li>
<p>Si no utilizamos memoria virtual el <em>particionamiento dinámico</em> (el proceso ocupa justo la región de memoria que necesita)  produce fragmentación externa al eliminar particiones y el <em>particionamiento fijo</em> (el proceso ocupa menos de la región que tiene reservada) produce fragmentación interna</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>La Solución</strong> para que un proceso pueda ocupar particiones <strong>NO CONTIGUAS</strong> en la memoria FISICA : memoria VIRTUAL.</p>
<div class="ulist">
<ul>
<li>
<p>Al poder asignar particiones pequeñas fijas no contiguas el fraccionamiento externo desaparece y el interno se reduce al máximo (inferior al tamaño de la partición)</p>
</li>
</ul>
</div>
</li>
<li>
<p>El <strong>particionamiento</strong> es una técnica para asignar memoria principal a los distintos procesos que están siendo ejecutados concurrentemente en la computadora.</p>
</li>
<li>
<p>La memoria se divide en múltiples regiones o <em>particiones</em> de tamaño no uniforme.</p>
</li>
<li>
<p>A un proceso se le asigna una partición de <em>igual o mayor tamaño</em>.</p>
</li>
<li>
<p>Se utiliza en sistemas multitarea donde la memoria principal es compartida por múltiples procesos. De esta manera se puede <em>gestionar el compartir</em> la memoria entre los diferentes procesos, protección, permisos, superusuario, etc</p>
</li>
<li>
<p>Cuando el proceso no está ready se realiza un swapping con el disco duro.</p>
</li>
<li>
<p>Dos alternativas : la estructura de las particiones puede ser fijo o variable en el tiempo. En los dos casos un proceso requiere una partición, es decir, una región de posiciones de memoria <strong>contiguas</strong>.</p>
</li>
<li>
<p>Particionamiento <strong>FIJO</strong> :</p>
<div class="ulist">
<ul>
<li>
<p>La memoria principal se parte en regiones cuyo tamaño no varía durante la ejecución de los procesos.</p>
</li>
<li>
<p>Pariticionamiento fijo con regiones de igual tamaño o particionamiento fijo con regiones de diferente tamaño.</p>
</li>
<li>
<p>A los procesos se les asigna una partición de tamaño mayor que el requerido. Esto produce <strong>fragmentación interna</strong>, ya que una zona de la partición no es aprovechada por ningún proceso.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Particionamiento variable o <strong>DINAMICO</strong>:</p>
<div class="ulist">
<ul>
<li>
<p>A cada proceso se le asigna justo la memoria que necesita. No hay fragmentación interna.</p>
</li>
<li>
<p>El tamaño de las particiones cambia dinámicamente según se intercambian procesos con el disco duro adaptándose al tamaño de estos.</p>
</li>
<li>
<p>La <strong>fragmentación externa</strong> es considerable. Se podría reducir compactando los huecos dispersos, para lo cual es necesario mover o reubicar los procesos en la memoria principal. La reubicación de procesos significa resolver todas las direcciones físicas nuevamente en tiempo de ejecución &#8594; puede resultar inviable el tiempo requerido.</p>
</li>
<li>
<p>Hay publicidad de programas que defragmentan la memoria principal lo cual no es posible ya que únicamente el S.O. conoce las direcciones físicas de un proceso.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_alternativa">Alternativa</h5>
<div class="ulist">
<ul>
<li>
<p>La solución a la fragmentación debido a la técnica del particionamiento de la memoria física es la técnica de memoria virtual bien segmentada o bien paginada o ambas.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_gestión_mediante_la_memoria_virtual">34.2.3. Gestión mediante la Memoria Virtual</h4>
<div class="sect4">
<h5 id="_alternativa_2">Alternativa</h5>
<div class="ulist">
<ul>
<li>
<p>Los problemas de gestionar la memoria de los procesos asignando a los procesos <em>directamente</em> un espacio de direcciones físico se resuelven mediante el mecamismo de la <em>memoria virtual</em>.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_espacio_de_direcciones_virtual">Espacio de direcciones virtual</h5>
<div class="ulist">
<ul>
<li>
<p>El programador, el compilador, el linker y los procesos no operan con direcciones físicas.</p>
</li>
<li>
<p>El programador referencia la memoria en el módulo fuente con símbolos (etiquetas, variables, nombres de funciones, etc)</p>
</li>
<li>
<p>El compilador y el linker traducen los símbolos a direcciones de una memoria imaginaria lineal y contigua denominada memoria virtual.</p>
</li>
<li>
<p>Esta independencia de las direcciones físicas simplifica enormemente la gestión de la memoria.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_ejemplo_programa_exit">Ejemplo: programa exit</h5>
<div class="ulist">
<ul>
<li>
<p>Desensamblado del módulo objeto ejecutable residente en el disco</p>
<div class="ulist">
<ul>
<li>
<p><code>objdump -S exit</code></p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="nl">exit:</span>     <span class="n">file</span> <span class="n">format</span> <span class="n">elf64</span><span class="o">-</span><span class="n">x86</span><span class="o">-</span><span class="mi">64</span>


<span class="n">Disassembly</span> <span class="n">of</span> <span class="n">section</span> <span class="p">.</span><span class="n">text</span><span class="o">:</span>

<span class="mo">000000000040007</span><span class="mi">8</span> <span class="o">&lt;</span><span class="p">.</span><span class="n">text</span><span class="o">&gt;:</span>
  <span class="mi">400078</span><span class="o">:</span>	<span class="mi">48</span> <span class="n">c7</span> <span class="n">c0</span> <span class="mi">3</span><span class="n">c</span> <span class="mo">00</span> <span class="mo">00</span> <span class="mo">00</span> 	<span class="n">mov</span>    <span class="err">$</span><span class="mh">0x3c</span><span class="p">,</span><span class="o">%</span><span class="n">rax</span>
  <span class="mi">40007</span><span class="n">f</span><span class="o">:</span>	<span class="mi">48</span> <span class="n">c7</span> <span class="n">c7</span> <span class="n">ff</span> <span class="mo">00</span> <span class="mo">00</span> <span class="mo">00</span> 	<span class="n">mov</span>    <span class="err">$</span><span class="mh">0xff</span><span class="p">,</span><span class="o">%</span><span class="n">rdi</span>
  <span class="mi">400086</span><span class="o">:</span>	<span class="mi">0</span><span class="n">f</span> <span class="mo">05</span>                	<span class="n">syscall</span></code></pre>
</div>
</div>
</li>
<li>
<p>Las direcciones 0x400078,.. son direcciones del espacio virtual. El espacio de direcciones virtual es <em>lineal</em>, contiguo y único.</p>
</li>
<li>
<p>La dirección virtual <em>0x0000000000400078</em> comprende 16 dígitos hexadecimales, es decir, el espacio de direcciones virtual del proceso <em>exit</em> tiene capacidad para 2<sup>64</sup> Bytes.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_memoria_recurso_compartido">Memoria: Recurso compartido</h5>
<div class="ulist">
<ul>
<li>
<p>Cada proceso tiene su propio espacio de direcciones virtual.</p>
</li>
<li>
<p>Todos los procesos han de compartir la misma memoria física.</p>
</li>
<li>
<p>Todos los espacios virtuales han de ser traducidos al mismo espacio físico.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_traducción_virtual_fisico">Traducción virtual &#8594; fisico</h5>
<div class="ulist">
<ul>
<li>
<p>Cada vez que la CPU acceda a memoria para capturar instrucciones y datos o escribir resultados, será necesario <em>traducir</em> la dirección lógica en una dirección física. Es decir, las direcciones</p>
</li>
<li>
<p>Esta traducción la realiza la unidad hardware <em>Management Memory Unit (MMU)</em>.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_direccionamiento_lógico">Direccionamiento lógico</h5>
<div class="ulist">
<ul>
<li>
<p>En el intercambio de procesos entre la memoria y el disco duro, las direcciones físicas de memoria donde son cargados los datos y las instrucciones pueden cambiar. Debido a ello no es factible un modelo de direccionamiento que utilice direcciones físicas absolutas.</p>
</li>
<li>
<p>Las direcciones del proceso se expresan de forma <strong>relativa</strong> respecto de una <strong>dirección base</strong>. Al par dirección base y offset se le denomina <em>dirección lógica</em>.</p>
</li>
<li>
<p>Esta dirección lógica es una dirección virtual, no física.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_dos_tipos_segmentación_y_paginación">Dos tipos: Segmentación y Paginación</h5>
<div class="ulist">
<ul>
<li>
<p>El espacio de memoria virtual se puede gestionar utilizando dos mecanismos o la combinaición de ellos:</p>
<div class="ulist">
<ul>
<li>
<p><strong>Segmentación</strong></p>
<div class="ulist">
<ul>
<li>
<p>La memoria virtual de un proceso se divide en unidades lógicas indivisibles denominadas segmentos</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Paginación</strong></p>
<div class="ulist">
<ul>
<li>
<p>La memoria virtual de un proceso y la memoria física de la computadora se dividen en unidades denominadas páginas (lógicas en la memoria virtual y físicas en la memoria principal).</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="apendice_segmentos_secciones">34.3. Memoria Virtual Segmentada</h3>
<div class="sect3">
<h4 id="_interpretación_de_la_segmentación">34.3.1. Interpretación de la segmentación</h4>
<div class="ulist">
<ul>
<li>
<p>La segmentación se puede aplicar tanto al espacio de direcciones físico como al espacio de direcciones virtual.</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Segmentación del espacio de direcciones virtual</p>
<div class="ulist">
<ul>
<li>
<p>División de un programa (proceso) en unidades lógicas: código,variables inicializados, variables sin inicializar, datos read only, etc. División de la memoria virtual de un proceso en áreas de <strong>memoria contigua</strong> y cuyo tamaño puede variar dinámicamente. Los segmentos lógicos no se pueden dividir.</p>
</li>
<li>
<p>Facilita el trabajo del compilador,linker,sharing, etc</p>
</li>
<li>
<p>El espacio total de la memoria virtual formado por todos los procesos estaría formado por la dirección base  segmento y el desplazamiento (offset) del registro contador de programa.</p>
</li>
<li>
<p>Se ha utilizado memoria virtual segmentada en las CPU: 80286,80386,80486 y Pentium</p>
</li>
</ul>
</div>
</li>
<li>
<p>Segmentación del espacio de direcciones físico.</p>
<div class="ulist">
<ul>
<li>
<p>Se utilizó en la arquitectura intel 8086 para pasar de un bus de direcciones de 16 bits a 20 bits manteniendo el tamaño de los registros con 16 bits.</p>
</li>
<li>
<p>Incrementar el espacio de direcciones físicas añadiendo un registro de segmento y sin incrementar el tamaño del registro contador de programa. Por ejemplo un microprocesador Intel de 16 bits sin segmentación tiene límitado el espacio físico a 2<sup>16</sup> = 64KB. Con el mismo micro y un registro adicional de segmento RS de 16 bits podemos concatenar el registro RS con el contador de programa PC formando direcciones físicas de 32 bits con lo que tendríamos un espacio de direcciones físicas de 2<sup>32</sup> = 4GB</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_secciones">34.3.2. Secciones</h4>
<div class="ulist">
<ul>
<li>
<p>cada módulo objeto reubicable está estructurado en secciones</p>
</li>
<li>
<p>una sección es una división lógica, no física.</p>
</li>
<li>
<p>la estructura en secciones se define en el módulo fuente</p>
</li>
<li>
<p>Secciones principales</p>
<div class="ulist">
<ul>
<li>
<p>text : instrucciones</p>
</li>
<li>
<p>data : variables inicializadas</p>
</li>
<li>
<p>rodata: variables readonly</p>
</li>
<li>
<p>bss:    variables sin inicializar</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>readelf -S maximum</code></p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sh">There are 16 section headers, starting at offset 0x448:

Section Headers:
  <span class="o">[</span>Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  <span class="o">[</span> 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  <span class="o">[</span> 1] .interp           PROGBITS         0000000000400158  00000158
       000000000000001c  0000000000000000   A       0     0     1
  <span class="o">[</span> 2] .hash             HASH             0000000000400178  00000178
       000000000000000c  0000000000000004   A       3     0     8
  <span class="o">[</span> 3] .dynsym           DYNSYM           0000000000400188  00000188
       0000000000000000  0000000000000018   A       4     1     8
  <span class="o">[</span> 4] .dynstr           STRTAB           0000000000400188  00000188
       000000000000000b  0000000000000000   A       0     0     1
  <span class="o">[</span> 5] .text             PROGBITS         0000000000400193  00000193
       0000000000000037  0000000000000000  AX       0     0     1
  <span class="o">[</span> 6] .eh_frame         PROGBITS         00000000004001d0  000001d0
       0000000000000000  0000000000000000   A       0     0     8
  <span class="o">[</span> 7] .dynamic          DYNAMIC          00000000006001d0  000001d0
       00000000000000d0  0000000000000010  WA       4     0     8
  <span class="o">[</span> 8] .data             PROGBITS         00000000006002a0  000002a0
       000000000000000e  0000000000000000  WA       0     0     1
  <span class="o">[</span> 9] .debug_aranges    PROGBITS         0000000000000000  000002b0
       0000000000000030  0000000000000000           0     0     16
  <span class="o">[</span>10] .debug_info       PROGBITS         0000000000000000  000002e0
       0000000000000078  0000000000000000           0     0     1
  <span class="o">[</span>11] .debug_abbrev     PROGBITS         0000000000000000  00000358
       0000000000000014  0000000000000000           0     0     1
  <span class="o">[</span>12] .debug_line       PROGBITS         0000000000000000  0000036c
       000000000000004a  0000000000000000           0     0     1
  <span class="o">[</span>13] .shstrtab         STRTAB           0000000000000000  000003b6
       000000000000008d  0000000000000000           0     0     1
  <span class="o">[</span>14] .symtab           SYMTAB           0000000000000000  00000848
       0000000000000240  0000000000000018          15    20     8
  <span class="o">[</span>15] .strtab           STRTAB           0000000000000000  00000a88
       000000000000006f  0000000000000000           0     0     1
Key to Flags:
  W <span class="o">(</span>write<span class="o">)</span>, A <span class="o">(</span>alloc<span class="o">)</span>, X <span class="o">(</span>execute<span class="o">)</span>, M <span class="o">(</span>merge<span class="o">)</span>, S <span class="o">(</span>strings<span class="o">)</span>, l <span class="o">(</span>large<span class="o">)</span>
  I <span class="o">(</span>info<span class="o">)</span>, L <span class="o">(</span><span class="nb">link </span>order<span class="o">)</span>, G <span class="o">(</span>group<span class="o">)</span>, T <span class="o">(</span>TLS<span class="o">)</span>, E <span class="o">(</span>exclude<span class="o">)</span>, x <span class="o">(</span>unknown<span class="o">)</span>
  O <span class="o">(</span>extra OS processing required<span class="o">)</span> o <span class="o">(</span>OS specific<span class="o">)</span>, p <span class="o">(</span>processor specific<span class="o">)</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_enlace_de_secciones">34.3.3. Enlace de Secciones</h4>
<div class="ulist">
<ul>
<li>
<p>el linker mezcla de forma organizada cada tipo de sección de todos los módulos objeto reubicables generando un único módulo objeto ejecutable</p>
</li>
<li>
<p>Ejemplo de tres módulos objeto reubicables:</p>
<div class="ulist">
<ul>
<li>
<p>los tres módulos fuente p1.c, p2.c, p3.c  se compilan dando lugar a p1.o, p2.o y p3.o los cuales se enlazan dando lugar al ejecutable <em>p</em></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/memvirtual/linksections.png" alt="enlace de secciones">
</div>
</div>
</div>
<div class="sect3">
<h4 id="_segmentos_lógicos">34.3.4. Segmentos lógicos</h4>
<div class="ulist">
<ul>
<li>
<p>El módulo ejecutable está estructurado en segmentos</p>
<div class="ulist">
<ul>
<li>
<p>text</p>
<div class="ulist">
<ul>
<li>
<p>código de las instrucciones a ejecutar</p>
</li>
</ul>
</div>
</li>
<li>
<p>data</p>
<div class="ulist">
<ul>
<li>
<p>código de datos: variables inicializadas, sin inicializar</p>
</li>
</ul>
</div>
</li>
<li>
<p>stack</p>
<div class="ulist">
<ul>
<li>
<p>pila</p>
</li>
</ul>
</div>
</li>
<li>
<p>heap</p>
<div class="ulist">
<ul>
<li>
<p>montículo</p>
</li>
<li>
<p>es la asignación de memoria en tiempo de ejecución</p>
</li>
<li>
<p>en C la función <code>malloc()</code>: memory allocation: <code>void *malloc(size_t size)</code></p>
<div class="ulist">
<ul>
<li>
<p>size: tamaño en bytes de la memoria a asignar</p>
</li>
<li>
<p>devuelve un puntero a la región de memoria asignada</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>mapa de memoria del programa en ejecución</p>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/ditaa/svg/eNoLyywqKU3MUXBMSSlKLS7mVFDQRQCXIEdfXRTAZVDhhga0dfEAbS4FDFCjgAfUUEeDHhCQpCHZ0tISvwaDCgsDOKhRcKnMS8zNTFYITk3PTc0rKVZQ0PBITSzQxGEDMaFkUGGOCNYaheCSxORskDjUCpqEEika6BHTJDoJGA-JJYlIgVQ8dPxgUGECTUshqRUlg8APBhWI5A3OD6F5uYkFBakpNEgaNigqwvOLUpC4dgDbjMhx" alt="Diagram">
</div>
</div>
</li>
</ul>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/memvirtual/linux_vm_map.png" alt="MMU">
</div>
<div class="title">Figure 114. linux_vm_map</div>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/memvirtual/linux_vm_map_2.png" alt="MMU">
</div>
<div class="title">Figure 115. linux_vm_map_2</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Cada proceso tiene su propia memoria virtual independiente del resto de los procesos</p>
</li>
<li>
<p>Los segmentos pueden cambiar de tamaño dinámicamente en tiempo de ejecución.</p>
<div class="ulist">
<ul>
<li>
<p>Carga del módulo objeto ejecutable</p>
</li>
</ul>
</div>
</li>
<li>
<p>El loader no carga el módulo ejecutable en DRAM, sino que mapea el fichero a memoria virtual, creando la tabla de páginas.</p>
</li>
<li>
<p>La carga efectiva se realiza bajo demanda.</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/memvirtual/load_segments.png" alt="load segments">
</div>
</div>
</div>
<div class="sect3">
<h4 id="_evolución_memoria_intel_8086_80286">34.3.5. Evolución memoria Intel 8086-80286</h4>
<div class="sect4">
<h5 id="_8086">8086</h5>
<div class="ulist">
<ul>
<li>
<p>80x86 &#8594; (bits bus direcciones, bits bus datos)</p>
</li>
<li>
<p>8086  &#8594; (20,16) &#8594; 2<sup>20</sup>=1MB de memoria física&#8594; Modo Real</p>
<div class="ulist">
<ul>
<li>
<p>Segmentación</p>
<div class="ulist">
<ul>
<li>
<p>La dirección lógica esta formada por un tuple de dos valores: dirección base y offset.</p>
</li>
<li>
<p>Conversión de dirección lógica a dirección física:</p>
<div class="ulist">
<ul>
<li>
<p>Con un contador de programa de 16 bits se pueden direccionar 64KB. Si añadimos un registro segmento adicional de 16 bits cuyo contenido lo desplazamos 4 bits a la izda (equivale a <strong>multiplicar por 2<sup>4</sup></strong>) tendríamos una dirección base de 20 bits a la cual añadiríamos el offset del PC de 16 bits obteniendo una dirección  física de 20 bits- &gt; espacio físico de 1MB.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Este modo de memoria se denominó <em>modo real</em>: espacio de direcciones memoria segmentada de 20 bits.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_80286">80286</h5>
<div class="ulist">
<ul>
<li>
<p>80286 &#8594; (24,16) &#8594; 2<sup>24</sup>=16MB de memoria física&#8594; Modos Real y protegido.</p>
<div class="ulist">
<ul>
<li>
<p>Concepto de memoria Virtual: memoria generada por el compilador y por los procesos al ejecutarse</p>
<div class="ulist">
<ul>
<li>
<p>En este caso son 4 bytes de memoria virtual &#8594; los 2 bytes más altos son el selector de segmento y los dos bytes más bajos el offset.</p>
</li>
<li>
<p>Capacidad de memoria virtual &#8594; 2<sup>32</sup> = 4GB</p>
</li>
</ul>
</div>
</li>
<li>
<p>La memoria virtual de los procesos se parte en segmentos.</p>
</li>
<li>
<p>Segmentación</p>
<div class="ulist">
<ul>
<li>
<p>Forming different segments for data, code, and stack, and preventing their overlapping</p>
</li>
<li>
<p>Cada segmento únicamente puede direccionar 64KB ya que el Contador de Programa es de 16 bits</p>
</li>
<li>
<p>La conversión memoria lógica a memoria física:</p>
<div class="ulist">
<ul>
<li>
<p>Se utiliza uno de los 4 registros de segmento CS,DS,ES,SS: son de 64 bits: 16 bits visibles y 6 bytes escondidos</p>
</li>
<li>
<p>Se utiliza una tabla de descripción del segmento residente en la memoria principal: cada entrada de la tabla son 8 bytes de los cuales 3 bytes son la dirección base física asociada a la dirección virtual segmentada.</p>
</li>
<li>
<p>En la parte visible del registro de segmento se cargan los 2 bytes más altos de la dirección virtual (selector de segmento)</p>
</li>
<li>
<p>El selector de segmento apunta a una de las entradas de la tabla de selección de descripción de segmento y carga 6 bytes de la tabla en la zona escondida del registro de segmento el cual contiene: dirección base física (3bytes), tamaño del segmento (2 bytes) y propiedades del segmento (1byte)</p>
</li>
<li>
<p>dirección física: la dirección base (3bytes) más el offset (2bytes): con 3 bytes &#8594; 2<sup>24</sup>=16MB de espacio físico</p>
</li>
<li>
<p>El espacio de direcciones de 4GB de memoria virtual de un segmento debiera poder traducirse en el espacio de direcciones físico de 16MB, pero únicamente puede acceder a 64KB.</p>
</li>
<li>
<p>Espacio físico total: de los 16MB posibles un segmento direcciona solo 64KB y como tenemos 4 segmentos &#8594; 4*64KB=256KB totales.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Multitasking, memory management (on chip MMU), protected memory &#8594; <em>modo protegido</em>: espacio de direcciones memoria segmentada de 24 bits.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_80386">80386</h5>
<div class="ulist">
<ul>
<li>
<p>80386 &#8594; (32,32) &#8594; Espacio Físico: 2<sup>32</sup> = 4GB</p>
<div class="ulist">
<ul>
<li>
<p>Misma arquitectura que el 286 pero incrementa la ruta de datos de 16 bits a 32 bits, añade dos registros de segmento más (FS,GS) y añade la técnica de la paginación.</p>
</li>
<li>
<p>Memoria Virtual: 6 bytes : 2<sup>48</sup> = 64TB . Los 2 bytes altos son el selector de registro y los 4 bytes bajos el offset</p>
<div class="ulist">
<ul>
<li>
<p>de los 64TB posibles los 6 segmentos pueden direccionar <em>en un momento dado</em> 4GB cada uno &#8594; 6*4GB=24GB</p>
</li>
</ul>
</div>
</li>
<li>
<p>Segmentación</p>
<div class="ulist">
<ul>
<li>
<p>Selector de Segmento = 2 bytes como en el 286 &#8594; puntero a la entrada de la tabla descriptor de segmento</p>
</li>
<li>
<p>Descriptor de Segmento = Contiene 4 bytes de la dirección base física</p>
</li>
</ul>
</div>
</li>
<li>
<p>Conversión de la dirección lógica a dirección física con sólo segmentación</p>
<div class="ulist">
<ul>
<li>
<p>A la dirección base física (4 bytes) se le añade el offset de la dirección virtual (4bytes) &#8594; dirección física de 32 bits.</p>
</li>
<li>
<p>En este caso, a diferencia del 80286, el espacio de memoria virtual de 4GB de cada segmento se pueden traducir en el espacio físico de 4GB.</p>
</li>
</ul>
</div>
</li>
<li>
<p>instrucciones</p>
<div class="ulist">
<ul>
<li>
<p><code>movl $42,%fs:(%eax)</code></p>
</li>
<li>
<p>implícitamente</p>
<div class="ulist">
<ul>
<li>
<p>push, pop &#8594; SS,DS</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Ver paginación 80386</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_amd64">amd64</h5>
<div class="ulist">
<ul>
<li>
<p>amd64 &#8594; (52,64) &#8594; Espacio Físico: 2<sup>52</sup> = 4PetaBytes y Espacio Virtual 2<sup>48</sup> = 256TB</p>
<div class="ulist">
<ul>
<li>
<p><a href="https://en.wikipedia.org/wiki/X86-64#Physical_address_space_details" class="bare">https://en.wikipedia.org/wiki/X86-64#Physical_address_space_details</a></p>
</li>
<li>
<p><strong>No utiliza la segmentación lógica</strong> del espacio de direcciones virtual debido a que el espacio de memoria virtual de 256TB es suficiente para todos los procesos. Los segmentos lógicos (text,data,stack,heap, etc ) de un proceso se almacenan en el mismo espacio virtual asignado a dicho proceso mediante la técnica de paginación.</p>
</li>
<li>
<p>Hay que tener en cuenta la limitación de la tabla de paginas virtual que depende del número de páginas virtuales y la dirección de una página física. El area de memoria principal ocupada crece exponencialmente con el tamaño de la tabla y de forma innecesaria.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/memvirtual/amd64_virtualformat.png" alt="MMU">
</div>
<div class="title">Figure 116. Formato de direcciones amd64</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_memoria_virtual_paginada">34.4. Memoria Virtual Paginada</h3>
<div class="sect3">
<h4 id="_fundamento">34.4.1. Fundamento</h4>
<div class="ulist">
<ul>
<li>
<p>La paginación consiste en dividir tanto la memoria <em>física</em> como la memoria <em>virtual</em> de los procesos en pequeños <em>pedazos</em> denominados páginas.</p>
</li>
<li>
<p>Los pedazos de memoria física se denominan <em>marcos de página</em> y los pedazos de memoria virtual del proceso se denominan <em>páginas</em></p>
</li>
<li>
<p>En este caso se asigna cada página a un marco de página diferente, quedando los trozos de proceso diseminados en zonas <strong>NO CONTIGUAS</strong> de la memoria.</p>
</li>
<li>
<p>De esta manera se reduce la fragmentación interna ,ya que la memoria infrautilizada siempre será menor al tamaño de una página.</p>
</li>
<li>
<p>El sistema operativo genera para cada proceso la <em>tabla de páginas</em> que mapea páginas con marcos.</p>
<div class="ulist">
<ul>
<li>
<p>PTE: Page Table Entry &#8594; (index,PhysPageNumber)</p>
</li>
</ul>
</div>
</li>
<li>
<p>Dirección lógica</p>
<div class="ulist">
<ul>
<li>
<p>Cada dirección lógica estará formada por la dirección base de la página y el offset dentro de la página. Direccionamiento <strong>no lineal</strong>, (dirección base, desplazamiento)</p>
</li>
</ul>
</div>
</li>
<li>
<p>Traducción de dirección lógica a física.</p>
<div class="ulist">
<ul>
<li>
<p>El espacio de direcciones físico es único y contiguo, es decir, lineal.</p>
</li>
<li>
<p>La dirección base de la página del proceso se asocia con la dirección base del marco: tabla de páginas.</p>
</li>
<li>
<p>El offset dentro del marco será el mismo que el offset dentro de la página.</p>
</li>
<li>
<p>La gestión de la paginación la realiza la MMU</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_concepto_de_memoria_virtual_paginada">34.4.2. Concepto de Memoria Virtual Paginada</h4>
<div class="ulist">
<ul>
<li>
<p>Debido a que no es necesario cargar todas las páginas del proceso &#8594; el espacio de memoria del <strong>PROCESO</strong> puede ser <strong>mayor</strong> que la memoria física &#8594; concepto de <strong>memoria virtual</strong></p>
</li>
<li>
<p>La memoria virtual es única, contigua, es decir, <em>LINEAL</em>. Es una abstracción para no depender de las direcciones físicas.</p>
</li>
<li>
<p>Por el principio de localidad en la memoria física sólo está la copia de las páginas virtuales que son necesarias dinámicamente en un momento dado.</p>
<div class="ulist">
<ul>
<li>
<p><strong>concepto de cache</strong></p>
</li>
</ul>
</div>
</li>
<li>
<p>La memoria principal es la cache de la memoria secundaria (ficheros el disco o pendrive)</p>
</li>
<li>
<p>SDRAM cache</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_fragmentación">34.4.3. Fragmentación</h4>
<div class="ulist">
<ul>
<li>
<p>En el desalojo de áreas de memoria que no son necesarias se generan huecos que fragmentan la memoria física en una sucesión de áreas de memoria utilizadas y áreas no utilizadas</p>
</li>
<li>
<p>La fragmentación interna será menor cuanto más pequeñas sean las páginas.</p>
<div class="ulist">
<ul>
<li>
<p>En la paginación las páginas pueden tener bytes sin utilizar, son huecos internos a las páginas.</p>
</li>
</ul>
</div>
</li>
<li>
<p>La fragmentación externa se reduce ya que los marcos de página pueden ser asignados a un proceso independientemente del tamaño del proceso.</p>
<div class="ulist">
<ul>
<li>
<p>Un proceso ocupará los huecos dejados por las páginas que no tienen porque ser contiguas. El tamaño del proceso afectará al número de páginas requeridas en caso de que queramos tener todo el proceso residente en memoria principal.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_mmu">34.4.4. MMU</h4>
<div class="ulist">
<ul>
<li>
<p>Unidad Hardware interna a la CPU</p>
</li>
<li>
<p>Su entrada es el bus de direcciones virtuales y su salida el bus de direcciones físicas.</p>
</li>
<li>
<p>La MMU accede a la tabla de descripción de segmentos y a la tabla de páginas y realiza la traducción de dirección virtual en dirección física</p>
</li>
<li>
<p>La tabla de páginas de la MMU es la función de correspondencia que mapea el espacio virtual y el físico.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_virtual_memory_cached">34.4.5. Virtual Memory Cached</h4>
<div class="ulist">
<ul>
<li>
<p>Tabla de páginas con función de correspondencia fully associative (las VPages se asocian con cualquier Marco de página)</p>
</li>
<li>
<p>Bit de validación</p>
<div class="ulist">
<ul>
<li>
<p>1 &#8594; cached page</p>
</li>
<li>
<p>o &#8594; uncached page: allocated o unallocated</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/memvirtual/vm_concept.png" alt="MMU">
</div>
<div class="title">Figure 117. MMU</div>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/memvirtual/vm_table.png" alt="MMU">
</div>
<div class="title">Figure 118. MMU</div>
</div>
</div>
<div class="sect3">
<h4 id="_tabla_de_paginas">34.4.6. Tabla de paginas</h4>
<div class="ulist">
<ul>
<li>
<p>La tabla de páginas reside en la memoria principal SDRAM.</p>
</li>
<li>
<p>Las entradas de la tabla son un puntero a marcos de página física</p>
</li>
<li>
<p>Tantas entradas como páginas virtuales</p>
</li>
<li>
<p>El número de página virtual es el índice de la tabla.</p>
</li>
<li>
<p>La MMU accede a la tabla de páginas y realiza la traducción de dirección virtual en dirección física</p>
</li>
<li>
<p>El kernel actualiza la tabla de páginas y activa las transferencias</p>
</li>
</ul>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/memvirtual/vm_table_protection.png" alt="MMU">
</div>
<div class="title">Figure 119. Protección</div>
</div>
<div class="ulist">
<ul>
<li>
<p>SUP: SUPervisor: únicamente el kernel tiene acceso</p>
</li>
<li>
<p>Write No: read only.</p>
</li>
</ul>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/memvirtual/formato_direcciones.png" alt="MMU">
</div>
<div class="title">Figure 120. Formato de Direcciones</div>
</div>
</div>
<div class="sect3">
<h4 id="_multilevel_paging">34.4.7. Multilevel paging</h4>
<div class="ulist">
<ul>
<li>
<p>Debido a qué la tabla de páginas puede ser enorme se considera reducir el área de ram que consume la tabla mediante una organización jerárquica de múltiples tablas.</p>
</li>
<li>
<p>La memoria se puede dividir jerárquicamente en agrupamientos de páginas. Superpáginas que agrupan páginas, hiperpáginas que agrupan superpáginas.</p>
</li>
<li>
<p>Ejemplo: Paginación de 3 niveles: Nivel 1 de pedazos de 16 MB, nivel 2 de pedazos de 2MB, nivel 2 de páginas de 4KB.</p>
</li>
<li>
<p>Cada nivel de agrupamiento lleva asociada una tabla de descripción de dicho nivel. La tabla de páginas se convierte en una jerarquía de múltiples tablas.</p>
</li>
<li>
<p>En el proceso de traducción de la MMU la dirección virtual se descompone en múltiples campos. Cada campo será un índice de cada tabla asociada, enlazando tantas páginas como niveles.</p>
</li>
<li>
<p>Si la tabla de nivel i tiene un contenido NULL no existirá las tablas de niveles superiores i+1,i+2,etc de la cadena de enlaces.</p>
</li>
<li>
<p>El  hecho de acceder a múltiples tablas no ralentiza la traducción de direcciones si las tablas están implementadas en la cache interna de la MMU. Sería distinto si dichas páginas estuviesen en la memoria DRAM.</p>
</li>
</ul>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/memvirtual/table_multiple.png" alt="MMU" height="400">
</div>
<div class="title">Figure 121. Tabla de dos niveles</div>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/memvirtual/table_level_k.png" alt="MMU">
</div>
<div class="title">Figure 122. Tabla de K niveles</div>
</div>
</div>
<div class="sect3">
<h4 id="_intel_evolución_memoria_virtual">34.4.8. Intel: Evolución memoria virtual</h4>
<div class="sect4">
<h5 id="_80386_2">80386</h5>
<div class="ulist">
<ul>
<li>
<p>Se utiliza por primera vez la paginación.</p>
</li>
<li>
<p>La traducción de memoria virtual en física conlleva dos fases: primero la segmentación y a continuación la paginación (opcional)</p>
</li>
<li>
<p>Ver mecanismo de segmentación.</p>
</li>
<li>
<p>La segmentación traduce el espacio virtual en un espacio  lineal de 32 bits con campos:dir(10 bits)-pag(10)-offset(12)</p>
</li>
<li>
<p>Se implementa dos niveles de tablas de paǵinas: dir es una tabla de punteros de tablas de páginas (directorio de páginas)</p>
<div class="ulist">
<ul>
<li>
<p>con 10 bits se consiguen 2<sup>10</sup> punteros a tablas &#8594; 1K tablas</p>
</li>
</ul>
</div>
</li>
<li>
<p>pag es el índice de la tabla de páginas</p>
<div class="ulist">
<ul>
<li>
<p>con 10 bits se consiguen 2<sup>10</sup> entradas de tabla &#8594; 1K páginas virtuales asociadas a 1K páginas físicas</p>
<div class="ulist">
<ul>
<li>
<p>La dirección de página física son 32 bits</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Con 12 bits de offset el tamaño de página es 2<sup>12</sup>=4KB</p>
</li>
<li>
<p>1K tablas donde cada tabla contiene 1K páginas son en total 1M de páginas y cada página 4KB da un total de 4GB de direcciones de memoria física.</p>
</li>
<li>
<p>Por lo que de los 64TB de memoria virtual posible podemos traducir en un momento dado a 24GB de memoria segmentada y cada segmento de 4GB lineales a 4GB de memoria física.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_amd64_2">amd64</h5>
<div class="ulist">
<ul>
<li>
<p>amd64 &#8594; 64 bits &#8594; Espacio Virtual teórico = 2<sup>64</sup> = 16 ExaBytes</p>
<div class="ulist">
<ul>
<li>
<p>Paginación y <strong>no segmentación</strong>.</p>
</li>
<li>
<p>Espacio Virtual = 256 TeraBytes ya que la CPU únicamente utiliza 48 bits para el espacio de direcciones virtual <em>porque</em> es suficiente memoria para las aplicaciones actuales, utilizar los 64 bits provocaría tablas de páginas enormes bajando el rendimiento del sistema sin necesidad. No hay ni memoria secundaria para tanta memoria virtual.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_glosario">34.4.9. Glosario</h4>
<div class="ulist">
<ul>
<li>
<p>Espacios: Logic (segmentation) &#8594; Logic Linear (virtual,pagination) &#8594; Physical Linear</p>
</li>
<li>
<p>VP: Virtual Page</p>
</li>
<li>
<p>VA: Virtual Address</p>
</li>
<li>
<p>PP: Physical Page</p>
</li>
<li>
<p>PA: Physical Address</p>
</li>
<li>
<p>VPO:VP offset</p>
</li>
<li>
<p>VPN:VP number</p>
</li>
<li>
<p>TLB: Translation lookaside Buffer: buffer (cache) de anticipación de la tabla de páginas. Residente en la MMU.</p>
</li>
<li>
<p>PTE: Page Table Entry &#8594; (index/contenido)&#8594;(VPN/PPN)</p>
</li>
<li>
<p>PTBR: Registro de control de la CPU: page table base register: pointer to TLB</p>
</li>
<li>
<p>TLBI:TLB index &#8594; campo set de la cache</p>
</li>
<li>
<p>TLBT: TLB tag</p>
</li>
<li>
<p>PPO: PP offset</p>
</li>
<li>
<p>PPN: PP number</p>
</li>
<li>
<p>CO: Cache offset en el superbloque</p>
</li>
<li>
<p>CT: Cache tag</p>
</li>
<li>
<p>CI: Cache index ó línea</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_traducción_dirección_virtual_a_fisica">34.4.10. Traducción: dirección virtual a fisica</h4>
<div class="imageblock text-center">
<div class="content">
<img src="./images/memvirtual/virtualtoframe.png" alt="MMU">
</div>
<div class="title">Figure 123. Traducción Virtual &#8594; Física</div>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/memvirtual/mmu_hit.png" alt="MMU" height="200">
</div>
<div class="title">Figure 124. Resultado con éxito</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>CPU: vuelca la dirección de memoria virtual</p>
</li>
<li>
<p>MMU: apunta a la entrada de la tabla de páginas ubicada en la memoria principal</p>
</li>
<li>
<p>Memoria Principal: devuelve el contenido de la entrada de la tabla. MMU: A partir de la dirección lógica obtiene al dirección física.</p>
</li>
<li>
<p>MMU: vuelca la dirección física en el bus de direcciones del bus del sistema.</p>
</li>
<li>
<p>El dato referenciado puede estar en la memoria caché o en la memoria principal.</p>
</li>
</ol>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/memvirtual/mmu_fault.png" alt="MMU" height="300">
</div>
<div class="title">Figure 125. Resultado con fracaso</div>
</div>
</div>
<div class="sect3">
<h4 id="_translation_lookaside_buffer">34.4.11. Translation Lookaside Buffer</h4>
<div class="ulist">
<ul>
<li>
<p>TLB</p>
</li>
<li>
<p>Es una Caché de la tabla de páginas virtuales TPV. Además de residir la tabla de páginas en la memoria principal se tiene una copia parcial de dicha tabla en una unidad de memoria interna de la MMU. Objetivo: aumentar la velocidad de acceso a la tabla ya que la solución de múltiples tablas en niveles jerárquicos requiere múltiples accesos a la memoria principal externa.</p>
</li>
<li>
<p>Formato de dirección virtual si la TLB es una caché con función de correspondencia asociativa</p>
<div class="ulist">
<ul>
<li>
<p>El índice es el campo set o superbloque típico de la cache</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/memvirtual/tlb_connection.png" alt="MMU">
</div>
<div class="title">Figure 126. Operación con TLB</div>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/memvirtual/tlb_entry.png" alt="MMU" height="100">
</div>
<div class="title">Figure 127. Formato Virtual con TLB</div>
</div>
<div class="ulist">
<ul>
<li>
<p>TLBTag</p>
</li>
<li>
<p>TLBIndex</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejercicio">34.4.12. Ejercicio</h4>
<div class="ulist">
<ul>
<li>
<p>La arquitectura de una computadora dispone de TLB y L1 d-Cache. La memoria es direccionable byte a byte y tiene palabras de 1 byte.</p>
</li>
<li>
<p>La MMU tiene una Tabla TLB (Translation Lookup Buffer)   y una memoria d-Cache según las figuras</p>
<div class="imageblock text-center">
<div class="content">
<img src="./images/memvirtual/tabla_cache_ejercicio.png" alt="MMU">
</div>
<div class="title">Figure 128. TLB y d-cache </div>
</div>
<div class="ulist">
<ul>
<li>
<p>Virtual addresses are 14 bits wide (n = 14).</p>
</li>
<li>
<p>Physical addresses are 12 bits wide (m = 12).</p>
</li>
<li>
<p>The page size is 64 bytes (P = 64).</p>
</li>
<li>
<p>The TLB is four-way set associative with 16 total entries.</p>
</li>
<li>
<p>The L1 d-cache is physically addressed and direct mapped, with a 4-byte line size and 16 total set.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Calcular la dirección física de la DIRECCION VIRTUAL <strong>0x03d4</strong></p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Formato de Direcciones</p>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>Dimensión de VPO</p>
</li>
<li>
<p>Dimensión de PPO</p>
</li>
<li>
<p>Dimensión de VPN</p>
</li>
<li>
<p>Dimensión de PPN</p>
</li>
</ol>
</div>
</li>
<li>
<p>Número de entradas de la tabla de páginas en memoria principal y la caché TLB</p>
</li>
<li>
<p>TLB</p>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>Líneas por set de TLB</p>
</li>
<li>
<p>Sets de TLB</p>
</li>
<li>
<p>Tamaño TLBI</p>
</li>
<li>
<p>Tamaño TLBT</p>
</li>
<li>
<p>Bits por Word</p>
</li>
<li>
<p>Words por línea de TLB</p>
</li>
<li>
<p>Valores TLBI-TLBT</p>
</li>
</ol>
</div>
</li>
<li>
<p>Está PPN en TLB?</p>
</li>
<li>
<p>Valor de PPN</p>
</li>
<li>
<p>Valor de PA</p>
</li>
<li>
<p>d-Cache</p>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>Memory Cache: Tipo</p>
</li>
<li>
<p>Sets</p>
</li>
<li>
<p>Líneas/Set</p>
</li>
<li>
<p>Words/Línea</p>
</li>
<li>
<p>Bytes/Word</p>
</li>
</ol>
</div>
</li>
<li>
<p>Formato Dirección Física</p>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>CO</p>
</li>
<li>
<p>CI</p>
</li>
<li>
<p>CT</p>
</li>
<li>
<p>Valores CT/CI/CO &#8594; PA</p>
</li>
</ol>
</div>
</li>
<li>
<p>Está PA en la caché?</p>
</li>
<li>
<p>Contenido de la PA</p>
</li>
<li>
<p>Resumen del resultado final</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_desarrollo">Desarrollo</h5>
<div class="ulist">
<ul>
<li>
<p>Respuestas</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>El formato de direcciones es</p>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>VO y PO &#8594; tamaño de página : 64 bytes &#8594; 2<sup>6</sup> &#8594; 6 bits de offset tanto virtual como físico</p>
</li>
<li>
<p>bits VPN= VA-VPO=14-6=8 bits &#8594; 2<sup>8</sup> = 256 páginas virtuales</p>
</li>
<li>
<p>bits PPN= PA-PPO=12-6=6 bits &#8594; 2<sup>6</sup> = 64 marcos de página</p>
<div class="imageblock text-center">
<div class="content">
<img src="./images/memvirtual/formato_direcciones.png" alt="MMU">
</div>
<div class="title">Figure 129. Formato de Direcciones</div>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>Valores de VPN y VPO</p>
<div class="ulist">
<ul>
<li>
<p>La dirección virtual VA de 14 bits 0x03D4 se codifica en binario como: 00-0011-1101-0100 &#8594; 00001111-010100 &#8594; VPN-VPO</p>
<div class="ulist">
<ul>
<li>
<p>VPO=PPO=010100=01x4</p>
</li>
<li>
<p>VPN=00001111=0x0F</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Tabla de páginas</p>
<div class="ulist">
<ul>
<li>
<p>256 puntos de entrada. Cada entrada contiene la dirección de uno de los 64 marcos de página. Es decir una tabla de 256 direcciones y palabras de 6 bits más los bits de validación, protección, etc</p>
</li>
<li>
<p>La tabla en MP son 256 entradas, en cambio la TLB en caché tiene 16 entradas &#8594; direccionables con 4 bits.</p>
</li>
</ul>
</div>
</li>
<li>
<p>TLB</p>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>Líneas por set de TLB: 4 vías &#8594; 4 líneas/set</p>
</li>
<li>
<p>Sets de TLB: 16 entradas son 16 líneas en total agrupadas por 4 líneas/set = 4 sets</p>
</li>
<li>
<p>Tamaño TLBI : para 4 set son necesarios 2 bits</p>
</li>
<li>
<p>Tamaño TLBT :</p>
<div class="ulist">
<ul>
<li>
<p>De los 8 bits necesarios para direccionar 256 entradas si 2 son para el índice TLBI, 6 serán para la etiqueta TLBT</p>
</li>
</ul>
</div>
</li>
<li>
<p>Bits por Word: 1 byte por palabra según el enunciado</p>
</li>
<li>
<p>Words por línea de TLB</p>
<div class="ulist">
<ul>
<li>
<p>Si me fijo en el díbujo de la tabla, cada línea contiene únicamente un PPN+tag, es decir, una palabra.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Valores TLBI-TLBT</p>
<div class="ulist">
<ul>
<li>
<p>VPN es una dirección de la tabla de páginas en la memoria RAM. El controlador de caché la descompone en TLBT-TLBI</p>
</li>
<li>
<p>VPN=00001111=000011-11=TLBT-TLBI=0x3-0x3</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>Está PPN en TLB?</p>
<div class="ulist">
<ul>
<li>
<p>busco en el set 0x3 de TLB si alguno de las líneas tiene un tag TLBT de 0x3 y lo tiene la segunda línea.</p>
</li>
<li>
<p>La segunda línea del set 3 tiene el bit de validación a 1 por lo que la página virtual está en la memoria principal y/o d-cache.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Valor de PPN</p>
<div class="ulist">
<ul>
<li>
<p>La segunda línea del set 3 tiene el contenido PPN=0x0D</p>
</li>
</ul>
</div>
</li>
<li>
<p>Valor de PA</p>
<div class="ulist">
<ul>
<li>
<p>Son 12 bits</p>
</li>
<li>
<p>La concatenación PPN(6)-PPO(6): 001101-010100=001101010100=0011-0101-0100= <strong>0x354</strong> =PA</p>
</li>
</ul>
</div>
</li>
<li>
<p>d-Cache</p>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>Memory Cache: Tipo : mapeo directo</p>
<div class="ulist">
<ul>
<li>
<p>Al ser de mapeo directo los set son de 1 línea por lo que es lo mismo decir set que línea.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Sets</p>
<div class="ulist">
<ul>
<li>
<p>16 líneas</p>
</li>
</ul>
</div>
</li>
<li>
<p>Líneas/Set : 1</p>
</li>
<li>
<p>Words/Línea: 4</p>
</li>
<li>
<p>Bytes/Word: 1</p>
</li>
</ol>
</div>
</li>
<li>
<p>Formato dirección física</p>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>CO: para direccionar 4 palabras son necesarios 2 bits</p>
</li>
<li>
<p>CI: para direccionar 16 líneas son necesarios 4 bits</p>
</li>
<li>
<p>CT: la dirección física PA son 12 bits &#8594; CT=PA-DI-CO=12-4-2=6 bits</p>
</li>
<li>
<p>Valores CT/CI/CO &#8594; PA=001101010100=001101-0101-00</p>
<div class="ulist">
<ul>
<li>
<p>Línea 0005; Palabra 00: Tag 001101=0x0D</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>Está PA en la d-Cache?</p>
<div class="ulist">
<ul>
<li>
<p>En la línea 5 el tag es 0D &#8594; coíncide con el tag de la dirección física &#8594; acierto &#8594; el dato está en d-cache</p>
</li>
<li>
<p>El bit de validación es 1 por lo que su contenido está actualizado y por lo tanto válido.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Contenido de la PA:</p>
<div class="ulist">
<ul>
<li>
<p>El contenido de la palabra 0 de la linea 5 de la d-cache es el byte <strong>0x36</strong></p>
</li>
</ul>
</div>
</li>
<li>
<p>Resumen del resultado final.</p>
<div class="ulist">
<ul>
<li>
<p>La dirección virtual <strong>0x03d4</strong> se corresponde con la dirección física <strong>0x354</strong> cuyo contenido es <strong>0x36</strong></p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_intel_core_i7">34.4.13. Intel Core i7</h4>
<div class="imageblock text-center">
<div class="content">
<img src="./images/memvirtual/corei7_virtual_memory.png" alt="MMU">
</div>
<div class="title">Figure 130. Memoria Core i7</div>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/memvirtual/corei7_mmu.png" alt="MMU">
</div>
<div class="title">Figure 131. Operación MMU</div>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/memvirtual/corei7_tlb_entry_123.png" alt="MMU">
</div>
<div class="title">Figure 132. Formato para las tablas de los tres primeros niveles</div>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/memvirtual/corei7_tlb_entry_4.png" alt="MMU">
</div>
<div class="title">Figure 133. Formato de la tabla del 4º nivel </div>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/memvirtual/corei7_address_translation.png" alt="MMU">
</div>
<div class="title">Figure 134. Linux: 4 niveles</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_sistemas_operativos_gestión_de_la_memoria_2">34.5. Sistemas Operativos: Gestión de la Memoria</h3>
<div class="sect3">
<h4 id="_protección">34.5.1. Protección</h4>
<div class="ulist">
<ul>
<li>
<p>Page level protection. HW isolation. Las páginas que gestiona la MMU tiene <em>bits de control</em> que indican los permisos de acción, acceso, etc</p>
</li>
<li>
<p>Segmentation fault o Protection Fault</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_paginación_bajo_demanda">34.5.2. Paginación Bajo Demanda</h4>
<div class="ulist">
<ul>
<li>
<p>Paginación bajo demanda</p>
<div class="ulist">
<ul>
<li>
<p>Las páginas de un proceso se cargan en memoria únicamente cuando son <em>demandadas</em>.No se cargan todas las páginas de un proceso de una tacada.</p>
</li>
<li>
<p>Cuando una página es requerida y no está en la memoria, se genera un <em>page fault</em> por parte de la MMU y el SO se encargará de cargar la página requerida.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Principio de localidad</p>
<div class="ulist">
<ul>
<li>
<p>Un proceso en un momento dado tiene en memoria únicamente las páginas que están utilizándose o con las que tienen probabilidad alta de ser utilizadas.</p>
</li>
<li>
<p>Furthermore, time is saved because unused pages <strong>are not swapped</strong> in and out of memory, ya que ese trozo puede ser requerido con inmediatez.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_reemplazo_2">34.5.3. Reemplazo</h4>
<div class="ulist">
<ul>
<li>
<p>Reemplazar una página</p>
<div class="ulist">
<ul>
<li>
<p>Dilema:¿qué página extraigo de la memoria? Algoritmos de reemplazo  &#8594;  Least Recently Used LRU, First Input Output (FIFO)</p>
</li>
<li>
<p>La política de reemplazo la gestiona el SO.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_vm_tool">34.5.4. VM Tool</h4>
<div class="ulist">
<ul>
<li>
<p>La Memoria Virtual es una herramienta para:</p>
<div class="ulist">
<ul>
<li>
<p>que la M. Principal sea una cache del disco</p>
</li>
<li>
<p>Gestionar la Memoria</p>
<div class="ulist">
<ul>
<li>
<p>Simplifying linking: mezcla con direcciones independientes de la dirección física final</p>
</li>
<li>
<p>Simplifying loading: se carga bajo demanda las páginas requeridas</p>
</li>
<li>
<p>Simplifying sharing: procesos (librerías) que son compartidos.</p>
</li>
<li>
<p>Simplifying memory allocation:En memoria virtual el SO o compilador distribuye los segmentos de forma contigua y luego está la flexibilidad de ubicarlos arbitrariamente en memoria física.</p>
</li>
<li>
<p>Proteger los segmentos: control con los bits sup(supervisor),read,write</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph nav-footer">
<p>← Previous: <a href="_apéndice_unidad_de_memoria_dram.html">Apéndice: Unidad de Memoria DRAM</a> | ↑ Up: <a href="_viii_apéndices.html">VIII Apéndices</a> | ⌂ Home: <a href="eecc_book.html">Estructura de Computadores  (240306)</a> | Next: <a href="_lenguaje_de_programación_c_2.html">Lenguaje de Programación C</a> →</p>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2022-11-03 13:10:16 +0100
</div>
</div>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]],
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },
  TeX: { equationNumbers: { autoNumber: "none" } }
})
MathJax.Hub.Register.StartupHook("AsciiMath Jax Ready", function () {
  MathJax.InputJax.AsciiMath.postfilterHooks.Add(function (data, node) {
    if ((node = data.script.parentNode) && (node = node.parentNode) && node.classList.contains("stemblock")) {
      data.math.root.display = "block"
    }
    return data
  })
})
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
</body>
</html>