<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.17">
<meta name="keywords" content="computer, architecture">
<meta name="author" content="Cándido Aramburu">
<title>Estructura de Computadores  (240306)</title>
<style>
@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";
@import "https://cdn.jsdelivr.net/gh/asciidoctor/asciidoctor@2.0/data/stylesheets/asciidoctor-default.css";



h1, h2, h3, h4, h5, h6, #toctitle,
.sidebarblock > .content > .title {
  color: rgba(221, 72, 20, 0.8);
}



</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<!-- Change some CSS.
<style>
.imageblock{
  &.text-center > .title {
    text-align: center !important;
  }
}
</style>

-->

<style type="text/css"> .imageblock > .title { text-align: center; } </style>

<style>.toc-current{font-weight: bold;} .toc-root{font-family: "Open Sans","DejaVu Sans",sans-serif;
                       font-size: 0.9em;} #content{display: flex; flex-direction: column; flex: 1 1 auto;}
             .nav-footer{text-align: center; margin-top: auto;}
             .nav-footer > p > a {white-space: nowrap;}</style>
</head>
<body id="_llamadas_al_sistema_operativo_2" class="book">
<div id="header">
<h1>Estructura de Computadores  (240306)</h1>
<div class="details">
<span id="author" class="author">Cándido Aramburu</span><br>
<span id="email" class="email"><a href="mailto:candido@unavarra.es">candido@unavarra.es</a></span><br>
<span id="revdate">2022-09-04</span>
</div>
<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<p><span class="toc-root"><a href="eecc_book.html">Estructura de Computadores  (240306)</a></span></p><ul class="sectlevel0">
<li><a href="_i_arquitectura_del_repertorio_de_instrucciones_isa_computadora_von_neumann_datos_instrucciones_programación.html">I Arquitectura del Repertorio de Instrucciones (ISA): computadora von Neumann, datos, instrucciones, programación.</a>
</li>
<li><a href="_ii_unidades_básicas_procesador_central_unidad_de_memoria_mecanismos_entradasalida.html">II Unidades Básicas: Procesador Central, Unidad de Memoria, Mecanismos Entrada/Salida.</a>
</li>
<li><a href="_iii_ejercicios_de_teoría.html">III Ejercicios de Teoría</a>
</li>
<li><a href="_iv_autoevaluación_teoría.html">IV Autoevaluación Teoría</a>
</li>
<li><a href="_v_guiones_de_prácticas_programación_ensamblador_x86.html">V Guiones de Prácticas: Programación Ensamblador x86</a>
</li>
<li><a href="_vi_hojas_de_referencia_rápida.html">VI Hojas de Referencia Rápida</a>
</li>
<li><a href="_vii_autoevaluación_prácticas.html">VII Autoevaluación Prácticas</a>
</li>
<li><a href="_viii_apéndices.html">VIII Apéndices</a>
<ul class="sectlevel1">
<li><a href="_programas_ensamblador_iassim.html">21. Programas ensamblador IASSim</a>
</li>
<li><a href="_simulador_iassim_2.html">22. Simulador IASSim</a>
</li>
<li><a href="_lenguajes_de_programación_para_sum1ton.html">23. Lenguajes de programación para sum1toN</a>
</li>
<li><a href="_rtl_register_transfer_language.html">24. RTL Register Transfer Language</a>
</li>
<li><a href="_formato_de_instrucción_isa_intel_x86_64_2.html">25. Formato de Instrucción: ISA Intel x86-64</a>
</li>
<li><a href="_fpu_x87.html">26. FPU x87</a>
</li>
<li><a href="_pila.html">27. Pila</a>
</li>
<li><a href="_llamadas_al_sistema_operativo_2.html"><span class="toc-current">28. Llamadas al Sistema Operativo</span></a>
<ul class="sectlevel2">
<li><a href="_llamadas_al_sistema_operativo_2.html#llamadas_SO">28.1. Introducción</a>
</li>
<li><a href="_llamadas_al_sistema_operativo_2.html#_manuales_de_las_llamadas">28.2. Manuales de las llamadas</a>
</li>
<li><a href="_llamadas_al_sistema_operativo_2.html#_llamada_indirecta">28.3. Llamada INDIRECTA</a>
</li>
<li><a href="_llamadas_al_sistema_operativo_2.html#_llamada_directa">28.4. LLamada DIRECTA</a>
<ul class="sectlevel3">
<li><a href="_llamadas_al_sistema_operativo_2.html#_argumentos_de_la_llamada_directa">28.4.1. Argumentos de la llamada directa</a>
</li>
<li><a href="_llamadas_al_sistema_operativo_2.html#_códigos_de_la_llamada_directa">28.4.2. Códigos de la llamada directa</a>
</li>
</ul>
</li>
<li><a href="_llamadas_al_sistema_operativo_2.html#_ejemplos_lenguaje_c">28.5. Ejemplos: lenguaje C</a>
</li>
<li><a href="_llamadas_al_sistema_operativo_2.html#_ejemplos_asm_indirecto">28.6. Ejemplos: ASM INDIRECTO</a>
</li>
<li><a href="_llamadas_al_sistema_operativo_2.html#_ejemplos_asm_directo">28.7. Ejemplos: ASM DIRECTO</a>
</li>
<li><a href="_llamadas_al_sistema_operativo_2.html#_línea_de_comandos">28.8. Línea de Comandos</a>
<ul class="sectlevel3">
<li><a href="_llamadas_al_sistema_operativo_2.html#_procedimiento">28.8.1. Procedimiento</a>
</li>
<li><a href="_llamadas_al_sistema_operativo_2.html#_stack_initialization">28.8.2. Stack Initialization</a>
</li>
<li><a href="_llamadas_al_sistema_operativo_2.html#_rutina_principal_con_retorno">28.8.3. Rutina principal con Retorno</a>
</li>
<li><a href="_llamadas_al_sistema_operativo_2.html#_ejercicios_suma_linea_com_s_maximum_linea_com_s">28.8.4. Ejercicios: suma_linea_com.s ,maximum_linea_com.s</a>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="_lenguaje_de_programación_c_2.html">29. Lenguaje de Programación C</a>
</li>
<li><a href="_apéndice_prácticas.html">30. Apéndice Prácticas</a>
</li>
<li><a href="_arquitectura_amd64_4.html">31. Arquitectura amd64</a>
</li>
<li><a href="_exámenes_de_cursos_anteriores.html">32. Exámenes de Cursos Anteriores</a>
</li>
<li><a href="_miaulario_videoconferencia.html">33. Miaulario: Videoconferencia</a>
</li>
</ul>
</li>
<li><a href="_ix_bibliografía.html">IX Bibliografía</a>
</li>
<li><a href="_x_glosario.html">X Glosario</a>
</li>
<li><a href="_xi_colofón.html">XI Colofón</a>
</li>
<li><a href="_index.html">Index</a>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_llamadas_al_sistema_operativo_2">28. Llamadas al Sistema Operativo</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="llamadas_SO">28.1. Introducción</h3>
<div class="ulist">
<ul>
<li>
<p>Se conoce con el nombre de <em>llamadas al sistema</em> a las Llamadas que realizar el programa de usuario a subrutinas del Kernel del Sistema Operativo.</p>
</li>
<li>
<p>Para realizar funciones privilegiadas del sistema operativo como el acceso a los dispositivos i/o de la computadora es necesario que los programas de usuario llamen al kernel para que sea éste quien realice la operación de una manera segura y eficaz. De esta forma se evita que el programador de aplicaciones acceda al hardware y al mismo tiempo se facilita la programación.</p>
</li>
<li>
<p>Ejemplos de llamadas</p>
<div class="ulist">
<ul>
<li>
<p><strong>exit</strong> : el kernel suspende la ejecución del programa eliminando el proceso</p>
</li>
<li>
<p><strong>read</strong> : el kernel lee los datos de un fichero accediendo al disco duro</p>
</li>
<li>
<p><strong>write</strong>: el kernel escribe en un fichero</p>
</li>
<li>
<p><strong>open</strong> : el kernel abre un fichero</p>
</li>
<li>
<p><strong>close</strong>: el kernel cierra el proceso</p>
</li>
<li>
<p>más ejemplos de llamada en el listado <code>man 2 syscalls</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>La llamada a los servicios del kernel denominados <em>syscalls</em> se puede realizar de dos formas: <strong>directa</strong> o <strong>indirecta</strong></p>
<div class="ulist">
<ul>
<li>
<p>Directa: desde ASM mediante la instrucción <code>syscall</code></p>
</li>
<li>
<p>Indirecta: desde C o ASM mediante funciones de la librería <code>libc</code>: wrappers de las llamadas directas</p>
</li>
</ul>
</div>
</li>
<li>
<p>API/ABI</p>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/ditaa/svg/eNqNUUEKwjAQvOcVe2wp_YJQo2AvHorgOS0RgmksSRsJ5PHWanQbrDqXhM0wO5MhYJzpeQsNkxKumnUd15CkkK-AwmlQTS8uisALHt-h3G_KaksPBZpakuULyIifKBSkqDXT7n42T60Ro5fJx7icGcPbWjoQyvR6eNjwaPUM_svT34wQ5bfUO6CPAqJpIBXrEkla-AQbW5xw5lpxGXMRLQkfFooyKaIt1jCvJJLfHW8uzG55" alt="Diagram">
</div>
</div>
</li>
<li>
<p>Ejemplo</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c">* printf() -&gt; write(int fd, const void *buf, size_t count) -&gt; [RAX-RDI-RSI-RDX-R10-R8-R9,syscall] -&gt; kernel syscall write
* API      -&gt;        wrapper function                      -&gt;                ABI                  -&gt;  kernel syscall</code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_manuales_de_las_llamadas">28.2. Manuales de las llamadas</h3>
<div class="ulist">
<ul>
<li>
<p>Los syscall están descritos en los manuales de los wrappers de la librería libc</p>
</li>
<li>
<p>listado de los syscall</p>
<div class="ulist">
<ul>
<li>
<p><code>info syscalls</code> o <code>man syscalls</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>syscalls:</p>
<div class="ulist">
<ul>
<li>
<p>exit  &#8594; <code>man 3 exit</code></p>
</li>
<li>
<p>read  &#8594; <code>man 2 read</code></p>
</li>
<li>
<p>write &#8594; <code>man 2 write</code></p>
</li>
<li>
<p>open  &#8594; <code>man 2 open</code></p>
</li>
<li>
<p>close &#8594; <code>man 2 close</code></p>
</li>
<li>
<p>etc..</p>
</li>
</ul>
</div>
</li>
<li>
<p>Los argumentos de la llamada al sistema son los asociados a la función wrapper de la biblioteca libc.</p>
<div class="ulist">
<ul>
<li>
<p>El 1º argumento de la llamada al sistema es el argumento de la IZDA de la función en libc y el último el de la DCHA.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_llamada_indirecta">28.3. Llamada INDIRECTA</h3>
<div class="ulist">
<ul>
<li>
<p><strong>C</strong>: El programador de aplicaciones en C utiliza las funciones interfaz de la librería <em>libc</em> de GNU para acceder <strong>indirectamente</strong> al kernel a través de los <em>contenedores (wrapper)</em>.</p>
<div class="ulist">
<ul>
<li>
<p>system calls wrapper: adaptación al lenguaje C de las llamadas implementadas en lenguaje ASM</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_llamada_directa">28.4. LLamada DIRECTA</h3>
<div class="ulist">
<ul>
<li>
<p><strong>ASM</strong>: El programador de aplicaciones en lenguaje ASM utiliza las <em>llamadas al sistema</em> para acceder <strong>directamente</strong> al kernel</p>
<div class="ulist">
<ul>
<li>
<p>La llamada se realiza mediante la instrucción ensamblador <code>syscall</code> en x86-64 y <code>int 0x80</code> en x86-32</p>
</li>
<li>
<p>Los argumentos de la llamada se pasan a través de los registros de propósito general GPR</p>
</li>
<li>
<p>El tipo de llamada se especifica a través de un número entero y se pasa a través <strong>RAX</strong></p>
<div class="ulist">
<ul>
<li>
<p>Códigos "System call number" disponibles en el fichero <em>/usr/include/asm/unistd_32.h</em></p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c">## Macros en el fichero macros_x86-64_gas.h

## Llamadas al Sistema
.equ	STDIN_ID,  0		# input-device (keyboard)
.equ	STDOUT_ID, 1		# output-device (screen)
.equ	SYS_READ,  0		# ID-number for 'read'
.equ	SYS_WRITE, 1		# ID-number for 'write'
.equ	SYS_OPEN,  2		# ID-number for 'open'
.equ	SYS_CLOSE, 3		# ID-number for 'close'
.equ	SYS_EXIT,  60		# ID-number for 'exit'</code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_argumentos_de_la_llamada_directa">28.4.1. Argumentos de la llamada directa</h4>
<div class="ulist">
<ul>
<li>
<p>El convenio de la llamada está descrito en la norma ABI</p>
</li>
<li>
<p>x86-64</p>
<div class="ulist">
<ul>
<li>
<p>Los 6 primeros argumentos de la llamada se pasan a través de los registros siguiendo la secuencia: <strong>RDI-RSI-RDX-R10-R8-R9</strong></p>
</li>
<li>
<p>El valor de retorno de la llamada se pasa a través del registro <strong>RAX</strong></p>
</li>
</ul>
</div>
</li>
<li>
<p>x86-32</p>
<div class="ulist">
<ul>
<li>
<p>Los 6 primeros argumentos se pasan a través de de los registros siguiendo la secuencia: <strong>EBX-ECX-EDX-ESI-EDI-EBP</strong></p>
</li>
<li>
<p>El valor de retorno de la llamada se pasa a través del registro <strong>EAX</strong></p>
</li>
</ul>
</div>
</li>
<li>
<p>manual libc: Información sobre cuáles son los argumentos de las llamadas</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_códigos_de_la_llamada_directa">28.4.2. Códigos de la llamada directa</h4>
<div class="ulist">
<ul>
<li>
<p>El código de llamada es un número entero asociado a la función que va a ejecutar el kernel</p>
</li>
<li>
<p>El código de llamada se pasa al kernel a través de <strong>RAX</strong></p>
</li>
<li>
<p>Códigos:</p>
<div class="ulist">
<ul>
<li>
<p><em>/usr/include/asm/unistd_64.h</em>: declaración de macros con el código de la llamada en la arquitectura x86-64</p>
<div class="ulist">
<ul>
<li>
<p>exit &#8594; 60, read &#8594; 0, write &#8594; 1, open &#8594; 2, close &#8594; 3, etc..</p>
</li>
</ul>
</div>
</li>
<li>
<p><em>/usr/include/asm/unistd_32.h</em> : declaración de macros con el código de la llamada en la arquitectura x86-32</p>
</li>
<li>
<p><em>/usr/include/bits/syscall.h</em>  : macros antiguas también válidas en la arquitectura x86-32</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ejemplos_lenguaje_c">28.5. Ejemplos: lenguaje C</h3>
<div class="ulist">
<ul>
<li>
<p><code>exit (status_value)</code> y <code>syscall(exit_code,status_value)</code></p>
<div class="ulist">
<ul>
<li>
<p>exit(0xFF) y syscall(60,0xFF)</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>write (int fd, const void *buf, size_t count)</code> y <code>syscall(write_code,int fd, const void *buf, size_t count)</code></p>
<div class="ulist">
<ul>
<li>
<p>write (0,buffer,80) y syscall(1,1,buffer,80)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_ejemplos_asm_indirecto">28.6. Ejemplos: ASM INDIRECTO</h3>
<div class="ulist">
<ul>
<li>
<p>Programando en lenguaje ASM podemos llamar a los wrappers de la librería libc.</p>
</li>
<li>
<p><code>exit(status_value)</code></p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c">mov $status_value,%rdi
call exit</code></pre>
</div>
</div>
</li>
<li>
<p><code>syscall(exit_code,status_value)</code></p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c">mov $60,%rax
mov $status_value,%rdi
call syscall</code></pre>
</div>
</div>
</li>
<li>
<p><code>write(int fd, const void *buf, size_t count)</code></p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c">mov fd,%rdi			#fd es la refencia al fichero donde se va a escribir
mov $buffer_address_label, %rsi #dirección de memoria de lo que se va a escribir en el fichero
mov size,%rdx			#tamaño del buffer de memoria que se va a escribir
call write			#orden de escritura al kernel a través de la librería libc</code></pre>
</div>
</div>
</li>
<li>
<p><code>syscall(write_code,int fd, const void *buf, size_t count)</code></p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c">mov $1,%rax
mov $1,%rdi			# 1 es el código del fichero pantalla. En unix los dispositivos son ficheros.
mov $buffer_address_label,%rsi
mov size,%rdx
call syscall</code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_ejemplos_asm_directo">28.7. Ejemplos: ASM DIRECTO</h3>
<div class="ulist">
<ul>
<li>
<p>exit</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c">mov $60,%rax
mov $status_value,%rdi
syscall</code></pre>
</div>
</div>
</li>
<li>
<p>write</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c">mov $1,%rax
mov $1,%rdi			# 1 es el código del fichero pantalla. En unix los dispositivos son ficheros.
mov $buffer_address_label,%rsi
mov size,%rdx
syscall</code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_línea_de_comandos">28.8. Línea de Comandos</h3>
<div class="sect3">
<h4 id="_procedimiento">28.8.1. Procedimiento</h4>
<div class="ulist">
<ul>
<li>
<p>Process Initialization</p>
<div class="ulist">
<ul>
<li>
<p>Cuando escribimos un comando o programa  en la línea de comandos del shell el sistema operativo los interpreta como una secuencia de strings. Por ejemplo <code>$suma 2 3</code> son tres argumentos en la línea de comandos:</p>
<div class="ulist">
<ul>
<li>
<p>La codificación de un string es la secuencia de sus caracteres en código ASCII y finalizada con el caracter NULL cuyo código es 0x00</p>
</li>
<li>
<p>el string "suma": 5 caracteres ASCII: 0x73,0x75,0x6d,0x61,0x00</p>
</li>
<li>
<p>el string "2"   : 2 caracteres ASCII: 0x32,0x00</p>
</li>
<li>
<p>el string "3"   : 2 caracteres ASCII: 0x33,0x00</p>
</li>
<li>
<p>Como son 3 los argumentos de la línea el parametro argument counter <strong>argc</strong> valdrá 3.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Los tres strings de la línea de comandos, "suma"-"2"-"3", son asignados a la variable array de strings <em>argv</em></p>
<div class="ulist">
<ul>
<li>
<p>argv[0] apunta al string "suma"</p>
</li>
<li>
<p>argv[1] apunta al string "2"</p>
</li>
<li>
<p>argv[2] apunta al string "3"</p>
</li>
<li>
<p>argv[argc] apunta al caracter NULL</p>
</li>
<li>
<p>argv es una array de punteros, por lo tanto, es del tipo (char **)argv</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>kernel</p>
<div class="ulist">
<ul>
<li>
<p>El kernel declara el prototipo <code>extern int main (int argc , char* argv[] , char* envp[]) ;</code></p>
</li>
<li>
<p>declaración y definición del módulo principal <code>main</code></p>
<div class="ulist">
<ul>
<li>
<p>La función <code>main</code> es declarada como global por el kernel y es definida por el usuario.</p>
</li>
</ul>
</div>
</li>
<li>
<p><em>argc</em> is a non-negative argument count;</p>
</li>
<li>
<p><em>argv</em> is an array of argument strings, with argv[argc]==0;</p>
</li>
<li>
<p><em>envp</em> is an array of environment strings, also terminated by a null pointer.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

/*
 * Introducimos en la línea de comandos el programa y un argumento
 * Si el argumento tiene espacios en blanco, entrecomillarlo con comillas simples:'Hola Mundo'
 * gcc -g -o linea_comandos linea_comandos.c
 * ./programa 'Hola Mundo'
 */

int  main (int parc, char *parv[])
{
  if (parc==1){
    printf("Introducimos en la línea de comandos cualquier mensaje\n\n");
    exit (EXIT_FAILURE);
  }
  printf("%s\n",parv[1]);
  return EXIT_SUCCESS;
}</code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_stack_initialization">28.8.2. Stack Initialization</h4>
<div class="ulist">
<ul>
<li>
<p>Cuando comienza a ejecutarse al función <em>main()</em> o la instrucción <em>_start</em> el estado de la pila es el siguiente:</p>
</li>
<li>
<p>Stack Initialization</p>
<div class="ulist">
<ul>
<li>
<p>El kernel pasa los argumentos <strong>argc</strong> y <strong>argv</strong> de la función global main a través de la PILA. La función main es la función llamada.</p>
<table class="tableblock frame-all grid-all" style="width: 50%;">
<caption class="title">Table 22. Convenio ABI: Stack</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Stack Reference</th>
<th class="tableblock halign-center valign-top">Interpretation</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">arguments strings</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1 word cada variable</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Environment pointers</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">8+8*argc(%rsp)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">8*argc(%rsp)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">- pointer to argcº string</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">- - - - - - - -</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">- - - - - - - - - - -</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">16(%rsp)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">- pointer to 2º argument string &#8594; argv[1]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">8(%rsp)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">- pointer to 1º argument string &#8594; string argv[0]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0(%rsp)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">- argument count &#8594; argc</p></td>
</tr>
</tbody>
</table>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_rutina_principal_con_retorno">28.8.3. Rutina principal con Retorno</h4>
<div class="ulist">
<ul>
<li>
<p>Si la rutina principal no termina con la llamada <strong>exit</strong> y termina con la instrucción <strong>ret</strong> el convenio de llamada es el de llamada a función por lo que los parámetros <em>argc</em> y <em>argv</em> se pasan a través de los registros <strong>RDI-RSI-RDX-RCX-R8-R9</strong></p>
</li>
<li>
<p>Ejemplo: <em>imprimir_arg.s</em></p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c">### gcc imprimir_arg.s
### ./a.out 'Hola Mundo'
###
###

        .equ STDOUT,1
        .equ SYSWRITE,1
        .equ EXIT_SUCCESS,0XFF
        .equ ARGV1,8


mensaje:
        .ascii "Introducir un mensaje como argumento del programa. Si el mensaje tiene espacios blancos, poner el mensaje entre comillas simples ''\n"
        .equ LON,. - mensaje    #longitud del mensaje

        .section .text
        .global main
main:
        push %rsi               #salvo el argumento argv
        ## comprobar que la ĺínea de comandos tiene dos argumentos
        cmp $2,%rdi
        je imp_arg
        ## si solo tengo el programa sin argumentos :imprimir en la pantalla
        mov $SYSWRITE,%rax
        mov $STDOUT,%rdi        #fd es la refencia al fichero donde se va a escribir
        mov $mensaje, %rsi               #dirección de memoria de lo que se va a escribir en el fichero
        mov $LON,%rdx                   #tamaño del buffer de memoria que se va a escribir
        syscall                  #orden de escritura al kernel
        jmp salida
imp_arg:
        pop  %rsi           #el stack pointer apunta al %rsi salvado y lo recupero -&gt; argv -&gt; argv[0]
        add $ARGV1, %rsi    #rsi apunta al primer puntero, si le sumo 8 apunto al segundo puntero
        mov (%rsi), %rdi    #mediante la indirección tengo el segundo puntero
        call puts

salida:
        ret

        .end</code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejercicios_suma_linea_com_s_maximum_linea_com_s">28.8.4. Ejercicios: suma_linea_com.s ,maximum_linea_com.s</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>suma_linea_com.s</p>
<div class="ulist">
<ul>
<li>
<p>Introducir los datos del programa <em>suma_linea_com.s</em> (suma de dos sumandos) a través de la línea de comandos</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c">### función: sumar dos números enteros de un dígito.
###          los sumandos se pasan a través de la línea de comandos
        ## Compilación en la arquitectura x86-64
        ## gcc  -nostartfiles -g -o sum_input sum_imput.s
        ## run 5 7
        ##  x /x  %rsp              -&gt;3                 argc:número de argumentos
        ##  x /a  (char**)($rsp+8)  -&gt; 0xffffd0a4:	0xffffd26e
        ##  x /c  *(char**)($rsp+8) -&gt; 0xffffd26e:	47 '/'
        ##  x /s  *(char**)($rsp+8) -&gt; 0xffffd26e:	 "/home/candido/tutoriales/as_tutorial/algoritmos_x86-32/basicos/sum_input"
        ##  p /s *(char**)($rsp+8)  -&gt; 0xffffd26e "/home/candido/tutoriales/as_tutorial/algoritmos_x86-32/basicos/sum_input"
        ##  x /s  *(char**)($rsp+16) -&gt; 0xffffd2b7:	 "5"
        ##  x /s  *(char**)($rsp+24) -&gt; 0xffffd2b9:	 "7"

        .section .text
.globl _start
_start:

        ## instrucciones aclaratorias

	lea 8(%rsp),%rax       #eax contiene argv[1] la dirección de la pila que contiene el pointer al argumento string
        mov 8(%rsp),%rbx       #ebx tiene el contendio de la pila= dirección del string
        xor %rcx,%rcx
        movb (%rbx),%cl        #caracter ASCII

        ## string argument pointers
        mov 16(%rsp),%rax       #eax tiene el contendio de la pila= dirección del string. argv[2]
        mov 24(%rsp),%rbx       #eax tiene el contendio de la pila= dirección del string. argv[3]
        ## fetch string indirect
        ## convert ascii numbers to values
        xor %rcx,%rcx
        xor %rdx,%rdx
        movb (%rax),%cl         # indirección para acceder al string referenciado por argv[1]
        movb (%rbx),%dl         # indirección para acceder al string referenciado por argv[1]
        sub $0x30,%rcx
        sub $0x30,%rdx

        mov %rcx,%rsi
        mov %rdx,%rdi

        call suma

	## salida
        mov %rax,%rdi
	mov  $60, %rax	    #1 is the exit() syscall
	syscall


### Función que calcula la suma entre dos valores
	.type suma, @function
	.section .text
suma:
	## prologo
	push %rbp
	mov %rsp,%rbp
	sub $8,%rsp            #reserva de memoria

	## captura de argumentos
	mov %rdi,%rax      #1º argumento
	mov %rsi,%rcx     #2º argumento
	## cuerpo
	addl %ecx,%eax          #
	## guardar resultado
	## el resultado está en EAX
salto:
	## epilogo

	mov %rbp,%rsp           # frame anterior
	pop %rbp
	ret                     # recuperar dirección de retorno</code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>maximum_linea_com.s</p>
<div class="ulist">
<ul>
<li>
<p>Introducir los datos del programa <em>maximum_linea_com.s</em> a través de la línea de comandos</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph nav-footer">
<p>← Previous: <a href="_pila.html">Pila</a> | ↑ Up: <a href="_viii_apéndices.html">VIII Apéndices</a> | ⌂ Home: <a href="eecc_book.html">Estructura de Computadores  (240306)</a> | Next: <a href="_lenguaje_de_programación_c_2.html">Lenguaje de Programación C</a> →</p>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2022-09-04 21:51:14 +0200
</div>
</div>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]],
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },
  TeX: { equationNumbers: { autoNumber: "none" } }
})
MathJax.Hub.Register.StartupHook("AsciiMath Jax Ready", function () {
  MathJax.InputJax.AsciiMath.postfilterHooks.Add(function (data, node) {
    if ((node = data.script.parentNode) && (node = node.parentNode) && node.classList.contains("stemblock")) {
      data.math.root.display = "block"
    }
    return data
  })
})
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
</body>
</html>