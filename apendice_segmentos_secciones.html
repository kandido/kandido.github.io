<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.17">
<meta name="keywords" content="computer, architecture">
<meta name="author" content="Cándido Aramburu">
<title>Apéndice: Memoria Virtual</title>
<style>
@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";
@import "https://cdn.jsdelivr.net/gh/asciidoctor/asciidoctor@2.0/data/stylesheets/asciidoctor-default.css";



h1, h2, h3, h4, h5, h6, #toctitle,
.sidebarblock > .content > .title {
  color: rgba(221, 72, 20, 0.8);
}



</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
pre.rouge table td { padding: 5px; }
pre.rouge table pre { margin: 0; }
pre.rouge .cm {
  color: #999988;
  font-style: italic;
}
pre.rouge .cp {
  color: #999999;
  font-weight: bold;
}
pre.rouge .c1 {
  color: #999988;
  font-style: italic;
}
pre.rouge .cs {
  color: #999999;
  font-weight: bold;
  font-style: italic;
}
pre.rouge .c, pre.rouge .ch, pre.rouge .cd, pre.rouge .cpf {
  color: #999988;
  font-style: italic;
}
pre.rouge .err {
  color: #a61717;
  background-color: #e3d2d2;
}
pre.rouge .gd {
  color: #000000;
  background-color: #ffdddd;
}
pre.rouge .ge {
  color: #000000;
  font-style: italic;
}
pre.rouge .gr {
  color: #aa0000;
}
pre.rouge .gh {
  color: #999999;
}
pre.rouge .gi {
  color: #000000;
  background-color: #ddffdd;
}
pre.rouge .go {
  color: #888888;
}
pre.rouge .gp {
  color: #555555;
}
pre.rouge .gs {
  font-weight: bold;
}
pre.rouge .gu {
  color: #aaaaaa;
}
pre.rouge .gt {
  color: #aa0000;
}
pre.rouge .kc {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kd {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kn {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kp {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kr {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kt {
  color: #445588;
  font-weight: bold;
}
pre.rouge .k, pre.rouge .kv {
  color: #000000;
  font-weight: bold;
}
pre.rouge .mf {
  color: #009999;
}
pre.rouge .mh {
  color: #009999;
}
pre.rouge .il {
  color: #009999;
}
pre.rouge .mi {
  color: #009999;
}
pre.rouge .mo {
  color: #009999;
}
pre.rouge .m, pre.rouge .mb, pre.rouge .mx {
  color: #009999;
}
pre.rouge .sa {
  color: #000000;
  font-weight: bold;
}
pre.rouge .sb {
  color: #d14;
}
pre.rouge .sc {
  color: #d14;
}
pre.rouge .sd {
  color: #d14;
}
pre.rouge .s2 {
  color: #d14;
}
pre.rouge .se {
  color: #d14;
}
pre.rouge .sh {
  color: #d14;
}
pre.rouge .si {
  color: #d14;
}
pre.rouge .sx {
  color: #d14;
}
pre.rouge .sr {
  color: #009926;
}
pre.rouge .s1 {
  color: #d14;
}
pre.rouge .ss {
  color: #990073;
}
pre.rouge .s, pre.rouge .dl {
  color: #d14;
}
pre.rouge .na {
  color: #008080;
}
pre.rouge .bp {
  color: #999999;
}
pre.rouge .nb {
  color: #0086B3;
}
pre.rouge .nc {
  color: #445588;
  font-weight: bold;
}
pre.rouge .no {
  color: #008080;
}
pre.rouge .nd {
  color: #3c5d5d;
  font-weight: bold;
}
pre.rouge .ni {
  color: #800080;
}
pre.rouge .ne {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nf, pre.rouge .fm {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nl {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nn {
  color: #555555;
}
pre.rouge .nt {
  color: #000080;
}
pre.rouge .vc {
  color: #008080;
}
pre.rouge .vg {
  color: #008080;
}
pre.rouge .vi {
  color: #008080;
}
pre.rouge .nv, pre.rouge .vm {
  color: #008080;
}
pre.rouge .ow {
  color: #000000;
  font-weight: bold;
}
pre.rouge .o {
  color: #000000;
  font-weight: bold;
}
pre.rouge .w {
  color: #bbbbbb;
}
pre.rouge {
  background-color: #f8f8f8;
}
</style>
<!-- Change some CSS.
<style>
.imageblock{
  &.text-center > .title {
    text-align: center !important;
  }
}
</style>

-->

<style type="text/css"> .imageblock > .title { text-align: center; } </style>

<style>.toc-current{font-weight: bold;} .toc-root{font-family: "Open Sans","DejaVu Sans",sans-serif;
                       font-size: 0.9em;} #content{display: flex; flex-direction: column; flex: 1 1 auto;}
             .nav-footer{text-align: center; margin-top: auto;}
             .nav-footer > p > a {white-space: nowrap;}</style>
</head>
<body id="apendice_segmentos_secciones" class="book">
<div id="header">
<h1>Apéndice: Memoria Virtual</h1>
<div class="details">
<span id="author" class="author">Cándido Aramburu</span><br>
<span id="email" class="email"><a href="mailto:candido@unavarra.es">candido@unavarra.es</a></span><br>
<span id="revdate">2023-10-23</span>
</div>
<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<p><span class="toc-root"><a href="eecc_book.html">Apéndice: Memoria Virtual</a></span></p><ul class="sectlevel0">
<li><a href="_i_arquitectura_del_repertorio_de_instrucciones_isa_computadora_von_neumann_datos_instrucciones_programación.html">I Arquitectura del Repertorio de Instrucciones (ISA): computadora von Neumann, datos, instrucciones, programación.</a>
</li>
<li><a href="_ii_unidades_básicas_procesador_central_unidad_de_memoria_mecanismos_entradasalida.html">II Unidades Básicas: Procesador Central, Unidad de Memoria, Mecanismos Entrada/Salida.</a>
</li>
<li><a href="_iii_ejercicios_de_teoría.html">III Ejercicios de Teoría</a>
</li>
<li><a href="_iv_autoevaluación_teoría.html">IV Autoevaluación Teoría</a>
</li>
<li><a href="_v_guiones_de_prácticas_programación_ensamblador_x86.html">V Guiones de Prácticas: Programación Ensamblador x86</a>
</li>
<li><a href="_vi_hojas_de_referencia_rápida.html">VI Hojas de Referencia Rápida</a>
</li>
<li><a href="_vii_autoevaluación_prácticas.html">VII Autoevaluación Prácticas</a>
</li>
<li><a href="_viii_apéndices.html">VIII Apéndices</a>
</li>
<li><a href="_apéndice_unidad_de_memoria_dram.html">Apéndice: Unidad de Memoria DRAM</a>
</li>
<li><a href="_apéndice_memoria_virtual.html">Apéndice: Memoria Virtual</a>
<ul class="sectlevel1">
<li><a href="apendice_memvirtual.html">40. Bibliografia</a>
</li>
<li><a href="_sistemas_operativos_gestión_de_la_memoria.html">41. Sistemas Operativos: Gestión de la Memoria</a>
</li>
<li><a href="apendice_segmentos_secciones.html"><span class="toc-current">42. Memoria Virtual Segmentada</span></a>
<ul class="sectlevel2">
<li><a href="apendice_segmentos_secciones.html#_interpretación_de_la_segmentación">42.1. Interpretación de la segmentación</a>
</li>
<li><a href="apendice_segmentos_secciones.html#_secciones">42.2. Secciones</a>
</li>
<li><a href="apendice_segmentos_secciones.html#_enlace_de_secciones">42.3. Enlace de Secciones</a>
</li>
<li><a href="apendice_segmentos_secciones.html#_segmentos_lógicos">42.4. Segmentos lógicos</a>
</li>
<li><a href="apendice_segmentos_secciones.html#_evolución_memoria_intel_8086_80286">42.5. Evolución memoria Intel 8086-80286</a>
<ul class="sectlevel3">
<li><a href="apendice_segmentos_secciones.html#_8086">42.5.1. 8086</a>
</li>
<li><a href="apendice_segmentos_secciones.html#_80286">42.5.2. 80286</a>
</li>
<li><a href="apendice_segmentos_secciones.html#_80386">42.5.3. 80386</a>
</li>
<li><a href="apendice_segmentos_secciones.html#_amd64">42.5.4. amd64</a>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="_memoria_virtual_paginada.html">43. Memoria Virtual Paginada</a>
</li>
<li><a href="_sistemas_operativos_gestión_de_la_memoria_2.html">44. Sistemas Operativos: Gestión de la Memoria</a>
</li>
</ul>
</li>
<li><a href="_lenguaje_de_programación_c_2.html">Lenguaje de Programación C</a>
</li>
<li><a href="_fpu_x87.html">FPU x87</a>
</li>
<li><a href="_estructura_de_computadores_2022_primer_parcial_teoría.html">Estructura de Computadores 2022: Primer Parcial Teoría</a>
</li>
<li><a href="_estructura_de_computadores_2022_primer_parcial_prácticas.html">Estructura de Computadores 2022: Primer Parcial Prácticas</a>
</li>
<li><a href="_estructura_de_computadores_2022_segundo_parcial_prácticas.html">Estructura de Computadores 2022: Segundo Parcial Prácticas</a>
</li>
<li><a href="_nominación_de_los_ficheros_del_examen.html">Nominación de los ficheros del examen</a>
</li>
<li><a href="_exámenes_de_cursos_anteriores.html">Exámenes de Cursos Anteriores</a>
</li>
<li><a href="_miaulario_videoconferencia.html">Miaulario: Videoconferencia</a>
</li>
<li><a href="_ix_bibliografía.html">IX Bibliografía</a>
</li>
<li><a href="_x_glosario.html">X Glosario</a>
</li>
<li><a href="_xi_colofón.html">XI Colofón</a>
</li>
<li><a href="_index.html">Index</a>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="apendice_segmentos_secciones">42. Memoria Virtual Segmentada</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_interpretación_de_la_segmentación">42.1. Interpretación de la segmentación</h3>
<div class="ulist">
<ul>
<li>
<p>La segmentación se puede aplicar tanto al espacio de direcciones físico como al espacio de direcciones virtual.</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Segmentación del espacio de direcciones virtual</p>
<div class="ulist">
<ul>
<li>
<p>División de un programa (proceso) en unidades lógicas: código,variables inicializados, variables sin inicializar, datos read only, etc. División de la memoria virtual de un proceso en áreas de <strong>memoria contigua</strong> y cuyo tamaño puede variar dinámicamente. Los segmentos lógicos no se pueden dividir.</p>
</li>
<li>
<p>Facilita el trabajo del compilador,linker,sharing, etc</p>
</li>
<li>
<p>El espacio total de la memoria virtual formado por todos los procesos estaría formado por la dirección base  segmento y el desplazamiento (offset) del registro contador de programa.</p>
</li>
<li>
<p>Se ha utilizado memoria virtual segmentada en las CPU: 80286,80386,80486 y Pentium</p>
</li>
</ul>
</div>
</li>
<li>
<p>Segmentación del espacio de direcciones físico.</p>
<div class="ulist">
<ul>
<li>
<p>Se utilizó en la arquitectura intel 8086 para pasar de un bus de direcciones de 16 bits a 20 bits manteniendo el tamaño de los registros con 16 bits.</p>
</li>
<li>
<p>Incrementar el espacio de direcciones físicas añadiendo un registro de segmento y sin incrementar el tamaño del registro contador de programa. Por ejemplo un microprocesador Intel de 16 bits sin segmentación tiene límitado el espacio físico a 2<sup>16</sup> = 64KB. Con el mismo micro y un registro adicional de segmento RS de 16 bits podemos concatenar el registro RS con el contador de programa PC formando direcciones físicas de 32 bits con lo que tendríamos un espacio de direcciones físicas de 2<sup>32</sup> = 4GB</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_secciones">42.2. Secciones</h3>
<div class="ulist">
<ul>
<li>
<p>cada módulo objeto reubicable está estructurado en secciones</p>
</li>
<li>
<p>una sección es una división lógica, no física.</p>
</li>
<li>
<p>la estructura en secciones se define en el módulo fuente</p>
</li>
<li>
<p>Secciones principales</p>
<div class="ulist">
<ul>
<li>
<p>text : instrucciones</p>
</li>
<li>
<p>data : variables inicializadas</p>
</li>
<li>
<p>rodata: variables readonly</p>
</li>
<li>
<p>bss:    variables sin inicializar</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>readelf -S maximum</code></p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sh">There are 16 section headers, starting at offset 0x448:

Section Headers:
  <span class="o">[</span>Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  <span class="o">[</span> 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  <span class="o">[</span> 1] .interp           PROGBITS         0000000000400158  00000158
       000000000000001c  0000000000000000   A       0     0     1
  <span class="o">[</span> 2] .hash             HASH             0000000000400178  00000178
       000000000000000c  0000000000000004   A       3     0     8
  <span class="o">[</span> 3] .dynsym           DYNSYM           0000000000400188  00000188
       0000000000000000  0000000000000018   A       4     1     8
  <span class="o">[</span> 4] .dynstr           STRTAB           0000000000400188  00000188
       000000000000000b  0000000000000000   A       0     0     1
  <span class="o">[</span> 5] .text             PROGBITS         0000000000400193  00000193
       0000000000000037  0000000000000000  AX       0     0     1
  <span class="o">[</span> 6] .eh_frame         PROGBITS         00000000004001d0  000001d0
       0000000000000000  0000000000000000   A       0     0     8
  <span class="o">[</span> 7] .dynamic          DYNAMIC          00000000006001d0  000001d0
       00000000000000d0  0000000000000010  WA       4     0     8
  <span class="o">[</span> 8] .data             PROGBITS         00000000006002a0  000002a0
       000000000000000e  0000000000000000  WA       0     0     1
  <span class="o">[</span> 9] .debug_aranges    PROGBITS         0000000000000000  000002b0
       0000000000000030  0000000000000000           0     0     16
  <span class="o">[</span>10] .debug_info       PROGBITS         0000000000000000  000002e0
       0000000000000078  0000000000000000           0     0     1
  <span class="o">[</span>11] .debug_abbrev     PROGBITS         0000000000000000  00000358
       0000000000000014  0000000000000000           0     0     1
  <span class="o">[</span>12] .debug_line       PROGBITS         0000000000000000  0000036c
       000000000000004a  0000000000000000           0     0     1
  <span class="o">[</span>13] .shstrtab         STRTAB           0000000000000000  000003b6
       000000000000008d  0000000000000000           0     0     1
  <span class="o">[</span>14] .symtab           SYMTAB           0000000000000000  00000848
       0000000000000240  0000000000000018          15    20     8
  <span class="o">[</span>15] .strtab           STRTAB           0000000000000000  00000a88
       000000000000006f  0000000000000000           0     0     1
Key to Flags:
  W <span class="o">(</span>write<span class="o">)</span>, A <span class="o">(</span>alloc<span class="o">)</span>, X <span class="o">(</span>execute<span class="o">)</span>, M <span class="o">(</span>merge<span class="o">)</span>, S <span class="o">(</span>strings<span class="o">)</span>, l <span class="o">(</span>large<span class="o">)</span>
  I <span class="o">(</span>info<span class="o">)</span>, L <span class="o">(</span><span class="nb">link </span>order<span class="o">)</span>, G <span class="o">(</span>group<span class="o">)</span>, T <span class="o">(</span>TLS<span class="o">)</span>, E <span class="o">(</span>exclude<span class="o">)</span>, x <span class="o">(</span>unknown<span class="o">)</span>
  O <span class="o">(</span>extra OS processing required<span class="o">)</span> o <span class="o">(</span>OS specific<span class="o">)</span>, p <span class="o">(</span>processor specific<span class="o">)</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_enlace_de_secciones">42.3. Enlace de Secciones</h3>
<div class="ulist">
<ul>
<li>
<p>el linker mezcla de forma organizada cada tipo de sección de todos los módulos objeto reubicables generando un único módulo objeto ejecutable</p>
</li>
<li>
<p>Ejemplo de tres módulos objeto reubicables:</p>
<div class="ulist">
<ul>
<li>
<p>los tres módulos fuente p1.c, p2.c, p3.c  se compilan dando lugar a p1.o, p2.o y p3.o los cuales se enlazan dando lugar al ejecutable <em>p</em></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/memvirtual/linksections.png" alt="enlace de secciones">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_segmentos_lógicos">42.4. Segmentos lógicos</h3>
<div class="ulist">
<ul>
<li>
<p>El módulo ejecutable está estructurado en segmentos</p>
<div class="ulist">
<ul>
<li>
<p>text</p>
<div class="ulist">
<ul>
<li>
<p>código de las instrucciones a ejecutar</p>
</li>
</ul>
</div>
</li>
<li>
<p>data</p>
<div class="ulist">
<ul>
<li>
<p>código de datos: variables inicializadas, sin inicializar</p>
</li>
</ul>
</div>
</li>
<li>
<p>stack</p>
<div class="ulist">
<ul>
<li>
<p>pila</p>
</li>
</ul>
</div>
</li>
<li>
<p>heap</p>
<div class="ulist">
<ul>
<li>
<p>montículo</p>
</li>
<li>
<p>es la asignación de memoria en tiempo de ejecución</p>
</li>
<li>
<p>en C la función <code>malloc()</code>: memory allocation: <code>void *malloc(size_t size)</code></p>
<div class="ulist">
<ul>
<li>
<p>size: tamaño en bytes de la memoria a asignar</p>
</li>
<li>
<p>devuelve un puntero a la región de memoria asignada</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>mapa de memoria del programa en ejecución</p>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/ditaa/svg/eNoLyywqKU3MUXBMSSlKLS7mVFDQRQCXIEdfXRTAZVDhhga0dfEAbS4FDFCjgAfUUEeDHhCQpCHZ0tISvwaDCgsDOKhRcKnMS8zNTFYITk3PTc0rKVZQ0PBITSzQxGEDMaFkUGGOCNYaheCSxORskDjUCpqEEika6BHTJDoJGA-JJYlIgVQ8dPxgUGECTUshqRUlg8APBhWI5A3OD6F5uYkFBakpNEgaNigqwvOLUpC4dgDbjMhx" alt="Diagram">
</div>
</div>
</li>
</ul>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/memvirtual/linux_vm_map.png" alt="MMU">
</div>
<div class="title">Figure 114. linux_vm_map</div>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/memvirtual/linux_vm_map_2.png" alt="MMU">
</div>
<div class="title">Figure 115. linux_vm_map_2</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Cada proceso tiene su propia memoria virtual independiente del resto de los procesos</p>
</li>
<li>
<p>Los segmentos pueden cambiar de tamaño dinámicamente en tiempo de ejecución.</p>
<div class="ulist">
<ul>
<li>
<p>Carga del módulo objeto ejecutable</p>
</li>
</ul>
</div>
</li>
<li>
<p>El loader no carga el módulo ejecutable en DRAM, sino que mapea el fichero a memoria virtual, creando la tabla de páginas.</p>
</li>
<li>
<p>La carga efectiva se realiza bajo demanda.</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/memvirtual/load_segments.png" alt="load segments">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_evolución_memoria_intel_8086_80286">42.5. Evolución memoria Intel 8086-80286</h3>
<div class="sect3">
<h4 id="_8086">42.5.1. 8086</h4>
<div class="ulist">
<ul>
<li>
<p>80x86 &#8594; (bits bus direcciones, bits bus datos)</p>
</li>
<li>
<p>8086  &#8594; (20,16) &#8594; 2<sup>20</sup>=1MB de memoria física&#8594; Modo Real</p>
<div class="ulist">
<ul>
<li>
<p>Segmentación</p>
<div class="ulist">
<ul>
<li>
<p>La dirección lógica esta formada por un tuple de dos valores: dirección base y offset.</p>
</li>
<li>
<p>Conversión de dirección lógica a dirección física:</p>
<div class="ulist">
<ul>
<li>
<p>Con un contador de programa de 16 bits se pueden direccionar 64KB. Si añadimos un registro segmento adicional de 16 bits cuyo contenido lo desplazamos 4 bits a la izda (equivale a <strong>multiplicar por 2<sup>4</sup></strong>) tendríamos una dirección base de 20 bits a la cual añadiríamos el offset del PC de 16 bits obteniendo una dirección  física de 20 bits- &gt; espacio físico de 1MB.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Este modo de memoria se denominó <em>modo real</em>: espacio de direcciones memoria segmentada de 20 bits.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_80286">42.5.2. 80286</h4>
<div class="ulist">
<ul>
<li>
<p>80286 &#8594; (24,16) &#8594; 2<sup>24</sup>=16MB de memoria física&#8594; Modos Real y protegido.</p>
<div class="ulist">
<ul>
<li>
<p>Concepto de memoria Virtual: memoria generada por el compilador y por los procesos al ejecutarse</p>
<div class="ulist">
<ul>
<li>
<p>En este caso son 4 bytes de memoria virtual &#8594; los 2 bytes más altos son el selector de segmento y los dos bytes más bajos el offset.</p>
</li>
<li>
<p>Capacidad de memoria virtual &#8594; 2<sup>32</sup> = 4GB</p>
</li>
</ul>
</div>
</li>
<li>
<p>La memoria virtual de los procesos se parte en segmentos.</p>
</li>
<li>
<p>Segmentación</p>
<div class="ulist">
<ul>
<li>
<p>Forming different segments for data, code, and stack, and preventing their overlapping</p>
</li>
<li>
<p>Cada segmento únicamente puede direccionar 64KB ya que el Contador de Programa es de 16 bits</p>
</li>
<li>
<p>La conversión memoria lógica a memoria física:</p>
<div class="ulist">
<ul>
<li>
<p>Se utiliza uno de los 4 registros de segmento CS,DS,ES,SS: son de 64 bits: 16 bits visibles y 6 bytes escondidos</p>
</li>
<li>
<p>Se utiliza una tabla de descripción del segmento residente en la memoria principal: cada entrada de la tabla son 8 bytes de los cuales 3 bytes son la dirección base física asociada a la dirección virtual segmentada.</p>
</li>
<li>
<p>En la parte visible del registro de segmento se cargan los 2 bytes más altos de la dirección virtual (selector de segmento)</p>
</li>
<li>
<p>El selector de segmento apunta a una de las entradas de la tabla de selección de descripción de segmento y carga 6 bytes de la tabla en la zona escondida del registro de segmento el cual contiene: dirección base física (3bytes), tamaño del segmento (2 bytes) y propiedades del segmento (1byte)</p>
</li>
<li>
<p>dirección física: la dirección base (3bytes) más el offset (2bytes): con 3 bytes &#8594; 2<sup>24</sup>=16MB de espacio físico</p>
</li>
<li>
<p>El espacio de direcciones de 4GB de memoria virtual de un segmento debiera poder traducirse en el espacio de direcciones físico de 16MB, pero únicamente puede acceder a 64KB.</p>
</li>
<li>
<p>Espacio físico total: de los 16MB posibles un segmento direcciona solo 64KB y como tenemos 4 segmentos &#8594; 4*64KB=256KB totales.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Multitasking, memory management (on chip MMU), protected memory &#8594; <em>modo protegido</em>: espacio de direcciones memoria segmentada de 24 bits.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_80386">42.5.3. 80386</h4>
<div class="ulist">
<ul>
<li>
<p>80386 &#8594; (32,32) &#8594; Espacio Físico: 2<sup>32</sup> = 4GB</p>
<div class="ulist">
<ul>
<li>
<p>Misma arquitectura que el 286 pero incrementa la ruta de datos de 16 bits a 32 bits, añade dos registros de segmento más (FS,GS) y añade la técnica de la paginación.</p>
</li>
<li>
<p>Memoria Virtual: 6 bytes : 2<sup>48</sup> = 64TB . Los 2 bytes altos son el selector de registro y los 4 bytes bajos el offset</p>
<div class="ulist">
<ul>
<li>
<p>de los 64TB posibles los 6 segmentos pueden direccionar <em>en un momento dado</em> 4GB cada uno &#8594; 6*4GB=24GB</p>
</li>
</ul>
</div>
</li>
<li>
<p>Segmentación</p>
<div class="ulist">
<ul>
<li>
<p>Selector de Segmento = 2 bytes como en el 286 &#8594; puntero a la entrada de la tabla descriptor de segmento</p>
</li>
<li>
<p>Descriptor de Segmento = Contiene 4 bytes de la dirección base física</p>
</li>
</ul>
</div>
</li>
<li>
<p>Conversión de la dirección lógica a dirección física con sólo segmentación</p>
<div class="ulist">
<ul>
<li>
<p>A la dirección base física (4 bytes) se le añade el offset de la dirección virtual (4bytes) &#8594; dirección física de 32 bits.</p>
</li>
<li>
<p>En este caso, a diferencia del 80286, el espacio de memoria virtual de 4GB de cada segmento se pueden traducir en el espacio físico de 4GB.</p>
</li>
</ul>
</div>
</li>
<li>
<p>instrucciones</p>
<div class="ulist">
<ul>
<li>
<p><code>movl $42,%fs:(%eax)</code></p>
</li>
<li>
<p>implícitamente</p>
<div class="ulist">
<ul>
<li>
<p>push, pop &#8594; SS,DS</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Ver paginación 80386</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_amd64">42.5.4. amd64</h4>
<div class="ulist">
<ul>
<li>
<p>amd64 &#8594; (52,64) &#8594; Espacio Físico: 2<sup>52</sup> = 4PetaBytes y Espacio Virtual 2<sup>48</sup> = 256TB</p>
<div class="ulist">
<ul>
<li>
<p><a href="https://en.wikipedia.org/wiki/X86-64#Physical_address_space_details" class="bare">https://en.wikipedia.org/wiki/X86-64#Physical_address_space_details</a></p>
</li>
<li>
<p><strong>No utiliza la segmentación lógica</strong> del espacio de direcciones virtual debido a que el espacio de memoria virtual de 256TB es suficiente para todos los procesos. Los segmentos lógicos (text,data,stack,heap, etc ) de un proceso se almacenan en el mismo espacio virtual asignado a dicho proceso mediante la técnica de paginación.</p>
</li>
<li>
<p>Hay que tener en cuenta la limitación de la tabla de paginas virtual que depende del número de páginas virtuales y la dirección de una página física. El area de memoria principal ocupada crece exponencialmente con el tamaño de la tabla y de forma innecesaria.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/memvirtual/amd64_virtualformat.png" alt="MMU">
</div>
<div class="title">Figure 116. Formato de direcciones amd64</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph nav-footer">
<p>← Previous: <a href="_sistemas_operativos_gestión_de_la_memoria.html">Sistemas Operativos: Gestión de la Memoria</a> | ↑ Up: <a href="_apéndice_memoria_virtual.html">Apéndice: Memoria Virtual</a> | ⌂ Home: <a href="eecc_book.html">Estructura de Computadores  (240306)</a> | Next: <a href="_memoria_virtual_paginada.html">Memoria Virtual Paginada</a> →</p>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2023-10-11 14:37:36 +0200
</div>
</div>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]],
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },
  TeX: { equationNumbers: { autoNumber: "none" } }
})
MathJax.Hub.Register.StartupHook("AsciiMath Jax Ready", function () {
  MathJax.InputJax.AsciiMath.postfilterHooks.Add(function (data, node) {
    if ((node = data.script.parentNode) && (node = node.parentNode) && node.classList.contains("stemblock")) {
      data.math.root.display = "block"
    }
    return data
  })
})
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
</body>
</html>