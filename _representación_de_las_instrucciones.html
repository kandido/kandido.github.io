<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.17">
<meta name="keywords" content="computer, architecture">
<meta name="author" content="Cándido Aramburu">
<title>Estructura de Computadores  (240306)</title>
<style>
@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";
@import "https://cdn.jsdelivr.net/gh/asciidoctor/asciidoctor@2.0/data/stylesheets/asciidoctor-default.css";



h1, h2, h3, h4, h5, h6, #toctitle,
.sidebarblock > .content > .title {
  color: rgba(221, 72, 20, 0.8);
}



</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<!-- Change some CSS.
<style>
.imageblock{
  &.text-center > .title {
    text-align: center !important;
  }
}
</style>

-->

<style type="text/css"> .imageblock > .title { text-align: center; } </style>

<style>.toc-current{font-weight: bold;} .toc-root{font-family: "Open Sans","DejaVu Sans",sans-serif;
                       font-size: 0.9em;} #content{display: flex; flex-direction: column; flex: 1 1 auto;}
             .nav-footer{text-align: center; margin-top: auto;}
             .nav-footer > p > a {white-space: nowrap;}</style>
</head>
<body id="_representación_de_las_instrucciones" class="book">
<div id="header">
<h1>Estructura de Computadores  (240306)</h1>
<div class="details">
<span id="author" class="author">Cándido Aramburu</span><br>
<span id="email" class="email"><a href="mailto:candido@unavarra.es">candido@unavarra.es</a></span><br>
<span id="revdate">2022-11-23</span>
</div>
<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<p><span class="toc-root"><a href="eecc_book.html">Estructura de Computadores  (240306)</a></span></p><ul class="sectlevel0">
<li><a href="_i_arquitectura_del_repertorio_de_instrucciones_isa_computadora_von_neumann_datos_instrucciones_programación.html">I Arquitectura del Repertorio de Instrucciones (ISA): computadora von Neumann, datos, instrucciones, programación.</a>
<ul class="sectlevel1">
<li><a href="_introducción_a_la_estructura_de_los_computadores.html">1. Introducción a la Estructura de los Computadores</a>
</li>
<li><a href="_arquitectura_von_neumann.html">2. Arquitectura Von Neumann</a>
</li>
<li><a href="_representación_de_los_datos.html">3. Representación de los Datos</a>
</li>
<li><a href="_operaciones_aritmeticas_y_logicas.html">4. Operaciones Aritmeticas y Logicas</a>
</li>
<li><a href="_representación_de_las_instrucciones.html"><span class="toc-current">5. Representación de las Instrucciones</span></a>
<ul class="sectlevel2">
<li><a href="_representación_de_las_instrucciones.html#_temario_5">5.1. Temario</a>
<ul class="sectlevel3">
<li><a href="_representación_de_las_instrucciones.html#_bibliografía">5.1.1. Bibliografía</a>
</li>
</ul>
</li>
<li><a href="_representación_de_las_instrucciones.html#_objetivos">5.2. Objetivos</a>
<ul class="sectlevel3">
<li><a href="_representación_de_las_instrucciones.html#_requisitos">5.2.1. Requisitos</a>
</li>
</ul>
</li>
<li><a href="_representación_de_las_instrucciones.html#_lenguajes_de_programación_de_alto_nivel_vs_lenguajes_de_programación_de_bajo_nivel">5.3. Lenguajes de programación de alto nivel vs Lenguajes de Programación de bajo nivel</a>
<ul class="sectlevel3">
<li><a href="_representación_de_las_instrucciones.html#_lenguajes_de_alto_nivel">5.3.1. Lenguajes de alto nivel</a>
</li>
<li><a href="_representación_de_las_instrucciones.html#_el_lenguaje_máquina_y_el_lenguaje_ensamblador">5.3.2. El lenguaje máquina y el lenguaje ensamblador</a>
</li>
</ul>
</li>
<li><a href="_representación_de_las_instrucciones.html#_elementos_de_una_instrucción_máquina">5.4. Elementos de una Instrucción Máquina</a>
<ul class="sectlevel3">
<li><a href="_representación_de_las_instrucciones.html#_tipos_de_arquitecturas_de_operando_ejemplos">5.4.1. Tipos de Arquitecturas de Operando: Ejemplos</a>
</li>
</ul>
</li>
<li><a href="_representación_de_las_instrucciones.html#_instrucciones_en_lenguaje_máquina_de_la_arquitectura_x86">5.5. Instrucciones en lenguaje máquina de la arquitectura x86</a>
</li>
<li><a href="_representación_de_las_instrucciones.html#_representación_de_las_instrucciones_en_el_lenguaje_ensamblador_asm_para_computadoras_en_general">5.6. Representación de las instrucciones en el lenguaje ensamblador (ASM) para computadoras en general</a>
<ul class="sectlevel3">
<li><a href="_representación_de_las_instrucciones.html#_introducción">5.6.1. Introducción</a>
</li>
<li><a href="_representación_de_las_instrucciones.html#_códigos_de_operación">5.6.2. Códigos de Operación</a>
</li>
<li><a href="_representación_de_las_instrucciones.html#_operandos_modos_de_direccionamiento">5.6.3. Operandos: Modos de Direccionamiento</a>
</li>
</ul>
</li>
<li><a href="_representación_de_las_instrucciones.html#gas_sintax_direcci">5.7. Lenguaje Intel versus Lenguaje  AT&amp;T</a>
<ul class="sectlevel3">
<li><a href="_representación_de_las_instrucciones.html#_lenguajes_ensamblador_de_la_arquitectura_i386amd64">5.7.1. Lenguajes ensamblador de la arquitectura  i386/amd64</a>
</li>
<li><a href="_representación_de_las_instrucciones.html#_sintaxis_de_las_instrucciones_en_el_lenguaje_intel">5.7.2. Sintaxis de las instrucciones en el lenguaje INTEL</a>
</li>
</ul>
</li>
<li><a href="_representación_de_las_instrucciones.html#_operandos_modos_de_direccionamiento_2">5.8. Operandos: Modos de Direccionamiento</a>
<ul class="sectlevel3">
<li><a href="_representación_de_las_instrucciones.html#_localización_2">5.8.1. Localización</a>
</li>
<li><a href="_representación_de_las_instrucciones.html#_modos_de_direccionamiento">5.8.2. Modos de Direccionamiento</a>
</li>
</ul>
</li>
<li><a href="_representación_de_las_instrucciones.html#_programas_en_lenguaje_asm_y_lenguaje_binario">5.9. Programas en lenguaje ASM y lenguaje Binario</a>
</li>
</ul>
</li>
<li><a href="_programación_en_lenguaje_ensamblador_x86_construcciones_básicas_de_los_lenguajes_de_alto_nivel.html">6. Programación en Lenguaje Ensamblador (x86): Construcciones básicas de los lenguajes de alto nivel.</a>
</li>
</ul>
</li>
<li><a href="_ii_unidades_básicas_procesador_central_unidad_de_memoria_mecanismos_entradasalida.html">II Unidades Básicas: Procesador Central, Unidad de Memoria, Mecanismos Entrada/Salida.</a>
</li>
<li><a href="_iii_ejercicios_de_teoría.html">III Ejercicios de Teoría</a>
</li>
<li><a href="_iv_autoevaluación_teoría.html">IV Autoevaluación Teoría</a>
</li>
<li><a href="_v_guiones_de_prácticas_programación_ensamblador_x86.html">V Guiones de Prácticas: Programación Ensamblador x86</a>
</li>
<li><a href="_vi_hojas_de_referencia_rápida.html">VI Hojas de Referencia Rápida</a>
</li>
<li><a href="_vii_autoevaluación_prácticas.html">VII Autoevaluación Prácticas</a>
</li>
<li><a href="_viii_apéndices.html">VIII Apéndices</a>
</li>
<li><a href="_ix_bibliografía.html">IX Bibliografía</a>
</li>
<li><a href="_x_glosario.html">X Glosario</a>
</li>
<li><a href="_xi_colofón.html">XI Colofón</a>
</li>
<li><a href="_index.html">Index</a>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_representación_de_las_instrucciones">5. Representación de las Instrucciones</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_temario_5">5.1. Temario</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Representación de instrucciones</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Lenguaje máquina, lenguaje ensamblador y lenguajes de alto nivel</p>
</li>
<li>
<p>Formato de instrucción</p>
</li>
<li>
<p>Tipos de instrucción y modos de direccionamiento</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="_bibliografía">5.1.1. Bibliografía</h4>
<div class="ulist">
<ul>
<li>
<p>Tema referenciado en el libro de texto W. Stalling</p>
<div class="ulist">
<ul>
<li>
<p>Capítulo 10: Conjuntos de Instrucciones : Características y Funciones (Datos, Operandos y Operaciones)</p>
</li>
<li>
<p>Capítulo 11: Conjuntos de Instrucciones: Formatos de instrucciones y Modos de Direccionamiento (Lenguaje Ensamblador)</p>
</li>
<li>
<p>Apéndice B: Lenguaje Ensamblador y Toolchain</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_objetivos">5.2. Objetivos</h3>
<div class="ulist">
<ul>
<li>
<p>Analizar la arquitectura del repertorio de las instrucciones máquina (Formato de instrucciones, formato de datos, operaciones y direccionamiento de operandos) de arquitecturas ISA en general.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_requisitos">5.2.1. Requisitos</h4>
<div class="ulist">
<ul>
<li>
<p>Requisitos:</p>
<div class="ulist">
<ul>
<li>
<p>Von Neumann Architecture: Arquitectura de una Computadora, Máquina IAS.</p>
</li>
<li>
<p>Programación en lenguaje ensamblador IAS</p>
</li>
<li>
<p>Representacion de datos</p>
</li>
<li>
<p>Operaciones Aritméticas y Lógicas</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_lenguajes_de_programación_de_alto_nivel_vs_lenguajes_de_programación_de_bajo_nivel">5.3. Lenguajes de programación de alto nivel vs Lenguajes de Programación de bajo nivel</h3>
<div class="sect3">
<h4 id="_lenguajes_de_alto_nivel">5.3.1. Lenguajes de alto nivel</h4>
<div class="paragraph">
<p>Los lenguajes de alto nivel como Java, Python, C, etc &#8230;&#8203; se desarrollaron para facilitar la tarea de programar algoritmos, estructuras de datos, etc&#8230;&#8203;utilizando un lenguaje sencillo de manejar por los programadores. En cambio, los datos y las instrucciones que manejan las CPU de las computadoras están en otro lenguaje, el lenguaje MAQUINA BINARIO, que depende del tipo de procesador (intel,AMD,RISC-V,etc&#8230;&#8203;) de la computadora. El lenguaje máquina de un procesador intel de nuestra computadora difiere del lenguaje MAQUINA del procesador arm de un smartphone.</p>
</div>
<div class="paragraph">
<p>Al igual que los datos, las instrucciones también es necesario codificarlas en un formato BINARIO. Los programas en lenguaje máquina formados por datos e instrucciones binarias están preparados para ser cargados en la memoria principal RAM y ser procesados por la CPU.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Ejemplos de lenguajes de Programación de alto y bajo nivel:  <a href="_lenguajes_de_programación_de_alto_y_bajo_nivel.html#lang_altovsbajo">Apéndice</a>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_el_lenguaje_máquina_y_el_lenguaje_ensamblador">5.3.2. El lenguaje máquina y el lenguaje ensamblador</h4>
<div class="ulist">
<ul>
<li>
<p>En este tema se trata de la representación e interpretación de las instrucciones en lenguaje máquina y lenguaje ensamblador.</p>
</li>
<li>
<p>Las instrucciones se pueden representar en dos lenguajes</p>
<div class="ulist">
<ul>
<li>
<p>Lenguaje máquina en formato binario : 0101010101111111000011111</p>
<div class="ulist">
<ul>
<li>
<p>El lenguaje binario implica un <strong>formato de la instrucción</strong>.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Lenguaje símbolico o lenguaje ensamblador en formato texto :  <em>fin: ADD 0x33,resultado</em></p>
<div class="ulist">
<ul>
<li>
<p>El lenguaje ensamblador implica una <strong>sintaxis</strong></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>La representación de las instrucciones en lenguaje binario permite su almacenamiento en la memoria principal así como facilitar el ciclo de instrucción mediante su decodificación y ejecución por parte de la CPU.</p>
</li>
<li>
<p>La representación de las instrucciones en lenguaje simbólico, como es el texto, tiene como objetivo facilitar la tarea del programador en la interpretación  de las instrucciones y en el desarrollo de programas en lenguaje ensamblador.</p>
</li>
<li>
<p>El estudio de los formatos de las instrucciones máquina de  un procesador específico se enmarca dentro del concepto ISA de la Arquitectura del Procesador <a href="_arquitectura_de_una_computadora.html#estr_comp">Ver apéndice</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_elementos_de_una_instrucción_máquina">5.4. Elementos de una Instrucción Máquina</h3>
<div class="ulist">
<ul>
<li>
<p>Una instrucción máquina se estructura en diferentes campos: campo de operaciones, campo de operando, etc &#8230;&#8203; El número de campos dependerá del procesador que se esté diseñando.</p>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/ditaa/svg/eNrjUoABbV2KgTYX3LQaBefE3IJ8hZRUBf-C1KLE5Mz8vNRioDCaeF5KPopiPT29GpgRXKS4jZASLgAmCDCN" alt="Diagram">
</div>
</div>
</li>
<li>
<p>En el caso de la máquina IAS el formato de instrucción tiene únicamente dos campos: el código de operación y el campo del operando.</p>
</li>
<li>
<p>Código de Operaciones:</p>
<div class="ulist">
<ul>
<li>
<p>La instrucción debe de especificar que operación debe de realizar la CPU. Operaciones cómo las aritméticas de suma y resta ,  operaciones lógicas como not y and, operaciones de transferencia de datos entre posiciones de la memoria principal, operaciones de entrada y salida como la transferencia de datos del disco duro a la memoria principal, etc</p>
</li>
</ul>
</div>
</li>
<li>
<p>Source Operand Reference:</p>
<div class="ulist">
<ul>
<li>
<p>Una operación puede requerir el procesamiento de uno o más datos. Por ejemplo la operación lógica NOT requiere de un operando, la operación suma ADD requiere de dos operandos, etc</p>
</li>
</ul>
</div>
</li>
<li>
<p>Target Operand Reference:</p>
<div class="ulist">
<ul>
<li>
<p>Una operación  de suma requiere de dos operandos, uno es el operando fuente y otro el operando destino.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Result Reference:</p>
<div class="ulist">
<ul>
<li>
<p>Una operación de suma requiere salvar el resultado de la operación.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Next Instruction Reference:</p>
<div class="ulist">
<ul>
<li>
<p>Una vez finalizada la ejecución de la instrucción es necesario indicar a la CPU donde esta almacenada la próxima instrucción a ejecutar a través del Contador de Programa PC.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Direcciones del operando implícitas: Direcciones que no aparecen explícitamente en la instrucción. Ejemplos:</p>
<div class="ulist">
<ul>
<li>
<p>La Próxima instrucción es la dirección almacenada en otro registro: el Contador de Programa</p>
</li>
<li>
<p>El Resultado de la operación se guarda en otro registro: el Acumulador</p>
</li>
<li>
<p>etc</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_tipos_de_arquitecturas_de_operando_ejemplos">5.4.1. Tipos de Arquitecturas de Operando: Ejemplos</h4>
<div class="ulist">
<ul>
<li>
<p>3 Tipos</p>
<div class="ulist">
<ul>
<li>
<p>Arquitectura orientada a <strong>Acumulador</strong>: Un operando está implicitamente en el Acumulador</p>
</li>
<li>
<p>Arquitectura orientada a <strong>Stack</strong> (<a href="_pila.html#pila">Apéndice Pila</a>):</p>
<div class="ulist">
<ul>
<li>
<p>Los operandos se introducen o extraen de la pila interna de la CPU</p>
</li>
<li>
<p>Concepto de pila: push/pop &#8594; empujar/extraer &#8594; el primero en entrar es el último en salir &#8594; First Input Last Output</p>
</li>
<li>
<p>SP: Registro Stack Pointer : registro que apunta al Top de la pila (parte alta de la pila)</p>
</li>
</ul>
</div>
</li>
<li>
<p>Arquitectura orientada a <strong>Registros</strong>:</p>
<div class="ulist">
<ul>
<li>
<p>Dos tipos: Reg/Mem y Load/Store, como es el caso de la arquitectura amd64 y arm respectivamente.</p>
</li>
<li>
<p>Reg/Mem : para que la instrucción se ejecute uno de los dos operandos debe de estar en un registro</p>
</li>
<li>
<p>Load/Store: Los dos operandos deben de estar en dos registros para que dicha instrucción se ejecute</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Ejemplo: código para realizar la operación <strong>C=A+B</strong> en 4 arquitecturas de operando diferentes.</p>
<table class="tableblock frame-ends grid-all" style="width: 80%;">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Stack</th>
<th class="tableblock halign-center valign-top">Acumulator</th>
<th class="tableblock halign-center valign-top">Register/Memory</th>
<th class="tableblock halign-center valign-top">Load/Store</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>Push A</strong></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>Load A</strong></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>Load R1,A</strong></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>Load R1,A</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>Push B</strong></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>Add B</strong></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>Add R3,R1,B</strong></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>Load R2,B</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>Add</strong></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>Store C</strong></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>Store R3,C</strong></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>Add R3,R1,R2</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>Pop C</strong></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>Store R3,C</strong></p></td>
</tr>
</tbody>
</table>
<div class="ulist">
<ul>
<li>
<p>Los nombres de las variables, A, B,C son referencias a la Memoria Principal.</p>
</li>
<li>
<p>Descripción RTL</p>
<div class="ulist">
<ul>
<li>
<p>Stack: M[SP]&#8592;M[A],SP&#8592;SP-1; M[SP]&#8592;M[B],SP&#8592;SP-1;M[SP+1]&#8592;M[SP]+M[SP+1],SP&#8592;SP+1;</p>
<div class="ulist">
<ul>
<li>
<p><strong>Add</strong>    &#8594; NO hay referencia ni al operando fuente ni al operando destino.</p>
</li>
<li>
<p>Los operandos han de cargarse previamente en la pila</p>
</li>
</ul>
</div>
</li>
<li>
<p>Acumulator: AC&#8592;M[A];AC&#8592;AC+M[B];C&#8592;M[AC]</p>
<div class="ulist">
<ul>
<li>
<p><strong>Add B</strong>   &#8594; NO hay referencia al operando DESTINO</p>
</li>
<li>
<p>El Operando destino a de cargarse previamente en el acumulador.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Reg/Mem: R1&#8592;M[A];R3&#8592;R1+M[B];M[C]&#8592;R3</p>
<div class="ulist">
<ul>
<li>
<p><strong>Add R3,R1,B</strong>  &#8594; NO se puede referencia a más de un operando en MEMORIA</p>
</li>
</ul>
</div>
</li>
<li>
<p>Si un operando está almacenado en la memoria, el resto a de cargarse previamente en los registros.</p>
</li>
<li>
<p>Load/Store: R1&#8592;M[A];R2&#8592;M[B];R3&#8592;R1+R2;M[C]&#8592;R3.</p>
<div class="ulist">
<ul>
<li>
<p><strong>Add R3,R1,R2</strong> &#8594;Solamente se hacen referencias a REGISTROS, ninguna referencia a memoria</p>
</li>
<li>
<p>Los operandos fuente y destino han de cargarse previamente en los registros</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
La arquitectura x86 está orientada a Reg/Mem, por lo que no se puede referenciar en la misma instrucción a un operando fuente en MEMORIA y el operando destino también en MEMORIA, es decir, ambos operandos referenciados a MEMORIA.
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>Ejemplo de código para realizar la opeación <strong>(A-B)/(DxE+C)</strong> según 4 arquitecturas ISA diferentes: arquitectura con 3 operandos referenciados, con 2 operandos referenciados, con 1 operando referenciado y ninǵún operando referenciado</p>
<div class="imageblock">
<div class="content">
<img src="./images/instrucciones_representacion/addresses_arch.jpg" alt="addresses arch">
</div>
</div>
</li>
<li>
<p>4º Caso: Arquitectura de Operando tipo Stack:</p>
<div class="ulist">
<ul>
<li>
<p>M[SP]&#8592;M[C];M[SP]&#8592;M[E];M[SP]&#8592;M[D];MUL;ADD;M[SP]&#8592;M[B];M[SP]&#8592;M[A];SUB;DIV</p>
</li>
<li>
<p>push C; push E; push D; mul; add; push B; push A; sub; div;</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_instrucciones_en_lenguaje_máquina_de_la_arquitectura_x86">5.5. Instrucciones en lenguaje máquina de la arquitectura x86</h3>
<div class="ulist">
<ul>
<li>
<p>Ver el apéndice <a href="_lenguajes_de_programación_en_ensamblador.html#intel_i386_hola_asmbin">Apéndice</a> a modo de comprender un ejemplo. No es posible programar manualmente en lenguaje máquina en una computadora actual.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_representación_de_las_instrucciones_en_el_lenguaje_ensamblador_asm_para_computadoras_en_general">5.6. Representación de las instrucciones en el lenguaje ensamblador (ASM) para computadoras en general</h3>
<div class="sect3">
<h4 id="_introducción">5.6.1. Introducción</h4>
<div class="ulist">
<ul>
<li>
<p>Los dos campos más importantes y casi únicos del formato de instrucción son: El código de operación y los modos de direccionamiento de los campos de operandos. El número de operandos puede ser 0,1,2,3,etc</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_códigos_de_operación">5.6.2. Códigos de Operación</h4>
<div class="ulist">
<ul>
<li>
<p>La codificación del conjunto de operaciones depende de cada arquitectura ISA.</p>
</li>
<li>
<p>Categorías según el tipo de operaciones:</p>
<div class="ulist">
<ul>
<li>
<p>Data Processing: Arithmetic and logic instructions</p>
</li>
<li>
<p>Data Load/Store: Movement of data into or out of register and/or memory
locations</p>
</li>
<li>
<p>Data Movement: I/O instructions</p>
</li>
<li>
<p>Control: Test and Branch instructions</p>
</li>
<li>
<p>El repertorio puede ser: reducido/extenso, complejo/sencillo.</p>
</li>
</ul>
</div>
</li>
<li>
<p>En el lenguaje ensamblador a la palabra que indica el tipo de opeación, por ejemplo ADD para una suma, se le denomina <strong>mnemónico</strong> y suele estar en lengua inglesa, permitiendo intuir fácilmente de que operación se trata.</p>
</li>
<li>
<p>La mejor forma de prácticar con los mnemónicos del lenguaje ensamblador es programando, lo cual se verá en el siguiente tema <a href="_programación_en_lenguaje_ensamblador_x86_construcciones_básicas_de_los_lenguajes_de_alto_nivel.html#repertorio_instruc_oper">lenguaje ensamblador x86</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><span class="image"><img src="./images/instrucciones_representacion/tipos_instrucciones.png" alt="tipos de instrucciones"></span></p>
</div>
</div>
<div class="sect3">
<h4 id="_operandos_modos_de_direccionamiento">5.6.3. Operandos: Modos de Direccionamiento</h4>
<div class="sect4">
<h5 id="_localización">Localización</h5>
<div class="ulist">
<ul>
<li>
<p>Posibles ubicaciones de los operandos.</p>
<div class="ulist">
<ul>
<li>
<p>En la propia instrucción</p>
</li>
<li>
<p>Memoria interna: registros CPU</p>
</li>
<li>
<p>Memoria Principal: memoria DRAM</p>
</li>
<li>
<p>Memoria i/o: registros en controladores de entrada/salidas denominados puertos.</p>
</li>
</ul>
</div>
</li>
<li>
<p>La instrucción tiene que hacer referencia de alguna forma (modo de direccionamiento) a  la ubicación del operando.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_direcciones_referenciadas_durante_el_ciclo_de_instrucción">Direcciones referenciadas durante el ciclo de instrucción</h5>
<div class="ulist">
<ul>
<li>
<p>Durante el ciclo de instrucción se pueden referenciar:</p>
<div class="ulist">
<ul>
<li>
<p>Una dirección para referenciar a la instrucción</p>
</li>
<li>
<p>Una dirección para el operando primero</p>
</li>
<li>
<p>Una dirección para el operando segundo</p>
</li>
<li>
<p>Una dirección para el resultado</p>
</li>
<li>
<p>Una dirección que referencie a la siguiente instrucción</p>
</li>
</ul>
</div>
</li>
<li>
<p>Tipos de  instrucciones según el número de direcciones referenciadas durante su ejecución.</p>
<div class="ulist">
<ul>
<li>
<p>Instrucciones sin operando, con un operando, con múltiples operandos.</p>
</li>
<li>
<p>Depende de la arquitectura: Acumulador (Ej: máquina IAS), Registro-Memoria(Ej: máquina x86), Load/Store (Ej:ARM ), Stack (Ej: máquina JVM), Memoria-Memoria</p>
</li>
<li>
<p>referencias implicitas al operando</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_formato_de_instrucción_campos">Formato de instrucción: Campos</h5>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/ditaa/svg/eNrjUoABbV0ogDMwAJqMNhdcc42Cc36Kgn8BkKHgm5-ip-CSWZSanJyZn5eYm5maV5IPUgIGjjAdXBTZDADb5SPY" alt="Diagram">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Ejemplo particular</strong> de una estructura del formato de instrucción en tres campos en una arquitectura ISA.</p>
<div class="ulist">
<ul>
<li>
<p>Código de Operación: mover, cargar, sumar, restar, etc</p>
</li>
<li>
<p>Código A: campo de operando : hace referencia a la localización del operando</p>
</li>
<li>
<p>Código Mod. Direc: representa el modo de interpretar el campo A</p>
</li>
</ul>
</div>
</li>
<li>
<p>EA: Efective Address : Dirección efectiva donde está localizado el operando</p>
</li>
<li>
<p>Op: Operando .Es el dato contenido en la dirección efectiva EA.</p>
</li>
<li>
<p>Los datos <em>operando</em> Op pueden estar almacenados en:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Memoria externa RAM</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Una dirección de memoria conteniendo un dato.</p>
</li>
<li>
<p>Una dirección de memoria conteniendo una instrucción. El dato es uno de los campos de a propia instrucción. Direccionamieno Inmediato.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Memoria interna GPR</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Registros rax,eax,&#8230;&#8203;</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_tipos_de_direccionamiento">Tipos de direccionamiento</h5>
<div class="ulist">
<ul>
<li>
<p>La <em>dirección</em> de referencia efectiva E.A. de la ubicación del operando se obtiene según los distintos modos de direccionamiento.</p>
</li>
<li>
<p>El modo de direccionamiento está codificado en el campo M.D.</p>
</li>
<li>
<p>Inmediato:</p>
<div class="ulist">
<ul>
<li>
<p>El operando se obtiene del campo de la propia instrucción.</p>
</li>
<li>
<p>EA= no existe</p>
</li>
<li>
<p>Op=A</p>
</li>
</ul>
</div>
</li>
<li>
<p>Directo:</p>
<div class="ulist">
<ul>
<li>
<p>El operando está en la memoria externa. El campo de operando contiene la dirección efectiva</p>
</li>
<li>
<p>EA=A</p>
</li>
<li>
<p>Op=M[EA]</p>
</li>
</ul>
</div>
</li>
<li>
<p>Registro:</p>
<div class="ulist">
<ul>
<li>
<p>El operando está en la memoria interna. El campo de operando contiene la referencia del Registro.</p>
</li>
<li>
<p>EA=A</p>
</li>
<li>
<p>Op=R</p>
</li>
</ul>
</div>
</li>
<li>
<p>Indirecto:</p>
<div class="ulist">
<ul>
<li>
<p>La dirección efectiva esta almacenada en una posición de memoria externa o interna.</p>
</li>
<li>
<p>EA=M[A] o R</p>
</li>
<li>
<p>Op=M[M[A]] o M[R]</p>
</li>
</ul>
</div>
</li>
<li>
<p>Desplazamiento:</p>
<div class="ulist">
<ul>
<li>
<p>La dirección efectiva del operando se obtiene mediante una operación aritmética entre una dirección base y un desplazamiento relativo a la dirección base. La dirección base se toma como referencia y el desplazamiento es relativo a la dirección base.</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Relativo al contador de programa PC:</p>
<div class="ulist">
<ul>
<li>
<p>La dirección base es implíctamente el contador de programa y el desplazamiento está en el campo de operando.</p>
</li>
<li>
<p>EA=PC+A</p>
</li>
<li>
<p>Op=M[EA]</p>
</li>
</ul>
</div>
</li>
<li>
<p>Relativo a Base:</p>
<div class="ulist">
<ul>
<li>
<p>El desplazamiento está en el campo de operando y la dirección base está en el registro.</p>
</li>
<li>
<p>EA=R+A</p>
</li>
<li>
<p>Op=M[EA]</p>
</li>
</ul>
</div>
</li>
<li>
<p>Indexado:</p>
<div class="ulist">
<ul>
<li>
<p>El desplazamiento está en el registro y la dirección base está en el campo de operando.</p>
</li>
<li>
<p>EA=A+R</p>
</li>
<li>
<p>Op=M[EA]</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Para hacer referencia a los operandos fuente o destino la arquitectura de la instrucción es muy <em>flexible</em> ya que se dispone de distintos modos de direccionar dichos operandos.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="gas_sintax_direcci">5.7. Lenguaje Intel versus Lenguaje  AT&amp;T</h3>
<div class="sect3">
<h4 id="_lenguajes_ensamblador_de_la_arquitectura_i386amd64">5.7.1. Lenguajes ensamblador de la arquitectura  i386/amd64</h4>
<div class="ulist">
<ul>
<li>
<p>El lenguaje en código máquina del repertorio de instrucciones de la arquitectura AMD64 es único pero no así el lenguaje ensamblador correspondiente a dicha arquitectura.</p>
</li>
<li>
<p>En la asignatura "Estructura de Computadores" se utiliza la sintaxis <strong>AT&amp;T</strong> de la compañía telefónica americana AT&amp;T.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_sintaxis_de_las_instrucciones_en_el_lenguaje_intel">5.7.2. Sintaxis de las instrucciones en el lenguaje INTEL</h4>
<div class="ulist">
<ul>
<li>
<p>El formato de las instrucciones en lenguaje ensamblador se conoce como <em>sintaxis</em> de las instrucciones.</p>
</li>
<li>
<p>SINTAXIS ASM: Etiqueta-Código de Operación- Operando1- Operando2- Comentario</p>
</li>
<li>
<p>x86-64</p>
</li>
<li>
<p>x86</p>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 8. Sintaxis Intel</caption>
<colgroup>
<col style="width: 9.5238%;">
<col style="width: 19.0476%;">
<col style="width: 28.5714%;">
<col style="width: 4.7619%;">
<col style="width: 23.8095%;">
<col style="width: 14.2858%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>label:</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>op_mnemonic</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>operand_destination</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>,</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>operand_source</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>#comment</code></p></td>
</tr>
</tbody>
</table>
<div class="ulist">
<ul>
<li>
<p>Ejemplo:</p>
<div class="ulist">
<ul>
<li>
<p><code>bucle:  sub     rsp,16                ;RSP &#8592; RSP-16. Comienzo del bucle con la operación substraction</code></p>
</li>
<li>
<p><code>je      bucle                 ;je: jump equal: salto si la última operación dió resultado cero</code></p>
</li>
<li>
<p><code>suma:   add     eax,esi               ;EAX &#8592; EAX+M[ESI] . Sumar</code></p>
</li>
<li>
<p><code>mov     ax,[resultado]        ;AX &#8592; M[resultado]. Copiar el resultado</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
La sintaxis del lenguaje ensamblador depende del traductor del proceso de ensamblaje (assembler) utilizado, en este caso, se utiliza el assembler NASM. Ver un ejemplo en el <a href="_lenguajes_de_programación_en_ensamblador.html#sum1toN_nasm">Apéndice</a> de un programa en lenguaje ensamblador intel y assembler "NetWide Asm" (nasm)
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_gnu_assembly_gas">GNU Assembly (Gas)</h5>
<div class="ulist">
<ul>
<li>
<p>Lenguaje desarrollado por la empresa de telefonía AT&amp;T</p>
</li>
<li>
<p>Assembler gas (GNU as)</p>
<div class="ulist">
<ul>
<li>
<p>arquitecturas: i386, amd64, mips, 68000, etc</p>
</li>
<li>
<p>Sintaxis: Etiqueta-Código de Operación- Operando1- Operando2- Comentario</p>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 9. Sintaxis AT&amp;T</caption>
<colgroup>
<col style="width: 9.5238%;">
<col style="width: 19.0476%;">
<col style="width: 23.8095%;">
<col style="width: 4.7619%;">
<col style="width: 28.5714%;">
<col style="width: 14.2858%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>label:</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>op_mnemonic</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>operand_source</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>,</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>operand_destination</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>;comment</code></p></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Ejemplo:</p>
<div class="ulist">
<ul>
<li>
<p><code>bucle:  subq     $16,%rsp                ;RSP &#8592; RSP-16. Comienzo del bucle con la operación substraction</code></p>
</li>
<li>
<p><code>je       bucle                   ;je: jump equal: salto si la última operación dió resultado cero</code></p>
</li>
<li>
<p><code>suma:   addl     %esi,%eax               ;EAX &#8592; EAX+M[ESI] . Sumar</code></p>
</li>
<li>
<p><code>movw     %ax,resultado           ;AX &#8592; M[resultado]. Copiar el resultado</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>ETIQUETA</p>
<div class="ulist">
<ul>
<li>
<p>Se especifica en la primera columna. Tiene el sufijo <strong>:</strong></p>
</li>
</ul>
</div>
</li>
<li>
<p>CODIGO DE OPERACION: Se utilizan símbolos <em>mnemónicos</em> que ayudan a interpretar intuitivamente la operación. Pej: ADD sumar, MOV mover, SUB restar, &#8230;&#8203;</p>
</li>
<li>
<p>OPERANDO FUENTE Y/O DESTINO</p>
<div class="ulist">
<ul>
<li>
<p>dato alfanumérico: representación alfanumérica 	&#8594; 16</p>
<div class="ulist">
<ul>
<li>
<p>direccionamiento <em>inmediato</em>: prefijo <strong>$</strong></p>
</li>
</ul>
</div>
</li>
<li>
<p>dirección de memoria externa: etiqueta		&#8594; resultado</p>
<div class="ulist">
<ul>
<li>
<p>direccionamiento <em>directo</em></p>
</li>
</ul>
</div>
</li>
<li>
<p>registros internos de la CPU: %rax,%rbx,%rsp,%esi,..</p>
<div class="ulist">
<ul>
<li>
<p>El prefijo <strong>%</strong> significa que el nombre hace referencia a un registro</p>
</li>
</ul>
</div>
</li>
<li>
<p>tamaño del dato operando: <strong>sufijos</strong> de los mnemónicos: q(quad):8 bytes, l(long):4 bytes, w(word):2 bytes, b(byte):1 byte.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
La sintaxis del lenguaje ensamblador depende del traductor del proceso de ensamblaje (assembler) utilizado, en este caso, se utiliza el assembler GAS.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_operandos_modos_de_direccionamiento_2">5.8. Operandos: Modos de Direccionamiento</h3>
<div class="sect3">
<h4 id="_localización_2">5.8.1. Localización</h4>
<div class="ulist">
<ul>
<li>
<p>Ejemplo:</p>
<div class="ulist">
<ul>
<li>
<p><code>bucle:  SUBQ     $16,%rsp                ;comienzo del bucle</code></p>
<div class="ulist">
<ul>
<li>
<p>Operando fuente: $ indica direccionamiento INMEDIATO .El operando está en la propia instrucción &#8594; Operando=16</p>
</li>
<li>
<p>Operando destino: % indica REGISTRO. El operando está en el registro RSP</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>suma:   ADDW     (%ESI),resultado        ;fin de operación</code></p>
<div class="ulist">
<ul>
<li>
<p>Operando fuente: () indica INDIRECCION y % registro .El registro ESI continene la dirección de memoria donde está el operando</p>
</li>
<li>
<p>Operando destino: "resultado" es una etiqueta. Direccionamiento ABSOLUTO. El operando está en la dirección de memoria "resultado".</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_modos_de_direccionamiento">5.8.2. Modos de Direccionamiento</h4>
<div class="ulist">
<ul>
<li>
<p>Manual del assembler, apartado directivas dependientes de la arquitectura x86</p>
<div class="ulist">
<ul>
<li>
<p><a href="https://sourceware.org/binutils/docs-2.26/as/i386_002dDependent.html#i386_002dDependent" class="bare">https://sourceware.org/binutils/docs-2.26/as/i386_002dDependent.html#i386_002dDependent</a>:</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<strong>RECOMENDABLE</strong> leerse los seis primeros apartados por lo menos
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>Direccionamientos:</p>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 80%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>INMEDIATO:</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>El valor del operando está ubicado inmediatamente después del código de operación de la instruccion. Unicamente se especifica el operando fuente.</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" rowspan="2"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>sintaxis: el valor del operando se indica con el prefijo <strong>$</strong> .</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ejemplo: <strong>movl $0xabcd1234, %ebx</strong>. El operando fuente es el valor 0xABCD1234</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>REGISTRO:</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>El valor del operando está localizado en un registro de la CPU.</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" rowspan="2"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>sintaxis: Nombre del registro con el prefijo <strong>%</strong>.</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ejemplo: <strong>movl %eax, %ebx</strong>. El operando fuente es el REGISTRO EAX y el destino es el REGISTRO EBX</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DIRECTO:</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>La dirección efectiva apuntando al operando almacenado en la Memoria Principal es la dirección absoluta referenciada por la etiqueta especificada en el campo de operando. El programador utiliza el direccionamiento directo pero el compilador lo transforma en un direccionamiento relativo al contador de programa. Ver direccionamiento con desplazamiento.</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" rowspan="2"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>sintaxis: una etiqueta definida por el programador</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ejemplo: <strong>je somePlace</strong>   . Salto a la dirección marcada por la etiqueta somePlace si el resultado de la operación anterior activa el flag ZF=1 del registro RFLAG.</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>INDEXADO:</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>El valor del operando está localizado en memoria. La dirección efectiva apuntando a Memoria es la SUMA del valor del registro_base MAS scale POR el valor en el registro_índice, MAS el offset. <em>EA=Offset+R_Base+R_índice*Scale</em></code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" rowspan="2"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>sintaxis: lista de valores separados por coma y entre paréntesis (base_register, index_register, scale) y precedido por un offset.</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ejemplo: <strong>movl $0x6789cdef, -16(%edx, %eax, 4)</strong> . La dirección efectiva del destino es  EDX + EAX*4 - 16.</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>INDIRECTO:</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Si  el modo general de indexación  lo particularizamos en <code>(base_register)</code> entonces la dirección del operando no se obtiene mediante una indexación sino que la dirección efectiva es el contenido de rdx y por lo tanto se accede al operando indirectamente.</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" rowspan="2"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>sintaxis:  (base_register)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ejemplo: <strong>movl $0x6789cdef, (%edx)</strong> . La dirección efectiva del destino es  EDX. EDX es un puntero.</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>RELATIVO: registro base más un offset:</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>El valor del operando está ubicado en memoria. La dirección efectiva del operando es la suma del valor contenido en un registro base más un valor de offset.</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" rowspan="2"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>sintaxis: registro entre paréntesis y el offset inmediatamente antes del paréntesis.</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ejemplo: <strong>movl $0xaabbccdd, -12(%eax)</strong>  . La dirección efectiva del operando destino es  EAX-12</code></p></td>
</tr>
</tbody>
</table>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_ejemplos">Ejemplos</h5>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 10. Modos de Direccionamiento de los Operandos</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Direccionamiento Operando</th>
<th class="tableblock halign-left valign-top">Valor Operando</th>
<th class="tableblock halign-left valign-top">Nombre del Modo</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>$0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Valor Cero</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Inmediato</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>%rax</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>RAX</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Registro</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>loop_exit</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>M[loop_exit]</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Directo</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>data_items(,%rdi,4)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>M[data_item + 4*RDI]</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Indexado</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(%rbx)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>M[RBX]</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Indirecto</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(%rbx,%rdi,4)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>M[RBX + 4*RDI]</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Indirecto Indexado</code></p></td>
</tr>
</tbody>
</table>
<div class="ulist">
<ul>
<li>
<p>M[loop_exit]: directo ya que loop_exit es una dirección de memoria externa y M indica la memoria externa.</p>
</li>
<li>
<p>M[RBX]: indirecto ya que RBX es una dirección de memoria interna y M indica memoria externa: A la mem. externa se accede a través de la mem. interna.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_programas_en_lenguaje_asm_y_lenguaje_binario">5.9. Programas en lenguaje ASM y lenguaje Binario</h3>
<div class="ulist">
<ul>
<li>
<p>Ejemplos en el <a href="_lenguajes_de_programación_en_ensamblador.html#leng_asm">Apéndice</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="paragraph nav-footer">
<p>← Previous: <a href="_operaciones_aritmeticas_y_logicas.html">Operaciones Aritmeticas y Logicas</a> | ↑ Up: <a href="_i_arquitectura_del_repertorio_de_instrucciones_isa_computadora_von_neumann_datos_instrucciones_programación.html">I Arquitectura del Repertorio de Instrucciones (ISA): computadora von Neumann, datos, instrucciones, programación.</a> | ⌂ Home: <a href="eecc_book.html">Estructura de Computadores  (240306)</a> | Next: <a href="_programación_en_lenguaje_ensamblador_x86_construcciones_básicas_de_los_lenguajes_de_alto_nivel.html">Programación en Lenguaje Ensamblador (x86): Construcciones básicas de los lenguajes de alto nivel.</a> →</p>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2022-11-03 13:10:16 +0100
</div>
</div>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]],
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },
  TeX: { equationNumbers: { autoNumber: "none" } }
})
MathJax.Hub.Register.StartupHook("AsciiMath Jax Ready", function () {
  MathJax.InputJax.AsciiMath.postfilterHooks.Add(function (data, node) {
    if ((node = data.script.parentNode) && (node = node.parentNode) && node.classList.contains("stemblock")) {
      data.math.root.display = "block"
    }
    return data
  })
})
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
</body>
</html>