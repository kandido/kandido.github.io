<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui"><title>Estructura de Computadores</title><link rel="stylesheet" href="reveal.js/css/reset.css"><link rel="stylesheet" href="reveal.js/css/reveal.css"><link rel="stylesheet" href="reveal.js/css/theme/white.css" id="theme"><!--This CSS is generated by the Asciidoctor reveal.js converter to further integrate AsciiDoc's existing semantic with reveal.js--><style type="text/css">.reveal div.right {
  float: right
}

/* listing block */
.reveal .listingblock.stretch > .content {
  height: 100%
}

.reveal .listingblock.stretch > .content > pre {
  height: 100%
}

.reveal .listingblock.stretch > .content > pre > code {
  height: 100%;
  max-height: 100%
}

/* tables */
table {
  border-collapse: collapse;
  border-spacing: 0
}

table {
  margin-bottom: 1.25em;
  border: solid 1px #dedede
}

table thead tr th, table thead tr td, table tfoot tr th, table tfoot tr td {
  padding: .5em .625em .625em;
  font-size: inherit;
  text-align: left
}

table tr th, table tr td {
  padding: .5625em .625em;
  font-size: inherit
}

table thead tr th, table tfoot tr th, table tbody tr td, table tr td, table tfoot tr td {
  display: table-cell;
  line-height: 1.6
}

td.tableblock > .content {
  margin-bottom: 1.25em
}

td.tableblock > .content > :last-child {
  margin-bottom: -1.25em
}

table.tableblock, th.tableblock, td.tableblock {
  border: 0 solid #dedede
}

table.grid-all > thead > tr > .tableblock, table.grid-all > tbody > tr > .tableblock {
  border-width: 0 1px 1px 0
}

table.grid-all > tfoot > tr > .tableblock {
  border-width: 1px 1px 0 0
}

table.grid-cols > * > tr > .tableblock {
  border-width: 0 1px 0 0
}

table.grid-rows > thead > tr > .tableblock, table.grid-rows > tbody > tr > .tableblock {
  border-width: 0 0 1px
}

table.grid-rows > tfoot > tr > .tableblock {
  border-width: 1px 0 0
}

table.grid-all > * > tr > .tableblock:last-child, table.grid-cols > * > tr > .tableblock:last-child {
  border-right-width: 0
}

table.grid-all > tbody > tr:last-child > .tableblock, table.grid-all > thead:last-child > tr > .tableblock, table.grid-rows > tbody > tr:last-child > .tableblock, table.grid-rows > thead:last-child > tr > .tableblock {
  border-bottom-width: 0
}

table.frame-all {
  border-width: 1px
}

table.frame-sides {
  border-width: 0 1px
}

table.frame-topbot, table.frame-ends {
  border-width: 1px 0
}

.reveal table th.halign-left, .reveal table td.halign-left {
  text-align: left
}

.reveal table th.halign-right, .reveal table td.halign-right {
  text-align: right
}

.reveal table th.halign-center, .reveal table td.halign-center {
  text-align: center
}

.reveal table th.valign-top, .reveal table td.valign-top {
  vertical-align: top
}

.reveal table th.valign-bottom, .reveal table td.valign-bottom {
  vertical-align: bottom
}

.reveal table th.valign-middle, .reveal table td.valign-middle {
  vertical-align: middle
}

table thead th, table tfoot th {
  font-weight: bold
}

tbody tr th {
  display: table-cell;
  line-height: 1.6
}

tbody tr th, tbody tr th p, tfoot tr th, tfoot tr th p {
  font-weight: bold
}

thead {
  display: table-header-group
}

.reveal table.grid-none th, .reveal table.grid-none td {
  border-bottom: 0 !important
}

/* kbd macro */
kbd {
  font-family: "Droid Sans Mono", "DejaVu Sans Mono", monospace;
  display: inline-block;
  color: rgba(0, 0, 0, .8);
  font-size: .65em;
  line-height: 1.45;
  background: #f7f7f7;
  border: 1px solid #ccc;
  -webkit-border-radius: 3px;
  border-radius: 3px;
  -webkit-box-shadow: 0 1px 0 rgba(0, 0, 0, .2), 0 0 0 .1em white inset;
  box-shadow: 0 1px 0 rgba(0, 0, 0, .2), 0 0 0 .1em #fff inset;
  margin: 0 .15em;
  padding: .2em .5em;
  vertical-align: middle;
  position: relative;
  top: -.1em;
  white-space: nowrap
}

.keyseq kbd:first-child {
  margin-left: 0
}

.keyseq kbd:last-child {
  margin-right: 0
}

/* callouts */
.conum[data-value] {
  display: inline-block;
  color: #fff !important;
  background: rgba(0, 0, 0, .8);
  -webkit-border-radius: 50%;
  border-radius: 50%;
  text-align: center;
  font-size: .75em;
  width: 1.67em;
  height: 1.67em;
  line-height: 1.67em;
  font-family: "Open Sans", "DejaVu Sans", sans-serif;
  font-style: normal;
  font-weight: bold
}

.conum[data-value] * {
  color: #fff !important
}

.conum[data-value] + b {
  display: none
}

.conum[data-value]:after {
  content: attr(data-value)
}

pre .conum[data-value] {
  position: relative;
  top: -.125em
}

b.conum * {
  color: inherit !important
}

.conum:not([data-value]):empty {
  display: none
}

/* Callout list */
.hdlist > table, .colist > table {
  border: 0;
  background: none
}

.hdlist > table > tbody > tr, .colist > table > tbody > tr {
  background: none
}

td.hdlist1, td.hdlist2 {
  vertical-align: top;
  padding: 0 .625em
}

td.hdlist1 {
  font-weight: bold;
  padding-bottom: 1.25em
}

/* Disabled from Asciidoctor CSS because it caused callout list to go under the
 * source listing when .stretch is applied (see #335)
 * .literalblock+.colist,.listingblock+.colist{margin-top:-.5em} */
.colist td:not([class]):first-child {
  padding: .4em .75em 0;
  line-height: 1;
  vertical-align: top
}

.colist td:not([class]):first-child img {
  max-width: none
}

.colist td:not([class]):last-child {
  padding: .25em 0
}

/* Override Asciidoctor CSS that causes issues with reveal.js features */
.reveal .hljs table {
  border: 0
}

/* Callout list rows would have a bottom border with some reveal.js themes (see #335) */
.reveal .colist > table th, .reveal .colist > table td {
  border-bottom: 0
}

/* Fixes line height with Highlight.js source listing when linenums enabled (see #331) */
.reveal .hljs table thead tr th, .reveal .hljs table tfoot tr th, .reveal .hljs table tbody tr td, .reveal .hljs table tr td, .reveal .hljs table tfoot tr td {
  line-height: inherit
}

/* Columns layout */
.columns .slide-content {
  display: flex;
}

.columns.wrap .slide-content {
  flex-wrap: wrap;
}

.columns.is-vcentered .slide-content {
  align-items: center;
}

.columns .slide-content > .column {
  display: block;
  flex-basis: 0;
  flex-grow: 1;
  flex-shrink: 1;
}

.columns .slide-content > .column > * {
  padding: .75rem;
}

/* See #353 */
.columns.wrap .slide-content > .column {
  flex-basis: auto;
}

.columns .slide-content > .column.is-full {
  flex: none;
  width: 100%;
}

.columns .slide-content > .column.is-four-fifths {
  flex: none;
  width: 80%;
}

.columns .slide-content > .column.is-three-quarters {
  flex: none;
  width: 75%;
}

.columns .slide-content > .column.is-two-thirds {
  flex: none;
  width: 66.6666%;
}

.columns .slide-content > .column.is-three-fifths {
  flex: none;
  width: 60%;
}

.columns .slide-content > .column.is-half {
  flex: none;
  width: 50%;
}

.columns .slide-content > .column.is-two-fifths {
  flex: none;
  width: 40%;
}

.columns .slide-content > .column.is-one-third {
  flex: none;
  width: 33.3333%;
}

.columns .slide-content > .column.is-one-quarter {
  flex: none;
  width: 25%;
}

.columns .slide-content > .column.is-one-fifth {
  flex: none;
  width: 20%;
}

.columns .slide-content > .column.has-text-left {
  text-align: left;
}

.columns .slide-content > .column.has-text-justified {
  text-align: justify;
}

.columns .slide-content > .column.has-text-right {
  text-align: right;
}

.columns .slide-content > .column.has-text-left {
  text-align: left;
}

.columns .slide-content > .column.has-text-justified {
  text-align: justify;
}

.columns .slide-content > .column.has-text-right {
  text-align: right;
}

.text-left {
  text-align: left !important
}

.text-right {
  text-align: right !important
}

.text-center {
  text-align: center !important
}

.text-justify {
  text-align: justify !important
}

.footnotes {
  border-top: 1px solid rgba(0, 0, 0, 0.2);
  padding: 0.5em 0 0 0;
  font-size: 0.65em;
  margin-top: 4em;
}
</style><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/v4-shims.min.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({
tex2jax: {
  inlineMath: [["\\(", "\\)"]],
  displayMath: [["\\[", "\\]"]],
  ignoreClass: "nostem|nolatexmath"
},
asciimath2jax: {
  delimiters: [["\\$", "\\$"]],
  ignoreClass: "nostem|noasciimath"
},
TeX: { equationNumbers: { autoNumber: "none" } }
});</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script><!--Printing and PDF exports--><script>var link = document.createElement( 'link' );
link.rel = 'stylesheet';
link.type = 'text/css';
link.href = window.location.search.match( /print-pdf/gi ) ? "reveal.js/css/print/pdf.css" : "reveal.js/css/print/paper.css";
document.getElementsByTagName( 'head' )[0].appendChild( link );</script><link rel="stylesheet" href="styles/mipruebaCSS.css"></head><body><div class="reveal"><div class="slides"><section class="title" data-state="title"><h1>Estructura de Computadores</h1></section><section id="_indice"><h2>Indice</h2><div class="slide-content"><div class="paragraph"><p>Tema 1: <a href="#Tema1_Intro">Introducción a la Asignatura Estructura de Computadores.</a><br>
Tema 2: <a href="#Tema2_VonNeum">Arquitectura de Von Neumann.</a><br>
Tema 3: Representación Digital de la Información: <a href="#Tema3_RepDatos">Los Datos</a>: <a href="#ascii">ASCII </a>, <a href="#num_nat">Nº Naturales</a>, <a href="#num_ent">Nº Enteros</a><br>
Tema 4: Operaciones Aritméticas y Lógicas: <a href="#op_nat">Nº Naturales</a>, <a href="#op_ent">Nº Enteros</a>, <a href="#op_log">Operaciones Lógicas</a><br>
Tema 5: <a href="#Tema5_RepInstrucciones">Representación Digital de la Información: las Instrucciones.</a><br>
Tema 6: <a href="#Tema6_ProgAsm">Programación en Lenguaje Ensamblador (x86): Construcciones básicas de los lenguajes de alto nivel.</a><br>
Ejercicios Teoría: <a href="#Tema1-6_Ejer">Ejercicios Propuestos Temas 1-6</a><br>
Programas ASM Propuestos: <a href="#Prac_Ejer_I">Al finalizar el 1º Parcial</a><br>
Tema 3: <a href="#Tema3_Float">Representación de los Datos: Números Reales</a><br>
Tema 7: <a href="#Tema7_CPU">Unidad Central de Proceso.</a><br>
Tema 8: <a href="#Tema8_IO">Mecanismos de Entrada/Salida</a><br>
Tema 9: <a href="#Tema9_MEM">Unidad de Memoria.</a></p></div></div></section>
<section><section id="Tema1_Intro"><h2>Tema 1 : Introducción a la Asignatura Estructura de Computadores.</h2></section><section id="_indice_2"><h2>Indice.</h2><div class="slide-content"><div class="ulist"><ul><li><p>Profesorado</p></li><li><p>Organización Académica</p><div class="ulist"><ul><li><p>Programa</p></li><li><p>Prácticas</p></li><li><p>Ejercicios</p></li><li><p>Evaluación</p></li><li><p>Metodología</p></li></ul></div></li></ul></div></div></section><section id="_profesorado"><h2>Profesorado</h2><div class="slide-content"><div class="ulist"><ul><li><p>Profesor Cándido Aramburu Mayoz.</p><div class="ulist"><ul><li><p>Doctor Ingeniero Telecomunicación (UPNA-Universidad Politécnica de Madrid)</p></li><li><p>Empresa Ikusi S.A. (Sistemas de Telemedida 1989)</p></li><li><p>Profesor Titular UPNA (Dpto Ingeniería Electrónica y Comunicaciones 2000)</p></li></ul></div></li><li><p>Profesor Teoría: Carlos Juan de Dios</p></li><li><p>Profesor Prácticas: Andrés Garde</p></li></ul></div>
<aside class="notes"><div class="ulist"><ul><li><p><a href="https://www.etsit.upm.es/" class="bare">https://www.etsit.upm.es/</a></p></li><li><p><a href="https://www.velatia.com/es/empresas-que-forman-velatia/ikusi/" class="bare">https://www.velatia.com/es/empresas-que-forman-velatia/ikusi/</a></p></li><li><p><a href="https://www.unavarra.es/eu/sites/Portada/home.html" class="bare">https://www.unavarra.es/eu/sites/Portada/home.html</a></p></li></ul></div></aside></div></section><section id="_organización_académica"><h2>Organización Académica</h2></section><section id="_aulas_y_horarios"><h2>Aulas y Horarios</h2><div class="slide-content"><div class="ulist"><ul><li><p>Aulas</p><div class="ulist"><ul><li><p>Teoría: G91 &#8594; A019, G1 &#8594;A113, G2&#8594;A122</p></li><li><p>Prácticas: P91&#8594;A015, P1&#8594;A305, P2&#8594;E-ISM, P3&#8594;E-ISM</p></li><li><p>E-ISM : Edificio “Las Encinas” , lado derecho entre la Biblioteca y el Rectorado) en el Sótano, Laboratorio de Informática “ISM”</p></li></ul></div></li><li><p>Horario</p><div class="ulist"><ul><li><p>Teoría: G91(L-15:00), G1(X-17:00), G2(L-17:00)</p></li><li><p>Prácticas: P91(X-19:00), P1(J-17:00), P2(M-19:00), P3(M-17:00)</p></li></ul></div></li></ul></div></div></section><section id="_tutorías"><h2>Tutorías</h2><div class="slide-content"><div class="ulist"><ul><li><p>Despacho: Edificio Los Tejos 2 Planta: Despacho 2028 (Prof. Candido Aramburu)</p></li><li><p>Miaulario &#8594; correo interno</p></li><li><p><a href="https://www.unavarra.es/pdi?uid=364&amp;dato=tutorias">Tutorías</a></p><div class="ulist"><ul><li><p>Lunes (10-13) y  Miércoles (10-13)</p></li></ul></div></li></ul></div></div></section><section id="_programa_de_la_asignatura"><h2>Programa de la Asignatura</h2><div class="slide-content"><div class="ulist"><ul><li><p><a href="https://www.unavarra.es/ficha-asignaturaDOA?languageId=100000&amp;codPlan=240&amp;codAsig=240306&amp;anio=2023">Ficha Web Upna</a></p><div class="ulist"><ul><li><p>Programa en 3 partes</p><div class="olist lowerroman"><ol class="lowerroman" type="i"><li><p><strong><em>C</em></strong></p></li><li><p><strong><em>C</em></strong></p></li><li><p>Otros:</p></li></ol></div></li></ul></div></li></ul></div></div></section><section id="_bibliografía"><h2>Bibliografía</h2><div class="slide-content"><div class="ulist"><ul><li><p>Fundamentos de Electrónica Digital. Cecilio Blanco</p></li></ul></div></div></section><section id="_metodología"><h2>Metodología</h2><div class="slide-content"><div class="ulist"><ul><li><p>Trabajo en clase: principalmente Ejercicios con su teoría asociada</p></li></ul></div></div></section><section id="_prácticas"><h2>Prácticas</h2><div class="slide-content"><div class="ulist"><ul><li><p>Tipo de prácticas:</p></li></ul></div></div></section><section id="_ejercicios"><h2>Ejercicios</h2><div class="slide-content"><div class="ulist"><ul><li><p>x</p></li></ul></div></div></section><section id="_evaluación"><h2>Evaluación</h2><div class="slide-content"><div class="ulist"><ul><li><p>Sistema de Evaluación:</p><div class="ulist"><ul><li><p>35% teoría , 35% prácticas, 15% programación en papel, 15% otros</p></li></ul></div></li></ul></div></div></section></section>
<section><section id="Tema2_VonNeum" class="columns"><h2>Tema 2 : Arquitectura de Von Neumann</h2></section><section id="_indice_3"><h2>Indice</h2><div class="slide-content"><div class="ulist column"><ul><li><p>P</p></li></ul></div>
<div class="ulist column"><ul><li><p>O</p></li></ul></div></div></section><section id="_qué_conocemos_de_una_computadora"><h2>Qué conocemos de una computadora</h2><div class="slide-content"><div class="ulist"><ul><li><p>CPU? 3GHz? RAM? Memoria? 12GB? Disco Duro? Tarjeta gráfica? Pantalla? Ethernet? Placa base?</p></li><li><p>Hardware, Software, Firmware? BIOS? Windows? Linux?</p></li><li><p>Cuál es su arquitectura? Qué se entiende por arquitectura?</p></li></ul></div></div></section><section id="_organización_de_una_computadora_niveles"><h2>Organización de una computadora: niveles</h2><div class="slide-content"><div class="ulist"><ul><li><p>Los elementos básicos de una computadora desde el punto de vista del programador se pueden organizar por NIVELES:</p><div class="ulist"><ul><li><p>del nivel más bajo y cercano a la máquina al nivel más alto y cercano al programador.</p></li></ul></div></li></ul></div>
<div class="imageblock"><img src="images/eecc_tema2_niveles.svg" alt="eecc tema2 niveles"></div></div></section><section id="_organización_de_una_computadora_llamadas"><h2>Organización de una computadora: llamadas</h2><div class="slide-content"><div class="ulist"><ul><li><p>Cada nivel llama a un nivel inferior</p></li></ul></div>
<div class="imageblock"><img src="images/eecc_tema2_niveles_call.svg" alt="eecc tema2 niveles call"></div></div></section><section id="_organización_de_un_automóvil_concepto_de_abstracción"><h2>Organización de un automóvil: concepto de Abstracción</h2><div class="slide-content"><div class="ulist"><ul><li><p>Un símil sería la relación entre un conductor y el coche. El coche físico (motor,ventilador,ejes,inyector,válvulas,caja de cambios,etc&#8230;&#8203;) se <strong>ABSTRAE</strong> y para el conductor un coche son unos pedales, una palanca de cambios y un volante. La Arquitectura del coche también se podría describir por niveles, del nivel más bajo al nivel más alto, al más abstracto.</p></li><li><p>El conductor conduce (programa) una máquina ABSTRACTA: acelera,frena,cambia y gira. No tiene por qué saber que la máquina real, la física, lleva aceite, ni siquiera tiene que saber que son necesarias unas ruedas.</p></li><li><p>Gracias a la abstracción las máquinas se acercan en su uso a los humanos.</p></li><li><p>Es necesario saber el QUE hace una máquina y no el COMO lo hace.</p></li></ul></div></div></section><section id="_organización_de_una_computadora_isa" class="columns" data-state="txikiago"><h2>Organización de una computadora: ISA</h2><div class="slide-content"><div class="openblock column"><div class="content"><div class="ulist"><ul><li><p>El Hardware de la computadora tiene como función interpretar y ejecutar un conjunto de instrucciones con el objeto de procesar datos para obtener algún tipo de resultado.</p><div class="ulist"><ul><li><p>lenguaje de la máquina : lenguaje binario</p></li><li><p>las instrucciones y los datos de la máquina están en lenguaje binario: 0,1</p></li><li><p>instrucciones máquina: P.ej sumar dos datos (números enteros) &#8594;</p><div class="ulist"><ul><li><p>instrucción suma de 2 más 5 en código máquina: 0101010001000010101010101</p></li><li><p>misma instrucción máquina pero en lenguaje ensamblador (texto): add 2,5</p></li><li><p>La CPU mediante sus circuitos electrónicos digitales realiza la suma binaria de los dos datos binarios</p></li></ul></div></li></ul></div></li></ul></div></div></div>
<div class="openblock column"><div class="content"><div class="ulist"><ul><li><p><strong>I.S.A</strong> : Instruction Set Architecture</p><div class="ulist"><ul><li><p>Arquitectura del Conjunto de Instrucciones máquina de una computadora</p></li><li><p>Conjunto: sumar, restar, mover un dato, saltar a una instrucción de memoria</p></li><li><p>Arquitectura:</p><div class="ulist"><ul><li><p>instrucciones: qué operaciones? ¿cuál es el tamaño de una instrucción?¿cuantos operandos tiene?¿cuál es su código binario? ¿cómo se hace referencia a un operando?</p></li><li><p>datos: tipo de datos: enteros?reales? su tamaño? su codificación?</p></li></ul></div></li></ul></div></li></ul></div></div></div></div></section><section id="_organización_de_una_computadora_isa_2"><h2>Organización de una computadora: ISA</h2><div class="slide-content"><div class="ulist"><ul><li><p>El Hardware de la computadora tiene como nivel superior las instrucciones máquina que es capaz de ejecutar y los datos máquina que es capaz de ejecutar</p></li></ul></div>
<div class="imageblock"><img src="images/eecc_tema2_isa.svg" alt="align:left"></div>
<div class="imageblock"><img src="images/eecc_tema2_niveles_isa.svg" alt="eecc tema2 niveles isa"></div></div></section><section id="_organización_de_una_computadora_isa_3" class="columns" data-state="txikiago"><h2>Organización de una computadora: ISA</h2><div class="slide-content"><div class="ulist"><ul><li><p>Un programador de bajo nivel , pej los creadores de sistemas operativos, de compiladores, etc&#8230;&#8203;, necesitan conocer la ISA de la máquina.</p></li><li><p>La programación de un sistema operativo como Windows  y Linux, en los lenguajes C y el lenguaje ensamblador, requiere conocer la arquitectura ISA.</p></li><li><p>Los manuales ISA de un microprocesador tienen toda la información que necesita el programador, por lo tanto el programador de bajo nivel no necesita conocer todo el hardware interno de la CPU, de la memoria y de los controladores de entrada salida, sino únicamente la información disponible en el manual ISA.</p></li><li><p>Para el programador la máquina es la ISA, el programador ve una máquina ABSTRACTA, ve la FUNCION de la máquina, QUÉ hace la máquina&#8230;&#8203;y no COMO lo hace.</p></li><li><p>En el laboratorio programaremos en lenguaje del nivel más bajo, es decir, en el lenguaje de la máquina pero no en binario sino en modo texto mediante el lenguaje ensamblador. Las operaciones de las instrucciones de la máquina en lenguaje ensamblador se expresan mediante mnemónicos como ADD, SUB, LOAD, MOV &#8230;&#8203; que son reducciones de palabras inglesas.</p></li><li><p>Buscar en google los manuales isa de intel x86 de 64 bits que son ejecutados por los microprocesadores de intel: core i3, core i5, core i7, etc&#8230;&#8203;</p></li></ul></div></div></section><section id="_una_máquina_abstracta_y_muchas_reales_compatibilidad"><h2>Una máquina abstracta y muchas reales: compatibilidad</h2><div class="slide-content"><div class="ulist"><ul><li><p>De la misma forma que cuan do aprendemos a conducir (pedales+cambio+volante) nos sirve para cualquier coche, la <strong>arquitectura del conjunto de instrucciones</strong> es la misma para múltiples procesadores.</p></li><li><p>La ISA amd64 ó x86-64 es la misma para todos los procesadores de Intel (core,xeon,etc&#8230;&#8203;) o de AMD (Ryzen, etc). De esta forma un programa binario que se ejecute en un core-i7 también lo puede hacer en un Ryzen 9.HON</p></li></ul></div></div></section><section id="_programa_en_lenguaje_texto_suma_de_los_5_primeros_números_enteros"><h2>Programa en lenguaje texto: suma de los 5 primeros números enteros</h2><div class="slide-content"><div class="ulist"><ul><li><p>Algoritmo \(\sum_{i=1}^{5}i\)</p></li><li><p>Lenguaje de texto Python</p><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-python hljs" data-noescape="true" data-lang="python">sum(range(5,0,-1))</code></pre></div></div></li></ul></div></div></section><section id="_programa_en_lenguaje_texto_suma_de_los_5_primeros_números_enteros_2" class="columns" data-state="txikiago"><h2>Programa en lenguaje texto: suma de los 5 primeros números enteros</h2><div class="slide-content"><div class="listingblock column"><div class="content"><pre class="highlightjs highlight"><code class="language-C hljs" data-noescape="true" data-lang="C">/*
 Programa: sum1toN.c
 Descripción:
   1+2+3+4+...+N
*/
#include &lt;stdlib.h&gt;
int main ()
{
  short N=5,y;
  while(N&gt;=0)
    y+=N--;
  exit(y);
}</code></pre></div></div>
<div class="listingblock column"><div class="content"><pre class="highlightjs highlight"><code class="language-java hljs" data-noescape="true" data-lang="java">/* Programa Fuente: sum1toN.java
 compilación: javac sum1toN.java -&gt; sum1toN.class
 ejecución   -&gt; java -cp . sum1toN
*/
public class sum1toN {
// método main encapsulado en la clase class
  public static void main(String[] args) {
    System.out.println("Suma de Números enteros");
      int x=5, suma=0;
    while (x &gt;= 0 ) {
      System.out.print( x );
      System.out.print(",");
      suma=suma+x;
      x--;
      }
    System.out.print("\n");
    System.out.print("suma="+suma);
    System.out.print("\n");
  }
}</code></pre></div></div></div></section><section id="_módulo_binario_en_código_binario" data-state="txikiago"><h2>Módulo binario: en código binario</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-shell hljs" data-noescape="true" data-lang="shell">gcc -o sum1toN sum1toN.c
    -&gt; genera el módulo ejecutable sum1toN para la arquitectura x86-64 +
ls -l sum1toN -&gt; 16696 bytes
file sum1toN
   sum1toN: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV),
   dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2,
   BuildID[sha1]=8df3de7b9ba05ceb7861b39d703c8ef11161284a, for GNU/Linux 3.2.0,
   not   stripped</code></pre></div></div>
<div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-vhdl, x86asm, x86asmatt hljs" data-noescape="true" data-lang="vhdl, x86asm, x86asmatt">gcc -m32 sum1toM sum1toN.c
  -&gt; genera el módulo ejecutable sum1toN para la arquitectura x86-32
hexdump sum1toN
  0000000 457f 464c 0102 0001 0000 0000 0000 0000
  0000010 0003 003e 0001 0000 1060 0000 0000 0000
  0000020 0040 0000 0000 0000 3978 0000 0000 0000
  0000030 0000 0000 0040 0038</code></pre></div></div>
<div class="paragraph"><p>programa ejecutable en código <strong>hexadecimal</strong>, más compacto que el binario<br>
1ª columna: direcciones, apuntan o hacen referencia a un byte<br>
2ª columna:<br>
---  4 dígitos hexadecimales del contenido. Si cada dígito hexadecimal equivale a 4 bits, dos dígitos hex. equivalen a 1 byte.<br>
---  457f: 2 bytes de código ejecutable<br>
---  No podemos interpretar el código binario, pero el procesador x86-64 sí.</p></div></div></section><section id="_interpretación_del_código_binario_del_programa_sum1ton" data-state="txikiago"><h2>Interpretación del código binario (del programa sum1toN)</h2><div class="slide-content"><div class="ulist"><ul><li><p>Desensamblador: convierte el código binario en código texto ENSAMBLADOR</p></li><li><p>objdump -d sum1toN</p><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-vhdl, x86asm, x86asmatt hljs" data-noescape="true" data-lang="vhdl, x86asm, x86asmatt">Disassembly of section .text:

0000000000001060 &lt;_start&gt;:
    1060:	f3 0f 1e fa          	endbr64
    1064:	31 ed                	xor    %ebp,%ebp
    1066:	49 89 d1             	mov    %rdx,%r9
    1069:	5e                   	pop    %rsi
    106a:	48 89 e2             	mov    %rsp,%rdx
    106d:	48 83 e4 f0          	and    $0xfffffffffffffff0,%rsp
    1071:	50                   	push   %rax
    1072:	54                   	push   %rsp
    1073:	4c 8d 05 86 01 00 00 	lea    0x186(%rip),%r8
    107a:	48 8d 0d 0f 01 00 00 	lea    0x10f(%rip),%rcx
    1081:	48 8d 3d c1 00 00 00 	lea    0xc1(%rip),%rdi
    1088:	ff 15 52 2f 00 00    	callq  *0x2f52(%rip)
    108e:	f4                   	hlt
    108f:	90                   	nop

    .....       ....................    .........................

0000000000001149 &lt;main&gt;:
    1149:	f3 0f 1e fa          	endbr64
    114d:	55                   	push   %rbp
    114e:	48 89 e5             	mov    %rsp,%rbp
    1151:	48 83 ec 10          	sub    $0x10,%rsp
    1155:	66 c7 45 fc 05 00    	movw   $0x5,-0x4(%rbp)
    115b:	eb 19                	jmp    1176 &lt;main+0x2d&gt;
    115d:	0f b7 45 fc          	movzwl -0x4(%rbp),%eax
    1161:	89 c2                	mov    %eax,%edx
    1163:	83 ea 01             	sub    $0x1,%edx
    1166:	66 89 55 fc          	mov    %dx,-0x4(%rbp)
    116a:	89 c2                	mov    %eax,%edx
    116c:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
    1170:	01 d0                	add    %edx,%eax
    1172:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
    1176:	66 83 7d fc 00       	cmpw   $0x0,-0x4(%rbp)
    117b:	79 e0                	jns    115d &lt;main+0x14&gt;
    117d:	0f bf 45 fe          	movswl -0x2(%rbp),%eax
    1181:	89 c7                	mov    %eax,%edi
    1183:	e8 c8 fe ff ff       	callq  1050 &lt;exit@plt&gt;
    1188:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    118f:	00</code></pre></div></div></li></ul></div>
<div class="paragraph"><p>1ª columna: dirección de referencia a la instrucción<br>
<br>
2ª columna:  código máquina en hexadecimal<br>
<br>
3ª columna:  código de operación de la instrucción en <strong>lenguaje ensamblador</strong><br>
<br>
4ª columna:  operandos de la instrucción en <strong>lenguaje ensamblador</strong>.</p></div></div></section><section id="_lenguaje_ensamblador"><h2>Lenguaje Ensamblador</h2><div class="slide-content"><div class="ulist"><ul><li><p>Es el lenguaje máquina traducido del binario a TEXTO para poder programar módulos fuente los programadores</p></li><li><p>El formato de la instrucción ensamblador se compone principalmente de 2 campos:</p><div class="ulist"><ul><li><p>campo del código de operación mediante MNEMONICOS como push(insertar),mov(mover),add(sumar),jmp(saltar),jne(saltar si not equal), etv</p></li><li><p>campo de los operandos de la operación: son referencias a memoria donde está el operando ó se pone el propio operando</p></li></ul></div></li></ul></div></div></section><section id="_institute_advanced_machine_ias" class="columns"><h2>Institute Advanced Machine (IAS)</h2><div class="slide-content"><div class="ulist column"><ul><li><p><a href="https://es.wikipedia.org/wiki/M%C3%A1quina_de_von_Neumann">John von Neumann</a></p><div class="ulist"><ul><li><p>Matemático húngaro 1903</p></li><li><p>Proyecto Manhattan &#8594; Bomba atómica</p></li><li><p>Concepto de Arquitectura von Neumann de un Computador</p></li></ul></div></li></ul></div>
<div class="ulist column"><ul><li><p><a href="https://es.wikipedia.org/wiki/Arquitectura_de_Von_Neumann">Arquitectura de von Neumann</a></p><div class="ulist"><ul><li><p><a href="https://es.wikipedia.org/wiki/ENIAC">máquina ENIAC</a>: programa cableado</p></li><li><p><a href="https://es.wikipedia.org/wiki/EDVAC">máquina EDVAC</a>: programa almacenado &#8594; *unidad de memoria</p><div class="ulist"><ul><li><p>arquitectura von neumann: unidad de procesamiento + unidad de memoria + unidad de entrada salida</p></li><li><p><a href="https://www.youtube.com/watch?v=jhlSEIbxO0E">youtube EDVAC</a></p></li></ul></div></li></ul></div></li></ul></div></div></section><section id="_repertorio_de_la_máquina_ias_tabla" data-state="taula_txi"><h2>Repertorio de la máquina IAS: tabla</h2><div class="slide-content"><table class="tableblock frame-all grid-all" style="width:100%"><caption class="title">Table 1. Instruction Set I</caption><colgroup><col style="width:8.3333%"><col style="width:16.6666%"><col style="width:8.3333%"><col style="width:50%"><col style="width:16.6668%"></colgroup><thead><tr><th class="tableblock halign-left valign-top">Instruction name</th><th class="tableblock halign-left valign-top">Instruction name</th><th class="tableblock halign-center valign-top">Op Code</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Register Transfer Language (RTL)</th></tr><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock">S(x)&#8594;Ac+</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">LOAD M(X)</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">copy the number in Selectron location x into AC</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">AC &#8592; M[x]</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">S(x)&#8594;Ac-</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">LOAD -M(X)</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">same as #1 but copy the negative of the number</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">AC &#8592; ~M[x]+1</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">S(x)&#8594;AcM</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">LOAD |M(X)|</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">same as #1 but copy the absolute value</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">AC &#8592; |M[x]|</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">S(x)&#8594;Ac-M</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">LOAD -|M(X)|</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">same as #1 but subtract the absolute value</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">AC &#8592; AC-|M[x]|</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">S(x)&#8594;Ah+</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">ADD M(X)</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">5</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">add the number in Selectron location x into AC</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">S(x)&#8594;Ah-</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">SUB M(X)</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">6</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">subtract the number in Selectron location x from AC</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">S(X)&#8594;AhM</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">ADD |M(X)|</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">same as #5, but add the absolute value</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">S(X)&#8594;Ah-M</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">SUB |M(X)|</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">8</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">same as #7, but subtract the absolute value</p></td><td class="tableblock halign-left valign-top"></td></tr></table></div></section><section id="_repertorio_de_la_máquina_ias_tabla_2" data-state="taula_txi"><h2>Repertorio de la máquina IAS: tabla</h2><div class="slide-content"><table class="tableblock frame-all grid-all" style="width:100%"><caption class="title">Table 2. Instruction Set II</caption><colgroup><col style="width:8.3333%"><col style="width:16.6666%"><col style="width:8.3333%"><col style="width:50%"><col style="width:16.6668%"></colgroup><thead><tr><th class="tableblock halign-left valign-top">Instruction name</th><th class="tableblock halign-left valign-top">Instruction name</th><th class="tableblock halign-center valign-top">Op Code</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Register Transfer Language (RTL)</th></tr><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock">S(x)&#8594;R</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">LOAD MQ,M(X)</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">9</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">copy the number in Selectron location x into AR</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">R&#8594;A</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">LOAD MQ</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">A</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">copy the number in AR to AC</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">S(x)*R&#8594;A</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">MUL M(X)</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">B</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Multiply the number in Selectron location x by the number in AR. Place the left half of the result in AC and the right half in AR.</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">A/S(x)&#8594;R</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">DIV M(X)</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">C</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Divide the number in AC by the number in Selectron location x. Place the quotient in AR and the remainder in AC.</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Cu&#8594;S(x)</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">JUMP M(X,0:19)</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">D</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Continue execution at the left-hand instruction of the pair at Selectron location x</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Cu`&#8594;S(x)</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">JUMP M(X,20:39)</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">E</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Continue execution at the right-hand instruction of the pair at Selectron location x</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Cc&#8594;S(x)</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">JUMP+ M(X,0:19)</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">If the number in AC is &gt;= 0, continue as in #D. Otherwise, continue normally.</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Cc`&#8594;S(x)</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">JUMP+ M(X,20:39)</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">10</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">If the number in AC is &gt;= 0, continue as in #E. Otherwise, continue normally.</p></td><td class="tableblock halign-left valign-top"></td></tr></table></div></section><section id="_repertorio_de_la_máquina_ias_tabla_3" data-state="taula"><h2>Repertorio de la máquina IAS: tabla</h2><div class="slide-content"><table class="tableblock frame-all grid-all" style="width:100%"><caption class="title">Table 3. Instruction Set III</caption><colgroup><col style="width:8.3333%"><col style="width:16.6666%"><col style="width:8.3333%"><col style="width:50%"><col style="width:16.6668%"></colgroup><thead><tr><th class="tableblock halign-left valign-top">Instruction name</th><th class="tableblock halign-left valign-top">Instruction name</th><th class="tableblock halign-center valign-top">Op Code</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Register Transfer Language (RTL)</th></tr><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock">At&#8594;S(x)</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">STOR M(X)</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">11</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Copy the number in AC to Selectron location x</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Ap&#8594;S(x)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-center valign-top"><p class="tableblock">12</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Replace the right-hand 12 bits of the left-hand instruction at Selectron location x by the right-hand 12 bits of the AC</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Ap`&#8594;S(x)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-center valign-top"><p class="tableblock">13</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Same as #12 but modifies the right-hand instruction</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">L</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">LSH</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">14</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Shift the number in AC to the left 1 bit (new bit on the right is 0)</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">R</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">RSH</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">15</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Shift the number in AC to the right 1 bit (leftmost bit is copied)</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">halt</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Halt the program (see paragraph 6.8.5 of the IAS r)</p></td><td class="tableblock halign-left valign-top"></td></tr></table></div></section><section id="_repertorio_de_la_máquina_ias_explicación"><h2>Repertorio de la máquina IAS: explicación</h2><div class="slide-content"><div class="ulist"><ul><li><p>En la versión original no había código ensamblador, se programaba directamente en lenguaje máquina.</p><div class="ulist"><ul><li><p>La 1ª columna: MNEMÓNICOS del lenguaje ensamblador del simulador académico IASSIM</p></li><li><p>En la 2ª columna, los <strong>MNEMONICOS</strong> (LOAD,ADD,SUB,etc) de las operaciones de las instrucciones se corresponden con los diseñados por el libro de texto de William Stalling.</p></li><li><p>La 3ª columna describe la instrucción mediante el lenguaje de texto convencional</p></li><li><p>La última columna describe la instrucción mediante un lenguaje de transferencia entre registros RTL</p></li></ul></div></li></ul></div></div></section><section id="_ias_de_la_máquina_isa" class="columns" data-state="txikiago"><h2>IAS de la máquina ISA</h2><div class="slide-content"><div class="openblock column"><div class="content"><div class="imageblock"><img src="images/eecc_tema2_instr_formato.svg" alt="eecc tema2 instr formato"></div>
<div class="imageblock"><img src="images/eecc_tema2_data_format.svg" alt="eecc tema2 data format"></div>
<div class="ulist"><ul><li><p>Formato de datos</p><div class="ulist"><ul><li><p>longitud de 40 bits</p></li><li><p>números enteros con signo: código complemento a 2</p></li></ul></div></li></ul></div></div></div>
<div class="openblock column"><div class="content"><div class="ulist"><ul><li><p>Instrucciones: Sólo tiene 16 instrucciones por lo que el procesador es muy sencillo.</p></li><li><p>Formato de las instrucciones</p><div class="ulist"><ul><li><p>Tamaño fijo de 20 bit</p></li><li><p>la instrucción esta organizada en 2 campos: el campo de operaciones y el campo de operando</p></li><li><p>campo de operación: longitud de 8 bits &#8594; operaciones del tipo sumar,mover,saltar</p></li><li><p>campo de operando: longitud de 12 bits</p></li></ul></div></li></ul></div></div></div></div></section><section id="_memoria_de_la_máquina_ias" data-state="txikiago"><h2>Memoria de la máquina IAS</h2><div class="slide-content"><div class="openblock"><div class="content"><div class="imageblock"><img src="images/eecc_tema2_memoria.svg" alt="eecc tema2 memoria"></div>
<div class="paragraph"><p>La memoria almacena el programa que ha de ejecutar la CPU<br>
El programa se encuentra codificado en lenguaje binario<br>
El programa es una secuencia de instrucciones y datos<br>
Los puertos de la memoria son MAR y MBR<br>
La dirección de memoria en código binario es la entrada del circuito decodificador que activa una de sus salidas</p></div></div></div></div></section><section id="_alu_de_la_máquina_ias"><h2>ALU de la máquina IAS</h2><div class="slide-content"><div class="imageblock"><img src="images/eecc_tema2_ALU.svg" alt="eecc tema2 ALU"></div></div></section><section id="_unidad_de_control_de_la_máquina_ias" data-state="txikiago"><h2>Unidad de Control de la máquina IAS</h2><div class="slide-content"><div class="openblock"><div class="content"><div class="imageblock"><img src="images/eecc_tema2_control-unit.svg" alt="eecc tema2 control unit"></div>
<div class="paragraph"><p>La unidad de control es el circuito digital microelectrónico que lleva a efecto el ciclo de instrucción de cada instrucción
ciclo de instrucción: cada instrucción pasa por 3 fases<br>
- captura de la instrucción por la unidad de control<br>
- intepretación de la instrucción por la unidad de control<br>
- ejecución de la instrucción por la unidad de control<br>
circuito secuenciador: electrónica para la secuencia de fases del ciclo de instrucción<br>
IR: almacena la instrucción a interpretar<br>
PC: apunta a la siguiente instrucción que tiene que comenzar su ciclo de instrucción</p></div></div></div></div></section><section id="_unidad_de_control_de_la_máquina_ias_2" data-state="txikiago"><h2>Unidad de Control de la máquina IAS</h2><div class="slide-content"><div class="openblock"><div class="content"><div class="imageblock"><img src="images/eecc_tema2_mem-uc-alu-bus.svg" alt="eecc tema2 mem uc alu bus"></div>
<div class="paragraph"><p>bus de datos: 40 hilos<br>
bus de direcciones: 12 hilos<br>
bus de control (memoria): micro-órdenes de lectura y escritura<br>
bus de control (ALU): micro-órdenes de operaciones de suma,resta,and,or,etc..</p></div></div></div></div></section><section id="_ciclo_de_instrucción" class="columns"><h2>Ciclo de instrucción</h2><div class="slide-content"><div class="imageblock column"><img src="images/eecc_tema2_ciclo-instruccion.svg" alt="eecc tema2 ciclo instruccion"></div>
<div class="ulist column"><ul><li><p>Ejecución de un programa en la máquina IAS de von Neumann</p><div class="ulist"><ul><li><p>Las instrucciones se ejecutan una detrás de otra, secuencialmente</p></li><li><p>Todas las instrucciones pasan por las distintas fases del ciclo de instrucción.</p></li></ul></div></li></ul></div></div></section><section id="_ciclo_de_instrucción_animación"><h2>Ciclo de instrucción: Animación</h2><div class="slide-content"><div class="ulist"><ul><li><p>Programa en lenguaje máquina</p></li><li><p>3 instrucciones</p></li><li><p>Ruta de datos: transferencia de instrucciones y de datos a través de los registros y los buses</p></li><li><p>Buses externos al procesador: buses de conexión entre el chip procesador y la tarjeta de  memoria &#8594; buses de direcciones, datos y lectura/escritura</p></li><li><p>Buses internos al procesador: microbuses entre registros, ALU y unidad de control</p></li><li><p>Se va a visualizar la transferencia de información entre registros a través de la ruta de datos de la computadora</p></li><li><p><a href="https://www.youtube.com/watch?v=04UGopESS6A">Animación del ciclo instrucción</a></p></li></ul></div></div></section></section>
<section><section id="Tema3_RepDatos"><h2>Tema 3 : Representación Digital de la Información: los DATOS</h2></section><section id="_indice_4" class="columns" data-state="txikiago"><h2>Indice</h2><div class="slide-content"><div class="ulist column"><ul><li><p>Información: números, caracteres, imagen, sonido, etc ..</p></li><li><p>Prefijos</p></li><li><p>Digitalización de las señales</p></li><li><p>Números</p><div class="ulist"><ul><li><p>Sistemas posicionales: base 10 (decimales), base 2 (binaria), base 16 (hexadecimal)</p></li><li><p>Naturales: bases 10,2,8,16 . Conversión entre bases</p></li><li><p>Enteros: Signo Magnitud,  Complemento a la base</p></li><li><p>Operaciones aritméticas: Suma,Resta</p></li><li><p>Operaciones lógicas: not,and,or,xor,desplazamiento de bits.</p></li></ul></div></li></ul></div>
<div class="ulist column"><ul><li><p>Caracteres</p><div class="ulist"><ul><li><p>Alfanuméricos y Signos de Puntuación</p></li><li><p>ASCII standard y extendido</p></li></ul></div></li></ul></div></div></section><section id="_representación_científica_y_prefijos_de_las_unidades"><h2>Representación Científica y Prefijos de las Unidades</h2><div class="slide-content"><table class="tableblock frame-all grid-all" style="width:100%"><caption class="title">Table 4. Prefijos</caption><colgroup><col style="width:27.2727%"><col style="width:9.0909%"><col style="width:9.0909%"><col style="width:9.0909%"><col style="width:9.0909%"><col style="width:9.0909%"><col style="width:9.0909%"><col style="width:9.0909%"><col style="width:9.091%"></colgroup><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Prefijos</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">Tera</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">Giga</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">Mega</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">Kilo</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">mili</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">micro</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">nano</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">pico</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Base 10 &#8594; magnitudes:m,gr,Hz, ..</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">10<sup>12</sup></p></td><td class="tableblock halign-center valign-top"><p class="tableblock">10<sup>9</sup></p></td><td class="tableblock halign-center valign-top"><p class="tableblock">10<sup>6</sup></p></td><td class="tableblock halign-center valign-top"><p class="tableblock">10<sup>3</sup></p></td><td class="tableblock halign-center valign-top"><p class="tableblock">10<sup>-3</sup></p></td><td class="tableblock halign-center valign-top"><p class="tableblock">10<sup>-6</sup></p></td><td class="tableblock halign-center valign-top"><p class="tableblock">10<sup>-9</sup></p></td><td class="tableblock halign-center valign-top"><p class="tableblock">10<sup>-12</sup></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Base 2 &#8594; magnitudes: Byte</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>40</sup></p></td><td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>30</sup></p></td><td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>20</sup></p></td><td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>10</sup></p></td><td class="tableblock halign-center valign-top"><p class="tableblock">&#8201;&#8212;&#8201;</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">&#8201;&#8212;&#8201;</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">&#8201;&#8212;&#8201;</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">&#8201;&#8212;&#8201;</p></td></tr></table>
<div class="ulist text-left"><ul><li><p>Ejemplo: representar la magnitud=1000000000Hz debidamente</p><div class="ulist"><ul><li><p>Notación científica &#8594; 10<sup>9</sup>Hz</p></li><li><p>Debidamente: Notación científica con prefijos f=1GHz &#8594; T=1/f=10<sup>-9</sup>seg= 1ns</p></li></ul></div></li><li><p>Ejemplo: capacidad de la memoria en Bytes</p><div class="ulist"><ul><li><p>1KB &#8594; 1 Kilo-Byte &#8594; 2<sup>10</sup> Bytes &#8594; 1024 Bytes</p></li><li><p>16KB &#8594; 16 Kilo-Bytes &#8594; 2<sup>4</sup> '*' 2<sup>10</sup> Bytes &#8594; 2<sup>14</sup> Bytes &#8594; 4096 Bytes</p></li><li><p>1MB  &#8594; 1 Mega-Byte &#8594; 2<sup>20</sup> Bytes &#8594; 1048576 Bytes</p></li></ul></div></li></ul></div></div></section><section id="_señales_conversión_analógica_digital"><h2>Señales: Conversión Analógica Digital</h2></section><section id="_analogica_vs_digital"><h2>Analogica vs Digital</h2><div class="slide-content"><div class="ulist"><ul><li><p>Señal Continua</p><div class="ulist"><ul><li><p>Amplitud: \$oo\$ valores posibles en el rango</p></li><li><p>Tiempo: \$oo\$ valores posibles en el rango</p></li></ul></div></li><li><p>Señal Discreta ó Digital</p><div class="ulist"><ul><li><p>Amplitud: finitos valores posibles en el rango</p></li><li><p>Tiempo: finitos valores posibles en el rango</p></li></ul></div></li></ul></div></div></section><section id="_señales_muestreo_y_cuantificación"><h2>Señales : Muestreo y Cuantificación</h2><div class="slide-content"><div class="paragraph"><p><span class="image"><img src="images/muestreo_cuantificacion.jpg" alt="Mountain" width="900" height="400"></span></p></div></div></section><section id="_codificación"><h2>Codificación</h2><div class="slide-content"><div class="paragraph"><p><span class="image" style="float: left"><img src="images/ADC_codigo.webp" alt="Mountain" width="600" height="500"></span></p></div>
<div class="paragraph text-left"><p>Calcular para las resoluciones de 3 bit y 16 bits cual es el mínimo incremento de señal codificable o error de cuantificación: con 3 bits el número de niveles es 2<sup>3</sup>=8niveles y el mínimo relativo es 2<sup>-3</sup>=1/8; con 16 bits el número de niveles es 2<sup>16</sup> y el mínimo relativo es 2<sup>-16</sup>= 1/65536.</p></div>
<div class="paragraph text-left"><p>Representación de los números en código binario : <a href="#Tema3_RepDatos">[Tema3_RepDatos]</a></p></div></div></section><section id="_señales_binarias_abstractas"><h2>Señales Binarias : Abstractas</h2><div class="slide-content"><div class="paragraph"><p><span class="image" style="float: left"><img src="images/clock-signals.png" alt="Mountain" width="400" height="300"></span></p></div>
<div class="paragraph text-left"><p>Eje ordenada: valores abstractos (0/1, High/Low, ON/OFF, etc &#8230;&#8203;).<br>
Cronograma: Representación temporal de las señales digitales binarias.<br>
Esa representación típica de los libros de texto, pizarra de clase, etc &#8230;&#8203; es ideal ya que físicamente siempre habrá distorsión.</p></div></div></section><section id="_señales_binarias_físicas"><h2>Señales Binarias : Físicas</h2><div class="slide-content"><div class="paragraph"><p><span class="image" style="float: left"><img src="images/Digital-signal-noise.svg.png" alt="Mountain" width="400" height="300"></span></p></div>
<div class="paragraph text-left"><p>Eje ordenada: magnitudes físicas (mV ó mA).<br>
La señal física está distorsionada por causas como pej: línea larga de transmisión (efectos capacitivos e inductivos).<br>
Un ejemplo típico de distorsión son los tiempos de subida y bajada, que no son nulos sino del orden de unos nanosegundos.<br>
La distancia considerable entre los dos niveles (binario) a la entrada del receptor hace fácil la discriminación entre el '0' y el '1'.</p></div></div></section><section id="_digitalización_de_las_señales"><h2>Digitalización de las Señales</h2></section><section id="_ventajas"><h2>Ventajas</h2><div class="slide-content"><div class="ulist"><ul><li><p>Calidad: Fácil de recuperar a pesar de la distorsión</p></li><li><p>Almacenamiento: Fiabilidad, Diversidad Formatos</p></li><li><p>Compatibilidad: Diversidad de Equipos (PC, móvil, coche, etc</p></li><li><p>Procesamiento: Sencillo, Flexible</p></li><li><p>Coste: Barato (componentes)</p></li></ul></div></div></section><section id="_abstracción"><h2>Abstracción</h2><div class="slide-content"><div class="ulist"><ul><li><p>Niveles: el 0 y el 1</p></li><li><p>Lógica binaria</p><div class="ulist"><ul><li><p>Matemáticas: Algebra de Boole</p></li></ul></div></li></ul></div></div></section></section>
<section><section id="ascii"><h2>Tema 3 :Representación de los Caracteres</h2></section><section id="_representación_de_los_caracteres"><h2>Representación de los Caracteres</h2><div class="slide-content"><div class="ulist"><ul><li><p>Tipos de Caracteres:</p><div class="ulist"><ul><li><p>Alfanuméricos: a,b,&#8230;&#8203;z.0,1,&#8230;&#8203;9,A,B&#8230;&#8203;Z</p></li><li><p>Signos de Puntuación: !"$%&amp;/()=</p></li><li><p>de Control: Salto de Línea (\n), Find de Fichero (EOF), Fin de String (\00, &#8230;&#8203;)</p></li></ul></div></li><li><p>Formatos</p><div class="ulist"><ul><li><p>ASCII: standard y extendido</p></li><li><p>Unicode: UTF-8</p></li></ul></div></li></ul></div></div></section><section id="_ascii_standard" class="columns"><h2>ASCII Standard</h2><div class="slide-content"><div class="listingblock column zutabe"><div class="content"><pre class="highlightjs highlight"><code class="language-vhdl, x86asm, x86asmatt hljs" data-noescape="true" data-lang="vhdl, x86asm, x86asmatt">          2 3 4 5 6 7       30 40 50 60 70 80 90 100 110 120
        -------------      ---------------------------------
       0:   0 @ P ` p     0:    (  2  &lt;  F  P  Z  d   n   x
       1: ! 1 A Q a q     1:    )  3  =  G  Q  [  e   o   y
       2: " 2 B R b r     2:    *  4  &gt;  H  R  \  f   p   z
       3: # 3 C S c s     3: !  +  5  ?  I  S  ]  g   q   {
       4: $ 4 D T d t     4: "  ,  6  @  J  T  ^  h   r   |
       5: % 5 E U e u     5: #  -  7  A  K  U  _  i   s   }
       6: &amp; 6 F V f v     6: $  .  8  B  L  V  `  j   t   ~
       7: ' 7 G W g w     7: %  /  9  C  M  W  a  k   u  DEL
       8: ( 8 H X h x     8: &amp;  0  :  D  N  X  b  l   v
       9: ) 9 I Y i y     9: '  1  ;  E  O  Y  c  m   w
       A: * : J Z j z
       B: + ; K [ k {
       C: , &lt; L \ l |
       D: - = M ] m }
       E: . &gt; N ^ n ~
       F: / ? O _ o DEL</code></pre></div></div>
<div class="paragraph column zutabe_gehi"><p>American Standard Code for Information Interchange<br>
Alfabeto anglosajón<br>
7 bits &#8594; 2<sup>7</sup>=128 caracteres : 0x00 hasta 0x1F son 32 caracteres de control y el resto alfanuméricos<br>
En hexadecimal rango [0x00-0x7F]<br>
En decimal rango [0-127]<br>
<strong>Upna</strong> : 0x55706E61<br>
<strong>año 2023</strong>: 0x61&#8212;&#8203;6F2032303233</p></div></div></section><section id="_ascii_extendido"><h2>ASCII Extendido</h2><div class="slide-content"><div class="ulist"><ul><li><p>Para poder representar caracteres de otras culturas Europeas es necesrio expandir el standard con 1 bit más</p></li><li><p>ASCII 8 bits &#8594; 2<sup>8</sup> = 256 caracteres</p></li><li><p><a href="https://www.programiz.com/python-programming/online-compiler/">Python Intepreter Shell</a></p><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-python hljs" data-noescape="true" data-lang="python">ord('A')
hex(ord('A'))
hex(ord('\n'))
chr(65)
chr(0x41)
[hex(ord(c)) for c in "Hola"]
[chr(c) for c in [0x48, 0x6f, 0x6c, 0x61, 0x20, 0x4d, 0x75, 0x6e, 0x64, 0x6f]]
[hex(ord(c)) for c in "ñ"]
[hex(ord(c)) for c in "\n \t"]</code></pre></div></div>
<div class="ulist"><ul><li><p>La ñ tiene el código ASCII 0xF1</p></li></ul></div></li></ul></div></div></section></section>
<section><section id="num_nat"><h2>Tema 3: Representación de los Números NATURALES</h2></section><section id="_representación_de_los_números_decimales" data-state="taula"><h2>Representación de los Números Decimales</h2><div class="slide-content"><div class="ulist text-left"><ul><li><p>Decimal</p><div class="ulist"><ul><li><p>10 dígitos : 0,1,2,3,4,5,6,7,8,9</p></li><li><p>Pesos con base 10 : 10<sup>n</sup> donde n es la posición del dígito dentro del número</p></li></ul></div></li><li><p>Ejemplo: número 5421</p></li></ul></div>
<table class="tableblock frame-all grid-all" style="width:100%"><caption class="title">Table 5. Número 5451</caption><colgroup><col style="width:42.8571%"><col style="width:14.2857%"><col style="width:14.2857%"><col style="width:14.2857%"><col style="width:14.2858%"></colgroup><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Representación:</strong></p></td><td class="tableblock halign-center valign-top" colspan="4"><p class="tableblock">los símbolos 5421</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Posiciones:</strong></p></td><td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Pesos:</strong></p></td><td class="tableblock halign-center valign-top"><div><div class="paragraph"><p>10<sup>3</sup> &#8594; 1000</p></div></div></td><td class="tableblock halign-center valign-top"><p class="tableblock">10<sup>2</sup> &#8594; 100</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">10<sup>1</sup>&#8594;10</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">10<sup>0</sup>&#8594;1</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Dígitos:</strong></p></td><td class="tableblock halign-center valign-top"><div><div class="paragraph"><p>5</p></div></div></td><td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">5</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Valores : ponderación</strong></p></td><td class="tableblock halign-center valign-top"><div><div class="paragraph"><p>5*1000=cinco mil</p></div></div></td><td class="tableblock halign-center valign-top"><p class="tableblock">4*100=cuatrocientos</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">5*10=cincuenta</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">1*1=uno</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Valor:</strong></p></td><td class="tableblock halign-center valign-top" colspan="4"><p class="tableblock">5*1000+4*100+5*10+1= cinco mil cuatrocientos cincuenta y uno</p></td></tr></table></div></section><section id="_representación_de_los_valores_naturales_en_código_binario" data-state="taula"><h2>Representación de los Valores Naturales en Código Binario</h2><div class="slide-content"><div class="ulist"><ul><li><p>¿Número?¿Valor?¿Código?¿Representación?</p><div class="ulist"><ul><li><p>2 dígitos : 0,1</p></li><li><p>Pesos con base 2 : 2<sup>n</sup> donde n es la posición del dígito dentro del número: &#8230;&#8203;.-1024-512-256-128-64-32-16-8-4-2-1&#8230;&#8203;</p></li></ul></div></li><li><p>Ejemplo: número 0b1011</p></li></ul></div>
<table class="tableblock frame-all grid-all" style="width:100%"><caption class="title">Table 6. Número 0b1011</caption><colgroup><col style="width:42.8571%"><col style="width:14.2857%"><col style="width:14.2857%"><col style="width:14.2857%"><col style="width:14.2858%"></colgroup><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Representación:</strong></p></td><td class="tableblock halign-center valign-top" colspan="4"><p class="tableblock">los símbolos 1011</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Posiciones:</strong></p></td><td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Pesos:</strong></p></td><td class="tableblock halign-center valign-top"><div><div class="paragraph"><p>2<sup>3</sup> &#8594; 8</p></div></div></td><td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>2</sup> &#8594; 4</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>1</sup>&#8594;2</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">2<sup>0</sup>&#8594;1</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Dígitos:</strong></p></td><td class="tableblock halign-center valign-top"><div><div class="paragraph"><p>1</p></div></div></td><td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Valores : ponderación</strong></p></td><td class="tableblock halign-center valign-top"><div><div class="paragraph"><p>1*8=ocho</p></div></div></td><td class="tableblock halign-center valign-top"><p class="tableblock">0*4=cero</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">1*2=dos</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">1*1=uno</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Valor:</strong></p></td><td class="tableblock halign-center valign-top" colspan="4"><p class="tableblock">ocho+cero+dos+uno= once</p></td></tr></table></div></section><section id="_representación_de_los_valores_naturales_en_código_binario_2"><h2>Representación de los Valores Naturales en Código Binario</h2><div class="slide-content"><div class="ulist"><ul><li><p>¿Cómo se representa en binario el valor 123.125? b1111011.001</p></li><li><p>¿Cómo se calcula el valor del número binario b1111011.001?</p></li><li><p>Parte Entera: divisiones sucesivas por la base 2</p></li><li><p>Parte Fracción: multiplicaciones sucesivas por la base 2</p></li></ul></div></div></section><section id="_representación_de_los_valores_naturales_en_código_octal"><h2>Representación de los Valores Naturales en Código Octal</h2><div class="slide-content"><div class="ulist"><ul><li><p>Dígitos: 0,1,2,3,4,5,6,7</p></li><li><p>Posiciones y Pesos</p></li><li><p>¿Cómo se representa en octal el valor 123.125? 0o173.1</p></li><li><p>¿Cómo se calcula el valor del número octal 0o173.1?</p></li><li><p>Parte Entera: divisiones sucesivas por la base 8</p></li><li><p>Parte Fracción: multiplicaciones sucesivas por la base 8</p></li></ul></div></div></section><section id="_representación_de_los_valores_naturales_en_hexadecimal"><h2>Representación de los Valores Naturales en Hexadecimal</h2><div class="slide-content"><div class="ulist"><ul><li><p>Dígitos: 0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F <em>_</em> el valor de A es 10, B&#8594;11, C&#8594;12, D&#8594;13, E-14, F&#8594;15</p></li><li><p>Posiciones y Pesos</p></li><li><p>¿Cómo se representa en hexadecimal el valor 123.125? 0x7B.2</p></li><li><p>¿Cómo se calcula el valor del número octal 0x7B.2?</p></li><li><p>Parte Entera: divisiones sucesivas por la base 16</p></li><li><p>Parte Fracción: multiplicaciones sucesivas por la base 16</p></li></ul></div></div></section><section id="_calculadora_de_python"><h2>Calculadora de Python</h2><div class="slide-content"><div class="ulist"><ul><li><p><a href="https://www.programiz.com/python-programming/online-compiler/">Python Intepreter Shell</a></p><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-python hljs" data-noescape="true" data-lang="python">bin(123)
oct(123)
hex(123)
int(0b1111011)
int(0o173)
int(0x7B)</code></pre></div></div></li></ul></div></div></section><section id="_conversiones_entre_el_sistema_binario_y_sistemas_con_base_potencia_de_2" class="columns"><h2>Conversiones entre el sistema binario y sistemas con base potencia de 2</h2><div class="slide-content"><div class="ulist column"><ul><li><p>Conversión Binaria-Hexadecimal</p><div class="ulist"><ul><li><p>base 16=2<sup>4</sup></p></li><li><p>grupos de 4 bits empezando por la dcha</p></li><li><p>b1111011 &#8594;  111 - 1011  &#8594; 0x7B</p></li></ul></div></li><li><p>Conversión Hexadecimal-Binaria</p><div class="ulist"><ul><li><p>grupos de 4 bits</p></li></ul></div></li></ul></div>
<div class="ulist column"><ul><li><p>Conversión Binaria-Octal</p><div class="ulist"><ul><li><p>base 8=2<sup>3</sup></p></li><li><p>grupos de 3 bits empezando por la dcha</p></li><li><p>b1111011 &#8594; 1 - 111 - 011  &#8594; 0o173</p></li></ul></div></li><li><p>Conversión Octal-Binaria</p><div class="ulist"><ul><li><p>grupos de 3 bits</p></li></ul></div></li></ul></div></div></section></section>
<section><section id="op_nat"><h2>Tema 4 : Operaciones Aritméticas con los Números NATURALES</h2></section><section id="_suma_binaria"><h2>Suma binaria</h2><div class="slide-content"><div class="ulist"><ul><li><p>Suma 10011011+00011011 = 10110110</p><div class="literalblock"><div class="content"><pre>  Llevadas --&gt;          1 1   1 1

                    1 0 0 1 1 0 1 1  &lt;--sumando
                  + 0 0 0 1 1 0 1 1  &lt;--sumando

  Valor suma        1 0 1 3 2 1 3 2  &lt;- ¿cómo se representan los valores de cada posición?
                  *****************
  Resultado --&gt;     1 0 1 1 0 1 1 0  &lt;--suma</pre></div></div></li><li><p>LLEVADA</p><div class="ulist"><ul><li><p>Valor suma: el valor 3 de la posición 1 &#8594; 3*2¹=6 &#8594; 110</p><div class="ulist"><ul><li><p>el dígito 1 de la posición 1 es el resultado</p></li><li><p>el dígito 1 de la posición 2 es la LLEVADA</p></li></ul></div></li><li><p>Conclusión:Cuando la suma en una posición específica tiene un valor es mayor o igual a la base hay que restar <strong>n</strong> veces la base y el valor <strong>n</strong> será la llevada a sumar en la posición siguiente.</p></li></ul></div></li></ul></div></div></section><section id="_resta_binaria"><h2>Resta binaria</h2><div class="slide-content"><div class="ulist"><ul><li><p>Resta 10110110 - 10011011 = 00011011</p><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-vhdl, x86asm, x86asmatt hljs" data-noescape="true" data-lang="vhdl, x86asm, x86asmatt">Sumar crédito al minuendo            2  2     2  2

                            1  0  1  1  0  1  1  0  &lt;--minuendo
      	                  - 1  0  0  1  1  0  1  1  &lt;--sustraendo


Sumar llevada al sustraendo       1  1     1  1
                          *************************
Resta                       0  0  0  1  1  0  1  1</code></pre></div></div></li><li><p>Cuando en una posición específica el minuendo es menor que el sustraendo se suma la base al minuendo antes de realizar la resta y se suma la llevada al sustraendo de la posición siguiente.</p></li></ul></div></div></section><section id="_aritmética_modular_la_rueda"><h2>Aritmética Modular: la rueda</h2><div class="slide-content"><div class="imageblock" style="float: left"><img src="images/rueda_unsigned.png" alt="Rueda" width="500" height="500"></div>
<div class="paragraph text-left"><p>Representación binaria de números con 3 digitos.<br>
2<sup>3</sup> : 8 combinaciones posibles,&#8594; MODULO 8<br>
Ejemplo: cuentakilómetros del coche.<br>
Ejemplo: registro de 3 celdas &#8594; limitado a 8 combinaciones posibles.<br>
¿Cual es la siguiente combinación a 111?, 111+1 = ¿ ?.<br>
Calcular la representación del valor 33 en módulo 8 &#8594; Resto(33/8)=1 &#8594; en binario 001<br>
33 pasos en la rueda equivale al número 001 &#8594; aritmética modular en módulo 8</p></div></div></section><section id="_operaciones_aritméticas_hexadecimal"><h2>Operaciones aritméticas: Hexadecimal</h2><div class="slide-content"><div class="ulist"><ul><li><p>Base hexadecimal</p><div class="ulist"><ul><li><p>0xD1B+0xAFF = 0x181A</p></li><li><p>0xE53-0xBAA = 0x2A9</p></li></ul></div></li></ul></div></div></section></section>
<section><section id="num_ent"><h2>Tema 3 :Representación de los Números ENTEROS</h2></section><section id="_representación_de_números_con_valores_enteros"><h2>Representación de Números con Valores Enteros</h2><div class="slide-content"><div class="ulist"><ul><li><p>Signo-Magnitud</p></li><li><p>Complemento a la base</p></li></ul></div></div></section><section id="_representación_en_signo_magnitud" data-state="txikiago"><h2>Representación en Signo-Magnitud</h2><div class="slide-content"><div class="ulist"><ul><li><p>Signo &#8594; un bit (Binary digIT)</p></li><li><p>Base 2 :</p><div class="ulist"><ul><li><p>valores positivos: el signo el <strong>bit 0</strong> en la posición MSB (More Significant Bit) y resto de bits representa el mód</p></li><li><p>valores negativos: el signo el <strong>bit 1</strong> (base-1) en la posición MSB (More Significant Bit) y resto de bits representa el módulo</p></li><li><p>Ejemplo +123 &#8594; 0b01111011 y -123 &#8594; 0b11111011</p></li><li><p>Dibujar la tabla y la rueda con todos los valores con sus representaciones.</p></li><li><p>¿Cuantas representaciones son posibles?¿Es simétrico el rango de valores representado?¿Cuantas representaciones tiene el cero?</p></li><li><p>¿Cuál es la relación entre los números positivos y negativos?</p></li><li><p>Extender el número de bits del número sin cambiar su valor</p></li></ul></div></li></ul></div></div></section><section id="_extensión_del_signo_en_signo_magnitud"><h2>Extensión del signo en Signo-Magnitud</h2><div class="slide-content"><div class="ulist"><ul><li><p>Números positivos</p><div class="ulist"><ul><li><p>¿Cuánto vale un cero a la izda?</p></li><li><p>Extender el valor  '+123' a 12 bits &#8594; 000001111011</p></li></ul></div></li><li><p>Números negativos</p><div class="ulist"><ul><li><p>¿Cuánto vale &#8230;&#8203;. a la izda?</p></li><li><p>Extender el valor -123 a 12 bits &#8594; Convertimos el valor positivo en negativo</p><div class="ulist"><ul><li><p>100001111011</p></li></ul></div></li></ul></div></li></ul></div></div></section><section id="_representación_en_complemento_a_la_base_2_c2" data-state="txikiago"><h2>Representación en complemento a la base 2 : C2</h2><div class="slide-content"><div class="ulist"><ul><li><p>Signo &#8594; un dígito</p></li><li><p>Base 2: Complemento a 2 &#8594; <strong>C2</strong></p></li><li><p>Valores positivos: Definición: igual que los valores positivos en código Signo-Magnitud</p></li><li><p>Valores negativos: Definición: Hay que restar el código del valor en positivo del  minuendo 0000000 (base)</p><div class="ulist"><ul><li><p>Ejemplo '+123' &#8594; 0b01111011 y -123 &#8594; <strong>00000000-01111011</strong> = 0b100000101</p></li><li><p><strong>Alternativa 1</strong> a la definición: El código del valor negativo se puede calcular invirtiendo los bits del código del valor positivo y después sumarle 1</p><div class="ulist"><ul><li><p>Equivale a calcular el C1 y sumarle 1</p></li></ul></div></li><li><p><strong>Alternativa 2</strong> a la definición: El código del valor negativo se puede calcular a partir del código del valor positivo</p><div class="ulist"><ul><li><p>empezando por la dcha repetir los bits hasta el primer uno e invertir el resto de bits</p></li></ul></div></li></ul></div></li></ul></div></div></section><section id="_representación_en_complemento_a_la_base_2_c2_2"><h2>Representación en complemento a la base 2 : C2</h2><div class="slide-content"><div class="ulist"><ul><li><p>¿Cuál es la relación entre los números positivos y negativos?</p><div class="ulist"><ul><li><p>El C2 de un número positivo es el código C2 de su valor en negativo</p></li><li><p>El C2 de un número negativo es el código C2 de su valor en positivo</p></li><li><p>Dibujar la tabla y la rueda con todos los valores con sus representaciones.</p></li><li><p>¿Cuantas representaciones son posibles?¿Es simétrico el rango de valores representado?¿Cuantas representaciones tiene el cero?</p></li><li><p>Extender el número de bits del número sin cambiar su valor &#8594; Extensión del bit de SIGNO</p></li></ul></div></li></ul></div></div></section><section id="_extensión_del_signo_en_c2" data-state="txiki"><h2>Extensión del signo en C2</h2><div class="slide-content"><table class="tableblock frame-all grid-all" style="width:100%"><caption class="title">Table 7. Razonamiento de la extensión de signo de un número negativo: números de 3 bits</caption><colgroup><col style="width:33.3333%"><col style="width:33.3333%"><col style="width:33.3334%"></colgroup><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Valor</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">C2 sin extensión</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">C2 con extensión</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">+33</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">0100001</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">00100001</p></td></tr><tr><td class="tableblock halign-left valign-top" rowspan="4"><p class="tableblock">-33</p></td><td class="tableblock halign-left valign-top"><div class="literal"><pre> 0000000
-0100001
--------
 1011111</pre></div></td><td class="tableblock halign-left valign-top"><div class="literal"><pre> 00000000
-00100001
---------
 11011111</pre></div></td></tr></table>
<div class="ulist"><ul><li><p>Aplicamos la definición para los dos ejemplos, el segundo caso es una extensión del primero ya que hemos añadido un digito más al minuendo y al sustraendo:</p><div class="ulist"><ul><li><p>Se observa que en el C2 con extensión, al hacer la resta y extender con un 0 más el minuendo y el substraendo, provoca la extensión con un bit más en la resta de valor 1 en el digito más significante. Según añado ceros al minuendo y sustraendo, aparecen unos en la resta sin alterar su valor.</p></li></ul></div></li></ul></div></div></section><section id="_asimetría_del_rango_en_c2_4_con_3_bits"><h2>Asimetría del rango en C2: -4 con 3 bits</h2><div class="slide-content"><div class="ulist"><ul><li><p>Con números de 3 bits el formato S-M es simétrico con valores en el rango (+3,-3), en cambio el formato C2 tiene el rango (+3,-4)</p></li><li><p>En C2 el valor +4 se representa como 0b0100 y necesita por lo tanto 4 bits, no se puede representar con 3 bits, y el valor -4 se reprenta con el C2(0100), es decir, 1100 también con 4 bits. El 1100 se puede comprimir ya que tiene el signo extendido con la repetición de 1 de bit más significativo, por lo que la representación 100 es la representación del -4</p></li></ul></div></div></section><section id="_complemento_a_2_ejemplos"><h2>Complemento a 2 : Ejemplos</h2><div class="slide-content"><div class="ulist"><ul><li><p>0b101010101 está en C2 &#8594; ¿Cual es su valor?</p><div class="ulist"><ul><li><p>como es negativo no es un sistema posicional</p></li><li><p>tenemos que calcular el valor negativo a través del valor positivo</p></li><li><p>La representación del valor positivo es el C2 del valor negativo</p><div class="ulist"><ul><li><p>C2(0b101010101) = 0b010101011 cuyo valor es 2<sup>7</sup>+2<sup>5</sup>+2<sup>3</sup>+2<sup>1</sup>+2<sup>0</sup>=128+32+8+2+1=+171</p></li><li><p>El valor de 0b101010101 es -171</p></li></ul></div></li></ul></div></li><li><p>Si la representación de -123 es 0b100000101 ¿cual es la de '+123' ?</p><div class="ulist"><ul><li><p>C2(0b100000101)=0b011111011 representa el valor '+123'</p></li></ul></div></li></ul></div></div></section><section id="_número_en_complemento_a_2_y_base_hexadecimal"><h2>Número en complemento a 2 y base hexadecimal</h2><div class="slide-content"><div class="admonitionblock caution"><table><tr><td class="icon"><i class="fa fa-fire" title="Caution"></i></td><td class="content">Un número
 binario se puede representar en hexadecimal y hacer la interpretación en complento a 2. Hay que tener cuidado con las extensiones del signo</td></tr></table></div>
<div class="ulist"><ul><li><p>Calcular el valor del número 0xAAA si dicho número tiene formato en complemento a 2</p><div class="ulist"><ul><li><p>si lo convertimos a binario el número empieza por 1, luego es negativo</p></li><li><p>para saber su valor calculo su complementario C2 y tendré la representación del positivo</p><div class="ulist"><ul><li><p>0x000-0xAAA =0x556 &#8594; 5*16<sup>2</sup>+5*16<sup>1</sup>+5*16<sup>0</sup> = 5*256+5*16+5 = 1280+80+5 = '+213' &#8594; 0xAAA tiene de valor -213</p></li></ul></div></li></ul></div></li></ul></div></div></section><section id="_número_en_complemento_a_2_y_base_hexadecimal_2"><h2>Número en complemento a 2 y base hexadecimal</h2><div class="slide-content"><div class="ulist"><ul><li><p>Realizar la suma de los números en formato complemento a 2: 0x80+0x80</p><div class="ulist"><ul><li><p>sumar sin extender el signo de los operandos ¿Hay overflow?</p><div class="admonitionblock caution"><table><tr><td class="icon"><i class="fa fa-fire" title="Caution"></i></td><td class="content">Extender el número 0x80. ¿ Por qué hay que tener cuidado ?</td></tr></table></div></li></ul></div></li><li><p>sumar extendiendo un dígito el signo de los operandos 0x80</p></li></ul></div></div></section><section id="_extensión_del_signo_en_c2_problema_de_la_base" data-state="taula_ta"><h2>Extensión del signo en C2: problema de la BASE</h2><div class="slide-content"><table class="tableblock frame-all grid-all" style="width:100%"><caption class="title">Table 8. Extensión del Signo del Nº 0x80 en C2 en binario, hexadecimal y octal</caption><colgroup><col style="width:14.2857%"><col style="width:42.8571%"><col style="width:42.8572%"></colgroup><tbody><tr><td class="tableblock halign-center valign-top"><p class="tableblock">NºBits</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Binario</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Hexadecimal</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">8</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">10000000</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">1000_0000 &#8594;   0x80</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">9</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">110000000</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">1111_1000_0000 &#8594;  0xF80</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">10</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">1110000000</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">1111_1000_0000 &#8594;  0xF80</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">11</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">11110000000</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">1111_1000_0000 &#8594;  0xF80</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">12</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">111110000000</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">1111_1000_0000 &#8594;  0xF80</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">13</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">1111110000000</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">1111_1111_1000_0000 &#8594; 0xFF80</p></td></tr></table></div></section></section>
<section><section id="op_ent"><h2>Tema 4 :Operaciones Aritméticas con los números ENTEROS</h2></section><section id="_operaciones_aritméticas_suma_y_resta"><h2>Operaciones Aritméticas: Suma y Resta</h2></section><section id="_operaciones_aritméticas_en_c2" class="columns" data-state="txiki"><h2>Operaciones aritméticas en C2</h2><div class="slide-content"><div class="ulist column"><ul><li><p>Suma</p><div class="ulist"><ul><li><p>Se realiza de la misma manera como se ha visto para números naturales.</p></li><li><p>Si hay llevada en el MSBit, NO se tiene en cuenta, se elimina.</p></li><li><p>A=0b11011011. Suma A+A</p><div class="literalblock"><div class="content"><pre>Llevadas -&gt; 1 1   1 1   1 1

              1 1 0 1 1 0 1 1 (Valor -37)
            + 1 1 0 1 1 0 1 1 (Valor -37)

Valor suma      2 1 3 2 1 3 2
            *****************
Resultado --&gt; 1 0 1 1 0 1 1 0&lt;--(Valor -74)</pre></div></div></li></ul></div></li></ul></div>
<div class="ulist column"><ul><li><p>Resta</p><div class="ulist"><ul><li><p>La resta de números con signo se puede realizar de dos formas: A-B ó A-B = A+(-B)</p></li><li><p>A = 0b00110110 y B = 0b10011011</p></li><li><p>Si hay llevada en el MSBit, no se tiene en cuenta, se elimina.</p><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-vhdl, x86asm, x86asmatt hljs" data-noescape="true" data-lang="vhdl, x86asm, x86asmatt">Crédito   2 2   2 2   2 2

          1 0 1 1 0 1 1 0&lt;--(Valor -74)
        - 1 1 0 1 1 0 1 1&lt;--(Valor -37)


LLevada 1 1 1   1 1   1 1
         ****************
Resta     1 1 0 1 1 0 1 1 (Valor -101)</code></pre></div></div></li></ul></div></li></ul></div></div></section><section id="_operaciones_ariméticas_c2_overflow_o_desbordamiento" data-state="txiki"><h2>Operaciones ariméticas C2: Overflow o Desbordamiento</h2><div class="slide-content"><div class="ulist"><ul><li><p>A = 0b00110110 y B = 0b10011011 &#8594; Calcular A-B</p></li><li><p>Con 8 bits el máximo valor es 01111111 de valor 2<sup>7</sup>-1=128-1=127</p></li><li><p>La resta A-(B)=A+(-B)=54+103=157&gt;127 &#8594; <strong>Overflow</strong> o <strong>Desbordamiento</strong></p><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-vhdl, x86asm, x86asmatt hljs" data-noescape="true" data-lang="vhdl, x86asm, x86asmatt">Crédito  2     2 2   2 2

         0 0 1 1 0 1 1 0&lt;--(Valor = 54)
       - 1 0 0 1 1 0 1 1&lt;--(Valor = -103)


LLevada      1 1   1 1
        ****************
Resta    1 0 0 1 1 0 1 1 (Valor -101)</code></pre></div></div>
<div class="ulist"><ul><li><p>El valor -101 en lugar de la resta correcta +157 es debido a que el resultado esta fuera de rango &#8594;</p></li><li><p>Observarmos que hemos hecho la SUMA de dos números POSITIVOS y el resultado ha sido NEGATIVO</p></li></ul></div></li></ul></div></div></section><section id="_operaciones_ariméticas_c2_overflow"><h2>Operaciones ariméticas C2: Overflow</h2><div class="slide-content"><div class="admonitionblock important"><table><tr><td class="icon"><i class="fa fa-exclamation-circle" title="Important"></i></td><td class="content">Al realizar la suma de dos valores con el mismo signo si el resultado es de signo contrario hay overflow</td></tr></table></div></div></section><section id="_operaciones_aritméticas_c2_overflow" data-state="txiki"><h2>Operaciones aritméticas C2: Overflow</h2><div class="slide-content"><div class="ulist"><ul><li><p>Overflow: la operación requiere operandos con mayor número de bits manteniendo el valor para que el resultado sea correcto.</p></li><li><p>Si dos operandos a sumar tienen diferente signo nunca hay overflow</p></li><li><p>Si dos operandos a sumar tienen el mismo signo y resultado tiene signo contrario : <strong>Error</strong> de Overflow.</p></li><li><p>Ejemplo:</p><div class="ulist"><ul><li><p>Operandos de 1 byte :  01111111+01111111=11111110 &#8594; sumandos positivos y resultado negativo</p><div class="ulist"><ul><li><p>Solución: <strong>Extensión del signo</strong> : Operandos  9 bits &#8594; 001111111+001111111=011111110</p></li><li><p>la repetición del bit más significativo no altera el valor de la representación</p></li><li><p>el bit más significativo es 0 si es positivo y 1 si es negativo. Por lo tanto, 01010 equivale a 01010 ó 001010 ó 0&#8230;&#8203;.0001010. Por lo tanto, 1010 equivale a 11010 ó 111010 ó 1&#8230;&#8203;.1111010</p></li></ul></div></li></ul></div></li></ul></div></div></section><section id="_c2_representación_gráfica_del_overflow"><h2>C2: Representación gráfica del Overflow</h2><div class="slide-content"><div class="imageblock" style="float: left"><img src="images/rueda_signed.png" alt="Rueda" width="500" height="500"></div>
<div class="paragraph text-left"><p>Si a partir de la posición 010 nos movemos dos posiciones en sentido  horario llegamos a la posición 100.<br>
Si a 010 le sumamos el valor 2 nos da como resultado 100<br>
Por lo tanto 010+010=100, es decir, 2+2=-4 &#8594; <strong>overflow</strong> ya que el <em>+4</em> necesita 4 bits y estamos trabajando con 3 bits únicamente.</p></div></div></section><section id="_aritmética_modular_de_valores_representados_en_complemento_a_2"><h2>Aritmética Modular de valores representados en Complemento a 2</h2><div class="slide-content"><div class="imageblock" style="float: left"><img src="images/rueda_signed.png" alt="Rueda" width="500" height="500"></div>
<div class="paragraph text-left"><p>Representación de números binarios de 3 bits en C2<br>
Operaciones de suma y resta modular &#8594; método gráfico<br>
A partir de la posición 001 si nos movemos en sentido horario (SUMA modular) 2 posiciones obtenemos la posición 011, es decir, 1+2=3<br>
A partir de la posición 110 si nos movemos en sentido horario (SUMA modular) 9 posiciones obtenemos la posición 111, es decir, -2+9=-1<br>
A partir de la posición 110 si nos movemos en sentido antihorario (RESTA modular) 4 posiciones obtenemos la posición 010, es decir, -2-4=+2<br>
Los errores de <strong>overflow</strong> se resuelven aumentando el número de bits de la representación, pero siempre existira un rango que si lo traspasamos dará overflow.</p></div></div></section><section id="_comparación_s_m_y_c2" data-state="taula"><h2>Comparación S-M, y C2</h2><div class="slide-content"><table class="tableblock frame-all grid-all" style="width:100%"><caption class="title">Table 9. Números de 3 bits</caption><colgroup><col style="width:33.3333%"><col style="width:33.3333%"><col style="width:33.3334%"></colgroup><thead><tr><th class="tableblock halign-center valign-top">Valor</th><th class="tableblock halign-center valign-top">S-M</th><th class="tableblock halign-center valign-top">C2</th></tr><tbody><tr><td class="tableblock halign-center valign-top"><p class="tableblock">+3</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">011</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">011</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">+2</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">010</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">010</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">+1</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">001</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">001</p></td></tr><tr><td class="tableblock halign-center valign-top" rowspan="2"><p class="tableblock">0</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">000</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">000</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">100</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">---</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">-1</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">101</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">111</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">-2</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">110</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">110</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">-3</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">111</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">101</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">-4</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">-</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">100</p></td></tr></table></div></section></section>
<section><section id="op_log"><h2>Tema 4 :Operaciones Lógicas</h2><div class="slide-content"><div class="ulist"><ul><li><p>Operadores</p><div class="ulist"><ul><li><p>Operadores aritméticos: suma, resta, multiplicación, &#8230;&#8203;</p></li><li><p>Operadores lógicos: or (suma), and (producto), negación, or exclusiva, etc&#8230;&#8203;</p></li><li><p>Operadores comparadores: &gt; (..mayor que..), &gt; (..menor que..), == (..igual a..), etc</p></li><li><p>Operadores de desplazamiento: &gt;&gt; (desplazar hacia la derecha), &lt;&lt; (desplazar hacia la izquierda)</p></li></ul></div></li></ul></div></div></section><section id="_tablas_de_la_verdad_de_los_operadores_not_or_and_xor" class="columns" data-state="taula_ta"><h2>Tablas de la Verdad de los operadores NOT, OR, AND, XOR</h2><div class="slide-content"><table class="tableblock frame-all grid-all column" style="width:100%"><caption class="title">Table 10. NOT</caption><colgroup><col style="width:50%"><col style="width:50%"></colgroup><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock">x</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">z=x&#773;</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td></tr></table>
<table class="tableblock frame-all grid-all column" style="width:100%"><caption class="title">Table 11. OR</caption><colgroup><col style="width:25%"><col style="width:25%"><col style="width:50%"></colgroup><tbody><tr><td class="tableblock halign-center valign-top"><p class="tableblock">x</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">y</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">z = x + y</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td></tr></table>
<table class="tableblock frame-all grid-all column" style="width:100%"><caption class="title">Table 12. AND</caption><colgroup><col style="width:25%"><col style="width:25%"><col style="width:50%"></colgroup><tbody><tr><td class="tableblock halign-center valign-top"><p class="tableblock">x</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">y</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">z = x &#8729; y</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td></tr></table>
<table class="tableblock frame-all grid-all column" style="width:100%"><caption class="title">Table 13. XOR</caption><colgroup><col style="width:25%"><col style="width:25%"><col style="width:50%"></colgroup><tbody><tr><td class="tableblock halign-center valign-top"><p class="tableblock">x</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">y</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">z = x &#8853; y</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td></tr></table></div></section></section>
<section><section id="Tema5_RepInstrucciones"><h2>Tema 5: Representación Digital de la Información: las INSTRUCCIONES</h2></section><section id="_registro" class="columns" data-state="txikiago"><h2>Registro</h2><div class="slide-content"><div class="ulist column"><ul><li><p>Un registro es un circuito que funciona como una unidad de memoria y que almacena un único dato o una instrucción máquina.</p></li><li><p>Los registros:</p><div class="ulist"><ul><li><p>'almacenan' una palabra formada por una secuencia de bits.</p></li><li><p>son una array de celdas en una dimensión, donde cada celda almacena un bit.</p></li></ul></div></li><li><p>Su tamaño normalmente es un múltiplo de 8 bytes y recibe un nombre para poder ser referencia, por ej RAX</p><div class="ulist"><ul><li><p>8 bits: 1 Byte</p></li><li><p>16 bits: Word. Por razones históricas.(recordad que el tamaño de una palabra en otro contexto depende de la máquina de que se trate)</p></li></ul></div></li></ul></div>
<div class="ulist column"><ul><li><p>.</p><div class="ulist"><ul><li><p>32 bits: double word</p></li><li><p>64 bits: quad word</p></li></ul></div></li><li><p>Las celdas se enumeran empezando por cero.</p></li><li><p>LSB: Least Significant Bit es el bit de menor peso</p></li><li><p>MSB: Most Significant Bit es el bit de mayor peso</p><div class="imageblock"><img src="images/eecc_tema5_register.svg" alt="eecc tema5 register"></div></li></ul></div></div></section><section id="_lenguaje_rtl_operador_transferencia"><h2>Lenguaje RTL: operador transferencia</h2><div class="slide-content"><div class="ulist"><ul><li><p>El lenguaje RTL es un Lenguaje para la descripción de INSTRUCCIONES MAQUINA: Register Transfer Language (RTL)</p></li><li><p>El lenguaje RTL tiene como objetivo poder expresar las instrucciones máquina que ejecuta la CPU como sumar(ADD),restar(SUB),mover(MOV), etc. La descripción se realiza a nivel de transferencia de datos entre 'registros' internos de la CPU o entre registros internos y la memoria externa.</p></li><li><p>La operación de <strong>transferencia</strong> se representa con una flecha de derecha a izquierda</p><div class="ulist"><ul><li><p>Operador transferencia &#8592;</p></li><li><p>Sentencia transferencia: R2&#8592;R1</p></li><li><p>A R1 se le llama registro fuente y a R2 registro destino</p></li><li><p>Interpretación: Copiamos o Transferimos el contenido del registro R1 en el registro R2</p></li></ul></div></li></ul></div></div></section><section id="_lenguaje_rtl_otras_sentencias"><h2>Lenguaje RTL: otras sentencias</h2><div class="slide-content"><div class="openblock"><div class="content"><div class="paragraph"><p>Sentencia Condicional:<br>
If (K1=1) then R2&#8592;R1<br>
  K1:R2&#8592;R1<br>
  La transferencia o copia se realiza únicamente si K1 es verdad, es decir, si K1 vale el valor lógico 1 (TRUE).
<br>
<br>
Sentencia Concurrente:<br>
Operador coma<br>
 K3:R2&#8592;R1,R3&#8592;R1<br>
 Si K3 es verdad el contenido de R1 se copia en R2 y R3</p></div></div></div></div></section><section id="_sintaxis_de_las_instrucciones_en_el_lenguaje_intel" data-state="txikiago"><h2>Sintaxis de las instrucciones en el lenguaje INTEL</h2><div class="slide-content"><div class="ulist"><ul><li><p>El formato de las instrucciones en lenguaje ensamblador se conoce como 'sintaxis' de las instrucciones.</p></li><li><p>SINTAXIS ASM: Etiqueta-Código de Operación- Operando1- Operando2- Comentario</p></li><li><p>Arquitecturas x86-64 y x86</p><table class="tableblock frame-all grid-all" style="width:100%"><caption class="title">Table 14. Sintaxis Intel: Estructura</caption><colgroup><col style="width:9.5238%"><col style="width:19.0476%"><col style="width:28.5714%"><col style="width:4.7619%"><col style="width:23.8095%"><col style="width:14.2858%"></colgroup><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>label:</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>op_mnemonic</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>operand_destination</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>,</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>operand_source</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>#comment</code></p></td></tr></table></li></ul></div></div></section><section id="_sintaxis_de_las_instrucciones_en_el_lenguaje_intel_ejemplo" data-state="txikia"><h2>Sintaxis de las instrucciones en el lenguaje INTEL : Ejemplo</h2><div class="slide-content"><div class="ulist"><ul><li><p>Ejemplo:</p><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-vhdl, x86asm, x86asmatt hljs" data-noescape="true" data-lang="vhdl, x86asm, x86asmatt">bucle:  sub     rsp,16                ;RSP &lt;- RSP-16. Resta
        je      bucle                 ;je: jump equal:
                                      ;salto si la última operación dió resultado cero
suma:   add     eax,esi               ;EAX &lt;- EAX+M[ESI] . Sumar
        mov     ax,[resultado]        ;AX &lt;- M[resultado].
                                      ;Copiar en el registro AX el contenido de la posición de memoria resultado


resultado: "reserva de memoria"</code></pre></div></div></li></ul></div></div></section><section id="_sintaxis_de_las_instrucciones_en_el_lenguaje_de_la_compañía_telefónica_att" data-state="txikiago"><h2>Sintaxis de las instrucciones en el lenguaje de la compañía telefónica AT&amp;T</h2><div class="slide-content"><div class="ulist"><ul><li><p>SINTAXIS ASM: Etiqueta-Código de Operación- Operando1- Operando2- Comentario</p></li><li><p>Arquitecturas x86-64 y x86</p><table class="tableblock frame-all grid-all" style="width:100%"><caption class="title">Table 15. Sintaxis AT&amp;T: Estructura</caption><colgroup><col style="width:9.5238%"><col style="width:19.0476%"><col style="width:28.5714%"><col style="width:4.7619%"><col style="width:23.8095%"><col style="width:14.2858%"></colgroup><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>label:</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>op_mnemonic</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>operand_source</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>,</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>operand_destination</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>#comment</code></p></td></tr></table></li><li><p>La gran diferencia con el lenguaje de Intel son el orden de los dos operandos</p></li><li><p>Otra pequeña diferencia son los prefijos de los operandos para indicar el modo de direccionar el operando</p></li></ul></div></div></section><section id="_sintaxis_de_las_instrucciones_en_el_lenguaje_att_ejemplo" data-state="txikia"><h2>Sintaxis de las instrucciones en el lenguaje AT&amp;T : Ejemplo</h2><div class="slide-content"><div class="ulist"><ul><li><p>Ejemplo:</p><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-vhdl, x86asm, x86asmatt hljs" data-noescape="true" data-lang="vhdl, x86asm, x86asmatt">bucle:  sub     $16,%rsp              ;RSP &lt;- RSP-16. Resta
        je      bucle                 ;je: jump equal:
                                      ;salto si la última operación dió resultado cero
suma:   add     %esi,%eax             ;EAX &lt;- EAX+M[ESI] . Sumar
        mov     resultado,%ax         ;AX &lt;- M[resultado].
                                      ;Copiar en el registro AX el contenido de la posición de memoria resultado

resultado: "reserva de memoria"</code></pre></div></div></li></ul></div></div></section><section id="_sintaxis_att"><h2>Sintaxis AT&amp;T</h2><div class="slide-content"><div class="paragraph"><p>La sintaxis del lenguaje ensamblador depende del "traductor" del proceso de ensamblaje (<strong>assembler</strong>) utilizado, en este caso, se utiliza el assembler GAS.</p></div>
<div class="literalblock"><div class="content"><pre>ETIQUETA: Se especifica en la primera columna. Tiene el sufijo ":"
CODIGO DE OPERACION: Se utilizan símbolos mnemónicos que ayudan a interpretar intuitivamente la operación.
		 Pej: ADD sumar, MOV mover, SUB restar, …​
OPERANDO FUENTE Y/O DESTINO:
  dato alfanumérico: representación alfanumérica → 16
    direccionamiento inmediato: prefijo $
  dirección de memoria externa: etiqueta → resultado
    direccionamiento directo
  registros internos de la CPU: %rax,%rbx,%rsp,%esi,..
    El prefijo "%" significa que el nombre hace referencia a un registro
  tamaño del dato operando: sufijos de los mnemónicos:
		q(quad):8 bytes, l(long):4 bytes, w(word):2 bytes, b(byte):1 byte.
    Sin sufijo se toma la limitación del tamaño del registro referenciado
    y si no hay limitación el traductor avisa del error</pre></div></div></div></section><section id="_operandos_modo_de_direccionamiento" data-state="txikiago"><h2>Operandos: Modo de Direccionamiento</h2><div class="slide-content"><div class="ulist"><ul><li><p>Direccionamientos:</p><div class="paragraph text-left"><p>INMEDIATO: El valor del operando está ubicado inmediatamente después del código de operación de la instruccion. Unicamente se especifica el operando fuente.<br>
    sintaxis: el valor del operando se indica con el prefijo <strong>$</strong> .<br>
        ejemplo: <strong>movl $0xabcd1234, %ebx</strong>. El operando fuente es el valor 0xABCD1234<br>
<br>
 REGISTRO: El valor del operando está localizado en un registro de la CPU.<br>
    sintaxis: Nombre del registro con el prefijo <strong>%</strong>.<br>
        ejemplo: <strong>movl %eax, %ebx</strong>. El operando fuente es el REGISTRO EAX y el destino es el REGISTRO EBX<br>
<br>
DIRECTO:  La dirección efectiva apuntando al operando almacenado en la Memoria Principal es la dirección absoluta referenciada por la etiqueta especificada en el campo de operando. El programador utiliza el direccionamiento directo pero el compilador lo transforma en un direccionamiento relativo al contador de programa. Ver direccionamiento con desplazamiento.<br>
    sintaxis: una etiqueta definida por el programador<br>
	ejemplo: <strong>je somePlace</strong>   . Salto a la dirección marcada por la etiqueta somePlace si el resultado de la operación anterior activa el flag ZF=1 del registro RFLAG.<br>
<br>
INDEXADO: El valor del operando está localizado en memoria. La dirección efectiva apuntando a Memoria es la SUMA del valor del registro_base MAS scale POR el valor en el registro_índice, MAS el offset. 'EA=Offset+R_Base+R_índice*Scale'<br>
    sintaxis: lista de valores separados por coma y entre paréntesis (base_register, index_register, scale) y precedido por un offset.<br>
        ejemplo: <strong>movl $0x6789cdef, -16(%edx, %eax, 4)</strong> . La dirección efectiva del destino es  <strong>EDX + EAX*4 - 16</strong>.</p></div></li></ul></div></div></section><section id="_operandos_modo_de_direccionamiento_2" data-state="txikiago"><h2>Operandos: Modo de Direccionamiento</h2><div class="slide-content"><div class="ulist"><ul><li><p>Direccionamientos:</p><div class="paragraph text-left"><p>INDIRECTO: Si  el modo general de indexación  lo particularizamos en (base_register) entonces la dirección del operando no se obtiene mediante una indexación sino que la dirección efectiva es el contenido de rdx y por lo tanto se accede al operando indirectamente.<br>
    sintaxis:  (base_register)<br>
        ejemplo: <strong>movl $0x6789cdef, (%edx)</strong> . La dirección efectiva del destino es  EDX. EDX es un puntero.<br>
<br>
RELATIVO: registro base más un offset:  El valor del operando está ubicado en memoria. La dirección efectiva del operando es la suma del valor contenido en un registro base más un valor de offset.<br>
  	sintaxis: registro entre paréntesis y el offset inmediatamente antes del paréntesis.<br>
      	ejemplo: <strong>movl $0xaabbccdd, -12(%eax)</strong>  . La dirección efectiva del operando destino es  EAX-12</p></div></li></ul></div></div></section><section id="_operandos_modo_de_direccionamiento_3" data-state="txikiago"><h2>Operandos: Modo de Direccionamiento</h2><div class="slide-content"><div class="ulist"><ul><li><p>Direccionamientos <strong>prohibidos</strong></p><div class="ulist"><ul><li><p>En la misma instrucción los campos operando fuente y el operando destino no pueden hacer referencia a direcciones de memoria</p></li></ul></div></li><li><p>Ejemplos de direccionamientos prohibidos ó erróneos:</p><div class="ulist"><ul><li><p>mov dato,suma &#8594; siendo dato y suma dos direcciones de la memoria</p></li><li><p>mov (%edx),suma &#8594; siendo EDX un puntero a memoria y suma una dirección de memoria</p></li></ul></div></li></ul></div></div></section><section id="_modos_de_direccionar_los_operandos_ejemplos" data-state="taula"><h2>Modos de direccionar los operandos: Ejemplos</h2><div class="slide-content"><table class="tableblock frame-all grid-all" style="width:100%"><caption class="title">Table 16. Modos de Direccionamiento de los Operandos</caption><colgroup><col style="width:33.3333%"><col style="width:33.3333%"><col style="width:33.3334%"></colgroup><thead><tr><th class="tableblock halign-left valign-top">Direccionamiento Operando</th><th class="tableblock halign-left valign-top">Valor Operando</th><th class="tableblock halign-left valign-top">Nombre del Modo</th></tr><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>$0</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Valor Cero</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Inmediato</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>%rax</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>RAX</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Registro</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>loop_exit</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>M[loop_exit]</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Directo</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>data_items(,%rdi,4)</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>M[data_item + 4*RDI]</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Indexado</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>(%rbx)</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>M[RBX]</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Indirecto</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>(%rbx,%rdi,4)</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>M[RBX + 4*RDI]</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Indirecto Indexado</code></p></td></tr></table>
<div class="ulist"><ul><li><p>M[loop_exit]: directo ya que loop_exit es una dirección de memoria externa y M indica la memoria externa.</p></li><li><p>M[RBX]: indirecto ya que RBX es una dirección de memoria interna y M indica memoria externa: A la mem. externa se accede a través de la mem. interna.</p></li></ul></div></div></section><section id="_programa_sum1ton_organigrama"><h2>Programa sum1toN: Organigrama</h2><div class="slide-content"><div class="ulist"><ul><li><p>Calcular la suma de los 5 primeros números naturales</p></li></ul></div>
<div class="imageblock"><img src="images/sum1toN_organigrama.png" alt="sum1toN organigrama"></div></div></section><section id="_programa_sum1ton_en_lenguaje_c"><h2>Programa sum1toN en lenguaje C</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-c hljs" data-noescape="true" data-lang="c">/*
  Programa:       sum1toN.c
  Descripción:    realiza la suma de la serie 1,2,3,...N

  Arquitectura del Procesador: La programación de este algoritmo en lenguaje C NO DEPENDE de la arquitectura del pocesador ¿Por qué y Cómo es posible?
  Lenguaje:       C99
  Descripción:    Suma de los primeros 5 números naturales
  Entrada:        Definida en una variable
  Salida:         Sin salida
  Compilación:    gcc -m32 -g -o sum1toN sum1toN.c -&gt; -g: módulo binario depurable
                                                   -&gt; -m32: módulo binario arquitectura x86-32 bits
  S.O:            GNU/linux 4.10 ubuntu 17.04 x86-64
  Librería:       /usr/lib/x86_64-linux-gnu/libc.so
  CPU:            Intel(R) Core(TM) i5-6300U CPU @ 3.0GHz
  Compilador:     gcc version 6.3
  Ensamblador:    GNU assembler version 2.28
  Linker/Loader:  GNU ld (GNU Binutils for Ubuntu) 2.28
  Asignatura:     Estructura de Computadores
  Fecha:          20/09/2017
  Autor:          Cándido Aramburu
*/

#include &lt;stdio.h&gt;  // cabecera de la librería de la función printf()

// función de entrada al programa
void  main (void)
{
  // Declaración de variables locales
  char suma=0;
  char n=0b101;
  // bucle
  while(n&gt;0){
    suma+=n;
    n--;
  }
 printf("\n La suma es = %d \n",suma);
}</code></pre></div></div></div></section><section id="_programa_sum1ton_para_la_máquina_x86_en_lenguaje_att"><h2>Programa sum1toN para la máquina x86 en lenguaje AT&amp;T</h2><div class="slide-content"><div class="ulist"><ul><li><p>Lenguaje ensamblador ATT para la arquitectura x86-32</p><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-asm hljs" data-noescape="true" data-lang="asm">### Programa: sum1toN.s
### Descripción: realiza la suma de la serie 1,2,3,...N
### Arquitectura del Procesador: x86 32 bits
### Compilación
###     gcc -m32 -g -nostartfiles -o sum1toN sum1toN.s
### o como alternativa
###     Ensamblaje as --32 --gstabs sum1toN.s -o sum1toN.o
###     linker -&gt; ld -melf_i386 -I/lib/i386-linux-gnu/ld-linux.so.2   -o sum1toN sum1toN.o -lc

        ##  Declaración de variables
        .section .data

n:	.int 5

        .global _start

        ##  Comienzo del código
        .section .text
_start:
        mov $0,%ecx # ECX implementa la variable suma
        mov n,%edx
bucle:
        add %edx,%ecx
        sub $1,%edx
        jnz bucle

        mov %ecx, %ebx # el argumento de salida al S.O. a través de EBX según convenio

        ## salida
        mov $1, %eax  # código de la llamada al sistema operativo: subrutina exit
        int $0x80     # llamada al sistema operativo


        .end</code></pre></div></div></li></ul></div></div></section><section id="_programa_sum1ton_para_la_máquina_x86_en_lenguaje_intel"><h2>Programa sum1toN para la máquina x86 en lenguaje Intel</h2><div class="slide-content"><div class="ulist"><ul><li><p>Lenguaje ensamblador INTEL y assembler nasm</p><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-x86asm hljs" data-noescape="true" data-lang="x86asm">;;; Programa: sum1toN.asm
;;; Descripción: realiza la suma de la serie 1,2,3,...N
;;; Arquitectura del Procesador: x86 32 bits
;;; Lenguaje INTEL
;;; Assembler NASM

;;; nasm -hf -&gt; ayuda de la opción f
;;; Ensamblaje nasm -g -f elf  sum1toN.asm -o sum1toN.o
;;; linker -&gt; ld -m elf_i386    -o sum1toN sum1toN.o

	BITS 32	; cpu MODE
        ;;  Declaración de variables
        section .data

n:	dd 5	; 4 bytes

        global _start

        ;;  Comienzo del código
        section .text
_start:
        mov ecx,0 ; ECX implementa la variable suma
        mov edx,[n]  ; EDX implementa es un alias de la variable n
bucle:
        add ecx,edx
        sub edx,1
        jnz bucle

        mov ebx, ecx ; el argumento de salida al S.O. a través de EBX según convenio

        ;; salida
        mov eax,1  ; código de la llamada al sistema operativo: subrutina exit
        int 0x80     ; llamada al sistema operativo</code></pre></div></div></li></ul></div></div></section></section>
<section><section id="Tema6_ProgAsm"><h2>Tema 6: Programación en Lenguaje Ensamblador (x86): Construcciones básicas de los lenguajes de alto nivel.</h2></section><section id="_arquitecturas_x86_i386_x86_64_amd64"><h2>Arquitecturas x86 i386 x86-64 amd64</h2><div class="slide-content"><div class="ulist"><ul><li><p>La arquitectura de Intel x86 de 32 bits  comenzó en el año 1985 con el microprocessador 80386 qué más adelante fue renuraombrado como "i386"</p></li><li><p>x86-64 (también conocido como x64, x86_64, AMD64 e Intel 64) es la versión de 64 bits del conjunto de instrucciones x86. La especificación fue creada por AMD</p></li><li><p>Linux denomina a la arquitectura x86 como i386 y a la arquitectura x86-64 como amd64.</p></li><li><p>En esta asignatura se va a trabajar principalmente con la arquitectura x86 ya que las prácticas se realizan en esta arquitectura de 32 bits.</p></li></ul></div></div></section><section id="_isa_x86"><h2>ISA x86</h2><div class="slide-content"><div class="ulist"><ul><li><p>El objetivo de este capítulo es tener las conocimientos necesarios para la programación de bajo de nivel (lenguaje ensamblador) de la arquitectura de 32 bits de Intel: x86</p></li><li><p>Fases en el proceso de traducción (compilación,ensamblaje, módulos fuente, módulo objeto, módulo ejecutable, enlazado,resolución de referencias, librerías, sistema operativo ,etc) del módulo fuente y carga en memoria del módulo ejecutable.</p></li><li><p>El programador de bajo de nivel necesita el conocimiento de la ISA, es decir:</p><div class="ulist"><ul><li><p>Registros de propósito general internos de la CPU</p></li><li><p>Registro de estado o registro de flags</p></li><li><p>Direccionamiento de la memoria principal</p></li><li><p>Diferencia entre la memoria interna (registros) y la memoria externa (memoria principal)</p></li></ul></div></li></ul></div></div></section><section id="_isa_x86_2"><h2>ISA x86</h2><div class="slide-content"><div class="ulist"><ul><li><p>El programador de bajo de nivel necesita el conocimiento de la ISA, es decir:</p><div class="ulist"><ul><li><p>Tipos de datos y su formato: enteros complemento a 2</p></li><li><p>Tamaño de los operandos: sufijos b,w,l,q de los mnemónicos</p></li><li><p>Alineamiento de los datos en la memoria: little endian</p></li><li><p>Modos de direccionamiento: inmediato, directo, etc</p></li><li><p>Sintaxis del lenguaje "AT&amp;T"</p></li><li><p>Directivas del traductor assembler "as"</p></li></ul></div></li></ul></div></div></section><section id="_ejercicios_2"><h2>Ejercicios</h2><div class="slide-content"><div class="ulist"><ul><li><p><a href="./as_code/sum1toN.s">sum1toN.s</a></p><div class="ulist"><ul><li><p>Programa inicial de referencia</p></li><li><p>sección de datos y sección de instrucciones: directivas .section  .data y .section .text</p></li><li><p>direccionamientos: inmediato, a registro y directo</p></li><li><p>estructura de un bloque: saltos incondicionales y condicionales</p></li><li><p>etiqueta global</p></li><li><p>llamada a funciones del sistema operativo y paso del argumento por registro</p></li><li><p>comentarios en lenguaje C y pseudocódigo</p></li></ul></div></li></ul></div></div></section><section id="_ejercicios_3"><h2>Ejercicios</h2><div class="slide-content"><div class="ulist"><ul><li><p><a href="./as_code/sum1toN_v2.s">sum1toN_v2.s</a></p><div class="ulist"><ul><li><p>Declaración de variables: En la sección de datos reservar memoria para el dato e inicializarlo. Directivas .byte, 2byte, 4byte</p></li><li><p>instrucción de salto condicional: jnz ó jne</p></li></ul></div></li><li><p><a href="./as_code/sum1toN_v3.s">sum1toN_v3.s</a></p><div class="ulist"><ul><li><p>Directiva .string: reserva de memoria e inicialización con caracteres ASCII</p></li><li><p>llamada a funciones de la librería standard de C como "puts()" y pase de argumentos a través de la pila</p></li></ul></div></li><li><p><a href="./as_code/sum1toN_v4.s">sum1toN_v4.s</a></p><div class="ulist"><ul><li><p>llamada a la función "exit()" de la librería standard de C</p></li></ul></div></li></ul></div></div></section><section id="_ejercicio"><h2>Ejercicio</h2><div class="slide-content"><div class="ulist"><ul><li><p><a href="./as_code/sum1toN_v5.s">sum1toN_v5.s</a></p><div class="ulist"><ul><li><p>Macros con la directiva .equ</p></li><li><p>Inicializar una array de datos con los diez primeros números enteros impares y sumarlos</p></li></ul></div></li><li><p><a href="./as_code/sum1toN_v6.s">sum1toN_v6.s</a></p><div class="ulist"><ul><li><p>Macros con la directiva .equ</p></li><li><p>Inicializar una array de datos con los diez primeros números enteros impares y sumarlos</p></li><li><p>Bucle con la instrucción "cmp"</p></li><li><p><a href="https://www.felixcloutier.com/x86">x86</a>: <a href="https://www.felixcloutier.com/x86/cmp">cmp</a> , <a href="https://www.felixcloutier.com/x86/jcc">jcc</a></p></li><li><p>Visualizar el resultado con la función printf() de la librería standard de C</p></li></ul></div></li></ul></div></div></section><section id="_ejercicio_2"><h2>Ejercicio</h2><div class="slide-content"><div class="ulist"><ul><li><p><a href="./as_code/sum1toN_v6.s">sum1toN_v6.s</a></p><div class="ulist"><ul><li><p>Pasar los dos argumentos a través de la pila insertando primero el último argumento printf(1º arg,2º arg)</p></li></ul></div></li><li><p><a href="./as_code/sum1toN_v7.s">sum1toN_v7.s</a></p><div class="literalblock"><div class="content"><pre>### Descripción: Macros con la directiva .equ
###              Inicializar una array de datos con los diez primeros números enteros impares y sumarlos
###		 bucle con la instrucción "cmp"
###              Visualizar el resultado con la función printf() de la librería standard de C
###              Pasar los dos argumentos a través de la pila insertando primero el último argumento printf(1º arg,2º arg)</pre></div></div></li></ul></div></div></section><section id="_subrutinas"><h2>Subrutinas</h2></section><section id="_introducción"><h2>Introducción</h2><div class="slide-content"><div class="ulist"><ul><li><p>A las funciones de los lenguajes de alto nivel en el nivel máquina se les llama subrutinas</p></li><li><p>Las subrutinas son bloques de código que pueden ser llamadas desde otro bloque para su ejecución y posterior retorno a la sentencia siguiente al punto de llamada.</p></li><li><p>A las subrutinas se les pueden pasar parámetros o argumentos a través de unidades de memoria de diferentes formas:</p><div class="ulist"><ul><li><p>En la arquitectura x86 los parámetros se pasan a través de la pila</p></li></ul></div></li></ul></div></div></section><section id="_la_pila_a_nivel_máquina_x86"><h2>La pila a nivel máquina x86</h2><div class="slide-content"><div class="ulist"><ul><li><p>Es una estructura de datos  que se construye en la <strong>memoria principal</strong> y constituye una sección diferente (stack section) de la sección de datos y sección de texto.</p></li><li><p>La pila es una 'sección' del programa en ejecución en la memoria principal. A diferencia de la sección de datos y la sección de instrucciones la pila se crea en tiempo de ejecución ,no durante la carga en memoria.</p></li><li><p>En la pila los datos se van insertando (apilando) secuencialmente y también se van extrayendo (desapilando)</p></li><li><p>Es una estructura de datos tipo LIFO (last input first output): El último elemento apilado es el primero que se puede extraer.</p></li><li><p>La instrucción para insertar un dato el <strong>PUSH</strong> y para extraer es <strong>POP</strong>.</p><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-vhdl, x86asm, x86asmatt hljs" data-noescape="true" data-lang="vhdl, x86asm, x86asmatt">push %eax  # se inserta en la pila y se apila el contenido de EAX
pop %ebx   # se extrae de la pila el último dato apilado y se guarda en EBX
push etiqueta # ¿Da error?¿Por qué?</code></pre></div></div></li></ul></div></div></section><section id="_la_pila_a_nivel_máquina_x86_2" class="columns"><h2>La pila a nivel máquina x86</h2><div class="slide-content"><div class="imageblock column kroki-format-svg kroki"><img src="https://kroki.io/ditaa/svg/eNrjUjCoMIACbV0Y0OZSQIAahWQnn1AwC1UYzkIWxmkIVtU1CsGp6bmpeSX5aMIuiSX5xfS10jOvuKSoNFmPjlYGZOYk0ipgCUeaQYUbFOAw20bXxKmyJLVYV9eOCwDHp2Oa" alt="Diagram"></div>
<div class="ulist column"><ul><li><p><a href="./pila.html">pila</a></p></li><li><p>La anchura de la pila son 32 bits</p></li><li><p>Se apila en el sentido decreciente de las direcciones de memoria</p></li></ul></div>
<div class="imageblock column kroki-format-svg kroki"><img src="https://kroki.io/ditaa/svg/eNrjUjCoMIACbV0Y0OZSQIAahWQnn1AwC1UYzkIWRjHEoMIRajZQdbKLiwtxqk1Aqp2cnIhTbUGSameQaktLS6JUGxqQpNqEJNUWxKl2gqh2xhHexMSOQYUbFOCIYhtdE6fKktRiXV07Li4A_KBgdQ==" alt="Diagram"></div></div></section><section id="_anidamiento_de_llamadas_a_funciones_frame"><h2>Anidamiento de llamadas a funciones: FRAME</h2><div class="slide-content"><div class="imageblock kroki"><img src="https://kroki.io/ditaa/svg/eNrVlsGOgjAQQM_yFXPENJNwJSEmNI2ndQ8mxrOCJB5UQt2Ew378FoWItVOpIrpzgfRRmjczpUCcpsVGSgBARDGPZ-qCHgRlUAfDJph6iAbuyINL_Bru7KAraq_CqBmMflU3dO2S8K-F0YUAXdEbMqZX8tad0WmxoarH4rop1OKJEOKfubQ7WblMTxFWLpzzHlxkjpPh6pIX2_0xA31X9uSiowiz_Gkfag5VG1H5hGH4sE-EMn9Vn8mf3ex4-LYivTYOLpnWTE_vmU7Jt9bF0YVOfh_7f7fa7s0b40ys6J6LQ_I_oC5ByS_f5QHOmMfOy4bZ0FDnZVBO67j5WyKAO2q7RIjLQ5Gq4Uk1PGrG_dUYDOGvjcMnlJAI_HTs_QF-DKSM" alt="Diagram"></div>
<div class="ulist"><ul><li><p>Cada rutina o subrutina tiene que generar por programa su propio segmento dentro de la sección stack.</p></li></ul></div></div></section><section id="_punteros_del_frame_activo"><h2>Punteros del Frame Activo</h2><div class="slide-content"><div class="ulist"><ul><li><p>fp: frame pointer y sp: stack pointer</p></li><li><p>el puntero fp apunta a la parte baja del frame activo y el sp apunta a la parte alta (último dato apilado) del frame activo</p></li><li><p>En la arquitectura x86 el la función fp la realiza el registro <strong>EBP</strong> (Bottom Pointer) y la función sp la realiza el registro <strong>ESP</strong></p></li></ul></div></div></section><section id="_anidamiento_de_llamadas_a_funciones_frame_2"><h2>Anidamiento de llamadas a funciones: FRAME</h2><div class="slide-content"><div class="ulist"><ul><li><p>Un ejemplo típico de anidamiento de funciones son las subrutinas recurrentes o recursivas.</p></li><li><p>De aquí en adelante según se van aprendiendo los diferentes conceptos, ponerlos en práctica con <a href="https://diveintosystems.org/book/C8-IA32/recursion.html">La Animación de Recursión</a>: Analizar la función sumr en C y en ASM. Bajar al apartado 8.6.1. Animation: Observing How the Call Stack Changes.</p></li><li><p>Ejercicio propuesto al final del capítulo: sum1toN.s como subrutina recursiva</p></li></ul></div></div></section><section id="_pase_de_los_argumentos_y_llamada_a_la_subrutina"><h2>Pase de los argumentos y LLamada a la Subrutina</h2><div class="slide-content"><div class="ulist"><ul><li><p>función en lenguaje C: sumMtoN(M,N)</p></li><li><p>Primero se pasa el último argumento de la subrutina y el último argumento en pasar es el primer argumento de la subrutina</p></li><li><p>A continuación se llama a la subrutina</p></li><li><p>Código de pase de argumentos y llamada a la subrutina</p><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-x86asm hljs" data-noescape="true" data-lang="x86asm">main:
        xxxx xxx
        xxxx xxx
	push N
	push M
	call sumMtoN
        xxxx xxx
        xxxx xxx</code></pre></div></div></li><li><p>Estado de la pila después de insertar los argumentos y antes de ejecutarse la instrucción "call" &#8594; ¿?</p></li></ul></div></div></section><section id="_conservación_de_la_dirección_de_retorno"><h2>Conservación de la dirección de retorno</h2><div class="slide-content"><div class="ulist"><ul><li><p>El procesador durante el ciclo de instrucción de "call" inserta la dirección de retorno en la pila y salta a la dirección de comienzo de la subrutina introducción la dirección de la subrutina en el contador de programa.</p></li><li><p>Estado de la pila después de ejecutarse el <strong>call</strong> &#8594; ¿?</p></li></ul></div></div></section><section id="_comienzo_de_la_subrutina_prólogo"><h2>Comienzo de la Subrutina: Prólogo</h2><div class="slide-content"><div class="ulist"><ul><li><p>Es necesario conservar el fp de la rutina que realiza la llamada para una vez finaliza la subrutina volver a activar el frame de la rutina que llama.</p><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-x86asm hljs" data-noescape="true" data-lang="x86asm">sumMtoN:
        push %ebp</code></pre></div></div></li><li><p>El epílogo consisten activar un nuevo frame apuntando los dos punteros sp y fp al primer dato insertado.</p></li><li><p>Instrucciones del Prólogo</p><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-x86asm hljs" data-noescape="true" data-lang="x86asm">sumMtoN:
	push %ebp
	mov %esp,%ebp
        xxx xxx</code></pre></div></div></li><li><p>Estado de la pila: &#8594; ¿?</p></li></ul></div></div></section><section id="_variables_locales"><h2>Variables locales</h2><div class="slide-content"><div class="ulist"><ul><li><p>Las variables locales se definen en la pila después del prólogo reservando la memoria necesaria. Esto se realiza moviendo el stack pointer tantos bytes como ocupen las variables locales</p></li></ul></div></div></section><section id="_recuperación_de_los_argumentos"><h2>Recuperación de los Argumentos</h2><div class="slide-content"><div class="ulist"><ul><li><p>Pasar los argumentos de la pila a un registro para poder ser utilizados. Por ejemplo a los registros ECX y EDX en el caso de tener sólo 2 argumentos.</p></li></ul></div></div></section><section id="_fin_de_la_subrutina_epílogo"><h2>Fin de la subrutina: Epílogo</h2><div class="slide-content"><div class="ulist"><ul><li><p>El epílogo consiste en desactivar el frame de la subrutina, activar el frame de la rutina que realizó la llamada y saltar a la dirección de retorno.</p></li><li><p>Desactivar el frame de la subrutina: Que el sp apunte a la misma dirección que el bp.</p></li><li><p>Activar el Frame de la rutina: Actualizar el bp con el valor anterior al de la subrutina.</p></li><li><p>Saltar a la dirección de retorno: El sp ha de estar apuntando a donde se encuentra la dirección de retorno antes de ejecutar la instrucción <strong>ret</strong></p></li><li><p>Código del epílogo:</p><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-x86asm hljs" data-noescape="true" data-lang="x86asm">        xxx xxx
	mov %ebp,%esp
	push %ebp
        ret</code></pre></div></div></li><li><p>las instrucciones del epílogo son el proceso inverso del prólogo</p></li><li><p>Estado de la pila: &#8594; ¿?</p></li></ul></div></div></section><section id="_valor_de_retorno"><h2>Valor de retorno</h2><div class="slide-content"><div class="ulist"><ul><li><p>El valor de retorno no se pasa a través de la pila, se pasa a través del registro EAX</p></li></ul></div></div></section><section id="_preservación_de_los_registros"><h2>Preservación de los registros</h2><div class="slide-content"><div class="ulist"><ul><li><p>Es necesario preservar los registros EAX, ECX y EDX antes de llamar a la subrutina: la subrutina podrá utilizarlos libremente</p></li><li><p>Es necesario preservar los registros EBX,ESI,EDI,ESP,EBP  en caso de ser utilizados por la subrutina. Su valor ha de ser el mismo antes y después de la llamada a la subrutina.</p></li></ul></div></div></section><section id="_anidamiento_de_llamadas_a_funciones_frame_recurrente"><h2>Anidamiento de llamadas a funciones: FRAME RECURRENTE</h2><div class="slide-content"><div class="ulist"><ul><li><p>Comprender completamente <a href="https://diveintosystems.org/book/C8-IA32/recursion.html">La Animación de Recursión</a>: Analizar la función sumr en C y en ASM. Bajar al apartado 8.6.1. Animation: Observing How the Call Stack Changes.</p></li><li><p>Ejercicio: Desarrollar el código "sum1toN.s" como subrutina recursiva</p></li></ul></div></div></section><section id="_ejemplo_subrutina_summton_s" data-state="txikia"><h2>Ejemplo: Subrutina sumMtoN.s</h2><div class="slide-content"><div class="ulist"><ul><li><p>Código:</p></li></ul></div>
<div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-x86asm hljs" data-noescape="true" data-lang="x86asm">## Subrutina sumMtoN.s
### Descripcion: el shell de linux llama a la función main() y este llama a la subrutina suma()
                 el shell de linux pasa a main() los strings de la línea de comandos pero aquí no se utilizan
                 main() se va a definir como una subrutina (prologo,epilogo,etc ...)
		 suma() tiene dos argumentos M y N y calcula la suma de números enteros desde M hasta N
###
### gcc -m32 -o sumMtoN sumMtoN.s
### Ensamblaje as --32  -o sumMtoN.o  sumMtoN.s
### linker -&gt; ld  -e main -melf_i386 -I/lib/i386-linux-gnu/ld-linux.so.2  -o  sumMtoN  sumMtoN.o

### manual de instrucciones x86 -&gt; https://www.felixcloutier.com/x86/


	.section .data
M:	.byte 3
N:	.byte 10
resultado: .byte 0

	## el shell de linux llama a main()
	## el shell como funcion llamante ha preservado eax, ecx y edx

	.global main
	.section .text
main:
	## prologo de main
	push %ebp
	mov %esp,%ebp
	## variable local de main
	sub $4,%esp
	## como funcion que ha sido llamada por el shell preserva ebx, esi y edi para el shell
        push %edi
	push %esi
	push %ebx

	## capturar argumentos de la funcion llamante (linea de comandos del shell)
	##   en este caso no utilizo los argumentos
	## podría procesar los argumentos del shell y utilizar cualquiera de los registros eax,ebx,ecx,edx,esi,edi
        ##   en este caso no hay proceso

	## Voy a llamar a suma() y empiezan los preparativos
	## preservar los registros que puede utilizar suma() libremente
	push %edx
	push %ecx
	push %eax

	## pasar los argumentos a suma()
	movb N,%ecx   ## segundo argumento
        push %ecx
	movb M,%edx  ## primer argumento
        push %edx


	## Llamar a la subrutina
        call suma

	## Guardar el resultado de suma()
	movb %al,resultado

	## recuperar los registros salvados antes de la llamada suma()
	pop %eax
	pop %ecx
	pop %edx

	## podría procesar los datos y utilizar cualquiera de los registros eax,ebx,ecx,edx,esi,edi y  la variable resultado
	## En este caso no proceso nada, tengo el resultado en AL

	## Finalizo la funcion main() como toda subrutina retornando a la función llamante, en este caso el shell de linux
        ## como funcion que ha sido llamada por el shell recupera ebx, esi y edi para el shell
        pop %ebx
	pop %esi
	pop %edi

	## Retorna un valor al shell a traves de EAX por CONVENIO
	movb resultado,%al

	## epilogo de main
	mov %ebp,%esp           # frame anterior
	pop %ebp

        ret



### Funcion que calcula la suma de numeros de enteros en la secuencia entre dos limites dados
	.type suma, @function
	.section .text
suma:
	## Pasos iniciales antes del procesamiento de los argumentos de suma()
	## prologo: genera un nuevo frame para suma()
	push %ebp
	movl %esp,%ebp

        # una variable local de 4 bytes para suma()
	subl $4,%esp

	## preserva los registros utilizados por main()
	push %edi
	push %esi
	push %ebx

        ## captura de argumentos de la función suma()
	movb 8(%ebp),%al      #1º argumento
	movb 12(%ebp),%cl     #2º argumento


	## algoritmo de la subrutina suma(): suma desde el 1º arg hasta el 2º arg
        ## se pueden utilizar cualquiera de los registros eax,ebx,ecx,edx,esi,edi
	## utilizo "al" como suma parcial y "bl" como sumando
	movb %al,%bl
bucle:
	inc %bl
	addb %bl,%al
	cmpb %bl,%cl
	jg  bucle

	## el resultado esta en AL  por CONVENIO

	## Comienza el retorno a la función llamante main()
	## recupera los  registros salvados para main()
	pop %ebx
	pop %esi
	pop %edi

	## epilogo
	mov %ebp,%esp           # frame anterior
	pop %ebp
	ret                     # recuperar dirección de retorno

	.end</code></pre></div></div></div></section><section id="_ejercicio_3"><h2>Ejercicio</h2><div class="slide-content"><div class="ulist"><ul><li><p><a href="./as_code/sumMtoN_preservar.s">sumMtoN_preservar.s</a></p><div class="ulist"><ul><li><p>Convertir el bloque sumMtoN en una subrutina</p></li></ul></div></li><li><p><a href="./as_code/recursion.c">recursion.c</a></p><div class="ulist"><ul><li><p>Convertir la función recursion.c en una subrutina recursiva</p></li></ul></div></li></ul></div></div></section><section id="_llamadas_al_sistema"><h2>LLamadas al Sistema</h2></section><section id="_funciones_del_sistema"><h2>Funciones del sistema</h2><div class="slide-content"><div class="ulist"><ul><li><p>Privilegios del sistema, no del usuario: acceso al hardware (por ejemplo racceder a la pantalla para imprimir una imagen , acceder al disco para escribir un fichero, arrancar o finalizar un proceso, etc &#8230;&#8203;)</p></li><li><p>Volcar el contenido de la cabecera "/usr/include/asm/instd_32.h"</p><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-C hljs" data-noescape="true" data-lang="C">exit 1
fork 2r
open 5
close 6</code></pre></div></div></li></ul></div></div></section><section id="_llamada_y_pase_de_los_argumentos"><h2>LLamada y pase de los argumentos</h2><div class="slide-content"><div class="ulist"><ul><li><p>El código de identificación de la función se pasa a través del registro EAX</p></li><li><p>Los argumentos de la función se pasan a través de los registros EBX,ECX,EDX,ESI,EDI,EBP y en ese orden.</p></li><li><p>La llamada se realiza con la instrucción <strong>int $0x80</strong></p></li><li><p>Ejemplo con el servicio "exit":</p><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-x86asm hljs" data-noescape="true" data-lang="x86asm">	mov $1,%eax
	mov $0,%ebx
	int $0x80</code></pre></div></div></li><li><p>Ejercicio: código ensamblador con servicio "write" según el prototipo del manual "man 2 write"</p></li></ul></div></div></section></section>
<section id="Tema1-6_Ejer"><h2>Ejercicios Propuestos Temas 1-6</h2><div class="slide-content"><div class="ulist"><ul><li><p>En los apuntes <a href="https://kandido.github.io/eecc_book.html">on line</a>, en la sección III de "Ejercicios de Teoría" se invita a realizar como mínimo los ejercicios especificados en la "Lista mínima de ejercicios" de los cuales en clase se realizarán los siguientes:</p><div class="ulist"><ul><li><p>Arquitectura de Von Neumann: 1.1,1.2,1.3,1.4 y 1.6 (no programar en lenguaje ensamblador IASSim)</p></li><li><p>Representación de los Datos: 2,3,4 y 5</p></li><li><p>Programación en Lenguaje ensamblador AT&amp;T: 1.1, 1.2, 2.2.</p></li></ul></div></li></ul></div></div></section>
<section id="Prac_Ejer_I"><h2>Ejercicios de Prácticas I</h2><div class="slide-content"><div class="ulist"><ul><li><p>Datos:</p><div class="ulist"><ul><li><p>Todos los números enteros de todos los ejercicios tendrán un tamaño de 2 bytes.</p></li><li><p>Dado el string  "The United Nations Convention on the Rights of the Child is an important agreement by countries who have promised to protect children’s rights." contar el número de veces que aparece a letra "a"</p></li><li><p>Dado el array de números enteros: 0xFFFF,0x03,0x7FA0,0x87BC,0xBA34,0xFA,0x732 buscar el número con el valor negativo de menor módulo</p></li><li><p>Dado el array lista_A : 12,-33,45 y el array lista_B: 76,89,-65 generar el array lista_D suma de los elementos de lista_A y lista_B</p></li><li><p>Dado el array lista_A : 12,-33,45 y el array lista_B: 76,89,-65 generar el array lista_C formado el encadenamiento de lista_A y lista_B</p></li></ul></div></li><li><p>Llamadas al Sistema</p><div class="ulist"><ul><li><p>Imprimir en la pantalla el mensaje "Hola Mundo" mediante un programa en asm at&amp;t:</p><div class="ulist"><ul><li><p>Mediante las funciones de C printf y puts según los prototipos de los manuales "man 3 printf" y "man 3 puts"</p></li><li><p>Mediante la función del sistema "write" según el prototipo del manual "man 2 write"</p></li></ul></div></li></ul></div></li></ul></div></div></section>
<section id="Tema3_Float"><h2>Tema 3 Representación de los Datos: Números Reales</h2></section>
<section><section id="Tema7_CPU"><h2>Tema 7 Unidad Central de Proceso</h2><div class="slide-content"><div class="ulist"><ul><li><p>Introducción</p></li><li><p>Fases de ejecución de una instrucción</p></li><li><p>Ruta de datos</p></li><li><p>Segmentación</p></li><li><p>Arquitecturas CISC, RISC y VLIW</p></li><li><p>Conjunto de instrucciones</p></li></ul></div></div></section><section id="_introducción_2" class="columns"><h2>Introducción</h2><div class="slide-content"><div class="ulist column"><ul><li><p>El objetivo principal de la CPU es la implementación del ciclo de instrucción. Es el soporte hardware para poder llevar a cabo todas las operaciones que conllevan las intrucciones de un programa.</p></li><li><p>Nombres: Procesador, microprocesador (El componente electrónico básico es el transistor con un tamaño en sus origenes del orden de la micra ), ..</p></li><li><p>Central porque la computadora tiene varios procesadores: Por ejemplo el controlador de la memoria y los controladores de los periféricos.</p></li><li><p>La CPU es una de las unidades básicas que conforman la arquitectura Von-Neumann (CPU-MP-IO) y Buses.</p></li></ul></div>
<div class="openblock column"><div class="content"><div class="imageblock" style="text-align: center"><img src="images/von_neumann/ias_architecture.png" alt="ias architecture"></div><div class="title">Logo 1. IAS_Architecture</div></div></div></div></section><section id="_puntos_de_vista_sw_vs_hw"><h2>Puntos de Vista: SW vs HW</h2><div class="slide-content"><div class="imageblock" style="text-align: center"><img src="images/cpu/puntosdevista_isa_uarch.svg" alt="puntosdevista isa uarch" width="900" height="500"></div><div class="title">Logo 2. Puntos de Vista: SW y HW</div></div></section><section id="_puntos_de_vista_sw_vs_hw_2"><h2>Puntos de Vista: SW vs HW</h2><div class="slide-content"><div class="ulist"><ul><li><p>La CPU se puede ver desde el punto de vista del <strong>programador</strong> o desde el punto de vista del diseñador de procesadores (microarquitectura)</p></li><li><p>Desde el punto de vista del programador interesa conocer:</p><div class="ulist"><ul><li><p>La Arquitectura del Repertorio de Instrucciones (ISA): Formatos de datos e intrucciones, operaciones,  modos de direccionamiento, registros, direccionamiento de la memoria, alineamiento de los datos, etc</p></li><li><p>Modos de Funcionamiento de la CPU: modo superusuario, modo usuario, modo interrupción.</p></li></ul></div></li><li><p>Desde el punto de vista de la Microarquitectura u organización interna de la CPU.</p><div class="ulist"><ul><li><p>Las unidades básicas de la CPU son: Unidad de Control (UC), y la Ruta de Datos (ALU,FPU,MMU,Registros y circuitos de enrutamiento como multiplexores, conmutadores, etc).</p></li><li><p>La Unidad de Control se encarga de la gestión de las operaciones a realizar, mediante microórdenes, para completar el ciclo de instrucción. Electrónicamente es un circuito digital secuenciador cuyas secuencias son las fases del ciclo de instrucción.</p><div class="ulist"><ul><li><p>Las microórdenes son señales digitales binarias.</p></li></ul></div></li></ul></div></li></ul></div></div></section><section id="_fases_de_ejecución_de_una_instrucción"><h2>Fases de ejecución de una instrucción</h2><div class="slide-content"><div class="imageblock" style="text-align: center"><img src="images/cpu/12_5.jpg" alt="12 5"></div><div class="title">Logo 3. Diagrama de Estados del Ciclo de Instrucción</div>
<div class="paragraph"><p><strong>I</strong>-nstruction  and <strong>O</strong>-perand</p></div>
<div class="paragraph"><p>I-Fetch / I-Decode / O-Fetch / I-Execute / O-Write / I-Interrupt / Next-I</p></div></div></section><section id="_sincronismo_de_las_operaciones_señal_de_reloj" class="columns"><h2>Sincronismo de las operaciones: señal de reloj</h2><div class="slide-content"><div class="openblock column"><div class="content"><div class="ulist"><ul><li><p>Señal de Reloj: Señal binaria (niveles 0 y 1) periódica (cada ciclo de la señal se repite)</p></li><li><p>Físicamente es una señal electrónica: puede ser una tensión (microvoltios) ó una corriente (microamperios)</p></li></ul></div>
<div class="imageblock kroki"><img src="https://kroki.io/ditaa/svg/eNrjys1MLsovy88pycwv5orjqlGAgxAFW1s7BUP9NKCgjS4WYIesmhxgiGGANthgbcpFMUyuQSIpEh1GJpdRLjpiwtmAOJO1UbOINlKapFSU0txGAOQl5uUXp6aX5qUACwJtXdoDOy4AS1O6wQ==" alt="Diagram"></div>
<div class="ulist"><ul><li><p>Flancos de reloj: Cambio de nivel 0&#8594;1 (positivos) o  1&#8594;0 (negativos)</p></li></ul></div></div></div>
<div class="ulist column"><ul><li><p>El reloj se utiliza para poder sincronizar las operaciones de los circuitos electrónicos</p><div class="ulist"><ul><li><p>Pej : instantes en que cambian las salidas de un registro</p></li><li><p>Pej : instantes en que cambian las salidas de la memoria</p></li><li><p>Pej : instantes en que cambian las microórdenes de la unidad de control</p></li></ul></div></li><li><p>El objetivo es facilitar el diseño de los circuitos electrónicos digitales con que se implementan</p></li></ul></div></div></section><section id="_unidad_de_control_y_ruta_de_datos"><h2>Unidad de Control y Ruta de datos</h2><div class="slide-content"><div class="ulist"><ul><li><p>Primero diseñaremos la Ruta de Datos de cada Instrucción y finalmente la Unidad de Control que gestiona la ruta de datos de cada instrucción</p></li><li><p>Es necesario diseñar una ruta de datos diferente para cada instrucción y una única Unidad de Control para todas las instrucciones</p></li></ul></div>
<div class="imageblock" style="text-align: center"><img src="images/von_neumann/ias_operation.png" alt="ias operation"></div><div class="title">Logo 4. IAS Operation</div></div></section><section id="_rutas_de_datos"><h2>Rutas de Datos</h2><div class="slide-content"><div class="imageblock" style="text-align: center"><img src="images/cpu/singlecycle.jpg" alt="singlecycle"></div><div class="title">Logo 5. Data Path Single Cycle</div></div></section><section id="_rutas_de_datos_2" class="columns"><h2>Rutas de Datos</h2><div class="slide-content"><div class="openblock column"><div class="content"><div class="ulist"><ul><li><p>Los bloques que forman parte de la ruta de datos se encuentran interconectados uno a uno mediante hilos (pistas o cables)</p></li><li><p>En la imagen se distinguen los hilos de la ruta de datos de los nombres de las microoperaciones (subrayados)</p></li><li><p>Ins7-6 : son los bits 7-6 del campo de operación para cada instrucción &#8594; Dependiendo del valor de estos dos bits la ruta de datos cambia</p></li><li><p>InstM-N: son la secuencia de bits M(M-1) hasta N del campo de operaciones para cada instrucción. Mismo concepto que para Inst7-6</p></li></ul></div></div></div>
<div class="openblock column"><div class="content"><div class="ulist"><ul><li><p>Función del multiplexor:</p></li><li><p>se conecta sólo una de las 4 entradas a la salida. La entrada INx se selecciona con S1S0</p><div class="imageblock kroki"><img src="https://kroki.io/ditaa/svg/eNrjUoCAmhguBU8_Q11d3RoFMNMIzFSoiQcCBf_QEJCYMVQMxDYBs_W5YPr1a2pgbCAPwQ42DDYAAFL0FTQ=" alt="Diagram"></div></li></ul></div></div></div></div></section><section id="_unidad_de_control_microoperaciones_y_ruta_de_datos"><h2>Unidad de Control: Microoperaciones y Ruta de Datos</h2><div class="slide-content"><div class="ulist"><ul><li><p>La Unidad de Control gobierna la ruta de datos para completar todas las fases del ciclo de instrucción de cada instrucción del juego ISA</p></li><li><p>Microoperaciones: operaciones realizadas por la CPU internamente, al ejecutar cada fase del ciclo de instrucción de una Instrucción Máquina.</p><div class="ulist"><ul><li><p>Ejemplos de microoperacioones: escribir en el registro MAR, orden de lectura a la MPrincipal, leer de MBR, interpretar de IR, incrementar PC, etc</p></li><li><p>Microoperaciones síncronas con el flanco positivo del reloj del secuenciador (unidad de control) de la cpu</p></li></ul></div></li></ul></div></div></section><section id="_unidad_de_control_secuenciador_o_máquina_de_estados_finitos"><h2>Unidad de Control: Secuenciador o Máquina de Estados Finitos</h2><div class="slide-content"><div class="imageblock"><img src="images/cpu/microoperaciones_tabla.png" alt="Tabla de microoperaciones"></div>
<div class="ulist"><ul><li><p>El circuito electrónico controlador es un secuenciador digital síncrono o máquina de estados finitos</p></li><li><p>La tabla presenta las entradas y salidas del  secuenciador para cada instrucción</p></li><li><p>Las entradas del secuenciador son: el código del campo de operaciones de la instrucción, el código del registro de flags, la etapa del ciclo de instrucción y el RELOJ.</p></li><li><p>La salida es el conjunto de microoperaciones para esa entrada que cambiará sincronamente con el RELOJ.</p></li></ul></div></div></section><section id="_unidad_de_control_secuenciador_o_máquina_de_estados_finitos_2" class="columns"><h2>Unidad de Control: Secuenciador o Máquina de Estados Finitos</h2><div class="slide-content"><div class="openblock column"><div class="content"><div class="imageblock"><img src="images/cpu/secuenciador_fases.png" alt="Secuencia de Fases de cada Instrucción"></div></div></div>
<div class="openblock column"><div class="content"><div class="ulist"><ul><li><p>Cada instrucción tiene su propia secuencia</p></li><li><p>En cada fase será necesario ejecutar las microoperaciones para completar dicha fase</p></li><li><p>La unidad de control se diseña para que cada fase se complete en un ciclo de reloj</p></li></ul></div></div></div></div></section><section id="_unidad_de_control_micro_operaciones"><h2>Unidad de control: micro-operaciones</h2><div class="slide-content"><div class="imageblock" style="text-align: center"><img src="images/von_neumann/ias_operation.png" alt="ias operation"></div><div class="title">Logo 6. IAS Operation</div></div></section><section id="_microarquitecturas_risc_y_cisc" class="columns"><h2>Microarquitecturas: RISC y CISC</h2><div class="slide-content"><div class="ulist column"><ul><li><p>CISC: Complex Instruction Set Computer</p><div class="ulist"><ul><li><p>Intel</p></li><li><p>elevado número de códigos de operación</p></li><li><p>instrucciones máquina que realizan operaciones "complejas" y múltiples modos de direccionamiento complejos</p></li><li><p>Ventajas: fácil de compilar, módulo binario reducido</p></li><li><p>Inconvenientes: Unidad de Control compleja, alto consumo y elevado coste</p></li><li><p>Aplicación : servidores</p></li></ul></div></li></ul></div>
<div class="ulist column"><ul><li><p>RISC: Reduced Instruction Set Computer</p><div class="ulist"><ul><li><p>ARM</p></li><li><p>reducido número de códigos de operación</p></li><li><p>operaciones "sencillas" y modos de direccionamiento sencillos</p></li><li><p>Ventajas: unidad de control sencilla, bajo consumo y bajo coste</p></li><li><p>Inconvenientes: no puede competir en número de procesos a ejecutar y a alta velocidad,</p></li><li><p>Aplicación: computación portátil</p></li></ul></div></li></ul></div></div></section><section id="_microarquitectura_segmentada"><h2>Microarquitectura Segmentada</h2><div class="slide-content"><div class="ulist"><ul><li><p>Pipeline &#8594; tuberías</p></li><li><p>Ejemplo de la cadena para la limpieza automática de coches</p></li><li><p>Múltiples fases del ciclo de instrucción ejecutándose simultáneamente: paralelismo</p></li><li><p>Calcular el Througput: instrucciones ejectudas por unidad de tiempo</p></li></ul></div></div></section><section id="_arquitectura_vliw_vs_superscalar"><h2>Arquitectura VLIW vs Superscalar</h2><div class="slide-content"><div class="ulist"><ul><li><p>VLIW: Very Large Instruction Word</p></li><li><p>Superscalar</p></li><li><p>Múltiples Unidades de Ejecución: ¿Cómo se distribuyen las instrucciones para cada Unidad de Ejecución?</p></li></ul></div></div></section><section id="_investigar_la_microarquitectura_del_ordenador_personal"><h2>Investigar la microarquitectura del ordenador personal</h2><div class="slide-content"><div class="ulist"><ul><li><p>Herramientas</p></li></ul></div></div></section></section>
<section id="Tema8_IO"><h2>Tema 8:  Mecanismos de Entrada/Salida</h2></section>
<section><section id="Tema9_MEM"><h2>Tema 9: Unidad de Memoria</h2></section><section id="_introducción_3" class="columns"><h2>Introducción</h2><div class="slide-content"><div class="ulist column"><ul><li><p>¿ Qué hemos visto relacionado con la Memoria de una Computadora ?</p></li><li><p>John von Neumann 1950 : Computadora con programa almacenado</p><div class="ulist"><ul><li><p>Unidad de Memoria: programación binaria &#8594; Instrucciones máquina y datos</p></li><li><p>Arquitectura von Neumann: CPU+Unidad de Memoria+I/O+buses</p></li></ul></div></li><li><p>Memoria: Registros de la CPU y Memoria Principal (Externa a la CPU)</p></li><li><p>Ciclo de Instrucción: Captura de Instrucciones y Operandos de la Memoria Principal</p></li></ul></div>
<div class="ulist column"><ul><li><p>Objetivo de la Memoria Principal:</p><div class="ulist"><ul><li><p>Aumentar la Capacidad de Almacenamiento: En las computadoras multiproceso se ejecutan simultáneamente múltiples programas (centenares) que han de estar accesibles a la CPU.</p></li><li><p>Reducir la Latencia (tiempo de acceso o captura): Hay instrucciones que la cpu ejecuta en un ciclo de reloj (del orden de 1 ns) y el tiempo de captura de la instrucción o dato es del orden de 100 ciclos de reloj.</p></li></ul></div></li></ul></div></div></section><section id="_perspectivas_de_estudio"><h2>Perspectivas de estudio</h2><div class="slide-content"><div class="ulist"><ul><li><p>La memoria es estudiada desde puntos de vista diferentes dependiendo del entorno de estudio.</p></li><li><p>Sistemas Operativos: Gestor de Memoria Virtual</p></li><li><p>Compilador, Linker,&#8230;&#8203;: secciones de memoria ( datos, instrucciones, pila, &#8230;&#8203;), resolución de direcciones de etiquetas, etc</p></li><li><p>ISA: etiquetas, modos de direccionamiento, tamaño de los datos, instrucciones de movimiento de bloques de datos, directivas, etc</p></li><li><p>Programador: Variables ordinarias, arrays, estructuras de datos, etc</p></li><li><p>Hardware: Organización y Estructura de la Memoria</p></li></ul></div></div></section><section id="_jerarquía_de_memoria"><h2>Jerarquía de Memoria</h2><div class="slide-content"><div class="imageblock"><img src="images/memoria/MemoryHierarchy.png" alt="MemoryHierarchy" width="80%"></div><div class="title">Logo 7. Jerarquía de Memoria</div>
<div class="ulist"><ul><li><p>Capacidad vs Latencia</p></li><li><p>Concepto de Caching</p></li></ul></div></div></section><section id="_registros"><h2>Registros</h2><div class="slide-content"><div class="imageblock"><img src="images/instrucciones_representacion/registers_1200x800.png" alt="registers 1200x800" width="70%"></div><div class="title">Logo 8. Registros x86</div></div></section><section id="_registros_2"><h2>Registros</h2><div class="slide-content"><div class="imageblock"><img src="images/memoria/Table_of_x86_Registers_svg.png" alt="Table of x86 Registers svg" width="100%"></div><div class="title">Logo 9. Registros arquitectura amd64</div></div></section><section id="_memoria_de_semiconductor" data-state="taula_ta"><h2>Memoria de Semiconductor</h2><div class="slide-content"><table class="tableblock frame-topbot grid-all" style="width:90%"><colgroup><col style="width:20%"><col style="width:20%"><col style="width:20%"><col style="width:20%"><col style="width:20%"></colgroup><thead><tr><th class="tableblock halign-left valign-top">Memory Type</th><th class="tableblock halign-left valign-top">Category</th><th class="tableblock halign-left valign-top">Erasure</th><th class="tableblock halign-left valign-top">Write Mechanism</th><th class="tableblock halign-left valign-top">Volatility</th></tr><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Random-access memory (RAM)</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Read-write memory</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Electrically, byte-level</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Electrically</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Volatile</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Read-only memory (ROM)</code></p></td><td class="tableblock halign-left valign-top" rowspan="2"><p class="tableblock"><code>Read-only memory</code></p></td><td class="tableblock halign-left valign-top" rowspan="2"><p class="tableblock"><code>Not possible</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Masks</code></p></td><td class="tableblock halign-left valign-top" rowspan="5"><p class="tableblock"><code>Nonvolatile</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Programmable ROM (PROM)</code></p></td><td class="tableblock halign-left valign-top" rowspan="4"><p class="tableblock"><code>Electrically</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Erasable PROM (EPROM)</code></p></td><td class="tableblock halign-left valign-top" rowspan="3"><p class="tableblock"><code>Read-mostly memory</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>UV light,chip-level</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Electrically Erasable PROM (EEPROM)</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Electrically, byte-level</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Flash memory</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Electrically,block-level</code></p></td></tr></table></div></section><section id="_memoria_ram_dinámica_celda_dram" class="columns"><h2>Memoria RAM Dinámica: Celda DRAM</h2><div class="slide-content"><div class="openblock column text-left"><div class="content"><div class="paragraph"><p><span class="image" style="float: left"><img src="images/dram/cell_1t1c.png" alt="cell 1t1c" title="cell_1t1c"></span></p></div>
<div class="ulist"><ul><li><p>Celda DRAM: 1 Transistor (14nm) y 1 Condensador (3nm)</p></li><li><p>Celda de área reducida y bajo consumo &#8594; alto nivel de integración &#8594; Memoria Principal</p></li><li><p>Fugas de carga del condensador: necesidad de reescritura (Refresco) &#8594; Estado Dinámico</p></li></ul></div></div></div>
<div class="openblock column"><div class="content"><div class="paragraph"><p><span class="image" style="float: left"><img src="images/dram/cell_capacitor.png" alt="cell capacitor" title="cell_capacitor"></span></p></div></div></div></div></section><section id="_memoria_ram_estática_celda_sram"><h2>Memoria RAM eStática: Celda SRAM</h2><div class="slide-content"><div class="imageblock" style="text-align: center"><img src="images/cache/sram_cell_6T.png" alt="sram cell 6T"></div><div class="title">Logo 10. SRAM-cell</div>
<div class="ulist text-left"><ul><li><p>Celda SRAM : 6 Transistores</p></li><li><p>Memoria Caché: latencia reducida</p></li><li><p>Sin fugas: Estado Estático</p></li></ul></div></div></section><section id="_memoria_dram_demultiplexor" class="columns"><h2>Memoria DRAM: Demultiplexor</h2><div class="slide-content"><div class="openblock column"><div class="content"><div class="ulist"><ul><li><p>¿Cómo se pueden organizar y estructurar miles de millones de celdas?</p></li><li><p>Una memoria con un bus de direcciones de 30 hilos qué decodificador necesitaría?</p><div class="ulist"><ul><li><p>Con 30 hilos se pueden direccionar 2<sup>30</sup> bits</p></li><li><p>Entrada binaria: 30 hilos</p></li><li><p>Salida decimal: 2<sup>30</sup> = 1.073.741.824 salidas &#8594; IMPOSIBLE DE FABRICAR en un chip</p></li></ul></div></li></ul></div></div></div>
<div class="openblock column"><div class="content"><div class="imageblock"><img src="images/dram/demux.png" alt="demux" width="50%"></div><div class="title">Logo 11. Demultiplexor del bus de Direcciones</div></div></div></div></section><section id="_memoria_dram_array_bidimensional" class="columns"><h2>Memoria DRAM: Array Bidimensional</h2><div class="slide-content"><div class="openblock column"><div class="content"><div class="ulist"><ul><li><p>Solución</p><div class="ulist"><ul><li><p>2<sup>30</sup> = 2<sup>15</sup> * 2<sup>15</sup></p></li><li><p>2<sup>15</sup> =  32.768</p></li><li><p>La solución son dos multiplexores de 15 entradas y 32.768 salidas cada uno.</p></li><li><p>La organización de las celdas es una matriz de dos dimensiones. Filas y Columnas cuya intersección es una celda de memoria.</p></li><li><p>De los 30 hilos del bus de direcciones 15 son la entrada del multiplexor de Filas y las otra 15 del multiplexor de columnas</p></li></ul></div></li><li><p>Otros Componentes: Amplificador de Salida y Buffer I/O de datos</p></li></ul></div></div></div>
<div class="openblock column"><div class="content"><div class="imageblock"><img src="images/dram/array2.png" alt="array2" width="120%"></div><div class="title">Logo 12. Array 2D</div></div></div></div></section><section id="_memoria_dram_banco"><h2>Memoria DRAM: Banco</h2><div class="slide-content"><div class="ulist"><ul><li><p>Con un Array tenemos datos de un sólo bit</p></li><li><p>Mediante el agrupamiento de N arrays tenemos datos de N bits &#8594; xN</p></li><li><p>Agrupando múltiples arrays organizamos las celdas de memoria en 3 dimensiones</p></li><li><p>Un agrupamiento de arrays recibe el nombre de <strong>Bank</strong></p></li></ul></div>
<div class="paragraph"><p><span class="image"><img src="images/dram/bank1.png" alt="Banco"></span></p></div></div></section><section id="_memoria_dram_chip"><h2>Memoria DRAM: Chip</h2><div class="slide-content"><div class="ulist"><ul><li><p>Un chip de memoria consiste en el agrupamiento de múltiples Bancos</p></li><li><p>Un chip de memoria tiene un <strong>Buffer I/O</strong> para todos los bancos. Almacena el dato a escribir o leer</p></li><li><p>El tamaño del Buffer I/O se indica mediante el prefijo xN</p></li></ul></div>
<div class="imageblock"><img src="images/dram/bank2.png" alt="bank2"></div><div class="title">Logo 13. Chip</div></div></section><section id="_memoria_dram_ejemplo_de_un_chipx16" class="columns"><h2>Memoria DRAM: Ejemplo de un Chipx16</h2><div class="slide-content"><div class="openblock column"><div class="content"><div class="ulist"><ul><li><p>Control Logic: Circuitería para Direccionamiento, Lectura, Escritura, Refresco, &#8230;&#8203;</p></li><li><p>Un banco &#8594; 3D: 8196 x 512 x 16 &#8594; Filas x Columnas x Nº_de_Arrays/Banco &#8594; 2<sup>13</sup> x 2<sup>9</sup> x 16</p><div class="ulist"><ul><li><p>Demultiplexor del direccionamiento de Filas : 13 entradas y 8196 salidas</p></li><li><p>Demultiplexor del direccionamiento de Columnas: 9 entradas y 512 salidas</p></li><li><p>Capacidad de Memoria del Banco: 2<sup>22</sup> x 16bits = 2<sup>22</sup> x 2<sup>1</sup>Bytes = 2<sup>23</sup> Bytes = 2<sup>3</sup> x 2<sup>20</sup> = 8MB</p></li><li><p>Bus de direcciones: 2<sup>23</sup> &#8594; 23 hilos</p></li><li><p><strong>Espacio de Direcciones</strong> &#8594; (Fila,Columna) &#8594; Se seleccionan 2 Bytes de forma NO Lineal.</p></li></ul></div></li></ul></div></div></div>
<div class="openblock column"><div class="content"><div class="ulist"><ul><li><p><strong>Ejemplo</strong>: Dirección Lineal 0x7A4E6B de un byte</p><div class="ulist"><ul><li><p>Espacio no lineal: (Fila 111-1010-0100-11 , Columna 10-0110-1010) &#8594; (0x1E93 , 0x26B)</p></li><li><p>Se seleccionan 2 bytes para las direcciones lineales 0x7A4E6A y el 0x7A4E6B ubicados en la posición (0x1E93 , 0x26B) del Banco</p></li></ul></div></li><li><p>Chip</p><div class="ulist"><ul><li><p>Buffer i/o del chip= 16 bits de datos = 2Bytes</p></li><li><p>Capacidad de Memoria del chip: 4 Bancos x 8MB = 32MB</p></li><li><p>Espacio de direcciones NO lineal <strong>(Banco,Fila,Columna)</strong></p></li><li><p>La lógica electrónica del Chip debe de realizar la conversión: espacio lineal&#8594; espacio no lineal</p></li></ul></div></li></ul></div></div></div></div></section><section id="_memoria_dram_tarjeta_ó_módulo_dimm"><h2>Memoria DRAM: Tarjeta ó Módulo DIMM</h2><div class="slide-content"><div class="paragraph"><p><span class="image"><img src="images/dram/tarjeta_micron_1.png" alt="tarjeta micron 1"></span></p></div>
<div class="ulist"><ul><li><p>DIMM: Dual In-Line Memory Module : Chips por las dos caras de la tarjeta</p></li></ul></div></div></section><section id="_row_buffer"><h2>Row Buffer</h2><div class="slide-content"><div class="imageblock"><img src="images/dram/row-buffer_2.svg" alt="row buffer 2"></div></div></section><section id="_row_buffer_2"><h2>Row Buffer</h2><div class="slide-content"><div class="ulist"><ul><li><p>Actúa como caché dentro del propio módulo de memoria DRAM</p></li><li><p>Capturas sucesivas de operandos &#8594; no es necesario volver a leer los condensadores</p></li><li><p>Optimización al programar estructuras de datos</p></li></ul></div></div></section><section id="_memoria_dram_rank"><h2>Memoria DRAM: Rank</h2><div class="slide-content"><div class="paragraph"><p><span class="image"><img src="images/dram/rank1.png" alt="rank1"></span></p></div>
<div class="paragraph"><p>Chip Select: Activa los chips para que se conecten a los buses</p></div></div></section><section id="_espacios_de_direccionamiento_de_memoria"><h2>Espacios de Direccionamiento de Memoria</h2><div class="slide-content"><div class="ulist"><ul><li><p>Espacio de Direcciones: Formato del modo de direccionamiento</p><div class="ulist"><ul><li><p>Ejemplo no lineal: Prof Cándido Aramburu, Dpto Ingeniería Eléctrónica y Comunicaciones, Campus Arrosadía, UPNA, Av/Cataluña, Pamplona 31006, Navarra</p></li><li><p>Ejemplo lineal : DNI 17.987.XXX</p></li></ul></div></li><li><p>Programador lenguaje ensamblador: espacio de memoria en secciones, etiquetas, &#8230;&#8203;</p></li><li><p>Programa lenguaje binario : espacio de memoria virtual &#8594; direccionamiento lógico no lineal &#8594; (sección datos , dirección 0x000012AF)</p></li><li><p>CPU: espacio de memoria virtual &#8594; direccionamiento lógico no lineal &#8594; (segmento datos, dirección 0xBC007100)</p></li><li><p>Módulo DRAM &#8594; espacio (rank,bank,row,column)</p></li></ul></div></div></section><section id="_controlador_de_memoria"><h2>Controlador de Memoria</h2><div class="slide-content"><div class="ulist"><ul><li><p>Unidad Intermedia entre la CPU y los módulos de Memoria DRAM</p></li><li><p>Realiza tareas de: Refresco, Sincronismo de la transferencia de datos, Traductor de espacios de direcciones: virtual, lineal, no lineal, etc</p></li></ul></div>
<div class="imageblock"><img src="images/dram/system.png" alt="system"></div></div></section><section id="_memoria_dram_channel"><h2>Memoria DRAM: Channel</h2><div class="slide-content"><div class="ulist"><ul><li><p>Un canal de memoria selecciona un grupo de tarjetas DIMM. Cada canal tiene su propio espacio de direccionamiento.</p></li><li><p>El Controlador de Memoria puede operar simultáneamente con diferentes canales</p></li></ul></div></div></section><section id="_controlador_de_memoria_dram"><h2>Controlador de Memoria DRAM</h2><div class="slide-content"><div class="ulist"><ul><li><p>Unidad Memory Managment Unit (MMU): traduce la dirección virtual lógica en una dirección física lineal</p></li><li><p>Traductor físico lineal a físico no lineal (canal,rank,bank,row,column)</p></li></ul></div></div></section><section id="_intel_82946gz_graphics_and_memory_controller_hub"><h2>Intel® 82946GZ Graphics and Memory Controller Hub</h2><div class="slide-content"><div class="paragraph text-left"><p>El manual del controlador de memoria de Intel ( Intel ® 946 Express Chipset Family año 2006) en el apartado 1.3.2 (System Memory Interface) dice:<br>
• The (G)MCH integrates a system <strong>memory</strong> DDR2 (Double Data Rate 2 generation) <strong>controller</strong> with two, 64-bit wide interfaces. Capabilities of the system memory interface include:<br>
• Supports 256-Mb, 512-Mb, and 1-Gb technologies for x8 and x16 devices<br>
• Supports four banks for all DDR2 devices up to 512-Mbit density. Supports eight banks for 1-Gbit DDR2 devices<br>
• By using 1 Gb technology in Dual Channel Interleaved Mode, the largest <strong>memory capacity</strong> possible is 4 GB. (16 K rows x 1 K columns x 1 cell/(row x column) x 8 b/cell x 8 banks/device x 8 devices/DIMM-side x 2 DIMM-sides/channel x 2 channels x 1 B/8 b x 1 G/1024 M x 1 M/(KxK)<br>
 = (2<sup>14</sup> rows x 2<sup>10</sup> columns x 1 cell/(row x column) x 2<sup>3</sup> b/cell x 2<sup>3</sup> banks/device x 2<sup>3</sup> devices/DIMM-side x 2<sup>1</sup> DIMM-sides/channel x 2<sup>1</sup><br>
channels x 1Byte/8bits x 1KB/1024B x 1MB/1024KB x 1GB/1024MB   = 2<sup>(14+10+3+3+3+1+1-3-10-10-10)</sup>GB = 2<sup>(35-33)</sup>GB=4GB<br>
• Maximum DRAM address decode space is 4 GB (assuming 36-bit addressing)<br>
• Supports up to 32 simultaneous <strong>open pages</strong> per channel (assuming 4 ranks of 8 bank devices)</p></div></div></section><section id="_sincronismo_de_la_memoria_dram_sdram" class="columns"><h2>Sincronismo de la Memoria DRAM : SDRAM</h2><div class="slide-content"><div class="openblock column"><div class="content"><div class="ulist"><ul><li><p>La transferencia de datos entre la CPU y los módulos DRAM se realiza de forma síncrona con el reloj propio del bus de memoria.</p></li><li><p>El flanco del reloj es el patrón de comienzo y fin de las operaciones</p></li><li><p><strong>DDR (Double Data Rate)</strong></p><div class="ulist"><ul><li><p>Permite transferir el bit tanto en el flanco de <strong>bajada</strong> como de <strong>subida</strong> del reloj (<strong>doble bombeo</strong>)</p></li><li><p>Arquitectura amd64 &#8594; Bus de datos de 64  bits conectado al <strong>Buffer i/o</strong> de la memoria</p></li></ul></div></li><li><p>Frecuencia del buffer i/o</p><div class="ulist"><ul><li><p>El buffer i/o de la memoria pude ir a frecuencias x2, x4 y x8 respecto de la frecuencia de acceso a la celda.</p></li><li><p><strong>Supercelda</strong> ó <strong>Macrocelda</strong>:Ahora una selección (fila,columna) de un array supone no la seleccion de 1 celda sino la de una macrocelda de 2, 4 u 8 CELDAS de cada Banco.</p></li></ul></div></li></ul></div></div></div>
<div class="openblock column"><div class="content"><div class="ulist"><ul><li><p>DDR1: una macrocelda de 2<sup>1</sup> celdas &#8594; 2 celdas</p><div class="ulist"><ul><li><p>1ª Generación:  año 2000</p></li><li><p>El buffer i/o del chip tiene 2 registros, cada uno de 64 bits.</p></li></ul></div></li><li><p>DDR2: una macrocelda de 2<sup>2</sup> celdas &#8594; 4 celdas</p><div class="ulist"><ul><li><p>2ª Generación:  año 2006</p></li><li><p>El buffer i/o del chip tiene 4 registros</p></li></ul></div></li><li><p>DDR3: una macrocelda de 2<sup>3</sup> celdas &#8594; 8 celdas</p><div class="ulist"><ul><li><p>3ª Generación:  año 2011</p></li><li><p>El buffer i/o del chip tiene 8 registros</p></li></ul></div></li><li><p>DDR4: una macrocelda de 2<sup>4</sup> celdas &#8594; 16 celdas</p><div class="ulist"><ul><li><p>4ª Generación:  año 2014</p></li><li><p>El buffer i/o del chip tiene 16 registros</p></li></ul></div></li><li><p>DDR5: una macrocelda de 2<sup>5</sup> celdas &#8594; 32 celdas</p><div class="ulist"><ul><li><p>5ª Generación:  año 2020</p></li><li><p>El buffer i/o del chip tiene 32 registros</p></li></ul></div></li></ul></div></div></div></div></section><section id="_sincronismo_de_la_memoria_dram_synchronous_dram_sdram"><h2>Sincronismo  de la Memoria DRAM : Synchronous DRAM &#8594; SDRAM</h2><div class="slide-content"><div class="openblock"><div class="content"><div class="imageblock" style="float: left"><img src="images/dram/ddr1_frequency.png" alt="ddr1 frequency"></div></div></div>
<div class="paragraph"><p><strong>DDR</strong><br>
 En cada acceso a la macrocelda se leen 2<sup>1</sup> celdas, es decir, dos datos. Los 2 datos se almacenan en los 2 registos del buffer i/o<br>
 En el período del reloj del bus de memoria f_bm se realizan 2 transferencias (una en el flanco de bajada y otra en el flanco de subida), a través del bus de datos, de 64 bits (8Bytes) cada una.<br>
 Las 2 transferencias de los 2 registros i/o necesitan por lo tanto 1 período a la frecuencia f_bm.<br>
 Durante el período f_bm que dura el vaciado de los 2 registros i/o es necesario el acceso una macrocelda, por lo que la frecuencia de acceso a la macrocelda f_a = f_bm<br>
 La frecuencia efectiva (frecuencia de transferencia de datos de 8Bytes) del bus de memoria f_ebm es el el doble de la frecuencia f_bm por realizarse dos transferencias en un período  &#8594; f_ebm = 2f_bm = 2f_a &#8594; f_ebm transferencias por segundo &#8594; f_ebm*8Bytes por segundo</p></div>
<div class="imageblock" style="float: left"><img src="images/dram/ddr2_frequency.png" alt="ddr2 frequency"></div>
<div class="paragraph"><p><strong>DDR2</strong></p></div></div></section><section id="_sincronismo_de_la_memoria_dram_synchronous_dram_sdram_2"><h2>Sincronismo  de la Memoria DRAM : Synchronous DRAM &#8594; SDRAM</h2><div class="slide-content"><div class="imageblock"><img src="images/dram/ddr3_frequency.png" alt="ddr3 frequency"></div>
<div class="paragraph"><p><strong>DDR3</strong><br>
 En cada acceso a la macrocelda se leen 2<sup>3</sup> celdas, es decir, 8 datos. Los 8 datos se almacenan en los 8 registos del buffer i/o<br>
 En el período del reloj del bus de memoria f_bm se realizan 2 transferencias (una en el flanco de bajada y otra en el flanco de subida), a través del bus de datos, de 64 bits (8Bytes)cada una.<br>
 Las 8 transferencias de los 8 registros i/o necesitan por lo tanto 4 períodos a la frecuencia f_bm.<br>
 Durante los 4 períodos f_bm que dura el vaciado de los 8 registros i/o es necesario el acceso una macrocelda, por lo que la frecuencia f_bm = 4f_a<br>
 La frecuencia efectiva del bus de memoria f_ebm es el el doble de la frecuencia f_bm por realizarse dos transferencias en un período &#8594; f_ebm = 2f_bm = 8f_a &#8594; f_ebm transferencias por segundo &#8594; f_ebm*8Bytes por segundo</p></div></div></section><section id="_sincronismo_de_la_memoria_dram_nominación_de_los_módulos_de_memoria" class="columns"><h2>Sincronismo  de la Memoria DRAM: Nominación de los módulos de memoria</h2><div class="slide-content"><div class="ulist column"><ul><li><p>PC2-6400 (DDR2-800) 5-5-5-16</p><div class="ulist"><ul><li><p>DDR 2ª generación &#8594; Macroceldas de 4 celdas &#8594; Buffer i/o de 4 registros</p></li><li><p>Ancho de banda BW = 6400 MB/s</p></li><li><p>f_ebm = 800MHz &#8594; BW=8Bytes/transferencia*800*10<sup>6</sup>transferencias/seg = 6400 MB/s</p></li><li><p>f_bm=f_ebm/2=400MHz &#8594; f_a=f_ebm/4=200MHz</p></li><li><p>5-5-5-16 : diferentes tiempos de sincronismo (tCL-tRCD-tRP-tRAS) del bus de control expresados en número de ciclos de reloj (1/f_bm = 2.5ns) &#8594; tRAS=16*2.5ns=40ns &#8594; da una idea del orden del tiempo de latencia o tiempo de acceso a la memoria.</p></li><li><p>Si a la CPU le llegan datos a la frecuencia de 800MHz quiere decir que las fases de captura de instrucciones y operandos duran como mínimo 1/800 microsegundos &#8594; 1.25 nanosegundos</p></li></ul></div></li></ul></div>
<div class="ulist column"><ul><li><p>PC3-6400 (DDR3-800) 5-5-5-10</p><div class="ulist"><ul><li><p>DDR 3ª generación &#8594; Macroceldas de 8 celdas &#8594; Buffer i/o de 8 registros</p></li><li><p>Ancho de banda BW = 6400 MB/s</p></li><li><p>f_ebm = 800MHz &#8594; BW=8Bytes/transferencia*800*10<sup>6</sup>transferencias/seg = 6400 MB/s</p></li><li><p>f_bm=f_ebm/2=400MHz &#8594; f_a=f_ebm/8=100MHz</p></li><li><p>5-5-5-10 : diferentes tiempos de sincronismo (tCL-tRCD-tRP-tRAS) del bus de control expresados en número de ciclos de reloj (1/f_bm = 2.5ns) &#8594; tRAS=10*2.5ns=25ns</p></li></ul></div></li></ul></div></div></section><section id="_memoria_cache"><h2>Memoria Cache</h2></section><section id="_memoria_cache_arquitectura"><h2>Memoria Cache : Arquitectura</h2><div class="slide-content"><div class="imageblock"><img src="images/cache/cache_mmu_dram.png" alt="cache mmu dram"></div></div></section><section id="_memoria_cache_introducción"><h2>Memoria Cache : Introducción</h2><div class="slide-content"><div class="ulist"><ul><li><p>Función:</p><div class="ulist"><ul><li><p>Reducir la latencia de las fases de captura del ciclo de instrucción</p></li></ul></div></li><li><p>Implementación:</p><div class="ulist"><ul><li><p>Memoria estática &#8594; la latencia caché es un 10% la latencia de la memoria DRAM</p></li></ul></div></li><li><p>Unidades:</p><div class="ulist"><ul><li><p>MMU: Memory Managment Unit &#8594; traducción de direcciones virtuales (lógicas no lineales) a direcciones físicas (líneales)</p></li><li><p>Memoria dinámica SDRAM &#8594; memoria principal</p></li><li><p>Memoria estática SSRAM &#8594; memoria caché</p></li><li><p>La interfaz entre la CPU y la Memoria SDRAM es el controlador de memoria SDRAM</p></li><li><p>La interfaz entre la CPU y la Memoria Caché es el controlador de memoria caché</p></li></ul></div></li></ul></div></div></section><section id="_memoria_cache_read_operation"><h2>Memoria Cache: Read Operation</h2><div class="slide-content"><div class="imageblock"><img src="images/cache/cache_read_operation.png" alt="cache read operation"></div></div></section><section id="_memoria_caché_organización"><h2>Memoria Caché: Organización</h2><div class="slide-content"><div class="imageblock"><img src="images/cache/cache_dram_block.png" alt="cache dram block"></div></div></section><section id="_memoria_caché_bloqueslíneaspalabras"><h2>Memoria Caché: bloques,líneas,palabras</h2><div class="slide-content"><div class="ulist"><ul><li><p>La memoria principal:</p><div class="ulist"><ul><li><p>se organiza en bloques y direcciones de bloque: cada bloque se divide en palabras y cada palabra en bytes</p></li></ul></div></li><li><p>la memoria caché:</p><div class="ulist"><ul><li><p>se organiza en líneas y direcciones de la línea</p></li><li><p>cada línea de la memoria caché se corresponde con un bloque de la memoria principal según la función de correspondencia del controlador de la caché</p></li><li><p>el bloque de la línea por lo tanto se organiza en palabras y las palabras en bytes</p></li><li><p>cada línea tiene dos campos: la marga TAG y el bloque de la memoria principal correspondiente</p></li><li><p>el campo TAG de una línea informa sobre qué bloque principal corresponde a dicha línea caché</p></li></ul></div></li></ul></div></div></section><section id="_funciones_de_correspondecia_directa_totalmente_asociativa_asociativa_por_conjuntos"><h2>Funciones de correspondecia: directa, totalmente asociativa, asociativa por conjuntos</h2><div class="slide-content"><div class="ulist"><ul><li><p>Función directa</p><div class="ulist"><ul><li><p>A cada bloque principal le corresponde una <strong>dirección fija</strong> de una línea</p></li></ul></div></li><li><p>Función totalmente asociativa</p><div class="ulist"><ul><li><p>Cada bloque puede copiarse en <strong>cualquier</strong> dirección de línea</p></li></ul></div></li><li><p>Función asociativa por conjuntos</p><div class="ulist"><ul><li><p>Cada bloque principal puede copiarse de manera de forma libre dentro un pequeño conjunto de líneas</p></li></ul></div></li></ul></div></div></section><section id="_ejemplo_función_de_correspondencia_directa" class="columns"><h2>Ejemplo: Función de correspondencia directa</h2><div class="slide-content"><div class="ulist column"><ul><li><p>Enunciado:</p><div class="ulist"><ul><li><p>m : capacidad de la memoria caché : 64KB</p></li><li><p>Word size : 1 byte</p></li><li><p>K: Palabras / bloque : 4</p></li><li><p>M : capacidad de la memoria principal : 16 MB</p></li><li><p>¿Correspondencia de la dirección MP 0xA912AB?</p></li></ul></div></li></ul></div>
<div class="ulist column"><ul><li><p>MP</p><div class="ulist"><ul><li><p>Formato dirección MP : Bloque-Palabra</p></li><li><p>Dirección línea caché: 64KB=2<sup>16</sup> &#8594; 16bits</p></li><li><p>Dirección MP: 16MB=2<sup>24</sup> &#8594; 24bits</p></li><li><p>Dirección Bloque MP: 1 línea &lt;&#8594; 1 bloque &#8594; 16bits</p></li><li><p>Dirección palabra : 4 palabras &#8594; 2<sup>2</sup> &#8594; 2bits</p></li></ul></div></li></ul></div>
<div class="ulist column"><ul><li><p>Direccionamiento bloque-palabra</p><div class="ulist"><ul><li><p>los primeros 22 bits son el bloque y los 2 últimos bits la palabra</p></li><li><p>hay 2<sup>22</sup> bloques que se pueden corresponder con una de las 2<sup>16</sup> líneas</p></li><li><p>de los 22 bits de bloque los últimos 16 son la dirección de línea y los 6 primeros son el TAG</p></li></ul></div></li></ul></div></div></section><section id="_ejemplo_función_de_correspondencia_directa_2" class="columns"><h2>Ejemplo: Función de correspondencia directa</h2><div class="slide-content"><div class="ulist column"><ul><li><p>Función de <strong>correspondencia directa</strong>:</p><div class="ulist"><ul><li><p>el bloque 0 se corresponde con la línea de dirección 0 y así sucesivamente</p></li><li><p>el bloque 1 se corresponde con la línea de dirección 1</p></li><li><p>el bloque (2<sup>16</sup>-1) se corresponde con la línea de dirección (2<sup>16</sup>-1)</p></li><li><p>el bloque 2<sup>16</sup> se corresponde con la línea de dirección 0</p></li><li><p>el bloque "j" se corresponde con la línea de dirección i = j MOD[m]</p></li></ul></div></li></ul></div>
<div class="imageblock column"><img src="images/cache/cache_directmap_controller.png" alt="cache directmap controller"></div></div></section><section id="_ejemplo_función_de_correspondencia_directa_3" class="columns"><h2>Ejemplo: Función de correspondencia directa</h2><div class="slide-content"><div class="ulist column"><ul><li><p>Direcciones de los bloques</p><div class="ulist"><ul><li><p>el bloque "j" se corresponde con la dirección j*4</p></li><li><p>multiplicar por 2<sup>2</sup> equivale a un desplazamiento de 2 bits hacia la izda</p></li><li><p>dividir por 2<sup>2</sup> equivale a un desplazamiento de 2 bits hacia la derecha</p></li></ul></div></li></ul></div>
<div class="ulist column"><ul><li><p>Dirección MP 0xA912AB &#8594; 1010 1001 0001 0010 1010 1011</p><div class="ulist"><ul><li><p>Dirección de bloque 1010 1001 0001 0010 1010 10 &#8594; 10 1010 0100 0100 1010 1010 : 0x2A44AA</p></li><li><p>Dirección de palabra 11 : 3</p></li><li><p>Método 1º: Dirección de línea 01 0001 0010 1010 10 &#8594; 0100 0100 1010 1010 &#8594; 0x44AA</p></li><li><p>Método 2º: 0x2A44AA MOD [2<sup>16</sup>] &#8594; Resto de 0x2A44AA / 2<sup>16</sup></p><div class="ulist"><ul><li><p>0x2A44AA/ 2<sup>16</sup> = 0x00002A.44AA &#8594; Resto=0x0.44AA*2<sup>16</sup>=0x44AA</p></li><li><p>Divi=Coc*Disor+Resto &#8594; Divi/Coc=Disor+Resto/Coc &#8594; Resto=Fracción*Cociente</p></li></ul></div></li></ul></div></li></ul></div></div></section><section id="_ejemplo_función_de_correspondencia_asociativa_total"><h2>Ejemplo: Función de correspondencia Asociativa Total</h2><div class="slide-content"><div class="ulist"><ul><li><p>No hay función de correspondecia ya que a los bloques principales se le puede cualquier línea.</p></li><li><p>Se le correspondería una línea que no estuviera ocupada por un bloque</p></li><li><p>Si están todas ocupadas es necesaria una "política de reemplazo": Por ejemplo la línea que más tiempo lleva sin ser accedida por la CPU conocida como política "least-recently used (LRU)"</p></li></ul></div></div></section><section id="_política_de_escritura_en_la_caché"><h2>Política de Escritura en la Caché</h2><div class="slide-content"><div class="ulist"><ul><li><p>Si la CPU escribe un resultado en una línea de la caché, su bloque principal correspondiente no será idéntico por lo que será necesario copiar la línea de la caché en el bloque principal correspondiente. Es necesaría un política de reescritura para indicar cuál es el momento de realizar dicha copia, si justo después de haber modificado la línea de la caché o más tarde.</p></li></ul></div></div></section><section id="_memoria_virtual"><h2>Memoria Virtual</h2></section><section id="_memoria_virtual_lógica_secciones_y_segmentos"><h2>Memoria Virtual lógica: Secciones y Segmentos</h2><div class="slide-content"><div class="imageblock" style="float: left"><img src="images/memvirtual/linksections.png" alt="linksections"></div>
<div class="paragraph"><p>La memoria virtual de un programa binario está organizada en segmentos de datos, instrucciones, pila, heap, etc<br>
La memoria virtual de los módulos binarios antes de ser linkados están organizados en secciones de datos, instrucciones, pila, heap, etc. El linker resuelve los valores de direcciones de las etiquetas de cada sección y los entrelaza. Posteriormente el linker agrupa las diferentes secciones se en segmentos.</p></div></div></section><section id="_memoria_virtual_lógica_mapa_de_memoria_en_un_entorno_linux"><h2>Memoria Virtual lógica: Mapa de Memoria en un entorno Linux</h2><div class="slide-content"><div class="imageblock"><img src="images/memvirtual/linux_vm_map.png" alt="linux vm map"></div></div></section><section id="_memoria_virtual_lógica_paginación"><h2>Memoria Virtual lógica: Paginación</h2><div class="slide-content"><div class="paragraph"><p>El espacio de direcciones virtual es un espacio abstracto que se particiona de forma lógica en páginas y la unidad MMU traduce las direcciones de página virtual en direcciones físicas de la memoria DRAM</p></div>
<div class="paragraph"><p><span class="image"><img src="images/memvirtual/vm_table.png" alt="vm table"></span></p></div></div></section></section>
<section id="_mecanismos_de_entradasalida"><h2>Mecanismos de Entrada/Salida</h2></section></div></div><script src="reveal.js/js/reveal.js"></script><script>Array.prototype.slice.call(document.querySelectorAll('.slides section')).forEach(function(slide) {
  if (slide.getAttribute('data-background-color')) return;
  // user needs to explicitly say he wants CSS color to override otherwise we might break custom css or theme (#226)
  if (!(slide.classList.contains('canvas') || slide.classList.contains('background'))) return;
  var bgColor = getComputedStyle(slide).backgroundColor;
  if (bgColor !== 'rgba(0, 0, 0, 0)' && bgColor !== 'transparent') {
    slide.setAttribute('data-background-color', bgColor);
    slide.style.backgroundColor = 'transparent';
  }
});

// More info about config & dependencies:
// - https://github.com/hakimel/reveal.js#configuration
// - https://github.com/hakimel/reveal.js#dependencies
Reveal.initialize({
  // Display presentation control arrows
  controls: true,
  // Help the user learn the controls by providing hints, for example by
  // bouncing the down arrow when they first encounter a vertical slide
  controlsTutorial: true,
  // Determines where controls appear, "edges" or "bottom-right"
  controlsLayout: 'bottom-right',
  // Visibility rule for backwards navigation arrows; "faded", "hidden"
  // or "visible"
  controlsBackArrows: 'faded',
  // Display a presentation progress bar
  progress: true,
  // Display the page number of the current slide
  slideNumber: false,
  // Control which views the slide number displays on
  showSlideNumber: 'all',
  // Add the current slide number to the URL hash so that reloading the
  // page/copying the URL will return you to the same slide
  hash: true,
  // Push each slide change to the browser history. Implies `hash: true`
  history: true,
  // Enable keyboard shortcuts for navigation
  keyboard: true,
  // Enable the slide overview mode
  overview: true,
  // Disables the default reveal.js slide layout so that you can use custom CSS layout
  disableLayout: false,
  // Vertical centering of slides
  center: false,
  // Enables touch navigation on devices with touch input
  touch: true,
  // Loop the presentation
  loop: false,
  // Change the presentation direction to be RTL
  rtl: false,
  // See https://github.com/hakimel/reveal.js/#navigation-mode
  navigationMode: 'default',
  // Randomizes the order of slides each time the presentation loads
  shuffle: false,
  // Turns fragments on and off globally
  fragments: true,
  // Flags whether to include the current fragment in the URL,
  // so that reloading brings you to the same fragment position
  fragmentInURL: false,
  // Flags if the presentation is running in an embedded mode,
  // i.e. contained within a limited portion of the screen
  embedded: false,
  // Flags if we should show a help overlay when the questionmark
  // key is pressed
  help: true,
  // Flags if speaker notes should be visible to all viewers
  showNotes: false,
  // Global override for autolaying embedded media (video/audio/iframe)
  // - null: Media will only autoplay if data-autoplay is present
  // - true: All media will autoplay, regardless of individual setting
  // - false: No media will autoplay, regardless of individual setting
  autoPlayMedia: null,
  // Global override for preloading lazy-loaded iframes
  // - null: Iframes with data-src AND data-preload will be loaded when within
  //   the viewDistance, iframes with only data-src will be loaded when visible
  // - true: All iframes with data-src will be loaded when within the viewDistance
  // - false: All iframes with data-src will be loaded only when visible
  preloadIframes: null,
  // Number of milliseconds between automatically proceeding to the
  // next slide, disabled when set to 0, this value can be overwritten
  // by using a data-autoslide attribute on your slides
  autoSlide: 0,
  // Stop auto-sliding after user input
  autoSlideStoppable: true,
  // Use this method for navigation when auto-sliding
  autoSlideMethod: Reveal.navigateNext,
  // Specify the average time in seconds that you think you will spend
  // presenting each slide. This is used to show a pacing timer in the
  // speaker view
  defaultTiming: 120,
  // Specify the total time in seconds that is available to
  // present.  If this is set to a nonzero value, the pacing
  // timer will work out the time available for each slide,
  // instead of using the defaultTiming value
  totalTime: 0,
  // Specify the minimum amount of time you want to allot to
  // each slide, if using the totalTime calculation method.  If
  // the automated time allocation causes slide pacing to fall
  // below this threshold, then you will see an alert in the
  // speaker notes window
  minimumTimePerSlide: 0,
  // Enable slide navigation via mouse wheel
  mouseWheel: false,
  // Hide cursor if inactive
  hideInactiveCursor: true,
  // Time before the cursor is hidden (in ms)
  hideCursorTime: 5000,
  // Hides the address bar on mobile devices
  hideAddressBar: true,
  // Opens links in an iframe preview overlay
  // Add `data-preview-link` and `data-preview-link="false"` to customise each link
  // individually
  previewLinks: false,
  // Transition style (e.g., none, fade, slide, convex, concave, zoom)
  transition: 'slide',
  // Transition speed (e.g., default, fast, slow)
  transitionSpeed: 'default',
  // Transition style for full page slide backgrounds (e.g., none, fade, slide, convex, concave, zoom)
  backgroundTransition: 'fade',
  // Number of slides away from the current that are visible
  viewDistance: 3,
  // Number of slides away from the current that are visible on mobile
  // devices. It is advisable to set this to a lower number than
  // viewDistance in order to save resources.
  mobileViewDistance: 3,
  // Parallax background image (e.g., "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'")
  parallaxBackgroundImage: '',
  // Parallax background size in CSS syntax (e.g., "2100px 900px")
  parallaxBackgroundSize: '',
  // Number of pixels to move the parallax background per slide
  // - Calculated automatically unless specified
  // - Set to 0 to disable movement along an axis
  parallaxBackgroundHorizontal: null,
  parallaxBackgroundVertical: null,
  // The display mode that will be used to show slides
  display: 'block',

  // The "normal" size of the presentation, aspect ratio will be preserved
  // when the presentation is scaled to fit different resolutions. Can be
  // specified using percentage units.
  width: 960,
  height: 700,

  // Factor of the display size that should remain empty around the content
  margin: 0,

  // Bounds for smallest/largest possible scale to apply to content
  minScale: 0.2,
  maxScale: 1.5,

  // PDF Export Options
  // Put each fragment on a separate page
  pdfSeparateFragments: true,
  // For slides that do not fit on a page, max number of pages
  pdfMaxPagesPerSlide: 1,

  // Optional libraries used to extend on reveal.js
  dependencies: [
      { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
      { src: 'reveal.js/plugin/notes/notes.js', async: true },
      { src: 'revealjs-plugins/reveal.js-menu/menu.js' },
{ src: 'revealjs-plugins/chalkboard/chalkboard.js' }
  ],

  menu: {
    side: 'right'
},
keyboard: {
	    67: function() { RevealChalkboard.toggleNotesCanvas() },	// toggle notes canvas when 'c' is pressed
	    66: function() { RevealChalkboard.toggleChalkboard() },	// toggle chalkboard when 'b' is pressed
	    46: function() { RevealChalkboard.clear() },	// clear chalkboard when 'DEL' is pressed
	     8: function() { RevealChalkboard.reset() },	// reset chalkboard data on current slide when 'BACKSPACE' is pressed
	    68: function() { RevealChalkboard.download() },	// downlad recorded chalkboard drawing when 'd' is pressed
},


});</script><script>var dom = {};
dom.slides = document.querySelector('.reveal .slides');

function getRemainingHeight(element, slideElement, height) {
  height = height || 0;
  if (element) {
    var newHeight, oldHeight = element.style.height;
    // Change the .stretch element height to 0 in order find the height of all
    // the other elements
    element.style.height = '0px';
    // In Overview mode, the parent (.slide) height is set of 700px.
    // Restore it temporarily to its natural height.
    slideElement.style.height = 'auto';
    newHeight = height - slideElement.offsetHeight;
    // Restore the old height, just in case
    element.style.height = oldHeight + 'px';
    // Clear the parent (.slide) height. .removeProperty works in IE9+
    slideElement.style.removeProperty('height');
    return newHeight;
  }
  return height;
}

function layoutSlideContents(width, height) {
  // Handle sizing of elements with the 'stretch' class
  toArray(dom.slides.querySelectorAll('section .stretch')).forEach(function (element) {
    // Determine how much vertical space we can use
    var limit = 5; // hard limit
    var parent = element.parentNode;
    while (parent.nodeName !== 'SECTION' && limit > 0) {
      parent = parent.parentNode;
      limit--;
    }
    if (limit === 0) {
      // unable to find parent, aborting!
      return;
    }
    var remainingHeight = getRemainingHeight(element, parent, height);
    // Consider the aspect ratio of media elements
    if (/(img|video)/gi.test(element.nodeName)) {
      var nw = element.naturalWidth || element.videoWidth, nh = element.naturalHeight || element.videoHeight;
      var es = Math.min(width / nw, remainingHeight / nh);
      element.style.width = (nw * es) + 'px';
      element.style.height = (nh * es) + 'px';
    } else {
      element.style.width = width + 'px';
      element.style.height = remainingHeight + 'px';
    }
  });
}

function toArray(o) {
  return Array.prototype.slice.call(o);
}

Reveal.addEventListener('slidechanged', function () {
  layoutSlideContents(960, 700)
});
Reveal.addEventListener('ready', function () {
  layoutSlideContents(960, 700)
});
Reveal.addEventListener('resize', function () {
  layoutSlideContents(960, 700)
});</script><link rel="stylesheet" href="reveal.js/lib/css/monokai.css"/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/vhdl.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/x86asm.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/x86asmatt.min.js"></script>

<script>

/* highlightjs-line-numbers.js 2.6.0 | (C) 2018 Yauheni Pakala | MIT License | github.com/wcoder/highlightjs-line-numbers.js */
/* Edited by Hakim for reveal.js; removed async timeout */
!function(n,e){"use strict";function t(){var n=e.createElement("style");n.type="text/css",n.innerHTML=g(".{0}{border-collapse:collapse}.{0} td{padding:0}.{1}:before{content:attr({2})}",[v,L,b]),e.getElementsByTagName("head")[0].appendChild(n)}function r(t){"interactive"===e.readyState||"complete"===e.readyState?i(t):n.addEventListener("DOMContentLoaded",function(){i(t)})}function i(t){try{var r=e.querySelectorAll("code.hljs,code.nohighlight");for(var i in r)r.hasOwnProperty(i)&&l(r[i],t)}catch(o){n.console.error("LineNumbers error: ",o)}}function l(n,e){"object"==typeof n&&f(function(){n.innerHTML=s(n,e)})}function o(n,e){if("string"==typeof n){var t=document.createElement("code");return t.innerHTML=n,s(t,e)}}function s(n,e){e=e||{singleLine:!1};var t=e.singleLine?0:1;return c(n),a(n.innerHTML,t)}function a(n,e){var t=u(n);if(""===t[t.length-1].trim()&&t.pop(),t.length>e){for(var r="",i=0,l=t.length;i<l;i++)r+=g('<tr><td class="{0}"><div class="{1} {2}" {3}="{5}"></div></td><td class="{4}"><div class="{1}">{6}</div></td></tr>',[j,m,L,b,p,i+1,t[i].length>0?t[i]:" "]);return g('<table class="{0}">{1}</table>',[v,r])}return n}function c(n){var e=n.childNodes;for(var t in e)if(e.hasOwnProperty(t)){var r=e[t];h(r.textContent)>0&&(r.childNodes.length>0?c(r):d(r.parentNode))}}function d(n){var e=n.className;if(/hljs-/.test(e)){for(var t=u(n.innerHTML),r=0,i="";r<t.length;r++){var l=t[r].length>0?t[r]:" ";i+=g('<span class="{0}">{1}</span>\n',[e,l])}n.innerHTML=i.trim()}}function u(n){return 0===n.length?[]:n.split(y)}function h(n){return(n.trim().match(y)||[]).length}function f(e){e()}function g(n,e){return n.replace(/{(\d+)}/g,function(n,t){return e[t]?e[t]:n})}var v="hljs-ln",m="hljs-ln-line",p="hljs-ln-code",j="hljs-ln-numbers",L="hljs-ln-n",b="data-line-number",y=/\r\n|\r|\n/g;n.hljs?(n.hljs.initLineNumbersOnLoad=r,n.hljs.lineNumbersBlock=l,n.hljs.lineNumbersValue=o,t()):n.console.error("highlight.js not detected!")}(window,document);

/**
 * This reveal.js plugin is wrapper around the highlight.js
 * syntax highlighting library.
 */
(function( root, factory ) {
  if (typeof define === 'function' && define.amd) {
    root.RevealHighlight = factory();
  } else if( typeof exports === 'object' ) {
    module.exports = factory();
  } else {
    // Browser globals (root is window)
    root.RevealHighlight = factory();
  }
}( this, function() {

  // Function to perform a better "data-trim" on code snippets
  // Will slice an indentation amount on each line of the snippet (amount based on the line having the lowest indentation length)
  function betterTrim(snippetEl) {
    // Helper functions
    function trimLeft(val) {
      // Adapted from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/Trim#Polyfill
      return val.replace(/^[\s\uFEFF\xA0]+/g, '');
    }
    function trimLineBreaks(input) {
      var lines = input.split('\n');

      // Trim line-breaks from the beginning
      for (var i = 0; i < lines.length; i++) {
        if (lines[i].trim() === '') {
          lines.splice(i--, 1);
        } else break;
      }

      // Trim line-breaks from the end
      for (var i = lines.length-1; i >= 0; i--) {
        if (lines[i].trim() === '') {
          lines.splice(i, 1);
        } else break;
      }

      return lines.join('\n');
    }

    // Main function for betterTrim()
    return (function(snippetEl) {
      var content = trimLineBreaks(snippetEl.innerHTML);
      var lines = content.split('\n');
      // Calculate the minimum amount to remove on each line start of the snippet (can be 0)
      var pad = lines.reduce(function(acc, line) {
        if (line.length > 0 && trimLeft(line).length > 0 && acc > line.length - trimLeft(line).length) {
          return line.length - trimLeft(line).length;
        }
        return acc;
      }, Number.POSITIVE_INFINITY);
      // Slice each line with this amount
      return lines.map(function(line, index) {
        return line.slice(pad);
      })
        .join('\n');
    })(snippetEl);
  }

  var RevealHighlight = {

    HIGHLIGHT_STEP_DELIMITER: '|',
    HIGHLIGHT_LINE_DELIMITER: ',',
    HIGHLIGHT_LINE_RANGE_DELIMITER: '-',

    init: function() {

      // Read the plugin config options and provide fallbacks
      var config = Reveal.getConfig().highlight || {};
      config.highlightOnLoad = typeof config.highlightOnLoad === 'boolean' ? config.highlightOnLoad : true;
      config.escapeHTML = typeof config.escapeHTML === 'boolean' ? config.escapeHTML : true;

      [].slice.call( document.querySelectorAll( '.reveal pre code' ) ).forEach( function( block ) {

        // Trim whitespace if the "data-trim" attribute is present
        if( block.hasAttribute( 'data-trim' ) && typeof block.innerHTML.trim === 'function' ) {
          block.innerHTML = betterTrim( block );
        }

        // Escape HTML tags unless the "data-noescape" attrbute is present
        if( config.escapeHTML && !block.hasAttribute( 'data-noescape' )) {
          block.innerHTML = block.innerHTML.replace( /</g,"&lt;").replace(/>/g, '&gt;' );
        }

        // Re-highlight when focus is lost (for contenteditable code)
        block.addEventListener( 'focusout', function( event ) {
          hljs.highlightBlock( event.currentTarget );
        }, false );

        if( config.highlightOnLoad ) {
          RevealHighlight.highlightBlock( block );
        }
      } );

    },

    /**
     * Highlights a code block. If the <code> node has the
     * 'data-line-numbers' attribute we also generate slide
     * numbers.
     *
     * If the block contains multiple line highlight steps,
     * we clone the block and create a fragment for each step.
     */
    highlightBlock: function( block ) {

      hljs.highlightBlock( block );

      // Don't generate line numbers for empty code blocks
      if( block.innerHTML.trim().length === 0 ) return;

      if( block.hasAttribute( 'data-line-numbers' ) ) {
        hljs.lineNumbersBlock( block, { singleLine: true } );

        // If there is at least one highlight step, generate
        // fragments
        var highlightSteps = RevealHighlight.deserializeHighlightSteps( block.getAttribute( 'data-line-numbers' ) );
        if( highlightSteps.length > 1 ) {

          // If the original code block has a fragment-index,
          // each clone should follow in an incremental sequence
          var fragmentIndex = parseInt( block.getAttribute( 'data-fragment-index' ), 10 );
          if( typeof fragmentIndex !== 'number' || isNaN( fragmentIndex ) ) {
            fragmentIndex = null;
          }

          // Generate fragments for all steps except the original block
          highlightSteps.slice(1).forEach( function( highlight ) {

            var fragmentBlock = block.cloneNode( true );
            fragmentBlock.setAttribute( 'data-line-numbers', RevealHighlight.serializeHighlightSteps( [ highlight ] ) );
            fragmentBlock.classList.add( 'fragment' );
            block.parentNode.appendChild( fragmentBlock );
            RevealHighlight.highlightLines( fragmentBlock );

            if( typeof fragmentIndex === 'number' ) {
              fragmentBlock.setAttribute( 'data-fragment-index', fragmentIndex );
              fragmentIndex += 1;
            }
            else {
              fragmentBlock.removeAttribute( 'data-fragment-index' );
            }

          } );

          block.removeAttribute( 'data-fragment-index' )
          block.setAttribute( 'data-line-numbers', RevealHighlight.serializeHighlightSteps( [ highlightSteps[0] ] ) );

        }

        RevealHighlight.highlightLines( block );

      }

    },

    /**
     * Visually emphasize specific lines within a code block.
     * This only works on blocks with line numbering turned on.
     *
     * @param {HTMLElement} block a <code> block
     * @param {String} [linesToHighlight] The lines that should be
     * highlighted in this format:
     * "1" 		= highlights line 1
     * "2,5"	= highlights lines 2 & 5
     * "2,5-7"	= highlights lines 2, 5, 6 & 7
     */
    highlightLines: function( block, linesToHighlight ) {

      var highlightSteps = RevealHighlight.deserializeHighlightSteps( linesToHighlight || block.getAttribute( 'data-line-numbers' ) );

      if( highlightSteps.length ) {

        highlightSteps[0].forEach( function( highlight ) {

          var elementsToHighlight = [];

          // Highlight a range
          if( typeof highlight.end === 'number' ) {
            elementsToHighlight = [].slice.call( block.querySelectorAll( 'table tr:nth-child(n+'+highlight.start+'):nth-child(-n+'+highlight.end+')' ) );
          }
          // Highlight a single line
          else if( typeof highlight.start === 'number' ) {
            elementsToHighlight = [].slice.call( block.querySelectorAll( 'table tr:nth-child('+highlight.start+')' ) );
          }

          if( elementsToHighlight.length ) {
            elementsToHighlight.forEach( function( lineElement ) {
              lineElement.classList.add( 'highlight-line' );
            } );

            block.classList.add( 'has-highlights' );
          }

        } );

      }

    },

    /**
     * Parses and formats a user-defined string of line
     * numbers to highlight.
     *
     * @example
     * RevealHighlight.deserializeHighlightSteps( '1,2|3,5-10' )
     * // [
     * //   [ { start: 1 }, { start: 2 } ],
     * //   [ { start: 3 }, { start: 5, end: 10 } ]
     * // ]
     */
    deserializeHighlightSteps: function( highlightSteps ) {

      // Remove whitespace
      highlightSteps = highlightSteps.replace( /\s/g, '' );

      // Divide up our line number groups
      highlightSteps = highlightSteps.split( RevealHighlight.HIGHLIGHT_STEP_DELIMITER );

      return highlightSteps.map( function( highlights ) {

        return highlights.split( RevealHighlight.HIGHLIGHT_LINE_DELIMITER ).map( function( highlight ) {

          // Parse valid line numbers
          if( /^[\d-]+$/.test( highlight ) ) {

            highlight = highlight.split( RevealHighlight.HIGHLIGHT_LINE_RANGE_DELIMITER );

            var lineStart = parseInt( highlight[0], 10 ),
              lineEnd = parseInt( highlight[1], 10 );

            if( isNaN( lineEnd ) ) {
              return {
                start: lineStart
              };
            }
            else {
              return {
                start: lineStart,
                end: lineEnd
              };
            }

          }
          // If no line numbers are provided, no code will be highlighted
          else {

            return {};

          }

        } );

      } );

    },

    /**
     * Serializes parsed line number data into a string so
     * that we can store it in the DOM.
     */
    serializeHighlightSteps: function( highlightSteps ) {

      return highlightSteps.map( function( highlights ) {

        return highlights.map( function( highlight ) {

          // Line range
          if( typeof highlight.end === 'number' ) {
            return highlight.start + RevealHighlight.HIGHLIGHT_LINE_RANGE_DELIMITER + highlight.end;
          }
          // Single line
          else if( typeof highlight.start === 'number' ) {
            return highlight.start;
          }
          // All lines
          else {
            return '';
          }

        } ).join( RevealHighlight.HIGHLIGHT_LINE_DELIMITER );

      } ).join( RevealHighlight.HIGHLIGHT_STEP_DELIMITER );

    }

  }

  Reveal.registerPlugin( 'highlight', RevealHighlight );

  return RevealHighlight;

}));
        
hljs.initHighlightingOnLoad();
</script><script src="revealjs-plugins/menu/menu.js"></script>
<link rel="stylesheet" href="revealjs-plugins/chalkboard/style.css">
<script src="revealjs-plugins/chalkboard/plugin.js"></script>
<script src="revealjs-plugins/highlightjs-x86asmatt-main/src/languages/x86asmatt.js"></script>
<script>
  Reveal.configure({
    menu: {
      side: 'right',
      openButton: false
    },
    keyboard: {
      67: function() { RevealChalkboard.toggleNotesCanvas() },
      66: function() { RevealChalkboard.toggleChalkboard() }
    }
  })
  Reveal.registerPlugin(RevealMenu)
  Reveal.registerPlugin(RevealChalkboard)
  Reveal.registerPlugin(RevealX86asmatt)
</script></body></html>