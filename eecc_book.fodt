<!DOCTYPE html><html lang="es"><head><meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui" /><title>Estructura de Computadores  (240306)</title><meta name="keywords" content="computer, architecture" /><meta name="author" content="Cándido Aramburu" /><link rel="stylesheet" href="reveal.js/css/reset.css" /><link rel="stylesheet" href="reveal.js/css/reveal.css" /><link rel="stylesheet" href="reveal.js/css/theme/black.css" id="theme" /><!--This CSS is generated by the Asciidoctor reveal.js converter to further integrate AsciiDoc's existing semantic with reveal.js--><style type="text/css">.reveal div.right {
  float: right
}

/* listing block */
.reveal .listingblock.stretch > .content {
  height: 100%
}

.reveal .listingblock.stretch > .content > pre {
  height: 100%
}

.reveal .listingblock.stretch > .content > pre > code {
  height: 100%;
  max-height: 100%
}

/* tables */
table {
  border-collapse: collapse;
  border-spacing: 0
}

table {
  margin-bottom: 1.25em;
  border: solid 1px #dedede
}

table thead tr th, table thead tr td, table tfoot tr th, table tfoot tr td {
  padding: .5em .625em .625em;
  font-size: inherit;
  text-align: left
}

table tr th, table tr td {
  padding: .5625em .625em;
  font-size: inherit
}

table thead tr th, table tfoot tr th, table tbody tr td, table tr td, table tfoot tr td {
  display: table-cell;
  line-height: 1.6
}

td.tableblock > .content {
  margin-bottom: 1.25em
}

td.tableblock > .content > :last-child {
  margin-bottom: -1.25em
}

table.tableblock, th.tableblock, td.tableblock {
  border: 0 solid #dedede
}

table.grid-all > thead > tr > .tableblock, table.grid-all > tbody > tr > .tableblock {
  border-width: 0 1px 1px 0
}

table.grid-all > tfoot > tr > .tableblock {
  border-width: 1px 1px 0 0
}

table.grid-cols > * > tr > .tableblock {
  border-width: 0 1px 0 0
}

table.grid-rows > thead > tr > .tableblock, table.grid-rows > tbody > tr > .tableblock {
  border-width: 0 0 1px
}

table.grid-rows > tfoot > tr > .tableblock {
  border-width: 1px 0 0
}

table.grid-all > * > tr > .tableblock:last-child, table.grid-cols > * > tr > .tableblock:last-child {
  border-right-width: 0
}

table.grid-all > tbody > tr:last-child > .tableblock, table.grid-all > thead:last-child > tr > .tableblock, table.grid-rows > tbody > tr:last-child > .tableblock, table.grid-rows > thead:last-child > tr > .tableblock {
  border-bottom-width: 0
}

table.frame-all {
  border-width: 1px
}

table.frame-sides {
  border-width: 0 1px
}

table.frame-topbot, table.frame-ends {
  border-width: 1px 0
}

.reveal table th.halign-left, .reveal table td.halign-left {
  text-align: left
}

.reveal table th.halign-right, .reveal table td.halign-right {
  text-align: right
}

.reveal table th.halign-center, .reveal table td.halign-center {
  text-align: center
}

.reveal table th.valign-top, .reveal table td.valign-top {
  vertical-align: top
}

.reveal table th.valign-bottom, .reveal table td.valign-bottom {
  vertical-align: bottom
}

.reveal table th.valign-middle, .reveal table td.valign-middle {
  vertical-align: middle
}

table thead th, table tfoot th {
  font-weight: bold
}

tbody tr th {
  display: table-cell;
  line-height: 1.6
}

tbody tr th, tbody tr th p, tfoot tr th, tfoot tr th p {
  font-weight: bold
}

thead {
  display: table-header-group
}

.reveal table.grid-none th, .reveal table.grid-none td {
  border-bottom: 0 !important
}

/* kbd macro */
kbd {
  font-family: "Droid Sans Mono", "DejaVu Sans Mono", monospace;
  display: inline-block;
  color: rgba(0, 0, 0, .8);
  font-size: .65em;
  line-height: 1.45;
  background: #f7f7f7;
  border: 1px solid #ccc;
  -webkit-border-radius: 3px;
  border-radius: 3px;
  -webkit-box-shadow: 0 1px 0 rgba(0, 0, 0, .2), 0 0 0 .1em white inset;
  box-shadow: 0 1px 0 rgba(0, 0, 0, .2), 0 0 0 .1em #fff inset;
  margin: 0 .15em;
  padding: .2em .5em;
  vertical-align: middle;
  position: relative;
  top: -.1em;
  white-space: nowrap
}

.keyseq kbd:first-child {
  margin-left: 0
}

.keyseq kbd:last-child {
  margin-right: 0
}

/* callouts */
.conum[data-value] {
  display: inline-block;
  color: #fff !important;
  background: rgba(0, 0, 0, .8);
  -webkit-border-radius: 50%;
  border-radius: 50%;
  text-align: center;
  font-size: .75em;
  width: 1.67em;
  height: 1.67em;
  line-height: 1.67em;
  font-family: "Open Sans", "DejaVu Sans", sans-serif;
  font-style: normal;
  font-weight: bold
}

.conum[data-value] * {
  color: #fff !important
}

.conum[data-value] + b {
  display: none
}

.conum[data-value]:after {
  content: attr(data-value)
}

pre .conum[data-value] {
  position: relative;
  top: -.125em
}

b.conum * {
  color: inherit !important
}

.conum:not([data-value]):empty {
  display: none
}

/* Callout list */
.hdlist > table, .colist > table {
  border: 0;
  background: none
}

.hdlist > table > tbody > tr, .colist > table > tbody > tr {
  background: none
}

td.hdlist1, td.hdlist2 {
  vertical-align: top;
  padding: 0 .625em
}

td.hdlist1 {
  font-weight: bold;
  padding-bottom: 1.25em
}

/* Disabled from Asciidoctor CSS because it caused callout list to go under the
 * source listing when .stretch is applied (see #335)
 * .literalblock+.colist,.listingblock+.colist{margin-top:-.5em} */
.colist td:not([class]):first-child {
  padding: .4em .75em 0;
  line-height: 1;
  vertical-align: top
}

.colist td:not([class]):first-child img {
  max-width: none
}

.colist td:not([class]):last-child {
  padding: .25em 0
}

/* Override Asciidoctor CSS that causes issues with reveal.js features */
.reveal .hljs table {
  border: 0
}

/* Callout list rows would have a bottom border with some reveal.js themes (see #335) */
.reveal .colist > table th, .reveal .colist > table td {
  border-bottom: 0
}

/* Fixes line height with Highlight.js source listing when linenums enabled (see #331) */
.reveal .hljs table thead tr th, .reveal .hljs table tfoot tr th, .reveal .hljs table tbody tr td, .reveal .hljs table tr td, .reveal .hljs table tfoot tr td {
  line-height: inherit
}

/* Columns layout */
.columns .slide-content {
  display: flex;
}

.columns.wrap .slide-content {
  flex-wrap: wrap;
}

.columns.is-vcentered .slide-content {
  align-items: center;
}

.columns .slide-content > .column {
  display: block;
  flex-basis: 0;
  flex-grow: 1;
  flex-shrink: 1;
}

.columns .slide-content > .column > * {
  padding: .75rem;
}

/* See #353 */
.columns.wrap .slide-content > .column {
  flex-basis: auto;
}

.columns .slide-content > .column.is-full {
  flex: none;
  width: 100%;
}

.columns .slide-content > .column.is-four-fifths {
  flex: none;
  width: 80%;
}

.columns .slide-content > .column.is-three-quarters {
  flex: none;
  width: 75%;
}

.columns .slide-content > .column.is-two-thirds {
  flex: none;
  width: 66.6666%;
}

.columns .slide-content > .column.is-three-fifths {
  flex: none;
  width: 60%;
}

.columns .slide-content > .column.is-half {
  flex: none;
  width: 50%;
}

.columns .slide-content > .column.is-two-fifths {
  flex: none;
  width: 40%;
}

.columns .slide-content > .column.is-one-third {
  flex: none;
  width: 33.3333%;
}

.columns .slide-content > .column.is-one-quarter {
  flex: none;
  width: 25%;
}

.columns .slide-content > .column.is-one-fifth {
  flex: none;
  width: 20%;
}

.columns .slide-content > .column.has-text-left {
  text-align: left;
}

.columns .slide-content > .column.has-text-justified {
  text-align: justify;
}

.columns .slide-content > .column.has-text-right {
  text-align: right;
}

.columns .slide-content > .column.has-text-left {
  text-align: left;
}

.columns .slide-content > .column.has-text-justified {
  text-align: justify;
}

.columns .slide-content > .column.has-text-right {
  text-align: right;
}

.text-left {
  text-align: left !important
}

.text-right {
  text-align: right !important
}

.text-center {
  text-align: center !important
}

.text-justify {
  text-align: justify !important
}

.footnotes {
  border-top: 1px solid rgba(0, 0, 0, 0.2);
  padding: 0.5em 0 0 0;
  font-size: 0.65em;
  margin-top: 4em;
}
</style><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css" /><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/v4-shims.min.css" /><script type="text/x-mathjax-config">MathJax.Hub.Config({
tex2jax: {
  inlineMath: [["\\(", "\\)"]],
  displayMath: [["\\[", "\\]"]],
  ignoreClass: "nostem|nolatexmath"
},
asciimath2jax: {
  delimiters: [["\\$", "\\$"]],
  ignoreClass: "nostem|noasciimath"
},
TeX: { equationNumbers: { autoNumber: "none" } }
});</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script><!--Printing and PDF exports--><script>var link = document.createElement( 'link' );
link.rel = 'stylesheet';
link.type = 'text/css';
link.href = window.location.search.match( /print-pdf/gi ) ? "reveal.js/css/print/pdf.css" : "reveal.js/css/print/paper.css";
document.getElementsByTagName( 'head' )[0].appendChild( link );</script></head><body><div class="reveal"><div class="slides"><section class="title" data-state="title"><h1>Estructura de Computadores  (240306)</h1><p class="author"><small>Cándido Aramburu</small></p></section><section id="_i_arquitectura_del_repertorio_de_instrucciones_isa_computadora_von_neumann_datos_instrucciones_programación"><h2>I Arquitectura del Repertorio de Instrucciones (ISA): computadora von Neumann, datos, instrucciones, programación.</h2><div class="slide-content"><section><section id="_introducción_a_la_estructura_de_los_computadores"><h2>1. Introducción a la Estructura de los Computadores</h2></section><section id="introo"><h2>1.1. Introducción</h2><div class="slide-content"><div class="ulist"><ul><li><p>El objetivo de la asignatura Estructura de Computadores (240306) del Grado de <a href="http://www.unavarra.es/ets-industrialesytelecos/estudios/grado/grado-en-ingenieria-informatica/presentacion?submenu=yes">Ingeniería Informática</a> de la Universidad Pública de Navarra es ser un curso introductorio universitario a la arquitectura de los computadores, estudiando sus componentes básicos (procesador, memoria y módulo de entrada/salida) así como la programación de bajo nivel en lenguaje ensamblador x86 mediante la utilización de herramientas de desarrollo software como el compilador, depurador, etc.</p></li></ul></div></div></section><section id="_arquitectura_de_una_máquina"><h2>1.2. Arquitectura de una máquina</h2><div class="slide-content"><div class="ulist"><ul><li><p>Arquitectura: Organización, Estructura: Qué, Cómo, Implementación (tecnología)</p><div class="imageblock text-center" style="text-align: center"><img src="./images/introduccion/vehicle_arch.jpg" alt="vehicle arch" /></div><div class="title">Figure 1. Estructura del Automóvil</div></li></ul></div>
<div class="imageblock" style="text-align: center"><img src="./images/introduccion/Personal_computer,_exploded_6.png" alt="Personal computer, exploded 6" /></div><div class="title">Figure 2. Personal Computer</div>
<div class="imageblock" style="text-align: center"><img src="./images/introduccion/motherboard_parts.jpg" alt="motherboard parts" /></div><div class="title">Figure 3. Placa Base</div></div></section><section id="_arquitectura_desde_la_perspectiva_hw"><h2>1.3. Arquitectura desde la perspectiva HW</h2><div class="slide-content"><div class="ulist"><ul><li><p>4 Módulos Básicos: CPU-MEMORIA-CONTROLADORES Entrada/Salida [Periféricos]-BUSES</p></li></ul></div>
<div class="imageblock" style="text-align: center"><img src="./images/introduccion/cpui7.jpeg" alt="cpui7" /></div><div class="title">Figure 4. CPU Intel Core i7 4ª Generación</div>
<div class="imageblock" style="text-align: center"><img src="./images/introduccion/RAMtypes2.jpg" alt="RAMtypes2" width="600" /></div><div class="title">Figure 5. Memoria DRAM</div>
<div class="imageblock" style="text-align: center"><img src="./images/introduccion/memoria_SSD.png" alt="memoria SSD" width="600" /></div><div class="title">Figure 6. Periféricos: Memoria de Semiconductor Solid State Drive (SSD)</div>
<div class="imageblock" style="text-align: center"><img src="./images/introduccion/Seagate.jpg" alt="Seagate" width="600" /></div><div class="title">Figure 7. Periféricos: Disco Duro Seagate</div>
<div class="imageblock" style="text-align: center"><img src="./images/introduccion/memoria_M2M.png" alt="memoria M2M" width="600" /></div><div class="title">Figure 8. Periféricos: Memoria M2M</div>
<div class="imageblock" style="text-align: center"><img src="./images/introduccion/BusOnMotherboard.png" alt="BusOnMotherboard" /></div><div class="title">Figure 9. Bus de la Placa Base</div>
<div class="imageblock" style="text-align: center"><img src="./images/introduccion/busribbon.jpeg" alt="busribbon" width="600" /></div><div class="title">Figure 10. Bus Cableado</div></div></section><section id="_lenguajes_de_programación_y_lenguaje_máquina"><h2>1.4. Lenguajes de Programación y Lenguaje Máquina</h2><div class="slide-content"><div class="imageblock" style="text-align: center"><img src="./images/introduccion/lenguajemaquina.png" alt="lenguajemaquina" /></div><div class="title">Figure 11. Lenguaje Máquina: Binario</div>
<div class="ulist"><ul><li><p>Lenguaje Pascal</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-pascal" data-lang="pascal">program Hello_world;
 begin
   writeln('hello world')
 end.</code></pre></div></div></li><li><p>L. Máquina-Binario Intel x86</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-pascal" data-lang="pascal"># [2] begin
00000000004001a0 &lt;PASCALMAIN&gt;:
  4001a0:	01010101
  4001a1:	01001000 10001001 11100101
  4001a4:	01001000 10000011 11101100 00010000
  4001a8:	01001000 10001001 01011101 11111000
  4001ac:	11101000 10110111 00111110 00000001 00000000
# [3] writeln('hello world')
  4001b1:	11101000 11001010 10010011 00000001 00000000
  4001b6:	01001000 10001001 10100011
  4001b9:	01001000 10001001 11011110
  4001bc:	01001000 10111010 11000000 11110110 01100001 00000000 00000000
  4001c3:	00000000 00000000 00000000
  4001c6:	10111111 00000000 00000000 00000000 00000000
  4001cb:	11101000 01111000 10010110 00000001 00000000
  4001d0:	11101000 00010011 00111101 00000001 00000000
  4001d5:	01001000 10001001 11011111
  4001d8:	11101000 01110011 10010101 00000001 00000000
  4001dd:	11101000 00000110 00111101 00000001 00000000
  4001e2:	11101000 10011001 01000010 00000001 00000000
  4001e7:	01001000 10001011 01011101 11111000
  4001eb:	10101001
  4001ec:	10010011</code></pre></div></div></li><li><p>Lenguaje Máquina (Código Hexadecimal) vs Lenguaje Ensamblador ASM x86</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-pascal" data-lang="pascal"># [2] begin
00000000004001a0 &lt;PASCALMAIN&gt;:
  4001a0:	55                   	push   %rbp
  4001a1:	48 89 e5             	mov    %rsp,%rbp
  4001a4:	48 83 ec 10          	sub    $0x10,%rsp
  4001a8:	48 89 5d f8          	mov    %rbx,-0x8(%rbp)
  4001ac:	e8 b7 3e 01 00       	callq  414068 &lt;FPC_INITIALIZEUNITS&gt;
# [3] writeln('hello world')
  4001b1:	e8 ca 93 01 00       	callq  419580 &lt;fpc_get_output&gt;
  4001b6:	48 89 c3             	mov    %rax,%rbx
  4001b9:	48 89 de             	mov    %rbx,%rsi
  4001bc:	48 ba c0 f6 61 00 00 	movabs $0x61f6c0,%rdx
  4001c3:	00 00 00
  4001c6:	bf 00 00 00 00       	mov    $0x0,%edi
  4001cb:	e8 78 96 01 00       	callq  419848 &lt;FPC_WRITE_TEXT_SHORTSTR&gt;
  4001d0:	e8 13 3d 01 00       	callq  413ee8 &lt;FPC_IOCHECK&gt;
  4001d5:	48 89 df             	mov    %rbx,%rdi
  4001d8:	e8 73 95 01 00       	callq  419750 &lt;fpc_writeln_end&gt;
  4001dd:	e8 06 3d 01 00       	callq  413ee8 &lt;FPC_IOCHECK&gt;
  4001e2:	e8 99 42 01 00       	callq  414480 &lt;FPC_DO_EXIT&gt;
  4001e7:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  4001eb:	c9                   	leaveq
  4001ec:	c3                   	retq</code></pre></div></div></li><li><p>Lenguaje de programación humano (texto) vs Lenguaje de programación máquina (binario)</p></li><li><p>Traducir &#8594; Compilar</p></li><li><p>Interpretar</p></li><li><p>Lenguajes de programación: javascript, ruby, python, java, bash, C, assembly</p><div class="ulist"><ul><li><p>Niveles de abstracción: humano/máquina</p></li></ul></div></li></ul></div></div></section><section id="_interface_softwarehardware"><h2>1.5. Interface Software/Hardware</h2><div class="slide-content"><div class="ulist"><ul><li><p>Interacción directa del Programador con el hardware Máquina &#8594; Programación en un lenguaje de bajo nivel (ensamblador, C)</p><div class="literalblock"><div class="content"><pre>                                               +-----------------------------+
                                               |   Programador  Bajo Nivel   |
                                               |                             |
                                               +-------------+---------------+
                                                             |                        SOFTWARE
      -------------------------------------------------------|--------------------------------
                                                             +                        HARDWARE
                                                             |
                                                             v
                                               +-----------------------------+
                                               |   Unidad Central de Proceso |
                                               |                             |
                                               +-------------+---------------+
                                                             |
               +----------------------+----------------------+-----------+
               |                      |                                  |
               v                      v                                  v
  +-------------------+  +-------------------+  +------------------------------------------+
  | Memoria Principal |  | Cálculo Aritmético|  |                Controladores I/O         |
  |                   |  | y Lógico          |  |                                          |
  +-------------------+  +-------------------+  +------+-----------+-------------+---------+
                                                       |           |             |
                                                       v           v             v
                                                  +----+---+ +-----+----+ +------+------+
                                                  | Display| | Teclado  | | Disco Duro  |
                                                  |        | |          | |             |
                                                  +--------+ +----------+ +-------------+</pre></div></div></li><li><p>Programación de bajo nivel</p><div class="ulist"><ul><li><p>Módulo fuente: Lenguaje C ó Lenguaje ensamblador</p></li><li><p>Módulo objeto: Lenguaje máquina &#8594; Compilación, Ensamblaje y Enlazado del Módulo Fuente.</p></li><li><p>Sistemas Bare Metal: No hay Sistema Operativo. Programamos directamente sobre el Hardware.</p></li></ul></div></li><li><p>Interacción indirecta del programador con el hardware de la máquina. El programador interactua con el Sistema Operativo (S.O.)</p><div class="ulist"><ul><li><p>Interacción del Kernel (núcleo, pej linux) del Sistema Operativo (S.O.) con la máquina (pej intel x86)</p></li></ul></div></li></ul></div>
<div class="literalblock"><div class="content"><pre>                                               +-----------------------------+
                                               |         Programador         |
                                               |       LLamadas al S.O.      |
                                               +-------------+---------------+
                                                             |
                                               +-----------------------------+
                                               |         Kernel              |
                                               |         Drivers             |
                                               +-------------+---------------+
                                                             |                        SOFTWARE
      -------------------------------------------------------|--------------------------------
                                                             +                        HARDWARE
                                                             |
                                                             v
                                               +-----------------------------+
                                               |   Unidad Central de Proceso |
                                               |                             |
                                               +-------------+---------------+
                                                             |
               +----------------------+----------------------+-----------+
               |                      |                                  |
               v                      v                                  v
  +-------------------+  +-------------------+  +------------------------------------------+
  | Memoria Principal |  | Cálculo Aritmético|  |                Controladores I/O         |
  |                   |  | y Lógico          |  |                                          |
  +-------------------+  +-------------------+  +------+-----------+-------------+---------+
                                                       |           |             |
                                                       v           v             v
                                                  +----+---+ +-----+----+ +------+------+
                                                  | Display| | Teclado  | | Disco Duro  |
                                                  |        | |          | |             |
                                                  +--------+ +----------+ +-------------+</pre></div></div>
<div class="ulist"><ul><li><p>Sistemas con Sistema Operativo (pej GNU/linux): A la hora de programar recurrimos a librerías que acceden al hardware a travéś del sistema opearitov. Pej la función printf(), de la librería libc, al compilarse se traduce en la función write() del sistema operativo la cual llama al driver (en el sistema operativo) de la tarjeta gráfica de la pantalla. El Sistema operativo consigue "abstraer" el HW físico de la máquina y facilita enormemente la programación al no tener que conocer el funcionamiento físico de la computadora.</p></li></ul></div></div></section><section id="_apuntes"><h2>1.6. Apuntes</h2><div class="slide-content"><div class="ulist"><ul><li><p>Están disponibles los Cinco Guiones de Prácticas en los apuntes: en el documento <a href="./PDF/eecc_book.pdf">PDF</a> y en el documento <a href="https://kandido.github.io/eecc_book.html">Apuntes On Line</a> siendo este último el más actualizado</p><div class="imageblock" style="text-align: center"><img src="./images/introduccion/qr_eecc.jpg" alt="qr eecc" /></div><div class="title">Figure 12. Apuntes On Line</div></li></ul></div></div></section><section id="_temario"><h2>1.7. Temario</h2><div class="slide-content"><div class="ulist"><ul><li><p><a href="http://www.unavarra.es/ficha-asignaturaDOA?languageId=100000&amp;codPlan=240&amp;codAsig=240306">Web Estructura de Ordenadores</a></p></li></ul></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code class="language-sh" data-lang="sh">Temario

1 - Introducción
2 - Arquitectura de Von Neumann
     2.1 CPU
     2.2 Memoria
     2.3 Entrada / Salida
3 - Representación de datos
     3.1 Bit, Byte y Palabra
     3.2 Caracteres, enteros y reales
4 - Aritmética y lógica
     4.1 Operaciones aritméticas y lógicas sobre enteros en binario
     4.2 Redondeo y propagación de error en números reales
5 - Representación de instrucciones
     5.1 Lenguaje máquina, lenguaje ensamblador y lenguajes de alto nivel
     5.2 Formato de instrucción
     5.3 Tipos de instrucción y modos de direccionamiento
6 - Programación en lenguaje ensamblador de construcciones básicas de los lenguajes de alto nivel
     6.1 Sentencias de asignación
     6.2 Sentencias condicionales
     6.3 Bucles
     6.4 LLamadas y retorno de funcion o subrutina
7 - Arquitectura y organización de la CPU
     7.1 Conjunto de instrucciones
     7.2 Arquitecturas CISC, RISC y VLIW
     7.3 Fases de ejecución de una instrucción
     7.4 Camino de datos
8 - Sistema de entrada / salida
     8.1 Sincronización por encuesta
     8.2 Sincornización por interrupción
     8.3 Vector de interrupciones
     8.4 Acceso directo a memoria DMA
     8.5 Programación en lenguaje ensamblador de rutinas de entrada/salida
9 - Organización de la memoria
     9.1 Jerarquía de memoria
     9.2 Latencia y ancho de banda
     9.3 Memoria cache
     9.4 Memoria virtual</code></pre></div></div>
<h level="3">Bibliografia Basica</h><h level="4">Imprenta</h><div class="ulist"><ul><li><p>Teoría</p><div class="ulist"><ul><li><p><a href="http://williamstallings.com/ComputerOrganization/">William Stalling</a></p><div class="imageblock" style="text-align: center"><img src="./images/introduccion/william_stalling7_portada.jpg" alt="william stalling7 portada" width="300" /></div><div class="title">Figure 13. William Stalling Book</div></li></ul></div></li></ul></div>
<div class="literalblock"><div class="content"><pre>Organización y arquitectura de computadores .William Stallings
Edición 7, reimpresa Pearson Prentice Hall
ISBN 8489660824, 9788489660823 . 2006</pre></div></div>
<div class="literalblock"><div class="content"><pre>Computer Organization and Architecture: Designing for Performance.
William Stallings
9ª Ed Upper Saddle River (NJ) : Prentice Hall, [2013]
ISBN 0-273-76919-7 . 2012</pre></div></div>
<div class="ulist"><ul><li><p><a href="http://williamstallings.com/COA/COA7e.html">COA 7ª</a></p></li><li><p><a href="https://www.pearson.com/us/higher-education/program/Stallings-Pearson-e-Text-for-Computer-Organization-and-Architecture-Access-Code-Card-11th-Edition/PGM2043621.html">11º Ed 2019</a></p></li><li><p>Prácticas:</p></li></ul></div>
<div class="imageblock" style="text-align: center"><img src="./images/introduccion/programming_from_the_ground_up.jpg" alt="programming from the ground up" /></div><div class="title">Figure 14. Programming Assembly</div>
<div class="literalblock"><div class="content"><pre>Programming from the Ground Up
by Jonathan Bartlett Edited by Dominick Bruno, Jr.
Copyright © 2003 by Jonathan Bartlett
ISBN 0-9752838-4-7
Published by Bartlett Publishing in Broken Arrow, Oklahom</pre></div></div>
<div class="ulist"><ul><li><p>Programming from the Ground Up  by Jonathan Bartlett. Programación en Lenguaje Ensamblador AT&amp;T para la arquitectura x86.</p><div class="ulist"><ul><li><p><a href="http://programminggroundup.blogspot.com.es/2007/01/programming-from-ground-up.html">PGU book online</a></p></li><li><p><a href="http://savannah.nongnu.org/projects/pgubook/">PGU book home</a></p></li><li><p><a href="http://download.savannah.gnu.org/releases/pgubook/">pdf</a></p></li></ul></div></li><li><p><a href="https://upcommons.upc.edu/handle/2117/115067">El ensamblador&#8230;&#8203; pero si es muy fácil</a>: IA-32 (i386) (sintaxis AT&amp;T)</p><div class="ulist"><ul><li><p>Manuales GNU:</p></li></ul></div></li><li><p>Documentación de los Manuales: La mayoría de las aplicaciones y herramientas software de la fundación GNU y Linux disponen de Manuales bien on-line o bien localmente en la propia máquina. Manual del compilador gcc: <code>$man gcc</code></p></li></ul></div>
<div class="admonitionblock important"><table><tr><td class="icon"><i class="fa fa-exclamation-circle" title="Important"></i></td><td class="content">Es una habilidad a adquirir por el profesional informático el acceder y utilizar dichos manuales así como disponer de hojas de referencia de acceso rápido durante la sesiones de trabajo.</td></tr></table></div>
<h level="4">Online</h><div class="ulist"><ul><li><p><a href="https://diveintosystems.org/book/preface.html" class="bare">https://diveintosystems.org/book/preface.html</a></p></li></ul></div>
<h level="3">Bibliografía Complementaria</h><div class="ulist"><ul><li><p>Ir al capítulo de la <a href="#arqui_computadores">bibliografía</a>.</p></li></ul></div></div></section><section id="_profesorado"><h2>1.8. Profesorado</h2><div class="slide-content"><div class="ulist"><ul><li><p>Cándido Aramburu Mayoz.</p><div class="ulist"><ul><li><p>Doctor Ingenierio Telecomunicación. Profesor Titular de Universidad.</p></li><li><p>Edificio los Tejos, planta 2ª. Despacho 2028.</p></li><li><p>correo electrónico interno: a través del servidor Miaulario.</p></li><li><p><a href="http://www.unavarra.es/ficha-docente?rangoLetras=a-z&amp;uid=364">PDI Profesorado</a></p><div class="ulist"><ul><li><p>Tutorías, Aulas y Horario</p><div class="listingblock"><div class="content"><pre>Tutoría online (cita previa) y Presencial
Lugar: Edificio Los Tejos 2ª Planta, Despacho 2028 (Prof. Cándido Aramburu)

        Lunes :     10:00-13:00
        Miércoles   10:00-13:00

G91 -&gt; A223, G1 -&gt;A113, G2-&gt;A122, P91-&gt;A015, P1-&gt;A305, P2-&gt;E-ISM, P3-A y P3-B -&gt;A015
G91(L-15:00), G1(X-17:00), G2(L-17:00), P91(X-19:00), P1(J-17:00), P2(M-19:00), P3-A y P3-B (M-17:00)
Aula E-ISM: Edificio “Las Encinas” (Lado derecho entre la Biblioteca y el Rectorado) en el Sótano, Laboratorio de Informática “ISM”</pre></div></div></li></ul></div></li></ul></div></li><li><p>Andrés Garde Gurpegui</p><div class="ulist"><ul><li><p>Técnico Superior de la Dirección General de Informática y Telecomunicaciones del Gobierno de Navarra.</p></li><li><p>Profesor Asociado (Prácticas de Laboratorio)</p></li><li><p>Edificio de Los Tejos, planta 2ª, Sala de Asociados del departamento de INGENIERÍA ELÉCTRICA, ELECTRÓNICA Y DE COMUNICACIÓN.</p></li><li><p>andres.gardeATunavarra.es</p></li><li><p><a href="http://www.unavarra.es/pdi?uid=6578">PDI Profesorado</a></p></li></ul></div></li><li><p>Carlos Juan de Dios Ursúa</p><div class="ulist"><ul><li><p>Ingeniería Eléctrica y Electrónica</p></li><li><p>Master en Robótica y Automatización</p></li><li><p>Profesor Asociado (Teoría Estructura Computadores)</p></li><li><p>Edificio de Los Tejos, planta 2ª, Sala de Asociados del departamento de INGENIERÍA ELÉCTRICA, ELECTRÓNICA Y DE COMUNICACIÓN.</p></li><li><p>carlos.juandediosATunavarra.es</p></li></ul></div></li></ul></div></div></section><section id="_grado_informática"><h2>1.9. Grado Informática</h2><div class="slide-content"><div class="ulist"><ul><li><p><a href="https://www.unavarra.es/sites/grados/informatica-y-telecomunicacion/ingenieria-informatica/asignaturas-y-profesorado.html">Grado Informatica</a></p><div class="ulist"><ul><li><p>200 - Escuela Técnica Superior de Ingeniería Industrial, Informática y de Telecomunicación</p></li><li><p>240 - Graduado o Graduada en Ingeniería Informática por la Universidad Pública de Navarra</p></li></ul></div></li></ul></div></div></section><section id="_calendarios"><h2>1.10. Calendarios</h2><div class="slide-content"><div class="ulist"><ul><li><p><a href="https://www.unavarra.es/sites/estudios/calendarios.html">Calendario administrativo</a></p><div class="ulist"><ul><li><p>Teoría</p><div class="ulist"><ul><li><p>Grupo1 G1 Miércoles 17:00 A113</p></li><li><p>Grupo2 G2 Lunes 17:00 A122</p></li><li><p>Grupo91 G91 Lunes 15:00 A223</p></li></ul></div></li></ul></div></li><li><p>Prácticas</p><div class="ulist"><ul><li><p><a href="https://www2.unavarra.es/gesadj/servicioInformatico/usuario/aulas/Horario1C.htm">Calendario Aulas Informática 1º Cuatrimestre</a></p></li><li><p><a href="https://www2.unavarra.es/gesadj/servicioInformatico/usuario/aulas/Horario2C.htm">Calendario Aulas Informática 2º Cuatrimestre</a></p></li><li><p>P3-A: Martes a las 17:00 en A-015(40 puestos) &#8594; Prácticas de los Grupos de teoría G1 y G2</p></li><li><p>P3-B: Martes a las 17:00 en A-015(40 puestos) &#8594; Prácticas de los Grupos de teoría G1 y G2</p></li><li><p>P2: Miércoles a las 17:00 en E-ISM (36 puestos) &#8594; Prácticas del Grupo de teoría G2</p></li><li><p>P1: Lunes a las 19:00 en A305 (36 puestos) &#8594; Prácticas del Grupo de teoría G1</p></li><li><p>P91: Miércoles 19:00 en A015 (20 puestos) &#8594; Prácticas del Grupo de teoría Euskera</p></li><li><p>Aula E-ISM: Edificio “Las Encinas” (Lado derecho entre la Biblioteca y el Rectorado) en el Sótano, Laboratorio de Informática “ISM”</p></li></ul></div></li></ul></div>
<div class="literalblock"><div class="content"><pre>SEPTIEMBRE	Martes	  	Miércoles	Jueves
	        26 P3-A P2	27 P91   	28 P1
OCTUBRE
	         3 P3-B		                5 P1
	        10 P3-A P2	11 P91
	        17 P3-B
	        24 P3-A P2	25 P91	        26 P1
	        31 P3-B
NOVIEMBRE
		7 P3-A P2	8 P91		9 P1
		14 P3-B
		21 P3-A P2	22 P91		23 P1
		28 P3-B</pre></div></div>
<div class="ulist"><div class="title">Calendario Semestre Otoño 2022</div><ul><li><p>Fiestas</p><div class="listingblock"><div class="content"><pre>12 de octubre miércoles (Fiesta Nacional de España).
01 de noviembre martes (Festividad de Todos los Santos).
03 de diciembre martes (San Francisco Javier, Día de Navarra).
06 de diciembre jueves (Día de la Constitución).</pre></div></div></li><li><p>Semanas del curso :</p><div class="ulist"><ul><li><p>15 semanas: Duración del curso 2 de Septiembre al 20 de Diciembre</p></li></ul></div></li><li><p><a href="https://www.unavarra.es/sites/grados/informatica-y-telecomunicacion/ingenieria-informatica/evaluacion.html#cCentralUPNA">calendario exámenes</a></p><div class="ulist"><ul><li><p><a href="https://www2.unavarra.es/gesadj/CyD1/ETSIIT/Examenes/Grados/Otono/240_otono.pdf">otoño 2023</a></p></li><li><p>Convocatoria Ordinaria 18/12/2023 08:00 Convocatoria Extraordinaria: 18/01/2024 16:00</p></li></ul></div></li></ul></div></div></section><section id="_ejercicios_mediante_resolución_de_problemas"><h2>1.11. Ejercicios mediante resolución de problemas</h2><div class="slide-content"><div class="ulist"><ul><li><p>Realización de ejercicios básicos a lo largo de cada capítulo del temario incluidos en los apuntes.</p></li><li><p>Ejercicios tipo examen.</p></li></ul></div></div></section><section id="_prácticas"><h2>1.12. Prácticas</h2><div class="slide-content"><h level="3">Guiones</h><div class="ulist"><ul><li><p>Están disponibles los Cinco Guiones de Prácticas en los apuntes: en el documento eecc_book.pdf y en el documento <a href="https://kandido.github.io/eecc_book.html" class="bare">https://kandido.github.io/eecc_book.html</a> siendo este último el más actualizado</p></li></ul></div>
<h level="3">Ejercicios de Evaluación</h><div class="ulist"><ul><li><p>Al comienzo de cada sesión de prácticas se realizará un ejercicio individual de 20 minutos sobre el contenido de la sesión anterior cuya nota entra dentro del cómputo de la nota global de prácticas.</p></li></ul></div>
<h level="3">Memorias</h><div class="ulist"><ul><li><p>Prácticas Individuales.</p></li><li><p>Memorias :</p><div class="ulist"><ul><li><p>La entrega de la memoria a través del servidor de miaulario se realizará antes de la siguiente sesión de prácticas en la fecha indicada y publicada por el profesor.</p></li><li><p>La memoria es un documento único en formato PDF.</p></li><li><p>El nombre del fichero  debe ser apellido1_apellido2_tituloguionpractica.pdf</p></li><li><p>Contenido de la memoria.</p><div class="ulist"><ul><li><p>El programa descrito en pseudocódigo</p></li><li><p>El código fuente en lenguaje ensamblador debidamente comentados en coherencia con el programa en pseudocódigo.</p></li></ul></div></li><li><p>No se valora el estilo de la memoria sino su contenido ya que interesa que sirva como apuntes para las pruebas de evaluación.</p></li></ul></div></li></ul></div>
<div class="admonitionblock note"><table><tr><td class="icon"><i class="fa fa-info-circle" title="Note"></i></td><td class="content"><div class="ulist"><ul><li><p>Imprescindible tomar notas dentro y fuera del laboratorio</p></li><li><p>Salvar todo el trabajo en un pendrive o enviarlo por correo</p></li></ul></div></td></tr></table></div>
<div class="admonitionblock caution"><table><tr><td class="icon"><i class="fa fa-fire" title="Caution"></i></td><td class="content"><div class="ulist"><ul><li><p>Borrado automático a diario del contenido del disco duro.</p></li></ul></div></td></tr></table></div></div></section><section id="_recursos_informáticos"><h2>1.13. Recursos Informáticos</h2><div class="slide-content"><h level="3">UPNA</h><h level="4">servicio informático</h><div class="ulist"><ul><li><p><a href="https://www.unavarra.es/servicio-informatico/servicios/pdi?languageId=100000">Servicio Informático UPNA</a></p><div class="ulist"><ul><li><p><a href="http://www2.unavarra.es/gesadj/servicioInformatico/usuario/aulas/GERES.pdf">Reserva Aulas</a></p></li><li><p><a href="https://www.unavarra.es/servicio-informatico/servicios/pdi?opcion=23">Aulas VDI</a></p></li><li><p><a href="https://www2.unavarra.es/gesadj/servicioInformatico/usuario/aulas/AccesoRemotoVDI.pdf">Manual Acceso Remoto VDI</a></p></li><li><p><a href="https://vdibroker.unavarra.es">Escritorio Virtual</a></p></li></ul></div></li><li><p>Laboratorio Remoto de Computación</p><div class="ulist"><ul><li><p><a href="https://laboratoriosvirtuales.unavarra.es/">acceso general</a> &#8594; ¿?</p></li></ul></div></li></ul></div>
<h level="4">laboratorio remoto ARM/FPGA</h><div class="ulist"><ul><li><p>No se contempla la utilización del laboratorio remoto ARM/FPGA dentro del plan de la asignatura pero se encuentra disponible para quien desee utilizarlo, para lo cual es necesario abrir una cuenta de acceso.</p></li><li><p><a href="https://laboratoriosvirtuales.unavarra.es/fpga/#/">acceso fpga</a> &#8594; laboratorio remoto FPGA-Raspberry</p><div class="ulist"><ul><li><p>Guacamole login &#8594; credenciales UPNA</p></li><li><p>Acceso a la tarjeta DE1-SoC (ARM) &#8594; login  &#8594; Consola shell linux</p></li><li><p>Acceso a la tarjeta Raspberry (ARM) &#8594; login &#8594; Consola shell linux</p></li><li><p>Acceso a la tarjeta Xilinx (ARM) &#8594; login &#8594; Consola shell linux</p></li></ul></div></li><li><p><a href="https://labsland.com/es">Empresa Colaboradora Labsland</a>: Instancias DE1-SoC. Interfaz Web.</p><div class="ulist"><ul><li><p>Se instalará su acceso a través de miaulario mediante el botón EDA.</p></li><li><p>Herramientas de diseño dispositivos digitales</p></li></ul></div></li></ul></div>
<h level="3">Estaciones de Trabajo: 32 y 64 bits</h><h level="4">Arquitectura</h><div class="admonitionblock note"><table><tr><td class="icon"><i class="fa fa-info-circle" title="Note"></i></td><td class="content">Si la estación de trabajo particular de un alumno es Ubuntu (64 bits) sobre un procesador x86-64 no hay ningún problema para la ejecución de programas con una arquitectura de x86-64, en cambio, los programas a desarrollar en la asignatura utilizan una arquitectura de 32 bits que para poder compilar y ejecutar dichos programas es necesario</td></tr></table></div>
<h level="4">Qué instalar</h><div class="ulist"><ul><li><p>Es necesario disponer de un PC con una CPU  cuya arquitectura sea x86-64 ó amd64  y un Sistema Operativo <a href="https://linuxfoundation.org/">linux</a>/https://www.gnu.org/software/[GNU] mediante la distribución distribución <a href="https://ubuntu.com/download">Ubuntu</a>. La distribución Ubuntu que sea reciente con una versión superior a la 18. Se recomienda la distribución Ubuntu ya que es la distribución instalada en el laboratorio de informática donde se realizan las prácticas.</p><div class="ulist"><ul><li><p>El Sistema operativo puede estar instalado de forma nativa o virtual (VMware, Virtualbox, <a href="https://libvirt.org/">Virtio</a>, etc).</p></li></ul></div></li><li><p>Para la realización de las prácticas es necesaria una instalación mínima con las herramientas de programación de bajo nivel: <strong>binutils</strong>, Compilador <strong>gcc</strong>,  Debugger <strong>gdb</strong>, Editor <strong>vim</strong></p></li><li><p>En Ubuntu:</p><div class="ulist"><ul><li><p>realizar la instalación de los paquetes mediante el comando <code>sudo apt-get install binutils gcc gcc-multilib gdb vim</code></p></li><li><p>comprobar la instalación de los paquetes mediante el comando <code>dpkg -l binutils gcc gcc-multilib gdb vim</code> que el estado de cada uno de los programas es <em>ii</em></p></li><li><p>comprobar las versiones: <code>gcc --version &amp;&amp; as --version &amp;&amp; ld --version &amp;&amp; gdb --version &amp;&amp; vim --version</code></p></li></ul></div></li><li><p>Para la edición de los programas en los lenguajes C y ensamblador ASM se podrá utilizar además del editor Vim, el editor preferido (nano,sublime,gedit,kate,emacs,etc..) y/o el IDE preferido (Visual Studio Code, Eclipse, etc..)</p></li></ul></div>
<h level="3">Registrarse</h><h level="4">miaulario</h><div class="ulist"><ul><li><p><a href="https://miaulario.unavarra.es/portal">Miaulario</a></p></li></ul></div>
<h level="4">Github</h><div class="ulist"><ul><li><p>Es necesario tener una cuenta abierta en la plataforma de repositorios <a href="https://github.com/">Github</a></p></li></ul></div>
<h level="4">Google</h><div class="ulist"><ul><li><p><a href="https://support.google.com/accounts/answer/27441">Google account</a></p></li><li><p><a href="https://www.google.com/chrome/">Navegador Google Chrome</a>: permite seleccionar el idioma</p></li></ul></div></div></section><section id="_grupos_de_prácticas"><h2>1.14. Grupos de Prácticas</h2><div class="slide-content"><table class="tableblock frame-all grid-all" style="width:100%"><caption class="title">Table 1. Grupos de Prácticas</caption><colgroup><col style="width:16.6666%" /><col style="width:16.6666%" /><col style="width:16.6666%" /><col style="width:16.6666%" /><col style="width:16.6666%" /><col style="width:16.667%" /></colgroup><thead><tr><th class="tableblock halign-left valign-top">ALUMNO EECC</th><th class="tableblock halign-left valign-top">ID EECC</th><th class="tableblock halign-left valign-top">GRUPO EECC</th><th class="tableblock halign-left valign-top">PRACTICAS EECC</th><th class="tableblock halign-left valign-top">AULA</th><th class="tableblock halign-left valign-top">PROFESOR</th></tr><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Alén Urra, Saúl</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">alen.146325</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P3-A (Martes 17-19)</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">A015(30)</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Andrés Garde</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Alignani Álvarez, Tomás</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">alignani.153933</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P3-A (Martes 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Altamirano Trujillo, Ruth Nazareth</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">altamirano.146080</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P3-A (Martes 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Alustiza Sánchez, Aimar</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">alustiza.15399</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P3-A (Martes 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Álvarez Alonso, Markel</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">alvarez.147717</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P3-A (Martes 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Alvira Ballano, Alonso</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">alvira.153972</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P3-A (Martes 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Andueza Del Campo, Eneko</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">andueza.153944</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P3-A (Martes 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Arellano Cameo, Juan</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">arellano.154190</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P3-A (Martes 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Azkona Ekiza, Iker</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">azkona.153931</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P3-A (Martes 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Aznarez Gil, Iñigo</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">aznarez.138165</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P3-A (Martes 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Baquedano Simón, Javier</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">baquedano.153945</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P3-A (Martes 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Barrena Ribas, Fermín</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">barrena.154004</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P3-A (Martes 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Basterra Arteaga, Paula</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">basterra.128530</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P3-A (Martes 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Bellera Alsina, Alberto</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">bellera.142014</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P3-A (Martes 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Biurrun Rodríguez, Luna María</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">biurrun.153961</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P3-A (Martes 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Blasco Catalán, Diego</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">blasco.154001</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P1 (Jueves 17-19)</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">A305(36)</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Andrés Garde</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Boukhlik , Hajar</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">boukhlik.153919</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P1 (Jueves 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Bustince Labairu, Lucas</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">bustince.154005</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P1 (Jueves 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Cabrero Jiménez, Natalia Ana</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">cabrero.153898</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P1 (Jueves 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Calleja Pascual, Vidal</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">calleja.149323</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P1 (Jueves 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Cardenas Curicho, Solange Samanta</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">cardenas.139474</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P1 (Jueves 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Cerezo Uriz, Iñaki</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">cerezo.147574</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P1 (Jueves 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Chacón Flores, Malena Paola</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">chacon.145983</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P1 (Jueves 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Chacón González, Rubén</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">chacon.154006</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P1 (Jueves 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Chueca Irisarri, Daniel</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">chueca.146727</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P1 (Jueves 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Clemos Gómara, Samuel</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">clemos.153868</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P1 (Jueves 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Couceiro Eizaguirre, Javier</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">couceiro.126729</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P1 (Jueves 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Crespo Lamelas, Markel</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">crespo.153999</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P1 (Jueves 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Dabán Baines, Jorge</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">daban.153969</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P1 (Jueves 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Del Carmen Hernández, Aimer</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">delcarmen.153871</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P1 (Jueves 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Elizaincin Irungaray, Unax</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">elizaincin.153965</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P1 (Jueves 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Escribano López, Miguel</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">escribano.154010</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P1 (Jueves 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Espinosa Milla, Iván</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">espinosa.153952</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P1 (Jueves 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Ezcurdia Ruiz, Fermín</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">ezcurdia.153981</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P1 (Jueves 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Ezpeleta García, Laura</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">ezpeleta.153901</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P1 (Jueves 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Fernández Picorelli, Marina</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">fernandez.149320</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P1 (Jueves 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Fortun Iñurrieta, Lucas Nicolas</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">fortun.140006</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P1 (Jueves 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Garate Moreno, Gaizka</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">garate.153980</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P1 (Jueves 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Garatea Larrayoz, Iñaki</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">garatea.139258</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P1 (Jueves 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">García Manterola, Julen</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">garcia.153963</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P1 (Jueves 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Gómez De Segura Rodríguez, Laura</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">gomezdesegura.153995</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P1 (Jueves 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">González Augusto, Ibai</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">gonzalez.154119</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P1 (Jueves 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Goñi Lara, Iker</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">goni.147794</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P1 (Jueves 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Goyache Sarasa, Carlos</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">goyache.153907</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P1 (Jueves 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Guardia Arriazu, Jon</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">guardia.153924</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P1 (Jueves 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Herrero Lanzas, Eva Isabel</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">herrero.139723</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P1 (Jueves 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Hualde Romero, Israel</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">hualde.146905</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P1 (Jueves 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Illa Criado, Álvaro</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">illa.154577</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P1 (Jueves 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Iribarren Ruíz, Beñat</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">iribarren.148642</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P1 (Jueves 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Juárez Jiménez, Adrián</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">juarez.146292</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P1 (Jueves 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Larrayoz Díaz, Asier</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">larrayoz.146585</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P2(Martes 19-21)</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">EISM(34)</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Cándido</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Larrea Gallego, Javier</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">larrea.154156</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P2(Martes 19-21)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Latasa Sancha, Iván</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">latasa.146388</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P2(Martes 19-21)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Leiza Dávila, Leyre</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">leiza.153964</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P2(Martes 19-21)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Lumbreras Corredor, Imanol</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">lumbreras.147551</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P2(Martes 19-21)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Maeztu Vitaller, Carlos</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">maeztu.154202</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P2(Martes 19-21)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Manrique Rangel, Angelo Gabriel</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">manrique.153940</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P2(Martes 19-21)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Martinez Alberdi, Pablo</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">martinez.147687</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P2(Martes 19-21)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Martínez Arpón, Alain</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">martinez.146281</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P2(Martes 19-21)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Martinez Roncero, Rodrigo</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">martinez.153968</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P2(Martes 19-21)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Martínez Sesma, Álvaro</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">martinez.149151</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P2(Martes 19-21)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Merino Pinedo, Javier</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">merino.153915</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P2(Martes 19-21)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Molina Puyuelo, Alejandro</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">molina.147893</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P2(Martes 19-21)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Moral Garcia, Haizea</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">moral.147341</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P2(Martes 19-21)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Muñoz Villanueva, Asier</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">munoz.138255</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P2(Martes 19-21)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Nagore Irigoyen, Alejandro</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">nagore.95315</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P2(Martes 19-21)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Ochoa Martínez, Ángela</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">ochoa.153956</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P2(Martes 19-21)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Orenes Peñas, Martin</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">orenes.153979</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P2(Martes 19-21)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Ozcáriz Armendáriz, Iñaki</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">ozcariz.153949</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P2(Martes 19-21)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Parrales Gómez, Sarah Alicia</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">parrales.153967</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P2(Martes 19-21)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Percaz Angós, Asier</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">percaz.154165</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P2(Martes 19-21)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Pidlubnyy Lahodyn, Artem</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">pidlubnyy.154272</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P2(Martes 19-21)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Pinillos Osteriz, Iñaki</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">pinillos.153938</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P2(Martes 19-21)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Pío Aymerich, Mikel</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">pio.153922</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P2(Martes 19-21)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Prim Labiano, Ainara</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">prim.153947</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P2(Martes 19-21)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Razvant Sofrone, Bogdan</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">razvant.153957</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P2(Martes 19-21)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Reimóndez Blanco, Luis Rafael</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">reimondez.154002</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P2(Martes 19-21)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Resano Eguizábal, Amaia Duo</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">resano.154007</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P2(Martes 19-21)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Rodríguez Hidalgo, Junior Alberto</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">rodriguez.153941</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P2(Martes 19-21)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Rojas Urrutia, Aitor</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">rojas.150213</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P2(Martes 19-21)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Romero Samaniego, Oscar Hugo</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">romero.153951</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P2(Martes 19-21)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Ros Villanueva, Álvaro</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">ros.154011</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P3-B (Martes 17-19)</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">A015(30)</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Andrés</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Ruiz de Gopegui Rubio, Paula</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">ruizdegopegui.148800</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P3-B (Martes 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Sáez Zubillaga, Javier</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">saez.154043</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P3-B (Martes 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Sáinz González, Mario</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">sainz.153904</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P3-B (Martes 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Santos Garzon, Jaider Felipe</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">santos.138639</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P3-B (Martes 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Sotelo Aguirre, Martín</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">sotelo.153910</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P3-B (Martes 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Suárez Etulain, Diego</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">suarez.153960</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P3-B (Martes 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Tiraplegui Etulain, Manex</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">tiraplegui.154012</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P3-B (Martes 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Vallés Zamora, Miguel</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">valles.146260</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P3-B (Martes 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Vicente Obeso, Mario</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">vicente.154000</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P3-B (Martes 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Vinces Velastegui, José Ignacio</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">vinces.153986</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P3-B (Martes 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Zamboran Maldonado, Andrea</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">zamboran.146231</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P3-B (Martes 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Zheng , Yushan</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">zheng.146049</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P3-B (Martes 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Zubasti Aristu, Rubén</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">zubasti.153989</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">G2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">P3-B (Martes 17-19)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr></table></div></section><section id="_metodología"><h2>1.15. Metodología</h2><div class="slide-content"><div class="ulist"><ul><li><p>Teoría, Ejercicios, Prácticas y Exámenes.</p></li></ul></div>
<table class="tableblock frame-all grid-all" style="width:100%"><caption class="title">Table 2. metodología</caption><colgroup><col style="width:33.3333%" /><col style="width:33.3333%" /><col style="width:33.3334%" /></colgroup><thead><tr><th class="tableblock halign-left valign-top">Metodología - Actividad</th><th class="tableblock halign-left valign-top">Horas Presenciales</th><th class="tableblock halign-left valign-top">Horas no presenciales</th></tr><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock">A-1 Clases magistrales</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">24</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">A-2 Estudio autónomo</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock">30</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">A-3 Sesiones prácticas</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">16</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">A-4 Programación / experimentación u otros trabajos en ordenador / laboratorio</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock">20</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">A-5 Resolución de problemas, ejercicios y otras actividades de aplicación</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock">12</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">A-6 Aprendizaje basado en problemas y/o casos</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">14</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">A-7 Elaboración de trabajos y/o proyectos y escritura de memorias</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock">11</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">A-8 Lectura de Guiones, preparación de presentaciones de trabajos, proyectos, etc&#8230;&#8203;</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock">15</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">A-9 Actividades de Evaluación</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock">6</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">A-10 Tutorías</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Total</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">62</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">88</p></td></tr></table>
<div class="ulist"><ul><li><p>La asignatura se desdobla en 2 partes</p><div class="ulist"><ul><li><p>Parte I: Temas 1-6 (conceptos básicos)</p></li><li><p>Parte II: Temas 7-9 (conceptos avanzados y casos prácticos)</p></li></ul></div></li></ul></div>
<h level="3">Distribución de créditos</h><div class="ulist"><ul><li><p>Distribución de créditos:</p><div class="ulist"><ul><li><p>total créditos: 6 ECTS</p></li><li><p>total horas: 6x25 : 150 horas</p></li><li><p>horas presenciales: 62 horas</p><div class="ulist"><ul><li><p>clases : 24 horas. Durante 12 semanas (2horas/semana) de 15 semanas totales del curso</p></li><li><p>prácticas de laboratorio: 16 horas. Durante 8 semanas (2horas/semana)</p></li><li><p>problemas : 14 horas. Durante 7 semanas (2horas/semana)</p></li><li><p>evaluación: 6 horas. Durante 3 semanas (2horas/semana) de 15 semanas totales del curso</p></li></ul></div></li><li><p>tutorías   : 2 horas</p></li><li><p>horas no presenciales: 88 horas</p></li></ul></div></li></ul></div>
<h level="3">Distribución de créditos de las Prácticas</h><div class="ulist"><ul><li><p>Cada alumno tendrá 16 horas de prácticas en sesiones de 2 horas: 12 en el laboratorio y 4 para la realización de Memorias.</p></li></ul></div></div></section><section id="_evaluación"><h2>1.16. Evaluación</h2><div class="slide-content"><div class="ulist"><ul><li><p><a href="http://www.unavarra.es/ficha-asignaturaDOA?languageId=100000&amp;codPlan=240&amp;codAsig=240306">Web Estructura de Ordenadores</a></p></li><li><p>Nota Final: 15%(asistencia, actitud en la clase y en el laboratorio)+35%(prácticas)+35%(teoría y su ejercicios)+15%(programación en papel)</p></li><li><p>prácticas: Ejercicios en cada sesión de prácticas, Memorias y prueba final. Prueba final el 18/012/2023 (prácticas 1ª,2ª,3ª,4ª,5ª y 6ª), haciendo especial hincapié en la práctica de generación de imágenes BMP).</p><div class="ulist"><ul><li><p>Las prácticas suponen el 35% de la nota global, es necesaria una nota mínima de 4 puntos para aprobar la asignatura y son recuperables.</p></li><li><p>La nota de prácticas es la media ponderada de: asistencia a prácticas y entrega de memorias (15%), evaluación de los ejercicios realizados en el laboratorio en cada sesión (20%) y el examen final de prácticas(65%)</p></li></ul></div></li><li><p>teoría: supone el 35% de la nota globales, es necesaria una nota mínima de 4 puntos en el primer parcial para aprobar la asignatura y son recuperables.</p><div class="ulist"><ul><li><p>2 pruebas parciales. Primera prueba parcial el 16 de Octubre (Temas del 1 al 6). Segunda prueba parcial en la convocatoria final ordinaria el 18/12/2023 (Temas del 6 al 9 y lo no visto en el primer parcial del 1 al 6).</p></li><li><p>El primer parcial tiene un valor del 60% de la nota de teoría y el segundo parcial un 40%.</p></li></ul></div></li><li><p>Programación en papel</p><div class="ulist"><ul><li><p>Supone el 15% de la nota final</p></li></ul></div></li><li><p>Convocatoria Extraordinaria:</p><div class="ulist"><ul><li><p>En caso de tener suspendidas bien las prácticas o bien la teoría, una aprobada y la otra suspendida, se guarda la nota de la parte aprobada (teoría o práctica).</p></li></ul></div></li></ul></div>
<div class="admonitionblock caution"><table><tr><td class="icon"><i class="fa fa-fire" title="Caution"></i></td><td class="content">OBLIGATORIEDAD de las prácticas y de las pruebas teóricas:</td></tr></table></div>
<div class="ulist"><ul><li><p>Asistencia a las prácticas en el laboratorio: Es <strong>obligatorio</strong> asistir al 87.5% de las horas de prácticas en el laboratorio.</p></li><li><p>Entrega de las memorias de prácticas: Es <strong>obligatorio</strong> entregar el 100% de las memorias dentro del plazo establecido en la fecha habilitada en el servidor de miaulario. No se reciben memorias de prácticas ni de tareas fuera del plazo fijado por el servidor de miaulario.</p></li><li><p>La obligatoriedad de la asistencia al 87.5% de las horas de prácticas así como la entrega de memorias en el plazo y medio establecido es condición necesaria para poder superar la asignatura.</p></li></ul></div></div></section><section id="_exámenescontenidos"><h2>1.17. Exámenes:Contenidos</h2><div class="slide-content"><div class="ulist"><ul><li><p>Los exámenes de teoría tendrán preguntas teóricas sobre conceptos vistos en clase y ejercicios con una distribución "aproximada" en el primer  parcial del: 20% preguntas sobre conceptos teóricos y un 80% de ejercicios ; y para el segundo parcial: 60% preguntas sobre conceptos teóricos y un 40% de ejercicios.</p></li><li><p>El examen de programación en papel se realizará sin ordenador y con las hojas de referencia de las instrucciones en el lenguaje ensamblador, el depurador GDB y las sentencias del lenguaje C. Consiste en preguntas sobre el programación en el lenguaje ensamblador y no sobre GDB.</p></li><li><p>El examen de prácticas en el laboratorio se realizará con las memorias de prácticas y las hojas de referencia y sin poder utilizar ninguna información electrónica ni de forma remota (acceso a internet) ni de forma local (pendrive USB,etc).</p></li><li><p>Calendario:</p><div class="listingblock"><div class="content"><pre>1º parcial teoría: Temas 1,2,3,4,5 y 6: 16/10/2022
2º parcial teoría: Todos los temas: 18/12/2023
Examen de prácticas: Convocatoria Ordinaria 18/12/2023</pre></div></div></li></ul></div></div></section></section>
<section><section id="_arquitectura_von_neumann"><h2>2. Arquitectura Von Neumann</h2></section><section id="_arquitectura_von_neumann_2"><h2>2.1. Arquitectura Von Neumann</h2><div class="slide-content"><div class="ulist"><ul><li><p>Calcular la suma \(\sum_{i=1}^{N}i=N(N+1)/2\)</p></li></ul></div>
<h level="3">Temario</h><div class="olist arabic"><ol class="arabic" start="2"><li><p>Arquitectura Von Neumann:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>CPU</p></li><li><p>Memoria</p></li><li><p>Entrada / Salida</p></li></ol></div></li></ol></div>
<h level="3">Contexto Histórico</h><h level="4">Antecedentes</h><div class="ulist"><ul><li><p>1833: Charles Babbage &#8594; Diseña la 1ª Computadora mecánica</p></li><li><p>1890: Máquina tabuladora de Herman <strong>Hollerith</strong>. Censo en USA. IBM (1925)</p></li><li><p>1936: Alan Turing &#8594; Algoritmia y concepto de máquina de Turing.  Máquina código Enigma.</p></li><li><p><strong>Seguna Guerra Mundial 1939-1945</strong></p></li><li><p>1944: USA, IBM Computadora electromecánica Harvard Mark I</p></li><li><p>1944: Colossus (Colossus Mark I y Colossus Mark 2). Decodificar comunicaciones.</p></li></ul></div>
<h level="4">ENIAC</h><div class="ulist"><ul><li><p>1947: En la Universidad de Pensilvania (laboratorio de investigación de balística para la artillería) se construye la <strong>ENIAC</strong> (Electronic Numerical Integrator And Calculator)</p><div class="ulist"><ul><li><p>Ecuaciones diferenciales sobre balística (angle = f (location, tail wind, cross wind, air density, temperature, weight of shell, propellant charge, &#8230;&#8203; ) )</p></li><li><p>Computadora electrónica (no mecánica) de <strong>propósito general</strong>.</p></li><li><p>Memoria: Sólo 20 acumuladores &#8594; flip-flops hechos con triodos</p><div class="ulist"><ul><li><p>18,000 tubos electrónicos ó válvulas de vacío</p></li></ul></div></li><li><p>Programación manual de los interruptores</p></li><li><p>100,000 instrucciones por segundo</p></li><li><p>300 multiplicaciones por segundo</p></li><li><p>200 kW</p></li><li><p>13 toneladas y 180 m<sup>2</sup></p></li></ul></div></li></ul></div>
<h level="4">EDVAC</h><div class="ulist"><ul><li><p>1951: En la Universidad de Pensilvania (J. Presper Eckert y John William Mauchly ) comienza a operar la <strong>EDVAC</strong> (Electronic Discrete Variable Automatic Computer), concebida por <strong>John von Neumann</strong>, que a diferencia de la ENIAC no era decimal, sino binaria, y tuvo el primer <strong>programa</strong> (no solo los datos) diseñado para ser <strong>almacenado</strong>: STORED PROGRAM COMPUTER &#8594; program can be manipulated as data.</p><div class="ulist"><ul><li><p>500000$</p></li><li><p>La EDVAC poseía físicamente casi 6000 válvulas termoiónicas y 12 000 diodos de cristal. Consumía 56 kilowatts de potencia. Cubría 45,5 m² de superficie y pesaba 7850 kg.</p></li><li><p>Arquitectura:</p><div class="ulist"><ul><li><p>un lector-grabador de cinta magnética</p></li><li><p>una unidad de control con osciloscopio, una unidad para recibir instrucciones del control</p></li><li><p>la memoria : 2000 word storage "mercury delay lines" &#8594; poca fiabilidad</p></li><li><p>una unidad de aritmética de coma flotante en 1958.</p></li></ul></div></li></ul></div></li></ul></div>
<h level="4">IAS</h><div class="ulist"><ul><li><p>1946-1952 : <strong>IAS</strong> (Institute Advanced Studies) mainframe :</p><div class="ulist"><ul><li><p>Evolución de EDVAC: unidad de memoria principal y secundaria tambor magnético.</p></li><li><p>Memoria Selectron: almacenamiento capacitivo  &#8594; carga electrostática</p></li></ul></div></li></ul></div>
<h level="4">Posterior</h><div class="ulist"><ul><li><p>1952: <strong>UNIVAC I</strong> (UNIVersal Automatic Computer I) was the first commercial mainframe computer. Evolución de la máquina tabuladora de Hollerith aplicado al procesado del censo en USA.</p></li><li><p>1952: IBM 701, conocido como la "calculadora de Defensa" mientras era desarrollado, fue la primera computadora científica comercial de IBM &#8594; primer lenguaje <strong>ENSAMBLADOR</strong>.</p></li><li><p>1964: mainframe (computadora central) <strong>IBM 360</strong> &#8594; primer computador con ISA (microprogramación) &#8594; compatibilidad</p><div class="ulist"><ul><li><p>tecnología híbrida entre componentes integrados discretos de silicio y otros componentes &#8594; no "circuitos" integrados.</p></li><li><p>Basic Operating System/360 (BOS/360),  Disk Operating System/360 (DOS/360)</p></li></ul></div></li></ul></div>
<h level="4">Tecnología de Semiconductor</h><div class="ulist"><ul><li><p>1947: en los Laboratorios Bell, John Bardeen, Walter H. Brattain y William Shockley inventan el <strong>transistor</strong>.</p></li><li><p>1958: Kilby , primer circuito integrado en germanio.</p></li><li><p>1957: Robert Norton Noyce, cofundador de Fairchild Semiconductor, primer circuito integrado planar</p></li><li><p>1968: Robert Norton Noyce y  Gordon Moore fundan Intel.</p></li><li><p>1971: Intel 4004 &#8594; cpu integrada en silicio &#8594; 8 bits</p></li></ul></div></div></section><section id="_institute_advanced_machine_ias_arquitectura"><h2>2.2. Institute Advanced Machine (IAS) : Arquitectura</h2><div class="slide-content"><h level="3">Referencia</h><div class="ulist"><ul><li><p><a href="https://es.wikipedia.org/wiki/M%C3%A1quina_de_von_Neumann">The Von Neumann Machine</a></p></li></ul></div>
<h level="3">Ejemplo del Programa sum1toN</h><h level="4">Código binario para calcular \(\sum_{i=1}^{5}i\)</h><div class="imageblock text-center" style="text-align: center"><img src="./images/von_neumann/ias_code_machine.png" alt="ias code machine" /></div><div class="title">Figure 15. Código Máquina del programa sum1toN en la máquina IAS</div>
<h level="4">Programación Imperativa</h><div class="ulist"><ul><li><p>Paradigma:</p><div class="ulist"><ul><li><p>Paradigma imperativo ó estructural : el algoritmo se implementa desarrollando un programa que contiene las ORDENES que ha de ejecutar la máquina</p><div class="ulist"><ul><li><p>A diferencia de la programación declarativa: el algoritmo implementa QUÉ queremos que haga la computadora, no el COMO, no directamente las órdenes que ha de ejecutar.</p></li><li><p>Por ejemplo la operación \(\sum_{i=1}^{5}i\) , se puede describir en python como:</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-python" data-lang="python">sum(range(5,0,-1))</code></pre></div></div></li></ul></div></li></ul></div></li></ul></div>
<h level="4">Contenido de la Memoria: Datos e Instrucciones</h><div class="ulist"><ul><li><p>La computadora IAS se programaba directamente en <em>lenguaje máquina</em>, no tenía un lenguaje simbólico como el lenguaje ensamblador.</p></li><li><p>Lenguaje Máquina: Código Binario</p></li><li><p>Edición del código binario mediante tarjetas perforadas o cintas magnéticas a través de una consola.</p></li><li><p>Tipo de información contenido en la memoria: DATOS e INSTRUCCIONES</p><div class="ulist"><ul><li><p>Ejemplo de datos: números enteros <em>+3278,+5,-1,-6592,&#8230;&#8203;</em></p></li><li><p>Ejemplo de instrucciones:</p><div class="ulist"><ul><li><p>LOAD M(8) : cargar en el registro acumulador el contenido de la posición 8 de memoria</p></li><li><p>ADD M(3)  : sumar al registro acumulador el contenido de la posición 3 de la memoria</p></li><li><p>JMP M(100): saltar a la posición 100 de la memoria</p></li><li><p>etc</p></li></ul></div></li></ul></div></li><li><p>Concepto  de programa <strong>almacenado</strong> : Instrucciones binarias y Datos binarios almacenados  en la <strong>Unidad de Memoria</strong></p><div class="ulist"><ul><li><p>Fue la gran novedad de la arquitectura Von Neumannns</p></li><li><p>Es necesario CARGAR el módulo binario en la MEMORIA de la computadora para que quede almacenado.</p></li></ul></div></li><li><p>Programación secuencial: Las instrucciones se ejecutan secuencialmente según están almacenadas en la memoria&#8230;&#8203;mientras no se ejecute una instrucción explicita de salto que rompa la secuencia.</p></li></ul></div>
<h level="4">Arquitectura: Instruction Set Architecture (ISA)</h><div class="ulist"><ul><li><p>Para poder analizar el programa es necesario no solo conocer el lenguaje binario de la máquina sino conocer su ARQUITECTURA. La arquitectura de una compuradora es el WHAT de la máquina, es decir, QUE instrucciones es capaz  de ejecutar la máquina, para lo cual es necesario conocer
la ARQUITECTURA DEL REPERTORIO DE INSTRUCCIONES (Instruction Set Architecture <strong>ISA</strong>):</p><div class="ulist"><ul><li><p>el repertorio de instrucciones: operaciones y modo de acceso a los datos</p></li><li><p>jerarquía de memoria: memoria principal y registros</p></li><li><p>formato de instrucciones y datos</p></li></ul></div></li></ul></div>
<div class="admonitionblock important"><table><tr><td class="icon"><i class="fa fa-exclamation-circle" title="Important"></i></td><td class="content">la ISA es el primer nivel de <strong>abstracción</strong> del hardware físico de la computadora.</td></tr></table></div></div></section><section id="_estructura_de_la_computadora_ias"><h2>2.3. Estructura de la computadora IAS</h2><div class="slide-content"><h level="3">Módulos</h><div class="admonitionblock note"><table><tr><td class="icon"><i class="fa fa-info-circle" title="Note"></i></td><td class="content">La Estructura es el HOW de la máquina. De qué hardware disponemos para poder ejecutar las instrucciones máquina definidas por la arquitectura.</td></tr></table></div>
<div class="ulist"><ul><li><p>Hardware con Estructura <strong>Modular</strong>:</p><div class="ulist"><ul><li><p>CPU-Memoria-I/O-Bus</p><div class="ulist"><ul><li><p>Jerarquía de Memoria: 2 niveles : Memoria Principal (externa a la CPU) y Registros (internos a la CPU)</p></li></ul></div></li></ul></div></li></ul></div>
<div class="imageblock text-center" style="text-align: center"><img src="./images/von_neumann/ias_architecture.png" alt="ias architecture" /></div><div class="title">Figure 16. Arquitectura de la máquina IAS</div>
<div class="ulist"><ul><li><p>Arquitectura Interna de la CPU : Microarquitectura</p><div class="imageblock text-center" style="text-align: center"><img src="./images/von_neumann/ias_structure.png" alt="ias structure" /></div><div class="title">Figure 17. Estructura de la máquina IAS</div></li></ul></div>
<h level="3">Unidad Central de Proceso (CPU)</h><div class="ulist"><ul><li><p>CPU:</p><div class="ulist"><ul><li><p>El Funcionamiento de la CPU está dividido 3 FASES: Captura, Interpreta y Ejecuta las instrucciones secuencialmente. A la secuencia de las 3 fases se le conoce con el nombre de <strong>Ciclo de Instrucción</strong>.</p><div class="listingblock text-center"><div class="title">Ciclo de Instrucción</div><div class="content"><pre>                                         Próxima Instrucción
                +------------------------------------------------------------+
                |                                                            |
                |                                                            |
                |                                                            |
+-------------+ | +-------------+   +-----------------+    +--------------+  |  +----------+
|             | v |             |   |                 |    |              |  |  |          |
|   Start     +--&gt;+   Captura   +--&gt;+ Interpretación  +---&gt;+ Ejecución    +--+-&gt;+  Halt    |
|             |   |             |   |                 |    |              |     |          |
+-------------+   +-------------+   +-----------------+    +--------------+     +----------+</pre></div></div></li></ul></div></li><li><p>Cada instrucción máquina de un programa es capturada, interpretada y ejecutada por la CPU y en ese orden. El circuito electrónico digital encargado de controlar que se realize dicha secuencia es la <strong>Unidad de Control</strong> integrada en la CPU. La Unidad de Control da microordenes mediante señales electrónicas al subcircuito capturador, al subcircuito intérprete y al subcircuito ejecutor para que se lleven a cabo todas las fases del ciclo de instrucción de cada instrucción del programa almacendado en la memoria principal.</p></li><li><p>Tres submódulos principales de la CPU:</p><div class="ulist"><ul><li><p>Unidad de cálculo: Unidad Aritmético-Lógica (ALU)</p></li><li><p>Unidad de control: Circuito secuencial que implementa el Ciclo de instrucción dando las órdenes eléctricas a los distintos bloques (ALU, memoria principal, registros, buses, etc) en cada fase hasta completar el ciclo de instrucción.</p></li><li><p>Registros de memoria: En un registro se puede escribir o leer un dato o dos instrucciones.</p></li></ul></div></li></ul></div>
<h level="3">Memorias</h><h level="4">Memoria Principal</h><div class="listingblock text-center"><div class="title">Direccionamiento del contenido de la Memoria Principal</div><div class="content"><pre>Espacio de
DIRECCIONES         CONTENIDO

              +----------------------+
0x00000000    | 0101010101010101010  |
              +----------------------+
0x00000001    | 0101010101010101010  |
              +----------------------+
0x00000002    | 0101010101010101010  |
              +----------------------+
              |                      |
              +----------------------+
              |                      |
              +----------------------+
              |                      |
              +----------------------+
              |                      |
              +----------------------+
0x00000009    |                      |
              +----------------------+
0x0000000a    |                      |
              +----------------------+
              |                      |
              +----------------------+
              |                      |
              +----------------------+
              |                      |
              +----------------------+
              |                      |
              +----------------------+
0x0000000f    |                      |
              +----------------------+</pre></div></div>
<div class="ulist"><ul><li><p>Debe almacenar el programa a ejecutar en código binario.</p></li><li><p>La CPU es el único módulo que tiene acceso a la memoria principal.</p></li><li><p>Las instrucciones y datos del programa se almacenan secuencialmente.</p></li><li><p>Almacena el programa en dos <em>secciones</em>: Sección de Datos y Sección de Instrucciones</p></li><li><p>Organizada en Palabras accesibles aleatoriamente. Random Access Memory.</p></li><li><p>Dinamismo: Lectura/Escritura de datos e instrucciones</p></li><li><p>En la máquina IAS las direcciones de memoria apuntan a palabras de 40 bits que pueden almacenar ó un dato de 40 bits o dos instrucciones de 20 bits cada una.</p></li><li><p>Random Access Memory (RAM): direccionable cada posición de memoria.</p></li><li><p>Shared Memory: memoria compartida entre datos e instrucciones. También comparten el bus de acceso a memoria.</p></li><li><p>Capacidad para 2<sup>12</sup>=4K palabras con 40 bits para cada palabra.</p><div class="ulist"><ul><li><p>4K x 40bits = 4K x 5Bytes = 20KBytes</p></li><li><p>En cambio la memoria física disponible en esa época era de : 1024 palabras de 40 bits = 5 KBytes (Libro "The Computer from Pascal to von Neumann", Herdman Godstine, pg314, ISBN 0-691-02367-0). Limitación tecnológica.</p></li></ul></div></li></ul></div>
<h level="4">Registros de la CPU</h><div class="ulist"><ul><li><p>Memoria interna a la CPU: 2 tipos de registros: accesibles por el programador y no accesibles por el programador.</p></li><li><p>AC y AR/MQ: Acumuladores de la ALU. Multiplier/Quotient .Son los únicos registros accesibles por el programador.</p></li><li><p>Registros NO accesibles por el programador: todos los registros de la Unidad de Control: MBR,PC,IR,IBR,MAR</p><div class="ulist"><ul><li><p>MBR: Selectron Register ó Memory Buffer Register <em>MBR</em> ó Data Buffer Register <em>DBR</em>. Tamaño de 40 bits. Almacena el dato o par de instrucciones leídas de la memoria resultado de la fase de captura del ciclo de instrucción ó almacena el dato a escribir en la memoria resultado de la última fase del ciclo de instrucción.</p></li><li><p>PC: Control Counter: Program Counter (PC) o Instruction Pointer (IP). Tamaño de 12 bits. Apunta a la siguiente instrucción a capturar</p></li><li><p>IR: Control Register: también denominado Instruction Register <em>IR</em>. Tamaño de 20 bits. Almacena la instrucción capturada durante el ciclo de instrucción</p></li><li><p>IBR: Instruction Buffer Register: Almacena la segunda instrucción capturada durante el ciclo de instrucción. Tamaño de 20 bits. Observar que esto significa que en la fase de captura se capturan dos instrucciones simultáneamente.</p></li><li><p>MAR: Memory Address Register: current Memory Address. Tamaño de 12 bits. Apunta al operando o instrucción a capturar durante la primera fase del ciclo de instrucción.</p></li></ul></div></li><li><p>Su tamaño define lo que se conoce como "word size" de la arquitectura. La máquina IAS tiene una arquitectura de 40bits ó un Word de 40 bits</p></li></ul></div>
<h level="3">Bus</h><div class="ulist"><ul><li><p>Conjunto de hilos o pistas metálicas paralelas para conectar dos dispositivos electrónicos. Todo el mundo ha tenido en sus manos un cable USB el cual contiene un bus USB (Universal Serial Bus).</p></li><li><p>Bus del Sistema:</p><div class="ulist"><ul><li><p>Interconexión CPU-Memoria Principal: transferencia de datos e instrucciones.</p></li><li><p>Bus de Datos (40 hilos), Bus de Direcciones (12 hilos) y Bus de Control (Lectura/Escritura) (1 hilo). En total 53 hilos o pistas son necesarios para interconectar la CPU y la Memoria Principal.</p><div class="listingblock text-center"><div class="title">Conexión CPU-Memoria Principal</div><div class="content"><pre>+-------------+             +------------+
|             |             |            |
|             |  ADDRESS    |            |
|             +----------/-&gt;+            |
|             |    Bus   12 |            |
|             |             |            |
|             |             |            |
|             |             |            |
|             |             |            |
|             |   DATA      |            |
|  C P U      +&lt;---------/-&gt;+   MEMORIA  |
|             |   Bus    40 |            |
|             |             |            |
|             |             |            |
|             |             |            |
|             |             |            |
|             |   R/W       |            |
|             +------------&gt;+            |
|             |   Bus       |            |
|             |             |            |
|             |             |            |
+-------------+             +------------+</pre></div></div></li></ul></div></li></ul></div>
<h level="3">Input Output (I/O)</h><div class="ulist"><ul><li><p>Las entradas y salidas de una computadora son necesarias spara poder operar con ellas, bien el programador o bien otras máquinas. Para acceder externamente a la computadora son necesarios los periféricos como teclados, pantallas, etc</p><div class="ulist"><ul><li><p>En la máquina IAS el programa se escribe en tarjetas perforadas (Punch Cards). Tarjetas para Datos y tarjetas para instrucciones. Es necesario cargar los datos en la memoria antes de la ejecución del programa.</p></li><li><p>tarjetas perforadas, consola, tambores magnéticos, cintas magnéticas, cargador de memoria mediante un lector de tarjetas , display mediante tubos de vacío, etc.. &#8594; tecnología obsoleta.</p></li><li><p>No tendremos en cuenta el módulo I/O y nos centraremos en los módulos CPU-Memoria Principal.</p></li></ul></div></li></ul></div>
<h level="3">Animación del Ciclo de Instrucción</h><div class="ulist"><ul><li><p><a href="https://www.youtube.com/watch?v=04UGopESS6A">Animación del ciclo instrucción</a></p></li></ul></div></div></section><section id="_isa_arquitectura_del_repertorio_de_instrucciones_de_la_máquina_ias"><h2>2.4. ISA: Arquitectura del Repertorio de Instrucciones de la máquina IAS</h2><div class="slide-content"><h level="3">Formato de los datos e Instrucciones de la Computadora IAS</h><div class="ulist"><ul><li><p>Arquitectura de la Memoria</p><div class="ulist"><ul><li><p>Word</p><div class="ulist"><ul><li><p>40 bits : 1 dato ó  2 instrucciones</p></li></ul></div></li><li><p>Datos</p><div class="ulist"><ul><li><p>Números Enteros en formato Complemento a 2.</p></li><li><p><em>Data Format</em></p><div class="listingblock text-center"><div class="title">Formato de los datos</div><div class="content"><pre>   0   1                                                         39
+----+------------------------------------------------------------+
|    |                                                            |
| S  |                                                            |
|    |                                                            |
+----+------------------------------------------------------------+</pre></div></div></li><li><p>Observar que el bit con la numeración cero es el de la izda.</p></li></ul></div></li><li><p>Instrucciones</p><div class="ulist"><ul><li><p>Código de Operaciones de 8-bit seguidos de un operando de 12-bit (data address)</p></li><li><p><em>Instruction Format</em></p><div class="listingblock text-center"><div class="title">Formato de las instrucciones</div><div class="content"><pre>&lt;---------------Left Inst--------&gt;&lt;-------------Right Inst---------&gt;

 0            8                19 20           28                 39
+------------+-------------------+------------+--------------------+
|            |                   |            |                    |
|  Op Code   |  Address          |  Op Code   |  Address           |
|            |                   |            |                    |
+------------+-------------------+------------+--------------------+</pre></div></div></li><li><p>Definimos <strong>un sólo operando</strong> o ninguno en cada instrucción</p></li><li><p><em>Accumulator Based Architecture</em></p></li><li><p>Una operación que requiera dos operandos implicitamente hace referencia a un operando almacenado en el <em>acumulador</em></p></li><li><p>Observar que el bit con la numeración cero es el de la izda.</p></li><li><p>La instrucción de la izda (0-19) se carga en los registros, internos de la CPU, el código de operación IR y el campo de operación en MAR .</p></li><li><p>La instrucción de la derecha (20-39) se carga en el registro, interno de la CPU, IBR .</p></li><li><p>Modo de direccionamiento del Operando: Referencia del Operando. Esta arquitectura se diseño con único modo de direccionamiento denominado "Direccionamiento Directo" donde en el campo de operando de la instrucción se especifíca la <strong>dirección de memoria del operando</strong></p></li></ul></div></li></ul></div></li><li><p>Contenido de la Memoria</p><div class="ulist"><ul><li><p>Las direcciones de memoria las visualizamos dobles ya que hacen referencia a la primera a los 20 bits LSB y la segunda a los 20 bits MSB de una palabra de memoria de 40 bits.</p></li><li><p>Observar que en la columna data están las dos secciones: sección de instrucciones y sección de datos</p></li><li><p>En la arquitectura von Neumann datos e instrucciones comparten el mismo espacio de direcciones de memoria.</p><div class="imageblock text-center" style="text-align: center"><img src="./images/von_neumann/ias_code_machine.png" alt="ias code machine" /></div><div class="title">Figure 18. Codigo Maquina sum1toN de la máquina IAS</div></li></ul></div></li></ul></div>
<h level="3">Repertorio ISA</h><h level="4">Lenguaje RTL</h><div class="ulist"><ul><li><p>Información sobre el Lenguaje de Transferencia entre Registros (RTL) en el <a href="#RTL_lang">Apéndice</a></p></li><li><p>El lenguaje de transferencia entre registros permite describir programas a nivel de microoperaciones al igual que los lenguajes máquina binario y lenguaje ensamblador. La ventaja del lenguaje RTL es que su sintaxis es independiente de la arquitectura de la computadora, es decir, es un lenguaje Universal. Por lo tanto si describimos un programa en el lenguaje RTL su transcripción a un lenguaje ensamblador de arquitectura esapecífica como la arquitectura amd64,ARM, RISC-V,etc resulta mucho más sencilla.</p></li></ul></div>
<h level="4">Repertorio de la máquina IAS</h><div class="ulist"><ul><li><p>Instruction Set Architecture (ISA): Definición y características del conjunto de instrucciones. Arquitectura del Repertorio de Instrucciones.</p></li><li><p>En la versión original no había código ensamblador, se programaba directamente en lenguaje máquina.</p><div class="ulist"><ul><li><p>En la tabla adjunta, en la segunda columna, los <strong>MNEMONICOS</strong> (LOAD,ADD,SUB,etc) de las operaciones de las instrucciones se corresponden con los diseñados por el libro de texto de William Stalling. En la primera y última columnas las operaciones se simbolizan mediante un lenguaje de transferencia entre registros.</p></li><li><p>Selectron es el nombre de la tecnología utilizada para la Memoria Principal.</p><div class="ulist"><ul><li><p>La notación S(x) equivale en notación RTL a M[x]</p></li></ul></div></li><li><p>R es el registro AR que W.Stalling denomina registro MQ.</p></li></ul></div></li></ul></div>
<table class="tableblock frame-all grid-all" style="width:100%"><caption class="title">Table 3. Instruction Set</caption><colgroup><col style="width:8.3333%" /><col style="width:16.6666%" /><col style="width:8.3333%" /><col style="width:50%" /><col style="width:16.6668%" /></colgroup><thead><tr><th class="tableblock halign-left valign-top">Instruction name</th><th class="tableblock halign-left valign-top">Instruction name</th><th class="tableblock halign-center valign-top">Op</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Register Transfer Language (RTL)</th></tr><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock">S(x)&#8594;Ac+</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">LOAD M(X)</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">copy the number in Selectron location x into AC</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">AC &#8592; M[x]</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">S(x)&#8594;Ac-</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">LOAD -M(X)</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">same as #1 but copy the negative of the number</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">AC &#8592; ~M[x]+1</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">S(x)&#8594;AcM</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">LOAD |M(X)|</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">same as #1 but copy the absolute value</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">AC &#8592; |M[x]|</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">S(x)&#8594;Ac-M</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">LOAD -|M(X)|</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">same as #1 but subtract the absolute value</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">AC &#8592; AC-|M[x]|</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">S(x)&#8594;Ah+</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">ADD M(X)</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">5</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">add the number in Selectron location x into AC</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">S(x)&#8594;Ah-</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">SUB M(X)</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">6</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">subtract the number in Selectron location x from AC</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">S(X)&#8594;AhM</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">ADD |M(X)|</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">same as #5, but add the absolute value</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">S(X)&#8594;Ah-M</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">SUB |M(X)|</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">8</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">same as #7, but subtract the absolute value</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">S(x)&#8594;R</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">LOAD MQ,M(X)</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">9</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">copy the number in Selectron location x into AR</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">R&#8594;A</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">LOAD MQ</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">A</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">copy the number in AR to AC</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">S(x)*R&#8594;A</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">MUL M(X)</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">B</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Multiply the number in Selectron location x by the number in AR. Place the left half of the result in AC and the right half in AR.</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">A/S(x)&#8594;R</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">DIV M(X)</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">C</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Divide the number in AC by the number in Selectron location x. Place the quotient in AR and the remainder in AC.</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Cu&#8594;S(x)</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">JUMP M(X,0:19)</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">D</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Continue execution at the left-hand instruction of the pair at Selectron location x</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Cu`&#8594;S(x)</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">JUMP M(X,20:39)</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">E</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Continue execution at the right-hand instruction of the pair at Selectron location x</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Cc&#8594;S(x)</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">JUMP+ M(X,0:19)</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">F</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">If the number in AC is &gt;= 0, continue as in #D. Otherwise, continue normally.</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Cc`&#8594;S(x)</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">JUMP+ M(X,20:39)</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">10</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">If the number in AC is &gt;= 0, continue as in #E. Otherwise, continue normally.</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">At&#8594;S(x)</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">STOR M(X)</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">11</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Copy the number in AC to Selectron location x</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Ap&#8594;S(x)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-center valign-top"><p class="tableblock">12</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Replace the right-hand 12 bits of the left-hand instruction at Selectron location x by the right-hand 12 bits of the AC</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Ap`&#8594;S(x)</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-center valign-top"><p class="tableblock">13</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Same as #12 but modifies the right-hand instruction</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">L</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">LSH</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">14</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Shift the number in AC to the left 1 bit (new bit on the right is 0)</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">R</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">RSH</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">15</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Shift the number in AC to the right 1 bit (leftmost bit is copied)</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">halt</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Halt the program (see paragraph 6.8.5 of the IAS report)</p></td><td class="tableblock halign-left valign-top"></td></tr></table>
<div class="ulist"><ul><li><p>Instruction Set (William Stalling)</p><div class="imageblock text-center" style="text-align: center"><img src="./images/von_neumann/ias_instruction.png" alt="ias instruction" /></div><div class="title">Figure 19. IAS_Instruction_Set</div></li></ul></div>
<h level="3">Interfaz ISA</h><div class="ulist"><ul><li><p>La arquitectura del conjunto de instrucciones (ISA) define la <strong>INTERFAZ</strong> entre el Hardware y el Software de la máquina</p><div class="ulist"><ul><li><p>Podemos tener dos CPU totalmente diferentes, p.ej AMD e Intel, pero  si tienen la misma ISA serán máquinas compatibles desde el punto de vista del sistema operativo.</p></li><li><p>Concepto de familia: un mismo repertorio de instrucciones puede ser ejecutado por distintas computadoras</p></li></ul></div></li><li><p><a href="http://en.wikipedia.org/wiki/List_of_instruction_sets">ISA de distintas máquinas</a></p></li></ul></div>
<div class="listingblock text-center"><div class="title">Instruction Set Architecture (ISA)</div><div class="content"><pre>digraph G {
 ISA -&gt; "Estructura de la Computadora";
 ISA -&gt; "Formatos";
 ISA -&gt; "Repertorio de instrucciones";
 "Estructura de la Computadora" -&gt; CPU;
 "Estructura de la Computadora" -&gt; Memoria;
 "Estructura de la Computadora" -&gt; "I/O";
 "Estructura de la Computadora" -&gt; Bus;
 Memoria -&gt; Jerarquía ;
 Jerarquía -&gt; "Memoria Principal";
 "Memoria Principal" -&gt; "Espacio Lineal"
 "Memoria Principal" -&gt; "Bus direcciones 12 bits"
 Jerarquía -&gt; Registros;
 Registros -&gt; "Accesibles AC,AR"
 Registros -&gt; "No Accesibles: PC,IBR,IR,MBR,MAR"
 "Formatos" -&gt; Instrucciones;
 "Instrucciones" -&gt; "Código Operaciones"
 "Instrucciones" -&gt; "Ref Operando Fuente" -&gt; "Dirección Absoluta"
 "Formatos" -&gt; "Datos";
  "Datos" -&gt; "Enteros Complemento a 2";
 "Repertorio de instrucciones" -&gt; Operaciones;
 "Operaciones" -&gt; "Transferencia-Aritmética-Lógica-SaltoCondicional"
 "Repertorio de instrucciones" -&gt; "Modos de Direccionamiento";
 "Modos de Direccionamiento" -&gt; "Dirección Absoluta";
}</pre></div></div></div></section><section id="_programación_en_el_lenguaje_ensamblador_ias"><h2>2.5. Programación en el Lenguaje Ensamblador IAS</h2><div class="slide-content"><h level="3">Estrategia del Desarrollo de un Programa en Lenguaje Ensamblador</h><div class="sidebarblock"><div class="content"><div class="ulist"><ul><li><p>Una vez entendido el problema que ha de resolverse mediante la programación, no se programa directamente el módulo fuente solución del problema sino que se va resolviendo describiendo el problema y el algorimto solución en distintos lenguajes y en las siguiente fases:</p><div class="ulist"><ul><li><p>Descripción del algoritmo en lenguaje "pseudocódigo".</p></li><li><p>Descripción del algoritmo mediante un organigrama o diagrama de flujo.</p></li><li><p>Descripción del algoritmo en lenguaje de transferencia entre registros RTL.</p></li><li><p>Descripción del algoritmo en lenguaje ensamblador propio de la computadora</p></li></ul></div></li></ul></div></div></div>
<div class="listingblock text-center"><div class="title">Fases de la Programación</div><div class="content"><pre>digraph G {
 Pseudocódigo -&gt; "Organigrama" -&gt; RTL -&gt; Ensamblador-&gt;Simulación;
 }</pre></div></div>
<div class="admonitionblock important"><table><tr><td class="icon"><i class="fa fa-exclamation-circle" title="Important"></i></td><td class="content">El paso de una descripción en un lenguaje de alto nivel a bajo nivel se realiza en lenguaje RTL teniendo en cuenta la arquitectura de la computadora donde se ejecutará el lenguaje máquina. Cada instrucción de alto nivel habrá que traducirla en un bloque de instrucciones de bajo nivel</td></tr></table></div>
<h level="3">Codificación Binaria-Hexadecimal</h><div class="ulist"><ul><li><p>Ejecutar el programa en lenguaje python:</p></li></ul></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code class="language-python" data-lang="python"># Tabla decimal-binario-hexadecimal

for i in range(256):
  print(str(i)+"  0b"+'{:b}'.format(i).zfill(8))
  print(str(i)+"  0b"+'{:9_b}'.format(i)+"  0x"+'{:_x}'.format(i))
  print()</code></pre></div></div>
<div class="ulist"><ul><li><p>los dígitos binarios son 2: el 0 y el 1</p></li><li><p>los dígitos hexadecimales son 16: 0-1-2-3-4-5-6-7-8-9-A-B-C-D-E-F. Que se corresponden con los valores 0-1-2-&#8230;&#8203; hasta el valor 15.</p></li><li><p>El valor 9 se representan en binario como 1001 donde el peso de cada dígito viene determinado por su posición: 2<sup>3</sup>, 2<sup>2</sup>, 2<sup>1</sup>, 2<sup>0</sup></p><div class="ulist"><ul><li><p>El valor del número 1001 es la suma ponderada del los digitos del número con su peso: 1*2<sup>3</sup>+0*2<sup>2</sup>+0*2<sup>1</sup>+1*2<sup>0</sup></p></li></ul></div></li><li><p>En hexadecimal</p><div class="ulist"><ul><li><p>el número 0xA tiene el valor 10, el 0xB 11, el 0xC 12</p></li><li><p>el número 0x10 tiene el valor 1*16<sup>1</sup>+0*16<sup>0</sup> = 16</p></li><li><p>el número 0xFD tiene el valor 15*16<sup>1</sup>+13*16<sup>0</sup> = 240+13 = 253</p></li></ul></div></li><li><p>Relación hexadecimal-binario</p><div class="ulist"><ul><li><p>el número 0xF6 se convierte en binario mediante la conversión de cada dígito hexadecimal en un grupo de 4 dígitos binarios. F (valor 15) en binario 1111 y 6 (valor 6) en binario 0110. Por lo que al número hexadecimal 0xF6 le corresponde el binario 0b11110110</p></li></ul></div></li><li><p>Ejemplos de números de 1 byte: decimal-binario-hexadecimal</p><div class="listingblock"><div class="content"><pre>16 0b0001_0000 0x10 17 0b0001_0001 0x11 18 0b0001_0010 0x12 19 0b0001_0011 0x13 20 0b0001_0100 0x14 21 0b0001_0101 0x15
22 0b0001_0110 0x16 23 0b0001_0111 0x17 24 0b0001_1000 0x18 25 0b0001_1001 0x19 26 0b0001_1010 0x1a 27 0b0001_1011 0x1b
28 0b0001_1100 0x1c 29 0b0001_1101 0x1d 30 0b0001_1110 0x1e 31 0b0001_1111 0x1f


192 0b1100_0000 0xc0 193 0b1100_0001 0xc1 194 0b1100_0010 0xc2 195 0b1100_0011 0xc3 196 0b1100_0100 0xc4 197 0b1100_0101 0xc5
198 0b1100_0110 0xc6 199 0b1100_0111 0xc7 200 0b1100_1000 0xc8 201 0b1100_1001 0xc9 202 0b1100_1010 0xca 203 0b1100_1011 0xcb
204 0b1100_1100 0xcc 205 0b1100_1101 0xcd 206 0b1100_1110 0xce 207 0b1100_1111 0xcf</pre></div></div></li></ul></div>
<h level="3">Ejemplo 1: sum1toN.ias</h><h level="4">Enunciado</h><div class="ulist"><ul><li><p>Calcular la suma \(\sum_{i=1}^{N}i=N(N+1)/2\)</p></li></ul></div>
<h level="4">Pseudocódigo</h><div class="ulist"><ul><li><p>Descripción del algoritmo mediante expresiones modo texto en lenguaje NATURAL</p></li><li><p>VARIABLES:</p><div class="ulist"><ul><li><p>variable suma : almacena los resultados parciales y final</p></li><li><p>variable N    : almacena el dato de entrada</p></li><li><p>variable i    : almacena el sumando que varía en cada iteración</p></li></ul></div></li><li><p>Estructura del CODIGO imperativo:</p><div class="ulist"><ul><li><p>La construcción de instrucciones básica es un bucle</p><div class="ulist"><ul><li><p>El bucle cuenta las iteraciones en sentido descendente</p></li><li><p>En cada iteración se genera un sumando "i" y se realiza la suma=suma+i</p></li><li><p>Se inicializa "i"=N y en cada iteración i=i-1</p></li><li><p>Se sale del bucle cuando i=-1</p></li></ul></div></li></ul></div></li></ul></div>
<h level="4">Organigrama</h><div class="imageblock text-center"><img src="./images/von_neumann/sum1toN_organigrama.png" alt="Diagrama de Flujo" /></div><div class="title">Figure 20. Organigrama: Diagrama de Flujo</div>
<h level="4">RTL</h><div class="ulist"><ul><li><p>Descripción RTL para la máquina IAS orientada a acumulador</p><div class="listingblock"><div class="content"><pre>;CABECERA
;Descripcion en lenguaje RTL del algoritmo sum1toN

;SECCION DATOS	:
; Declaracion de etiquetas, reserva de memoria externa, inicializacion
; Variables ordinarias
n:	M[n] 	&lt;- 5		; variable sumando e inicializacion
suma:	M[suma] &lt;- 0		; variable suma parcial y final

;SECCION INSTRUCCIONES
;Arquitectura orientada a Acumulador (AC)
;Registros accesibles : AC
	; inicio bucle : suma y generación de sumandos
bucle:	AC 	&lt;- M[n]		; cargar sumando
	AC&gt;=0 : PC &lt;- sumar	; si el sumando &lt; 0 fin del bucle y si es &gt;0 salto a sumar
	; fin del bucle
	stop
	; realizar la suma
sumar:  AC 	&lt;- AC + M[suma]
	M[suma] &lt;- AC
	; actualizar sumando
	AC 	&lt;- M[n]
	AC 	&lt;- AC - 1
	M[n]  	&lt;- AC
	; siguiente iteracion
	PC 	&lt;- bucle</pre></div></div></li></ul></div>
<h level="4">Lenguaje ensamblador WStalling de la máquina IAS</h><div class="ulist"><ul><li><p>Módulo fuente sum1toN.ws</p><div class="listingblock"><div class="content"><pre>; CABECERA
; 1ª version : sum1toN_v1.ias
; Calcula la suma de una secuencia de numeros enteros: suma = 1+2+..+n
; dato de entrada : n
; dato de salida  : suma
; Algoritmo : bucle de n iteraciones
;             Los sumandos se van generando en sentido descendente de n a 0
;             Se sale del bucle si el sumando es negativo -&gt; -1
; Estructuras de datos : variables n y suma . Constante uno.
; Lenguaje ensamblador: William Stalling
; Arquitectura de la máquina IAS de Von Neumann

;;;;;;;;;;;;;;;; SECCION DE INSTRUCCIONES
;Arquitectura orientada a Acumulador (AC)
;Registros accesibles : AC
; algoritmo: bucle que genera la secuencia n, n-1, n-2,...0,-1 si n&gt;=0
bucle:	LOAD 	M(n)       	; AC &lt;- M[n]
	JMP+    sumar		; Si AC &gt;= 0, salto a sumar
	; fin del bucle
	HALT			; stop

	; realizar la suma
sumar:  ADD	M(suma)         ; AC &lt;- AC+M(suma)
	STOR 	M(suma)		; M[suma] &lt;- AC
	; actualizar sumando
        LOAD 	M(n)       	; AC &lt;- M[n]
	SUB  	M(uno)     	; AC &lt;- AC-M[uno]
	STOR 	M(n)		; M[suma] &lt;- AC
	; comprobar condición bucle
	JMP    bucle		; salto incondiconal




;;;;;;;;;;;;;;;;;;;SECCION DE DATOS
; Declaracion de etiquetas, reserva de memoria externa, inicializacion.
; Variables ordinarias
n:	.data	5 ; variable sumando
uno:	.data	1 ; cte
suma:	.data	0 ; sumas parciales y resultado final</pre></div></div>
<div class="ulist"><ul><li><p>Se ha desarrollado la sección de datos para la reserva de memoria.</p></li><li><p>Se ha realizado un BUCLE SENCILLO ya que el bucle es la construcción necesaria en el algoritmo final.</p></li><li><p>Se ha realizado la operación RESTA ya que es una operación necesaria en el algoritmo final.</p></li><li><p>Se ha COMENTADO el código</p></li></ul></div></li></ul></div>
<h level="4">Lenguaje ensamblador iassim</h><div class="sidebarblock"><div class="content"><div class="paragraph"><p>El desarrollo del módulo fuente en lenguaje ensamblador NO se realiza de principio a fin sino que se va realizando <strong>POR PASOS</strong>, empezando por un código lo más sencillo posible que será testeado y depurado antes de ir desarrollando hasta llegar al código completo</p></div></div></div>
<div class="ulist"><ul><li><p>módulo fuente  <em>sum1toN_A.ias</em>:</p><div class="ulist"><ul><li><p>La 1ª versión implementa un bucle cuyo cuerpo únicamente almacena un dato en la variable suma. El dato varía en cada iteración.</p></li><li><p>Sintaxis &#8594; etiqueta: operacion operando ;comentario &#8594; 4 Columnas</p></li><li><p>Sólo puede haber etiquetas que apunten a instrucciones ubicadas al <strong>derecha</strong> de una palabra.</p></li><li><p>Los símbolos para indicar la operación (Ej. S(x)&#8594;Ac+) no son mnemónicos</p></li><li><p>No utilizar tildes ni en los comentarios ni en las etiquetas, ya que únicamente se admite código ASCII no extendido.</p></li><li><p>Si el número de instrucciones es impar se ha de rellenar la palabra de 40 bits de la última instrucción con los 20 bits de menor peso a cero para conseguir que el número de instrucciones del programa sea <strong>par</strong>: utilizar la directiva <strong>.empty</strong></p></li><li><p>La sección de instrucciones  debe de ir previamente a la sección de datos</p><div class="listingblock"><div class="content"><pre>; CABECERA
; Este código necesita ser DEPURADO
; 1ª version : sum1toN_A.ias
; Calcula la suma de una secuencia de numeros enteros: suma = 1+2+..+n
; dato de entrada : n
; dato de salida  : suma
; Algoritmo : bucle de n iteraciones
;             Los sumandos se van generando en sentido descendente de n a 0
;             Se sale del bucle si el sumando es negativo -&gt; -1
; Estructuras de datos : variables n y suma . Constante uno.
; Lenguaje ensamblador: IASSim
; Arquitectura de la máquina IAS de Von Neumann

;;;;;;;;;;;;;;;; SECCION DE INSTRUCCIONES
;Arquitectura orientada a Acumulador (AC)
;Registros accesibles : AC
; algoritmo: bucle que genera la secuencia n, n-1, n-2,...0,-1 si n&gt;=0
bucle:	S(x)-&gt;Ac+  n    	; AC &lt;- M[n]
	S(x)-&gt;Ah-  uno  	; AC &lt;- AC-M[uno]
	At-&gt;S(x)   suma		; M[suma] &lt;- AC
	Cc-&gt;S(x)   bucle	; Si AC &gt;= 0, salto a bucle
	; fin del bucle
	halt			; stop
	.empty

;;;;;;;;;;;;;;;;;;;SECCION DE DATOS
; Declaracion de etiquetas, reserva de memoria externa, inicializacion.
; Variables ordinarias
n:	.data	5 ; variable sumando
uno:	.data	1 ; cte
suma:	.data	0 ; sumas parciales y resultado final</pre></div></div></li><li><p>Se ha desarrollado la sección de datos para la reserva de memoria.</p></li><li><p>Se ha realizado un BUCLE SENCILLO ya que el bucle es la construcción necesaria en el algoritmo final.</p></li><li><p>Se ha realizado la operación RESTA ya que es una operación necesaria en el algoritmo final.</p></li><li><p>Se ha COMENTADO el código</p></li><li><p><strong>FALTA</strong>:</p><div class="ulist"><ul><li><p>añadir las instrucciones para salvar los operandos en la dirección de memoria "n" en cada iteracción del bucle</p></li><li><p>añadir las instrucciones para realizar la suma parcial en cada iteracción del bucle</p></li><li><p>Ver versión del programa en lenguaje RTL ():</p><div class="listingblock"><div class="content"><pre>SECCION INSTRUCCIONES
bucle:	AC 	&lt;- M[n]		; cargar sumando
	AC&gt;=0 : PC &lt;- sumar	; si el sumando &lt; 0 fin del bucle y si no salto a sumar
	stop
	; realizar la suma
sumar:  AC 	&lt;- AC + M[suma]
	M[suma] &lt;- AC
	; actualizar sumando
	AC 	&lt;- M[n]
	AC 	&lt;- AC - M[uno]
	M[n]  	&lt;- AC
	PC 	&lt;- bucle	; salto incondicional

SECCION DATOS
n:	5		; variable sumando e inicializacion
uno:	1		; variable sumando e inicializacion
suma:	0		; variable suma parcial y final</pre></div></div></li></ul></div></li></ul></div></li><li><p>Versión rectificada</p><div class="listingblock"><div class="content"><pre>; CABECERA
; Codigo rectificado
; Version : sum1toN_A.ias
; Calcula la suma de una secuencia de numeros enteros: suma = 1+2+..+n
; dato de entrada : n
; dato de salida  : suma
; Algoritmo : bucle de n iteraciones
;             Los sumandos se van generando en sentido descendente de n a 0
;             Se sale del bucle si el sumando es negativo -&gt; -1
; Estructuras de datos : variables n y suma . Constante uno.
; Lenguaje ensamblador: IASSim
; Arquitectura de la maquina IAS de Von Neumann

;;;;;;;;;;;;;;;; SECCION DE INSTRUCCIONES
;Arquitectura orientada a Acumulador (AC)
;Registros accesibles : AC
; algoritmo: bucle que genera la secuencia n, n-1, n-2,...0,-1 si n&gt;=0
bucle:	S(x)-&gt;Ac+  n    	; AC &lt;- M[n]
	Cc-&gt;S(x)   sumar	; si el sumando &lt; 0 fin del bucle y si no salto a sumar
	; fin del bucle
	halt			; stop
	.empty
	; realizar la suma
sumar:  S(x)-&gt;Ah+  suma         ; AC &lt;- AC + M[suma]
        At-&gt;S(x)   suma         ; suma &lt;- AC
; actualizar sumando
        S(x)-&gt;Ac+  n    	; AC &lt;- M[n]
        S(x)-&gt;Ah-  uno          ; AC &lt;- AC - M[uno]
        At-&gt;S(x)   n            ; n &lt;- AC
	Cu-&gt;S(x)   bucle        ; salto incondicional a la instrucción izda de bucle

;;;;;;;;;;;;;;;;;;;SECCION DE DATOS
; Declaracion de etiquetas, reserva de memoria externa, inicializacion.
; Variables ordinarias
n:	.data	5 ; variable sumando
uno:	.data	1 ; cte
suma:	.data	0 ; sumas parciales y resultado final</pre></div></div></li><li><p>Versión B</p><div class="listingblock"><div class="content"><pre>; Version : sum1toN_B.ias
; Calcula la suma de una secuencia de numeros enteros: suma = 1+2+..+n
loop:      S(x)-&gt;Ac+  n    ;load n into AC
           S(x)-&gt;Ah+  sum  ;add n to the sum
           At-&gt;S(x)   sum  ;put total back at sum
           S(x)-&gt;Ac+  n    ;load n into AC
           S(x)-&gt;Ah-  one  ;decrement n
           At-&gt;S(x)   n    ;store decremented n
           Cc'-&gt;S(x)  loop ;if AC &gt;= 0, jump to pos right instruction
           halt            ;otherwise done


n:       .data 5  ;will loop 6 times total
one:     .data 1  ;constant for decrementing n
sum:     .data 0  ;where the running/final total is kept</pre></div></div></li></ul></div>
<h level="4">Registros</h><div class="ulist"><ul><li><p>The IAS machine has 7 registers: Accumulator, Arithmetic Register / Multiplier-Quotient (AR/MQ), Control Counter, Control Register, Function Table Register, Memory Address Register, Selectron Register</p><div class="ulist"><ul><li><p>The Accumulator (<em>AC</em>) and Arithmetic registers (<em>AR/MQ</em>) are the only two programmer-visible registers</p></li><li><p>The Control Counter is what we now call the Program Counter <em>PC</em></p></li><li><p>The Control Register holds the currently executing instruction <em>IBR</em>. Unicamente la instrucción de la derecha que se va a ejecutar.</p></li><li><p>The Function Table Register holds the current opcode <em>IR</em></p></li><li><p>The Memory Address Register the current memory address <em>MAR</em></p></li><li><p>Selectron Register the current data value being read from or written to memory &#8594; <em>MBR</em></p></li></ul></div></li></ul></div>
<h level="4">Simulador IASSim</h><div class="ulist"><ul><li><p>Instrucciones de instalación y de funcionamiento del Simulador IASSim de la máquina IAS de Von Neumann en el <a href="#iassim_install">Apéndice</a></p></li></ul></div>
<h level="4">Notas</h><div class="ulist"><ul><li><p>Es necesario que el número de instrucciones sea par. Si es impar se añade la directiva <em>.empty</em>.</p></li><li><p>Una etiqueta debe de apuntar a la instrucción izda. Si está en la dcha se puede anteponer una instrucción de salto incondicional a dicha etiqueta.</p></li><li><p>La sección de datos si está a continuación de la sección de código hay que terminar la sección de código con una instrucción en la dcha y si no la rellenamos con la directiva <em>.empty</em>.</p></li></ul></div>
<h level="4">Error</h><div class="ulist"><ul><li><p>Error al visualizar el valor del registro MAR</p><div class="ulist"><ul><li><p>Al ejecutar la primera instrucción de sum1toN.ias el contenido de MAR es 28, mayor que el rango de direcciones de la memoria principal donde esta cargado el programa.</p></li><li><p>El error se da tanto en Windows 7 como en Ubuntu 17.04</p></li></ul></div></li></ul></div>
<h level="3">Ejemplos de Programas en Lenguaje IASSim</h><div class="ulist"><ul><li><p>Más ejemplos en el <a href="#iassim_ejemplos">Apéndice</a>.</p></li></ul></div></div></section><section id="_operación_de_la_máquina_ias_ruta_de_datos"><h2>2.6. Operación de la Máquina IAS: Ruta de Datos</h2><div class="slide-content"><div class="imageblock text-center" style="text-align: center"><img src="./images/von_neumann/ias_operation.png" alt="ias operation" /></div><div class="title">Figure 21. IAS Operation</div>
<div class="ulist"><ul><li><p>Operación de la máquina IAS:</p><div class="ulist"><ul><li><p>El ciclo de instrucción tiene dos FASES</p></li><li><p>La primera fase es común a todas las instrucciones.</p></li></ul></div></li><li><p>Ejemplos de instrucciones</p><div class="ulist"><ul><li><p>X: referencia del operando</p></li><li><p>AC &#8592; M(X)</p></li><li><p>GOTO M(X,0:19): salto incondicional a la dirección X. X apunta a dos instrucciones. X,0:19 es la referencia de la Instrucción de la izda.</p></li><li><p>If AC&gt;0 goto M(X,0:19): salto condicional</p></li><li><p>AC &#8592; AC+M(x).</p></li></ul></div></li></ul></div></div></section><section id="_conclusiones"><h2>2.7. Conclusiones</h2><div class="slide-content"><div class="olist arabic"><ol class="arabic"><li><p>Para la programación de bajo nivel es necesario conocer las principales características de la arquitectura ISA de la computadora: la Estructura de la computadora (memoria,registros,etc) , Formato de datos (formato complemento a 2,etc) e instrucciones y el Repertorio de Instrucciones (operaciones, modos de direccionamiento, etc ..)</p></li><li><p>La programación en lenguaje ensamblador no se realiza directamente en dicho lenguaje sino que se sigue una estrategia top-down comenzando por una descripción en lenguaje de pseudocódigo, organigrama, lenguaje RTL, etc</p></li><li><p>Es el diseño del repertorio de instrucciones ISA de la computadora el que facilita o dificulta la programación de bajo nivel. Un repertorio excesivamente limitado como la máquina IAS de von Neumann dificulta la realización de expresiones matemáticas tan sencillas como una multiplicación seguida de la división. La secuencia de instrucciones RTL deberá tener en cuenta el facilitar el desarrollo del algoritmo.</p></li><li><p>La programación del algoritmo en lenguaje ensamblador sigue una estrategia ascendente comenzando por una versión incompleta y lo más sencilla posible del programa a desarrollar.</p></li><li><p>Cada versión desarrollada del programa en lenguaje ensamblador ha de ser depurada y verificada mediante un simulador y un depurador que permita la ejecución en modo paso a paso para analizar resultados parciales.</p></li></ol></div></div></section></section>
<section><section id="_representación_de_los_datos"><h2>3. Representación de los Datos</h2></section><section id="_temario_3"><h2>3.1. Temario</h2><div class="slide-content"><div class="olist arabic"><ol class="arabic" start="3"><li><p>Representación de datos</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Bit, Byte y Palabra</p></li><li><p>Caracteres, enteros y reales</p></li></ol></div></li></ol></div></div></section><section id="_objetivo"><h2>3.2. Objetivo</h2><div class="slide-content"><div class="ulist"><ul><li><p>Representación de los datos alfanuméricos en el lenguaje máquina, es decir, código binario.</p></li><li><p>Libro de texto W.Stalling</p><div class="ulist"><ul><li><p>Parte 3ª, Capítulo 9 : Sistemas Numéricos</p></li></ul></div></li></ul></div></div></section><section id="_datos_e_instrucciones_codificación_binaria"><h2>3.3. Datos e Instrucciones: Codificación Binaria</h2><div class="slide-content"><div class="ulist"><ul><li><p>Un programa almacenado en la memoria principal se representa en <em>lenguaje máquina</em> y está compuesto por datos e instrucciones . El lenguaje de la máquina es el lenguaje binario formado por los símbolos <em>0</em> y <em>1</em>. Por lo tanto los datos e instrucciones de un programa almacenado en la memoria principal debe de codificarse y representarse mediante estos dos símbolos.</p></li><li><p>Los datos tienen un valor númerico que pueden ser procesados por la Unidad Aritmetico Lógica (ALU) para realizar operaciones aritméticas como la suma, resta, etc ó lógicas como las operaciones not,or,etc.</p></li><li><p>Los datos son secuencias de <em>0</em> y <em>1</em> almacenados en la memoria que son capturados por la CPU para ser procesados pej mediante operaciones aritméticas como la suma.</p></li><li><p>Las instrucciones son secuencias de <em>0</em> y <em>1</em> almacenados en la memoria que son capturados por la CPU para ser interpretados y proceder a su ejecución. Pej la instrucción "sumar" dos números enteros.</p></li></ul></div></div></section><section id="_bit_byte_palabra"><h2>3.4. Bit, Byte, Palabra</h2><div class="slide-content"><div class="ulist"><ul><li><p>BInary digiT (bit) : los dígitos binarios son el <em>0</em> y el <em>1</em>. Son los símbolos que se utilizan para codificar tanto las instrucciones como los datos de un programa almacenado en memoria.</p></li><li><p>Byte: Es una secuencia de 8 dígitos binarios. Ejemplo: 00110101</p></li><li><p>Palabra: Es una secuencia de dígitos binarios múltiplo de 8, es decir, múltiplo de un byte. En el entorno de arquitectura de computadores se define como el número de bits del bus de datos que conecta la unidad central de proceso (CPU) a la Memoria principal y también suele ser la anchura de los registros de propósito general de memoria interna de la CPU.</p><div class="ulist"><ul><li><p>En linux +sudo lshw -C system | more + &#8594; anchura: <strong>64 bits</strong></p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-sh" data-lang="sh">    lur
    descripción: Notebook
    producto: 20F1S0H400 (LENOVO_MT_20F1_BU_Think_FM_ThinkPad L560)
    fabricante: LENOVO
    versión: ThinkPad L560
    serie: MP15YSW7
    anchura: 64 bits
    capacidades: smbios-2.8 dmi-2.8 smp vsyscall32
    configuración: administrator_password=disabled chassis=notebook family=ThinkPad L560 power-on_password=disabled sku=LENOVO_MT_20F1_BU_Think_FM_ThinkPad L560 uuid=4C2F45AA-0A2C-B211-A85C-B5C56EB5BBAC</code></pre></div></div></li></ul></div></li></ul></div></div></section><section id="_números_enteros"><h2>3.5. Números Enteros</h2><div class="slide-content"><h level="3">Base Decimal</h><div class="ulist"><ul><li><p>Son representados mediante un Sistema Posicional basado en:</p><div class="ulist"><ul><li><p>Número en Base Decimal</p><div class="ulist"><ul><li><p>Representación mediante la combinación de diez Dígitos: 0,1,2,3,&#8230;&#8203;,9</p></li><li><p>Posición &#8594; índice</p></li><li><p>Pesos de cada posición&#8594; son potencias de la forma <em>10<sup>posición</sup></em> &#8594; &#8230;&#8203;,Centenas, decenas, unidades</p></li><li><p>Valor representado = sumatorio de digitos ponderados con su peso posicional</p></li><li><p>Ejemplo: Dada la representación 1197 de un número decimal entero, calcular su valor.</p><div class="listingblock"><div class="content"><pre>Posición        3       2       1       0
Peso         	10^3    10^2    10^1    10^0
             	1000    100     10      1
Digito	        1       1       9       7
Ponderación  	1*1000  1*100   9*10    7*1

Valor		1*1000+1*100+9*10+7*1=mil ciento noventa y siete.

La representación uno-uno-nueve-siete tiene el valor mil ciento noventa y siete</pre></div></div></li></ul></div></li></ul></div></li></ul></div>
<h level="3">Base Binaria</h><div class="ulist"><ul><li><p>Número codificado en Base 2</p><div class="ulist"><ul><li><p>Representación mediante la combinación de dos Dígitos: 0,1</p></li><li><p>Posición &#8594; índice</p></li><li><p>Pesos de cada posición&#8594; son potencias de la forma <em>2<sup>posición</sup></em> &#8594; &#8230;&#8203;2<sup>5</sup>,2<sup>4</sup>,2<sup>3</sup>,2<sup>2</sup>,2<sup>1</sup>,2<sup>0</sup>&#8230;&#8203;,64,32,16,8,4,2,1</p></li><li><p>Valor representado = sumatorio de digitos ponderados con su peso posicional</p></li><li><p>Ejemplo: Dada la representación 1010 de un número binario entero, calcular su valor.</p><div class="listingblock"><div class="content"><pre>Posición        3       2       1       0
Peso         	2^3   	2^2   	2^1     2^0
             	8    	4     	2       1
Dígitos         1       0       1       0
Ponderación     1*8     0*4     1*2     0*1

Valor		1*8+0*4+1*2+0*1 = diez

La representación uno-cero-uno-cero tiene el valor diez</pre></div></div></li></ul></div></li><li><p>La Rueda: representación y valor de los números sin signo con 3 bits.</p><div class="imageblock" style="text-align: center"><img src="./images/datos_representacion/rueda_unsigned.png" alt="rueda unsigned" /></div><div class="title">Figure 22. Representación Números sin Signo</div></li></ul></div>
<h level="3">Conversión Decimal-Binaria</h><div class="ulist"><ul><li><p>Divisiones sucesivas / 2 &#8594; Dividendo1 = 2*Cociente1 <em>+</em>  Resto1</p></li><li><p>Cociente1 = 2*Cociente2 <em>+</em> Resto2 &#8594; Dividendo1 = <em>2 * (2*Cociente2 + Resto2) + Resto1 = Resto1*2<sup>0</sup> + Resto2*2<sup>1</sup> +Cociente*2<sup>2</sup></em></p></li><li><p>Resto1 es el dígito binario de la posición 0, Resto2 es el digito binario de la posición 1, Cociente es el dígito binario de la posición 2.</p></li><li><p>Regla: los digitos binarios son todos los restos y el último cociente.</p></li><li><p>La división se termina cuando un cociente no es divisible por 2, es decir, el cociente es 1. Este cociente es el MSB.</p></li><li><p>Ejemplo: Valor 1197 &#8594; Calcular su representación en código binario &#8594; Solución: 10010101101</p><table class="tableblock frame-all grid-all" style="width:100%"><caption class="title">Table 4. Conversión decimal binario</caption><colgroup><col style="width:7.6923%" /><col style="width:7.6923%" /><col style="width:7.6923%" /><col style="width:7.6923%" /><col style="width:7.6923%" /><col style="width:7.6923%" /><col style="width:7.6923%" /><col style="width:7.6923%" /><col style="width:7.6923%" /><col style="width:7.6923%" /><col style="width:7.6923%" /><col style="width:7.6923%" /><col style="width:7.6924%" /></colgroup><thead><tr><th class="tableblock halign-left valign-top">Número</th><th class="tableblock halign-left valign-top" colspan="2">1ª Div</th><th class="tableblock halign-left valign-top" colspan="2">2ª Div</th><th class="tableblock halign-left valign-top" colspan="2">3ª Div</th><th class="tableblock halign-left valign-top" colspan="2">4ª Div</th><th class="tableblock halign-left valign-top" colspan="2">5ª Div</th><th class="tableblock halign-left valign-top" colspan="2">6ª Div</th></tr><tbody><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Coc</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Resto</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Coc</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Resto</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Coc</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Resto</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Coc</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Resto</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Coc</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Resto</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Coc</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Resto</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>1197</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>598</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>299</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>149</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>74</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>37</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>18</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td></tr></table></li></ul></div>
<table class="tableblock frame-all grid-all" style="width:100%"><colgroup><col style="width:11.1111%" /><col style="width:11.1111%" /><col style="width:11.1111%" /><col style="width:11.1111%" /><col style="width:11.1111%" /><col style="width:11.1111%" /><col style="width:11.1111%" /><col style="width:11.1111%" /><col style="width:11.1112%" /></colgroup><thead><tr><th class="tableblock halign-left valign-top">Número</th><th class="tableblock halign-left valign-top" colspan="2">7ª Div</th><th class="tableblock halign-left valign-top" colspan="2">8ª Div</th><th class="tableblock halign-left valign-top" colspan="2">9ª Div</th><th class="tableblock halign-left valign-top" colspan="2">10º Div</th></tr><tbody><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Coc</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Resto</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Coc</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Resto</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Coc</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Resto</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Coc</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Resto</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>1197</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>9</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>4</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>2</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td></tr></table>
<h level="3">Base Octal</h><div class="ulist"><ul><li><p>Base 8</p></li><li><p>Digitos: 0,1,2,3,4,5,6,7</p></li><li><p>Pesos: 8 elevado a la posición</p></li><li><p>En C se específica la base con el prefijo <em>0</em> &#8594; <code>int 077;</code></p></li><li><p>Conversión Octal &#8592;&#8594; Binario y viceversa &#8594; cada digito octal se descompone en un binario de 3 bits</p></li><li><p>decimal 1197 &#8594; Calcular su representación en código octal.</p><div class="ulist"><ul><li><p>solución a) binario 10010101101 &#8594; octal 02255</p></li><li><p>solución b) divisiones sucesivas por la base 8.</p></li></ul></div></li></ul></div>
<h level="4">Base Hexadecimal</h><div class="ulist"><ul><li><p>Base 16</p></li><li><p>Digitos: 0-1-2-3-4-5-6-7-8-9-A-B-C-D-E-F</p></li><li><p>Pesos: 16 elevado a a la posición</p></li><li><p>En C se específica la base con el prefijo <em>0x</em> &#8594; <code>int 0xAF;</code></p></li><li><p>Hexadecimal &#8592;&#8594; Binario y viceversa &#8594; cada digito hexadecimal se descompone en un binario de 4 bits</p></li><li><p>decimal 1197 &#8594; Calcular su representación en código hexadecimal</p></li><li><p>Solución a) binario 10010101101 &#8594; 0x4AD</p></li><li><p>Solución b) divisiones sucesivas por la base 16.</p></li></ul></div>
<h level="3">Calculadora</h><div class="ulist"><ul><li><p>Calculadora en el sistema Linux</p><div class="ulist"><ul><li><p><code>candido@lur:~$ echo "obase=2 ; ibase=16; 80AA010F" | bc</code></p><div class="ulist"><ul><li><p>10000000101010100000000100001111</p></li></ul></div></li><li><p><code>echo "obase=10 ; ibase=16; 80AA010F" | bc</code> &#8594; es obligado poner primero la base del formato de salida</p><div class="ulist"><ul><li><p>2.158.625.039</p></li></ul></div></li><li><p>Intérprete <code>$ bc</code></p></li></ul></div></li></ul></div>
<h level="3">Python</h><div class="ulist"><ul><li><p><a href="https://docs.python.org/3/tutorial/index.html" class="bare">https://docs.python.org/3/tutorial/index.html</a></p><div class="ulist"><ul><li><p>help(builtins)</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-python" data-lang="python">bin(1197) -&gt; '0b10010101101'
oct(1197) -&gt; '02255'
hex(1197) -&gt; '0x4ad'
int(0x4ad) -&gt; 1197</code></pre></div></div></li></ul></div></li></ul></div>
<h level="3">Enteros con Signo</h><div class="ulist"><ul><li><p>Se van a estudiar dos formatos: Signo-Magnitud y Complemento a 2, siendo este último el más extendido en las arquitecturas de los computadores.</p></li></ul></div>
<h level="4">Signo-Magnitud</h><div class="ulist"><ul><li><p>Formato Signo-Magnitud</p><div class="ulist"><ul><li><p>El bit más significativo no tiene valor, indica el signo: el cero para los números positivos y el uno para los negativos.</p></li><li><p>El resto de bits representa el módulo del número entero</p></li><li><p>Ejemplo :</p></li><li><p>Valor <em>+1197</em> &#8594; Representación 010010101101</p></li><li><p>Valor <em>-1197</em> &#8594; Representación 110010101101</p></li><li><p>¿Cómo se representa el valor cero?</p></li></ul></div></li></ul></div>
<h level="4">Complemento a 2</h><div class="ulist"><ul><li><p>Formato Complemento a 2.</p><div class="ulist"><ul><li><p>Positivos: Igual que el formato signo-magnitud: Bit MSB= 0. Pesos: potencia 2<sup>posición</sup>.</p><div class="ulist"><ul><li><p>More Significant Bit (MSB) &#8594; posición más elevado con valor distinto de cero.</p></li><li><p>Less Significant Bit (LSB)</p></li></ul></div></li><li><p>Negativos: Transformación del número con la misma magnitud pero positivo mediante la función Complemento a 2.</p></li></ul></div></li><li><p>La Rueda: representación y valor de los números con signo con 3 bits.</p><div class="imageblock" style="text-align: center"><img src="./images/datos_representacion/rueda_signed.png" alt="rueda signed" /></div><div class="title">Figure 23. Representación Complemento a 2</div>
<div class="ulist"><ul><li><p>N: cantidad de bits del número : 3  bits</p></li><li><p>Dividir la circunferencia en el número de combinaciones binarias posibles: 2<sup>N</sup> : 2<sup>3</sup></p></li><li><p>Pinto todas las combinaciones binarias en sentido agujas reloj de forma secuencial: 000,001,010,011,</p></li><li><p>Pinto los valores de forma alternante: <em>0, +1, -1, +2, -2,&#8230;&#8203;.</em></p></li><li><p>Ejercicio: Representar el número positivo <em>+4</em> en complemento a 2</p></li></ul></div></li><li><p>Conclusiones:</p><div class="ulist"><ul><li><p>Asimetría entre el rango positivo y negativo</p></li><li><p>El cero tiene una única representación</p></li><li><p>Los números negativos comienzan por <em>1</em></p></li><li><p>El valor -1 se codifica con todos los dígitos unos <em>111111111111111</em></p></li><li><p>Extensión de Signo: un 1 por la izda es como en los positivos un cero por la izda: no tiene valor y se puede eliminar la repetición de 1 por la izda dejando el último <em>1</em> de los más significativos. <em>11110111</em> es equivalente a <em>10111</em>.</p></li></ul></div></li><li><p><strong>Función Complemento a 2</strong>:  El complemento a 2 de un número entero equivale a cambiar su signo. La conversión entre números enteros positivos y negativos en complemento a 2 se puede realizar mediante distintos métodos.</p></li><li><p>Ejemplos de obtención del complemento a 2 del número entero binario X:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Método 1: Realizar la operación lógica complemento (negación) de X y sumar 1 &#8594; ~X+1</p><div class="ulist"><ul><li><p>X=0101 tiene valor <em>+5</em> en complemento a 2</p></li><li><p>¿El complemento a 2 de 0101? <em>~0101 + 1 = 1010 + 1 = 1011 = -5</em> &#8594; El valor del complemento a 2 equivale a cambiar de signo.</p></li><li><p>X=1111 tiene valor -1 en complemento a 2</p></li><li><p>¿El complemento a 2 de 1111? <em>~1111 + 1 = 0000 + 1 = 0001 = +1</em></p></li><li><p>X=0110011100010101010000 &#8594; positivo por tener el bit más significativo (MSB) cero</p></li><li><p>C2(X)=1001100011101010101111+1=1001100011101010110000 &#8594; negativo por tener el bit más significativo (MSB) uno</p></li></ul></div></li><li><p>Método 2: Empezando por la posición 0 del código X (bit X<sub>0</sub>) copiar todos los dígitos hasta llegar al primer dígito 1 y a partir de ahí negar todos los dígitos hasta el bit más significativo (MSB).</p><div class="ulist"><ul><li><p>X = 0110011100010101010000 &#8594; en total 22 bits</p></li><li><p>El primer dígito 1 de X está en la posición 4 &#8594; 01100111000101010-10000 &#8594; copio los 5 primeros digitos e invierto los 17 restantes</p></li><li><p>C2 (X) = 10011000111010101-10000</p></li></ul></div></li><li><p>Método 3: Realizar la operación aritmética 0-X</p><div class="ulist"><ul><li><p>X = 0110011100010101010000</p></li><li><p>0-X=0000000000000000000000 - 0110011100010101010000 = 1001100011101010110000</p></li></ul></div></li></ol></div></li><li><p>Ejemplos</p><div class="ulist"><ul><li><p>Representar el número entero negativo -1197 en signo-magnitud y en complemento a 2</p><div class="ulist"><ul><li><p><em>+1197</em> = 010010101101 tanto en signo-magnitud como complemento a 2</p></li><li><p><em>-1197</em> = 101101010011</p></li></ul></div></li><li><p>Calcular el rango de los números enteros con 8 bits en complemento a 2</p><div class="ulist"><ul><li><p>Código máximo positivo: 01111111 &#8594; Valor = 2<sup>7</sup>-1</p></li><li><p>Código mínimo negativo: 10000000</p><div class="ulist"><ul><li><p>C2(n=10000000) = 010000000 = 2<sup>7</sup> ,luego n=10000000 tiene el valor -2<sup>7</sup></p></li></ul></div></li><li><p>Rango [-2<sup>7</sup>,+2<sup>7</sup>-1]</p></li></ul></div></li></ul></div></li></ul></div></div></section><section id="_números_reales"><h2>3.6. Números Reales</h2><div class="slide-content"><h level="3">Coma Fija</h><div class="ulist"><ul><li><p>Números Reales en Coma Fija:</p><div class="ulist"><ul><li><p>1234.56789</p></li><li><p>Sistema Posicional</p><div class="ulist"><ul><li><p>posición de los dígitos fracción: -1,-2,-3,&#8230;&#8203;</p></li><li><p>pesos de los dígitos fracción: 10<sup>-1</sup>, 10<sup>-2</sup>, 10<sup>-3</sup></p></li><li><p>ponderación 1234.56789 = 1*10<sup>3</sup>+2*10<sup>2</sup>+3*10<sup>1</sup>+4*10<sup>0</sup>+5*10<sup>-1</sup>+6*10<sup>-2</sup>+7*10<sup>-3</sup>+8*10<sup>-4</sup>+9*10<sup>-5</sup></p></li></ul></div></li></ul></div></li><li><p>Base Binaria</p><div class="ulist"><ul><li><p>1010.101 &#8594;  1*2<sup>3</sup>+0*2<sup>2</sup>+0*2<sup>1</sup>+1*2<sup>0</sup>+1*2<sup>-1</sup>+0*2<sup>-1</sup>+1*2<sup>-2</sup> &#8594; 10.625</p></li></ul></div></li></ul></div>
<h level="3">Coma Flotante</h><h level="4">Formato</h><div class="ulist"><ul><li><p>Coma Flotante &#8594;  Notación científica</p><div class="ulist"><ul><li><p>-23.4567E-34 ó -23.4567*10<sup>-34</sup></p></li><li><p>La <strong>mantisa</strong> o <strong>significando</strong> es el número que múltiplica a la potencia &#8594; -23.4567</p></li><li><p>Mantisa <strong>normalizada</strong> : La mantisa tiene como parte entero un número entero de un dígito distinto de cero.&#8594; -2.34567*10<sup>-33</sup></p><div class="ulist"><ul><li><p>parte entera de la mantisa normalizada : 2</p></li><li><p>parte fracción de la mantisa normalizada : 0.34567</p></li></ul></div></li><li><p>El <strong>exponente</strong> es el número entero al que se eleva la base de la potencia. Depende del lugar de la coma en la mantisa. En este caso es -33.</p></li><li><p>La <strong>base</strong> es la base de la potencia. En este ejemplo es 10.</p></li></ul></div></li><li><p>Codificación Binaria</p><div class="ulist"><ul><li><p>Ejemplo:  1234.56789</p><div class="ulist"><ul><li><p>Parte Entera: 1234 &#8594; 10011010010</p></li><li><p>Parte Fracción: 0.56789</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-scala" data-lang="scala">0.56789 * 2 = 1.13578 = 1 + 0.13578 -&gt; 1, bit de la posición -1
0.13578 * 2 = 0.27156 -&gt; 0, bit de la posición -2
0.27156 * 2 = 0.54312 -&gt; 0,  bit de la posición -3
0.54312 * 2 = 1.08624 = 1 + 0.08624 -&gt; 1, bit de la posición -4</code></pre></div></div>
<div class="ulist"><ul><li><p>fracción redondeada 0.1001</p></li><li><p>fracción sin redondear 0.10010001011000010</p></li><li><p>fracción redondeada 0.100100011</p></li></ul></div></li><li><p>Código Binario coma fija: 10011010010.10010001011000010</p></li><li><p>Notación científica: 1.001101001010010001011000010*2<sup>+10</sup> &#8594; coma flotante &#8594; la parte entera siempre vale 1.</p></li></ul></div></li></ul></div></li></ul></div>
<h level="4">Precisión</h><div class="ulist"><ul><li><p>Es el  número de digitos significantes</p></li><li><p>Se dice que el número q es una aproximación del número p != 0 con una precisión de, al menos, <strong>m</strong> cifras signficativas en la base b, siempre que el error relativo |p-q|/p &#x2264; 0.5*b<sup>-m+1</sup></p><div class="ulist"><ul><li><p>Cuando m es el mayor entero para el que se cumple la desigualdad anterior, se dice que q aproxima a p con m cifras signficativas.</p></li></ul></div></li><li><p>Ejemplo</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>p = 1E0 y q = .9999E0 &#8594; Error relativo=0.1E-3&lt;0.5E(-4+1) &#8594; precisión de 4 cifras significativas</p></li><li><p>Una calculadora, A, trabaja en base 2 con mantisa de 22 bits y otra, B, trabaja en base 16 con 6 dígitos de precision (24 bits). ¿Cuál de las dos es más precisa?</p></li></ol></div></li></ul></div>
<h level="4">Norma IEEE-Standard 754</h><div class="ulist"><ul><li><p>Float</p><div class="ulist"><ul><li><p>Norma IEEE-Standard 754</p><div class="ulist"><ul><li><p>Precisión simple &#8594; formato de longitud 32 bits en 3 campos <em>Signo/Exponente/Fraccción</em> de longitudes 1/8/23 bits</p><div class="listingblock"><div class="content"><pre>  1      8bits              23bits                       &lt;-- tamaño en bits
 +-+-------------+------------------------------------+
 |S|  Exp + 127  | Fracción de la Mantisa  Normalizada|
 +-+-------------+------------------------------------+
 31 30         23 22                                 0   &lt;-- índice del bit (0 a la derecha)</pre></div></div></li><li><p>Precisión doble  &#8594; formato de longitud 64 bits en 3 campos <em>Signo/Exponente/Fraccción</em> de longitudes 1/11/52 bits</p><div class="listingblock"><div class="content"><pre>  1      11bits              52bits            &lt;-- tamaño en bits
 +-+-------------+-----------------------+
 |S|  Exp + 1023 | Fracción Mantisa  Norm|
 +-+-------------+-----------------------+
 63 62         52 51                     0   &lt;-- índice del bit (0 a la derecha)</pre></div></div></li><li><p><a href="http://sandbox.mc.edu/~bennet/cs110/flt/dtof.html">conversion manual</a></p></li><li><p><a href="http://en.wikipedia.org/wiki/Floating_point">wiki</a></p></li><li><p>Binario: Tres campos</p><table class="tableblock frame-topbot grid-all" style="width:80%"><colgroup><col style="width:14.2857%" /><col style="width:28.5714%" /><col style="width:57.1429%" /></colgroup><tbody><tr><td class="tableblock halign-center valign-top"><p class="tableblock"><code>Signo</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>Exponente en Exceso</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>Fracción de la Mantisa Normalizada</code></p></td></tr></table></li></ul></div></li><li><p>Valor (-1)<sup>Signo</sup> x 1.Fracción_Mantisa_Normalizada x 2<sup>Exponente</sup></p><div class="ulist"><ul><li><p>Signo: positivo -&#8594; bit <em>0</em> , negativo --&#8594;bit <em>1</em></p></li><li><p>Exponente en exceso: Es el Exponente al que se añade 127 (precisión simple) ó 1023 (precisión doble)</p></li><li><p>Mantisa Normalizada: Es la mantisa tal que su parte entera es <em>1</em></p><div class="ulist"><ul><li><p>Fracción de la Mantisa Normalizada: Es la fracción de la mantisa normalizada.</p></li></ul></div></li></ul></div></li></ul></div></li></ul></div>
<h level="4">Conversores de Código</h><div class="ulist"><ul><li><p>Conversores online:</p><div class="ulist"><ul><li><p><a href="http://www.binaryconvert.com/index.html">binary converter</a>: tipos char,short,int,float,double</p></li><li><p><a href="http://www.zator.com/Cpp/E2_2_4a1.htm">conversor ieee754</a></p></li><li><p><a href="http://www.h-schmidt.net/FloatConverter/IEEE754.html">IEEE 754 single precision</a>: decimal &#8594; binario/hexadecimal y viceversa</p></li></ul></div></li></ul></div>
<h level="4">Float Point: Representaciión del Cero,Infinito e Indeterminado</h><div class="ulist"><ul><li><p>Cuando el campo del exponente son todo ceros o unos, no se sigue la regla general de un número normalizado</p><table class="tableblock frame-all grid-all" style="width:80%"><caption class="title">Table 5. Single precision</caption><colgroup><col style="width:33.3333%" /><col style="width:33.3333%" /><col style="width:33.3334%" /></colgroup><thead><tr><th class="tableblock halign-center valign-top">Números</th><th class="tableblock halign-center valign-top">Exp</th><th class="tableblock halign-center valign-top">Fracción</th></tr><tbody><tr><td class="tableblock halign-center valign-top"><p class="tableblock"><code>Ceros</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x00</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>0</code></p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock"><code>Números desnormalizados</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x00</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>distinto de 0</code></p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock"><code>Números normalizados</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x01-0xFE</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>cualquiera</code></p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock"><code>Infinitos</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>0xFF</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>0</code></p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock"><code>NaN (Not a Number)</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>0xFF</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>distinto de 0</code></p></td></tr></table></li><li><p>Cero</p><div class="ulist"><ul><li><p>Por qué el cero se representa en single precision como una secuencia de 32 ceros</p></li><li><p>Por qué cuando el campo del exponente es cero la potencia es 2<sup>-126</sup> en lugar de 2<sup>-127</sup> y la mantisa se considera NO normalizada, es decir, 0.fracción en lugar de 1.fracción.</p></li></ul></div></li><li><p><a href="http://www.cs.umd.edu/class/sum2003/cmsc311/Notes/Data/float.html">Notas Maryland</a></p></li><li><p>Infinito</p></li></ul></div>
<h level="4">Referencia</h><div class="ulist"><ul><li><p><a href="http://people.ds.cam.ac.uk/nmm1/arithmetic/na1.pdf">numerical analysis</a>: programas ejemplo sencillos</p></li><li><p><a href="http://grouper.ieee.org/groups/754/">IEEE</a></p></li><li><p><a href="http://www.cs.berkeley.edu/~wkahan/">William Kahan</a></p></li><li><p><a href="http://www.cs.yale.edu/homes/aspnes/pinewiki/C%282f%29FloatingPoint.html">Yale</a>: C programming. float.c.</p></li><li><p><a href="https://randomascii.wordpress.com/category/floating-point/">Bruce Dawson blog</a></p><div class="ulist"><ul><li><p><a href="https://randomascii.wordpress.com/2012/01/11/tricks-with-the-floating-point-format/" class="bare">https://randomascii.wordpress.com/2012/01/11/tricks-with-the-floating-point-format/</a></p></li></ul></div></li><li><p><a href="https://en.wikipedia.org/wiki/IEEE_floating_point">wikipedia</a></p><div class="ulist"><ul><li><p><a href="http://www.validlab.com/goldberg/paper.pdf" class="bare">http://www.validlab.com/goldberg/paper.pdf</a></p><div class="ulist"><ul><li><p><a href="https://hal.archives-ouvertes.fr/hal-00128124v5/document">The pitfalls of verifying
oating-point computations</a></p></li><li><p><a href="http://arxiv.org/pdf/cs/0701192.pdf">el mismo?</a></p></li></ul></div></li></ul></div></li><li><p><a href="http://www.cprogramming.com/tutorial/floating_point/understanding_floating_point_representation.html">cprogramming</a></p></li><li><p><a href="http://www.codeproject.com/Articles/29637/Five-Tips-for-Floating-Point-Programming">code tips</a></p></li><li><p><a href="https://www.cs.princeton.edu/courses/archive/fall09/cos323/precepts/precept2.html">c review</a>: practicas</p></li></ul></div></div></section><section id="_character_type"><h2>3.7. Character Type</h2><div class="slide-content"><h level="3">ASCII</h><div class="ulist"><ul><li><p>Codificación ASCII</p><div class="ulist"><ul><li><p>American Standard Code International Intechange: codificación con 7 bits : rango 0x00-0x7F</p></li><li><p>Tabla de conversión carácter-código_hexadecimal-código binario</p><div class="ulist"><ul><li><p><code>man ascii</code></p></li><li><p>K.N. King,Apéndice E, pg801</p><table class="tableblock frame-topbot grid-all" style="width:50%"><colgroup><col style="width:33.3333%" /><col style="width:33.3333%" /><col style="width:33.3334%" /></colgroup><thead><tr><th class="tableblock halign-left valign-top">Caracter</th><th class="tableblock halign-center valign-top">ASCII hex</th><th class="tableblock halign-left valign-top">Control (Secuencia de Escape)</th></tr><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>0</strong></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x30</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>1</strong></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x31</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>a</strong></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x61</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>A</strong></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x41</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>+</strong></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x2B</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>^J</strong></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x0A</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>nueva línea (\n)</strong></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>^M</strong></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x0D</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>retorno de carro (\r)</strong></p></td></tr></table></li></ul></div></li><li><p>fijarse la relación del código entre J y ^J, entre M y ^M&#8230;&#8203;</p></li></ul></div>
<div class="literalblock"><div class="content"><pre>C program '\X' escapes are noted.

       Oct   Dec   Hex   Char                        Oct   Dec   Hex   Char
       ────────────────────────────────────────────────────────────────────────
       000   0     00    NUL '\0'                    100   64    40    @
       001   1     01    SOH (start of heading)      101   65    41    A
       002   2     02    STX (start of text)         102   66    42    B
       003   3     03    ETX (end of text)           103   67    43    C
       004   4     04    EOT (end of transmission)   104   68    44    D
       005   5     05    ENQ (enquiry)               105   69    45    E
       006   6     06    ACK (acknowledge)           106   70    46    F
       007   7     07    BEL '\a' (bell)             107   71    47    G
       010   8     08    BS  '\b' (backspace)        110   72    48    H
       011   9     09    HT  '\t' (horizontal tab)   111   73    49    I
       012   10    0A    LF  '\n' (new line)         112   74    4A    J
       013   11    0B    VT  '\v' (vertical tab)     113   75    4B    K
       014   12    0C    FF  '\f' (form feed)        114   76    4C    L
       015   13    0D    CR  '\r' (carriage ret)     115   77    4D    M
       016   14    0E    SO  (shift out)             116   78    4E    N
       017   15    0F    SI  (shift in)              117   79    4F    O
       020   16    10    DLE (data link escape)      120   80    50    P
       021   17    11    DC1 (device control 1)      121   81    51    Q
       022   18    12    DC2 (device control 2)      122   82    52    R
       023   19    13    DC3 (device control 3)      123   83    53    S
       024   20    14    DC4 (device control 4)      124   84    54    T
       025   21    15    NAK (negative ack.)         125   85    55    U
       026   22    16    SYN (synchronous idle)      126   86    56    V
       027   23    17    ETB (end of trans. blk)     127   87    57    W
       030   24    18    CAN (cancel)                130   88    58    X
       031   25    19    EM  (end of medium)         131   89    59    Y
       032   26    1A    SUB (substitute)            132   90    5A    Z
       033   27    1B    ESC (escape)                133   91    5B    [
       034   28    1C    FS  (file separator)        134   92    5C    \  '\\'
       035   29    1D    GS  (group separator)       135   93    5D    ]
       036   30    1E    RS  (record separator)      136   94    5E    ^
       037   31    1F    US  (unit separator)        137   95    5F    _
       040   32    20    SPACE                       140   96    60    `
       041   33    21    !                           141   97    61    a
       042   34    22    "                           142   98    62    b
       043   35    23    #                           143   99    63    c
       044   36    24    $                           144   100   64    d
       045   37    25    %                           145   101   65    e
       046   38    26    &amp;                           146   102   66    f
       047   39    27    ´                           147   103   67    g
       050   40    28    (                           150   104   68    h
       051   41    29    )                           151   105   69    i
       052   42    2A    *                           152   106   6A    j
       053   43    2B    +                           153   107   6B    k
       054   44    2C    ,                           154   108   6C    l
       055   45    2D    -                           155   109   6D    m
       056   46    2E    .                           156   110   6E    n
       057   47    2F    /                           157   111   6F    o
       060   48    30    0                           160   112   70    p
       061   49    31    1                           161   113   71    q
       062   50    32    2                           162   114   72    r
       063   51    33    3                           163   115   73    s
       064   52    34    4                           164   116   74    t
       065   53    35    5                           165   117   75    u
       066   54    36    6                           166   118   76    v
       067   55    37    7                           167   119   77    w
       070   56    38    8                           170   120   78    x
       071   57    39    9                           171   121   79    y
       072   58    3A    :                           172   122   7A    z
       073   59    3B    ;                           173   123   7B    {
       074   60    3C    &lt;                           174   124   7C    |
       075   61    3D    =                           175   125   7D    }
       076   62    3E    &gt;                           176   126   7E    ~
       077   63    3F    ?                           177   127   7F    DEL</pre></div></div></li><li><p>ASCII Extendido</p><div class="ulist"><ul><li><p><a href="https://en.wikipedia.org/wiki/Extended_ASCII#ISO_8859_and_proprietary_adaptations" class="bare">https://en.wikipedia.org/wiki/Extended_ASCII#ISO_8859_and_proprietary_adaptations</a></p></li><li><p><code>man iso_8859_1</code>: latin-1: ascii extendido: 0x80-0xFF</p></li><li><p><code>man iso_8859-1 | grep ñ</code></p></li><li><p><a href="http://www.theasciicode.com.ar/ascii-printable-characters/vertical-bar-vbar-vertical-line-vertical-slash-ascii-code-124.html" class="bare">http://www.theasciicode.com.ar/ascii-printable-characters/vertical-bar-vbar-vertical-line-vertical-slash-ascii-code-124.html</a></p><div class="ulist"><ul><li><p>El linux pulsar ctrl-Shift-u-ascii_code Enter</p></li><li><p>Ejemplo: el código extendido de la <em>ñ</em> es 0xF1 &#8594; C-S-u-f1 Enter&#8594; C-S-u simultáneo y aparece la u esperando al código, F-1-enter</p></li></ul></div></li><li><p><a href="http://www.mauvecloud.net/charsets/CharCodeFinder.html">ascii code finder</a></p></li><li><p>&#x30;</p></li><li><p>&#x7e;</p></li><li><p>&#xac;</p></li><li><p>&#xf1;</p></li></ul></div></li></ul></div>
<h level="3">Python</h><div class="ulist"><ul><li><p>ejemplos de conversión</p><div class="ulist"><ul><li><p><code>python</code></p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-python" data-lang="python">ord('A')
hex(ord('A'))
hex(ord('\n'))
chr(65)
chr(0x41)
[hex(ord(c)) for c in "Hola"]
[chr(c) for c in [0x48, 0x6f, 0x6c, 0x61, 0x20, 0x4d, 0x75, 0x6e, 0x64, 0x6f]]
[hex(ord(c)) for c in "ñ"]
[hex(ord(c)) for c in "\n \t"]</code></pre></div></div></li></ul></div></li></ul></div>
<h level="3">Unicode UTF-8</h><div class="ulist"><ul><li><p><a href="https://www.unicode.org/main.html">Unicode Main</a></p></li><li><p>Unicode Transformation Format (UTF)</p></li><li><p>Unicode: Unicode can be implemented by different character encodings. The Unicode standard defines Unicode Transformation Formats (UTF): UTF-8, UTF-16, and UTF-32, and several other encodings. The most commonly used encodings are UTF-8, UTF-16, and the obsolete UCS-2 (a precursor of UTF-16 without full support for Unicode)</p></li><li><p>Unicode encoded: <a href="https://www.unicode.org/versions/Unicode14.0.0/ch02.pdf#G25564" class="bare">https://www.unicode.org/versions/Unicode14.0.0/ch02.pdf#G25564</a></p><div class="ulist"><ul><li><p>Se describe con el prefijo U+ seguido de un número entero (integers from 0 to 0x10FFFF). Al código se le llama <strong>code point"</strong></p></li></ul></div></li><li><p>UTF-8:</p><div class="ulist"><ul><li><p>The dominant encoding on the World Wide Web and on most Unix-like operating systems</p></li><li><p>Uses one byte[note 1] (8 bits) for the first 128 code points, and up to 4 bytes for other characters. The first 128 Unicode code points represent the ASCII characters, which means that any ASCII text is also a UTF-8 text.</p></li><li><p>La <em>ñ</em> da como salida 0xc3b1 . El terminal está configurado con salida Unicode UTF-8 según la variable de entorno local. Mediante el comando <strong>locale charmap</strong>  volcamos con que codificación tenemos la entrada/salida del terminal. Mediante <code>locale -m</code> los posibles. Podría haber sido iso-8859-1 (ascii extendido) en lugar de utf8.</p></li></ul></div></li><li><p><code>localectl status</code> &#8594; codificación de entrada del teclado</p><div class="listingblock"><div class="content"><pre>  System Locale: LANG=eu_ES.UTF-8
                  LANGUAGE=eu_ES:eu:en_GB:en
       VC Keymap: n/a
      X11 Layout: es
       X11 Model: pc105</pre></div></div></li><li><p><a href="http://www.utf8-chartable.de/unicode-utf8-table.pl?number=1024">utf8</a>:</p><div class="ulist"><ul><li><p>8-bit Unicode Transformation Format</p></li><li><p>Usa símbolos de longitud variable (de 1 a 4 bytes por carácter Unicode).</p></li><li><p>Esta orientado a la transmisión de palabras de 1 byte.</p></li><li><p><a href="http://www.fileformat.info/info/unicode/char/f1/index.htm">unicode ñ</a></p></li><li><p>la ñ tiene <strong>unicode point <em>U+00F1</em></strong> ó <strong>hex_code_utf8 <em>0xC3B1</em></strong></p><div class="ulist"><ul><li><p>en la wikipedia utf-8 explica cómo pasar de unicode point a hex code.</p></li><li><p><a href="https://unicode-table.com/es/00F1/" class="bare">https://unicode-table.com/es/00F1/</a></p></li></ul></div></li><li><p>Problema para copiar los caracteres no US-ASCII de la barra URL de firefox: <a href="https://es.wikipedia.org/wiki/Conmutaci%C3%B3n_de_circuitos" class="bare">https://es.wikipedia.org/wiki/Conmutaci%C3%B3n_de_circuitos</a>. &#8594; C3B3 es el código hexadecimal del código utf-8 del carácter ó.</p></li><li><p>wikipedia utf-8:</p><div class="ulist"><ul><li><p>desglose de códigos según 1byte,2byte,3 byte, 4 bytes.</p></li><li><p>cómo se mapea el unicode code point del utf-8 a hexadecimal</p></li></ul></div></li><li><p><code>man utf-8</code></p></li></ul></div></li><li><p><code>showkey -a</code> : espera a pulsar una letra y visualizará el código de la letra pulsada en la codificación de entrada del sistema operativo.</p><div class="ulist"><ul><li><p>El código de los caracteres del ASCII standard (7bits) coincide con el UTF8 pero no así para el resto de caracteres ASCII extendido.</p></li><li><p>útil para descubrir el código de cada carácter en ascii standard y  el de caracteres ñ, á, é, í, ó, ú si en el código en que el sistema esté configurado (UTF8)</p></li><li><p>útil para descubri el código de control de combinaciones Ctrl-C, CR, Ctrl-CR, Ctrl-D</p><div class="literalblock"><div class="content"><pre>\ 	 92 0134 0x5c   -&gt; tecla ESC: escape
^J 	 10 0012 0x0a   -&gt; teclas Ctrl-CR: Salto de línea
^M 	 13 0015 0x0d   -&gt; tecla CR: Retorno de Carro
^C 	  3 0003 0x03   -&gt; teclas Ctrl-c
^D 	  4 0004 0x04   -&gt; teclas Ctrl-d
ñ       195 0303 0xc3   -&gt; MSB: More Significand Byte.
 	177 0261 0xb1   -&gt; LSB: Less Significand Byte
        hex_code_utf8   -&gt; 0xC3B1</pre></div></div></li><li><p>UPNA &#8594; 0x55-0x50-0x4e-0x41-0x00 donde 0x00 es el caracter NUL de fin de cadena.</p></li></ul></div></li><li><p>Documentos HTML</p><div class="ulist"><ul><li><p>ñ &#8594; &amp;#x00F1 &#8594; utiliza el código "unicode point"</p></li></ul></div></li><li><p>URL &#8594; en la barra de direcciones de un navegador poner camión &#8594; enter</p><div class="ulist"><ul><li><p>copiar la URL y copiarla en una nueva barra &#8594; <a href="https://www.google.com/search?channel=fs&amp;client=ubuntu&amp;q=cami%C3%B3n" class="bare">https://www.google.com/search?channel=fs&amp;client=ubuntu&amp;q=cami%C3%B3n</a></p></li><li><p>%C3%B3 es el UTF-8 hex_code de ó</p></li></ul></div></li><li><p>Sistema operativo : variables del entorno</p><div class="ulist"><ul><li><p><code>env | grep LC_</code></p></li></ul></div></li><li><p><a href="http://www.unicode.org/charts/">Unicode chart</a></p><div class="ulist"><ul><li><p>Colocando el puntero sobre la categoría se visualiza el rango hexadecimal del charset</p></li><li><p>Symbols Punctuation:</p><div class="ulist"><ul><li><p>Punctuation: ASCII Punctuation: <a href="http://www.unicode.org/charts/PDF/U0000.pdf">U0000.pdf</a></p></li><li><p>Find chart by hex code: 278a</p></li><li><p>Pictographs: Dingbats: x278a &#8594; &#x278a; &#8594; <a href="http://www.unicode.org/charts/PDF/U2700.pdf">U2700.pdf</a></p></li><li><p>Mathematical symbols: Mathematical Operators:</p><div class="ulist"><ul><li><p><a href="https://en.wikipedia.org/wiki/Mathematical_operators_and_symbols_in_Unicode">wikipedia</a></p></li><li><p><a href="http://www.unicode.org/charts/PDF/U2200.pdf">U2200</a>: Mathematical Operators Range: 2200–22FF</p></li><li><p>U+2228 &#8594; hexadecimal x2228 &#8594; &#x2228; ó en decimal 8744 &#8744;</p></li><li><p>U+22BC &#8594; x22bc &#8594; &#x22bc;</p></li><li><p>U+22BD &#8594; x22bd &#8594; &#x22bd;</p></li><li><p>U+22A6 &#8594; x22a6 &#8594; &#x22a6;</p></li></ul></div></li></ul></div></li><li><p>otros</p><div class="ulist"><ul><li><p>x1f60b &#8594; &#x1f60b;</p></li><li><p>U+00F1 &#8594; x00f1  &#8594; &#x00f1;</p></li><li><p>241    &#8594; &#241;</p></li><li><p>x2190 &#8594; &#x2190;</p></li><li><p>x2192 &#8594; &#x2192;</p></li></ul></div></li></ul></div></li><li><p><a href="https://wiki.mozilla.org/Help:Special_characters#Unicode" class="bare">https://wiki.mozilla.org/Help:Special_characters#Unicode</a></p></li><li><p><a href="http://www.fileformat.info/info/unicode/char/305/index.htm">info detallada sobre un caracter unicode</a>: Pej U+0305</p></li><li><p><a href="https://support.office.com/en-us/article/Insert-ASCII-or-Unicode-Latin-based-symbols-and-characters-d13f58d3-7bcb-44a7-a4d5-972ee12e50e0">Microsoft Office</a></p></li><li><p><a href="https://en.wikipedia.org/wiki/Overline">Overline o suprarayado</a></p><div class="ulist"><ul><li><p>LibreOffice has direct support for several styles of overline in its <code>Format / Character / Font Effects" dialog: suprarayado</code></p></li></ul></div></li></ul></div></div></section><section id="_iso_8859_1"><h2>3.8. ISO-8859-1</h2><div class="slide-content"><div class="ulist"><ul><li><p>Alternativa a UTF-8 para el alfabeto latino</p></li><li><p><a href="https://es.wikipedia.org/wiki/ISO/IEC_8859-1" class="bare">https://es.wikipedia.org/wiki/ISO/IEC_8859-1</a></p><div class="ulist"><ul><li><p>Sólo utiliza 1 byte , por lo tanto es equivalente al ascii extended.</p></li><li><p>La norma ISO/IEC 8859-15 consistió en una revisión de la ISO 8859-1, incorporando el símbolo del Euro</p></li></ul></div></li><li><p><code>man iso_8859-1</code></p></li><li><p>La "ñ" tiene el código 0xF1</p></li></ul></div>
<h level="3">Programación en C</h><div class="ulist"><ul><li><p>Convertir un carácter numérico en su valor entero</p><div class="ulist"><ul><li><p>Mediante una operación aritmética</p></li></ul></div></li><li><p>Convertir un carácter minúscula en mayúscula</p><div class="ulist"><ul><li><p>Mediante una operación aritmética</p></li></ul></div></li></ul></div>
<h level="3">Otros</h><div class="ulist"><ul><li><p><a href="https://www.gnu.org/software/coreutils/manual/html_node/printf-invocation.html">Lenguaje C: printf</a></p><div class="ulist"><ul><li><p><code>locale -a</code> &#8594; C.UTF8</p></li><li><p>ñ &#8594; <code>env printf <em>\u00f1  \n</em></code> : incluir las simples comillas</p><div class="ulist"><ul><li><p><a href="http://www.gnu.org/software/coreutils/manual/html_node/printf-invocation.html#printf-invocation">printf invocation</a></p></li></ul></div></li></ul></div></li></ul></div></div></section></section>
<section><section id="_operaciones_aritmeticas_y_logicas"><h2>4. Operaciones Aritmeticas y Logicas</h2></section><section id="_temario_4"><h2>4.1. Temario</h2><div class="slide-content"><div class="olist arabic"><ol class="arabic"><li><p>Aritmética y lógica</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Operaciones aritméticas y lógicas sobre enteros en binario</p></li><li><p>Redondeo y propagación de error en números reales</p></li></ol></div></li></ol></div></div></section><section id="_objetivo_2"><h2>4.2. Objetivo</h2><div class="slide-content"><div class="ulist"><ul><li><p>Operaciones aritméticas de suma y resta con números naturales y enteros representados en código binario.</p></li><li><p>Operaciones lógicas de datos representados en código binario.</p></li><li><p>Libro de texto</p><div class="ulist"><ul><li><p>Parte 3ª, Capítulo 10 : Aritmética del Computador</p></li></ul></div></li></ul></div></div></section><section id="_introduccion"><h2>4.3. Introduccion</h2><div class="slide-content"><div class="ulist"><ul><li><p>La Unidad Aritmetico Lógica (ALU) es la unidad hardware básica encargada de realizar las operaciones de cálculo aritmético como la suma y resta y de realizar operaciones lógicas de tipo booleano como las operaciones NOT, OR, AND, etc</p></li></ul></div></div></section><section id="_aritmetica_binaria"><h2>4.4. Aritmetica Binaria</h2><div class="slide-content"><h level="3">Suma en módulo 2 (binaria) en binario puro (Nº NATURALES)</h><div class="ulist"><ul><li><p>Los  números naturales no tienen la marca de un signo ya que son todos positivos: 0,1,2,3&#8230;&#8203;.</p></li><li><p>Suma de datos en código binario puro</p><div class="ulist"><ul><li><p>Concepto de operación <strong>modular</strong></p><div class="ulist"><ul><li><p>Ejemplo: módulo 100.000 &#8594; Interpretación modular gráfica  mediante la circunferencia. Qué ocurre en el cuenta-kilómetros parcial del coche cuando llegamos a 99.999.</p></li></ul></div></li><li><p>Ejemplo: Representación de los números binarios en módulo 8. Suma binaria en módulo 8. Representación gráfica para números binarios de 3 bits &#8594; módulo= 2<sup>3</sup> = 8</p><div class="imageblock" style="text-align: center"><img src="./images/datos_representacion/rueda_unsigned.png" alt="rueda unsigned" /></div><div class="title">Figure 24. Representación Unsigned Number</div>
<div class="ulist"><ul><li><p>Suma: Gráficamente se puede ver que 7+1=0. La ALU al realizar la operación suma 111+001 da como resultado 000. 7+1 da como resultado el valor 8 que en módulo 8 es 0.</p></li><li><p>Suma: ¿Cuánto sería 7+7? &#8594; 14 en módulo 8 es 6. Si el resultado es igual o superior al módulo hay que restarle el módulo tantas veces como sea necesario.</p></li><li><p>Suma: Cuánto vale 33 en módulo 8 &#8594; 33-8*4=1 . El 1 está en el rango (0 , 7).</p></li><li><p>Resta: Gráficamente se puede ver que 0-1=7. La ALU al realizar la operación resta 000-001 da como resultado 111</p></li></ul></div></li><li><p>El <strong>acarreo</strong> (llevada) se produce al llegar o pasar el valor  <em>2</em>.</p><div class="ulist"><ul><li><p>1+1=uno más uno = dos &gt;=2 &#8594; al valor dos le resto el módulo 2 (2-2=0) y me llevo una. El valor 2 en binario se representa como 1 0, donde el cero es la representación en la misma posición que el digito sumando y el 1 la llevada a la siguiente posición.</p></li><li><p>1+1+1=uno más uno más uno = tres &gt;=2 &#8594; al valor tres le resto el módulo 2 (3-2=1) y me llevo una. El valor 3 en binario se representa como 1 1, donde el uno de la derecha es la representación en la misma posición que el digito sumando y el 1 de la izda es la llevada a la siguiente posición.</p></li></ul></div></li></ul></div></li><li><p>Ejercicio: calcular la suma de 10011011+00011011 = 10110110</p><div class="literalblock"><div class="content"><pre>  Llevadas --&gt;          1 1   1 1

                    1 0 0 1 1 0 1 1  &lt;--sumando
                  + 0 0 0 1 1 0 1 1  &lt;--sumando

  Valor suma          1 3 2 1 3 2
                  *****************
  Resultado --&gt;     1 0 1 1 0 1 1 0  &lt;--suma</pre></div></div></li></ul></div>
<h level="4">Overflow ó Desbordamiento</h><div class="ulist"><ul><li><p>Se dice que la suma o resta se ha desbordado cuando:</p><div class="ulist"><ul><li><p>El valor del resultado a representar está fuera del rango debido a la limitación del número de digitos.</p></li><li><p>El resultado de la operación aritmética tiene un tamaño superior al permitido por la palabra de memoria o registro donde se almacena.</p></li><li><p>La solución sería aumentar el número de digitos que representan al dato, pero no siempre se puede.</p></li><li><p>Lógicamente si se da un desbordamiento el resultado que proporciona la ALU no es correcto. La ALU dispone de un flag o banderín de desbordamiento OF (overflow flag) que almacena un bit. Si el bit OF=1 significa que la  última operación realizada por la ALU ha producido overflow. El programador puede saber si ha habido error de overflow leyendo el banderín OF.</p></li></ul></div></li><li><p>Ejemplos:</p><div class="ulist"><ul><li><p>La unidad ALU dispone de dos registros de entrada de "1 byte", AL y BL, cada uno donde almacena dos datos : 10011011 y 10011011. Dispone también de un registro de salida de 1 byte, CL. Calcular el resultado de la suma en formato binario puro: CL &#8592; AL+BL y el valor del banderín OF.</p><div class="listingblock"><div class="content"><pre>Llevadas --&gt;          1 1   1 1

                  1 0 0 1 1 0 1 1  &lt;--AL
      	        + 1 0 0 1 1 0 1 1  &lt;--BL

Valor suma        2   1 3 2 1 3 2
                *****************
Resultado --&gt;  1  0 0 1 1 0 1 1 0  &lt;--suma

CL : 0 0 1 1 0 1 1 0
OF : 1</pre></div></div></li><li><p>Error de overflow ya que la ALU ha calculado el resultado de la suma: 00110110</p></li><li><p>El resultado correcto 100110110 está fuera del rango de un registro de 8 bits. El rango permitido serían los números comprendidos entre 0000000 y 11111111, es decir, valores comprendidos entre 0 y 255. El dato 100110110 cuyo valor es 310. La solución sería diseñar una nueva CPU con registros cuyo tamaño de palabra sea mayor que 1 byte, pej 2 bytes. Entonces si a la entrada de la ALU tenemos AX=0000000010011011 BX=0000000010011011 , el resultado de la operación CX &#8592;AX+BX sería 0000000100110110 y OF=0 &#8594; no hay error de overflow.</p></li></ul></div></li></ul></div>
<h level="3">Resta en módulo 2 (binaria) en binario puro</h><div class="ulist"><ul><li><p>Para poder restar dos números naturales (sin signo) es necesario que el valor del minuendo sea superior al del sustraendo.</p><div class="ulist"><ul><li><p>0-0 = 0</p></li><li><p>1-1 = 0</p></li><li><p>1-0 = 0</p></li><li><p>¿Qué ocurre si a 0 le tengo que restar 1? Al valor 0 NO se el puede resta el valor 1. Cuando un dígito del minuendo en la posición "p" es menor que el dígito en la misma posición "p" del sustraendo, la solución es sumarle al minuendo de la posición p el módulo (2 en binario) y al mismo tiempo también sumarle el mismo valor al sustraendo pero a través de la posición "p+1", con lo cual si sumamos el mismo valor tanto al minuendo como al sustraendo el resultado de la resta no se ve afectado.</p></li><li><p>posición "p": minuendo 0 - sustraendo1 &#8594; En el minuendo 0+módulo-1=0+2-1= 1. El valor 2 en la posición "p" equivale al valor 1 en la posición "p+1". En la posición "p+1" sumaremos 1 al sustraendo.</p></li><li><p>posición "p": minuendo 0 - sustranedo 1 - llevada 1 &#8594; En el minuendo 0+módulo-1-1=0+2-1-1=0 y llevada 1 que sumaremos a la posición siguiente del sustraendo.</p></li><li><p>posición "p": 1-1-1 &#8594; en el sustraendo 1+módulo-1-1=1+2-1-1= 1 y llevada 1 que sumaremos a la posición siguiente del sustraendo.</p></li><li><p>10110110 - 10011011 = 00011011</p><div class="listingblock"><div class="content"><pre>Sumar crédito al minuendo            2  2     2  2

                            1  0  1  1  0  1  1  0  &lt;--minuendo
      	                  - 1  0  0  1  1  0  1  1  &lt;--sustraendo


Sumar llevada al sustraendo       1  1     1  1
                          *************************
Resta                       0  0  0  1  1  0  1  1</pre></div></div></li></ul></div></li></ul></div>
<h level="3">Suma/Resta en módulo 2 (binaria) en complemento a 2</h><div class="ulist"><ul><li><p>Repasar el formato complemento a 2 para números enteros con signo</p><div class="imageblock" style="text-align: center"><img src="./images/datos_representacion/rueda_signed.png" alt="rueda signed" /></div><div class="title">Figure 25. Representación Complemento a 2</div></li></ul></div>
<h level="4">suma</h><div class="ulist"><ul><li><p>Realizar la suma de en complemento a 2 de números enteros de 1 byte 00100101 y 0111</p></li><li><p>Los dos datos empiezan por cero, luego son positivos según el formato complemento a 2</p><div class="ulist"><ul><li><p>extiendo los sumandos para tener todos el mismo tamaño. 0111 extendiendo el bit de signo 0 es 00000111</p><div class="listingblock"><div class="content"><pre>Llevadas --&gt;              1 1 1

                  0 0 1 0 0 1 0 1  &lt;--AL
      	        + 0 0 0 0 0 1 1 1  &lt;--BL

Valor suma                1 3 2 2
                *****************
Resultado --&gt;     0 0 1 0 1 1 0 0  &lt;--suma</pre></div></div></li></ul></div></li></ul></div>
<h level="4">resta</h><div class="ulist"><ul><li><p>La resta X-Y equivale a la suma X+(-Y). La resta -X-Y equivale a la suma <em><code>(-X)</code>(-Y)</em>. Por lo que la ALU las restas la realiza mediante la operación suma y cambiando de signo a los operandos.</p><div class="ulist"><ul><li><p>Ejemplo: realizar la resta 27-101 en complemento a 2 utilizando registros de 1 byte</p><div class="listingblock"><div class="content"><pre>primero codifico tanto el minuendo +27 como el sustraendo +101
  +27 -&gt; 00011011
 +101 -&gt; 01100101

-101 es el complemento a 2 de +101 -&gt; 10011011

La operación equivale a la suma (-101)+27 -&gt; 10011011+00011011

Llevadas --&gt;          1 1   1 1

                  1 0 0 1 1 0 1 1  &lt;--AL
      	        + 0 0 0 1 1 0 1 1  &lt;--BL

Valor suma            1 3 2 1 3 2
                *****************
Resultado --&gt;     1 0 1 1 0 1 1 0  &lt;--suma</pre></div></div></li><li><p>¿ Cuál es el valor del resultado?</p><div class="listingblock"><div class="content"><pre>el resultado tiene el bit de la posición más significativa a 1 por lo que su valor es negativo en complemento a 2. Si es negativo no puedo calcular su valor mediante sumas ponderadas ya que no es una representación posicional. Tengo que cambiar lo de signo para hacerlo positivo y así poder calcular su valor por suma ponderada.

Complemento a 2 del resultado 10110110 -&gt; 01001010 cuyo valor es +74 , por lo que el valor de 10110010 es -74.</pre></div></div></li><li><p>repetir la operación cambiando de computadora y utilizando registros de 2 bytes. Basarse en el apartado anterior.</p><div class="listingblock"><div class="content"><pre>Extiendo el bit de signo del número negativo 10011011 hasta completar los 16 bits
  AX &lt;-- 1111111110011011   (-101)
Extiendo el bit de signo del número positivo 00011011 hasta completar los 16 bits
  BX &lt;-- 0000000000011011   (+27)
Extiendo el bit de signo del resultado negativo 10110110 hasta completar los 16 bits
  CX &lt;-- 1111111110110110   (-74)</pre></div></div></li></ul></div></li></ul></div>
<h level="4">Overflow en Complemento a 2 (C2)</h><div class="ulist"><ul><li><p>El desbordamiento u overflow ocurre en las operaciones aritméticas suma y resta cuando el resultado de la operación es de un tamaño fuera del rango de posibles representaciones, por lo que el valor resultante no es válido y provoca errores.</p><div class="ulist"><ul><li><p>Ejemplo de suma utilizando registros de 2 bytes : 10000000+10000000 = 00000000 &#8658; Overflow</p></li><li><p>Error ya que -128-128 no es cero.</p><div class="ulist"><ul><li><p>Si los dos sumandos son negativos el resultado no puede ser positivo</p><div class="listingblock"><div class="content"><pre>Para que el resultado fuese correcto deberíamos utilizar registros de un tamaño superior al byte, por ejemplo 9 bits. En este caso realizamos nuevamente la operación extendiendo los datos 1 bit más:
110000000+110000000 = 100000000 -&gt; no hay overflow -&gt; la suma de dos números negativos ha dado negativo

si realizamos la operación en decimal -&gt; (-128)+(-128) = (-256)</pre></div></div></li><li><p>Si los dos sumandos son positivos el resultado no puede ser negativo</p></li></ul></div></li></ul></div></li><li><p>Intelx86 activa el error de overflow cuando en el resultado de una operación aritmética con signo el acarreo del bit MSB afecta al valor del resultado.</p></li></ul></div>
<div class="admonitionblock note"><table><tr><td class="icon"><i class="fa fa-info-circle" title="Note"></i></td><td class="content">Observar que al realizar operaciones aritméticas de suma y resta, el código del resultado es idéntico en números sin signo y en complemento a 2. El código es idéntico pero su valor asociado no lo es.</td></tr></table></div>
<h level="3">Suma en Módulo 16 (Hexadecimal)</h><div class="ulist"><ul><li><p>Suma en módulo 16:</p><div class="ulist"><ul><li><p>el acarreo se produce al llegar o pasar el valor del módulo: 16.</p></li><li><p>0xF+0x1 = 0x10</p><div class="ulist"><ul><li><p>F+1=quince más uno = dieciséis &gt;=16 &#8594; al resultado dieciséis le resto 16 (16-16=0) y me llevo una.</p></li></ul></div></li><li><p>0x3AF+0xA = 0x3B9</p><div class="ulist"><ul><li><p>F+A=quince más 10 = 25&gt;=16 &#8594; al resultado veinticinco le resto 16 (25-16=9) y me llevo una</p></li></ul></div></li><li><p>0x3A1F+0xF4E1=0x12F00</p><div class="ulist"><ul><li><p>F+1=quince más 1 = 16&gt;=16 &#8594; al resultado dieciséis le resto 16 (16-16=0) y me llevo una.</p></li></ul></div></li></ul></div></li></ul></div>
<h level="3">Resta en Módulo 16 (Hexadecimal)</h><div class="ulist"><ul><li><p>Todo lo visto anteriormente para números binarios se puede realizar en cualquier otra base, por ejemplo en números codificados en hexadecimal.</p></li><li><p>Resta en módulo 16:</p><div class="ulist"><ul><li><p>el acarreo se produce cuando una posición p del minuendo es inferior a la misma posición p del sustraendo, en cuyo caso, es necesario sumar el módulo 16 al minuendo y la llevada a la posición siguiente p+1 del sustraendo:</p></li><li><p>0x4308 - 0x1ABC = 0x</p><div class="listingblock"><div class="content"><pre>                0x 4 3 0 8 &lt;-- Minuendo
      	      - 0x 1 A B C &lt;-- Sustraendo
LLevadas --&gt;       1 1 1
              *************
                0x 2 8 4 C</pre></div></div></li><li><p>8-C &#8594; 8+módulo_16-12=8+16-12=12=0xC y llevada 1 a la posición siguiente</p></li><li><p>0-B-LLevada &#8594; 0+módulo_16-11-1=0+16-11-1=4=0x4 y llevada 1 a la posición siguiente</p></li><li><p>3-A-LLevada &#8594; 3+módulo_16-10-1=3+16-10=8=0x8 y llevada 1 a la posición siguiente</p></li><li><p>4-1-LLevada &#8594; 4-1-1=2</p></li></ul></div></li></ul></div>
<h level="4">Suma en base hexadecimal en formato complemento a 2</h><div class="ulist"><ul><li><p>0xEC+0xAB=0x97</p><div class="ulist"><ul><li><p>En binario el bit MSB es 1 significa que el valor es negativo</p></li><li><p>Los dos sumandos y el resultado son negativos</p></li><li><p>La suma de dos números negativos da overflow si el resultado es positivo, por lo que no hay overflow</p></li><li><p>C2 de 0xEC &#8594; 0xEC negado es 0x13 y sumando 1 &#8594;  0x15</p></li><li><p>C2 de 0xAB &#8594; 0x54+1 &#8594; 0x55</p></li><li><p>C2 de 0x97 &#8594; 0x68+1 &#8594; 0x69</p></li></ul></div></li></ul></div>
<h level="4">Suma en base 8 (Octal)</h><div class="ulist"><ul><li><p>Suma en módulo <em>8</em>. El acarreo se produce al llegar o pasar el valor del dígito <em>8</em>.</p><div class="ulist"><ul><li><p>08+01 = 010</p></li><li><p>0377+06 = 0305</p></li></ul></div></li></ul></div>
<h level="3">Tipos de variables en C</h><div class="ulist"><ul><li><p>Enteros</p><div class="ulist"><ul><li><p>char</p></li><li><p>short</p></li><li><p>int</p></li><li><p>long</p></li></ul></div></li><li><p>Reales</p><div class="ulist"><ul><li><p>float</p></li><li><p>double</p></li></ul></div></li><li><p>Operador sizeof()</p></li><li><p>Conversión de tipos</p><div class="ulist"><ul><li><p>casting</p></li></ul></div></li></ul></div></div></section><section id="_operaciones_logicas"><h2>4.5. Operaciones Logicas</h2><div class="slide-content"><h level="3">Operadores BITWISE</h><div class="ulist"><ul><li><p>Bitwise: operaciones bit a bit</p><div class="ulist"><ul><li><p>not,and,or,xor</p></li></ul></div></li></ul></div>
<h level="4">Lenguaje C</h><div class="ulist"><ul><li><p><a href="https://www.salesforce.com/us/developer/docs/apexcode/Content/langCon_apex_expressions_operators_understanding.htm" class="bare">https://www.salesforce.com/us/developer/docs/apexcode/Content/langCon_apex_expressions_operators_understanding.htm</a></p></li><li><p><a href="http://en.wikipedia.org/wiki/Boolean_algebra">Algebra Boole</a></p></li><li><p><a href="http://en.wikipedia.org/wiki/List_of_logic_symbols">algebra symbols</a></p><div class="ulist"><ul><li><p>Bitwise operator: and &amp;, or |, xor ^, not ~</p></li><li><p>Shift operator: left &lt;&lt;,right signed &gt;&gt;, right unsigned &gt;&gt;&gt;</p></li></ul></div></li></ul></div>
<table class="tableblock frame-topbot grid-all" style="width:50%"><colgroup><col style="width:33.3333%" /><col style="width:33.3333%" /><col style="width:33.3334%" /></colgroup><thead><tr><th class="tableblock halign-right valign-top">Operador</th><th class="tableblock halign-center valign-top">Algebra</th><th class="tableblock halign-left valign-top">C</th></tr><tbody><tr><td class="tableblock halign-right valign-top"><p class="tableblock"><strong>NOT</strong></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>&#xac; &#x02dc;</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><em>~</em></p></td></tr><tr><td class="tableblock halign-right valign-top"><p class="tableblock"><strong>OR</strong></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>&#x2228;</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><em>|</em></p></td></tr><tr><td class="tableblock halign-right valign-top"><p class="tableblock"><strong>AND</strong></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>&#x2227;</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><em>&amp;</em></p></td></tr><tr><td class="tableblock halign-right valign-top"><p class="tableblock"><strong>XOR</strong></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>&#x2295;  &#x22bb;</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><em>^</em></p></td></tr><tr><td class="tableblock halign-right valign-top"><p class="tableblock"><strong>NOR</strong></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>&#x22bd;</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-right valign-top"><p class="tableblock"><strong>NAND</strong></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>&#x22bc;</code></p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-right valign-top"><p class="tableblock"><strong>Left SHIFT</strong></p></td><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock"><em>x &lt;&lt; m</em></p></td></tr><tr><td class="tableblock halign-right valign-top"><p class="tableblock"><strong>Right SHIFT signed</strong></p></td><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock"><em>x &gt;&gt; m</em></p></td></tr><tr><td class="tableblock halign-right valign-top"><p class="tableblock"><strong>Right SHIFT unsigned</strong></p></td><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock"><em>x &gt;&gt;&gt; m</em></p></td></tr></table>
<h level="4">Tablas de la Verdad</h><table class="tableblock frame-topbot grid-all" style="width:50%"><colgroup><col style="width:20%" /><col style="width:20%" /><col style="width:20%" /><col style="width:20%" /><col style="width:20%" /></colgroup><thead><tr><th class="tableblock halign-center valign-top">x</th><th class="tableblock halign-center valign-top">y</th><th class="tableblock halign-center valign-top">z=x&#x2228;y</th><th class="tableblock halign-center valign-top">z=x&#x2227;y</th><th class="tableblock halign-center valign-top">z=x&#x2295;y</th></tr><tbody><tr><td class="tableblock halign-center valign-top"><p class="tableblock"><strong>0</strong></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><strong>0</strong></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><strong>0</strong></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><strong>0</strong></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><strong>0</strong></p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock"><strong>0</strong></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><strong>1</strong></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><strong>1</strong></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><strong>0</strong></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><strong>1</strong></p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock"><strong>1</strong></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><strong>0</strong></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><strong>1</strong></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><strong>0</strong></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><strong>1</strong></p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock"><strong>1</strong></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><strong>1</strong></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><strong>1</strong></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><strong>1</strong></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><strong>0</strong></p></td></tr></table>
<h level="4">Expresión Lógica</h><div class="ulist"><ul><li><p>z=&#xac;x·y+x·&#xac;y</p><div class="ulist"><ul><li><p>Si desarrollamos la tabla de la verdad comprobamos su equivalencia con el operador XOR</p></li></ul></div></li></ul></div></div></section><section id="_multiplicación"><h2>4.6. Multiplicación</h2><div class="slide-content"><div class="ulist"><ul><li><p>Multiplicación 0xFF x 0x6</p><div class="ulist"><ul><li><p>Realizarla en Binario</p></li><li><p>Observar que al multiplicar por una potencia de 2 hay un desplazamiento del multiplicando hacia la dcha</p></li><li><p>multiplicar = sumar y desplazar</p></li></ul></div></li></ul></div></div></section><section id="_programación"><h2>4.7. Programación</h2><div class="slide-content"><h level="3">funciones matemáticas</h><div class="ulist"><ul><li><p><a href="http://bisqwit.iki.fi/story/howto/bitmath/" class="bare">http://bisqwit.iki.fi/story/howto/bitmath/</a></p><div class="ulist"><ul><li><p>El código fuente está escrito en lenguaje C</p></li></ul></div></li><li><p>Librería libm.so del standard de C</p></li></ul></div>
<h level="3">Aplicación</h><div class="ulist"><ul><li><p>Desarrollar un programa que multiplique números enteros con signo.</p></li></ul></div></div></section><section id="_hardware"><h2>4.8. Hardware</h2><div class="slide-content"><h level="3">Circuitos Digitales</h><h level="4">Básicos:Puerta lógicas</h><div class="ulist"><ul><li><p><a href="http://en.wikipedia.org/wiki/Logic_gate">Puertas lógicas</a></p><div class="ulist"><ul><li><p>not, and, or, xor</p></li></ul></div></li></ul></div>
<h level="4">Complejos</h><div class="ulist"><ul><li><p><a href="http://en.wikipedia.org/wiki/Adder_%28electronics%29#Full_adder">half adder, full adder</a></p></li><li><p><a href="http://en.wikipedia.org/wiki/Binary_multiplier">multiplicador</a></p><div class="ulist"><ul><li><p>circuito combinacional formado por puertas lógicas</p></li><li><p>acumulador y registro desplazador</p></li></ul></div></li></ul></div>
<h level="3">Unidad Aritmetico Lógica (ALU)</h><div class="ulist"><ul><li><p>Arithmetic logic unit (ALU)</p></li><li><p>Circuito Digital</p></li><li><p>Conexión CPU-DRAM</p><div class="ulist"><ul><li><p>Transferencia de Instrucciones y Datos</p></li><li><p>La ALU es interna a la CPU y procesa datos numéricos enteros almacenaddos en los registros de propósito general.</p><div class="listingblock"><div class="title">Arquitectura Intel x86 de 32 bits</div><div class="content"><pre>            Central Processor Unit (CPU)	                                  Memoria Externa RAM
+----------------------------------------------------+		               +----------------------+
|						     |                         |                      |
|						     |			       +----------------------+
|                +--------------+		     |			       |		      |
|                | Resultado    |		     |    BUS Direcciones      +----------------------+
|                +--------------+		     o----------------------/-&gt;|		      |
|                      ^			     |                     32  +----------------------+
|                      |			     |			       |                      |
|          /------------------------		     |			       +----------------------+
|         /                         \		     |			       |		      |
|        /	      ALU            \		     |			       +----------------------+
|       /	        X             \		     |			       |		      |
|      /               / \             \	     |			       +----------------------+
|     /	              /   \             \	     |			       |                      |
|    ----------------/     \-------------\	     |			       +----------------------+
|            ^                    ^		     |			       |		      |
|            |                    |		     |			       +----------------------+
|    +--------------+      +--------------+	     |			       |		      |
|    | Operando_1   |      | Operando_2   |	     |   BUS Read/Write	       +----------------------+
|    +--------------+      +--------------+	     o------------------------&gt;|                      |
|						     |                         +----------------------+
|              +--------------+			     |			       |		      |
|              | Registro A   |			     |			       +----------------------+
|              +--------------+			     |			       |		      |
|              | Registro B   |			     |			       +----------------------+
|              +--------------+			     |			       |                      |
|              | Registro     |			     |			       +----------------------+
|              +--------------+			     |			       |		      |
|              | Registro     |			     |			       +----------------------+
|              +--------------+			     |			       |		      |
|              | Registro     |			     |			       +----------------------+
|              +--------------+			     |			       |                      |
|              | Registro Z   |			     |			       +----------------------+
|              +--------------+			     |			       |&lt;-----  1 Byte ------&gt;|
|             Banco de Registros		     |			       +----------------------+
|              Memoria Interna			     |			       |		      |
|						     |			       +----------------------+
|						     |			       |                      |
+----------------------------------------------------+                         +----------------------+
                      ^                                                                   ^
                      |                          BUS Datos                                |
                      +-------------------------------------------/-----------------------+
                                                                 32</pre></div></div></li></ul></div></li></ul></div>
<h level="3">Registro de flags EFLAG</h><div class="ulist"><ul><li><p>El registro de flags EFLAGS es un registro de memoria interno a la CPU Intel x86</p></li><li><p>Cada bit del registro de 32 bits es un banderín o flag que se activa en función del resultado de la operación realizada por la última instrucción máquina ejecutada.</p><table class="tableblock frame-all grid-all" style="width:50%"><caption class="title">Table 6. RFLAG Register</caption><colgroup><col style="width:33.3333%" /><col style="width:33.3333%" /><col style="width:33.3334%" /></colgroup><thead><tr><th class="tableblock halign-left valign-top">Flag</th><th class="tableblock halign-center valign-top">Bit</th><th class="tableblock halign-left valign-top">Name</th></tr><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock">CF</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Carry flag</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">PF</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Parity flag</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">AF</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Adjust flag</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">ZF</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">6</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Zero flag</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">SF</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Sign flag</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">OF</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">11</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Overflow flag</p></td></tr></table></li><li><p>Carry flag CF:</p><div class="ulist"><ul><li><p>se activa si la llevada afecta a una posición de bit mayor que del ancho de palabra (word size) de la ALU en una operación aritmética de <strong>números enteros sin signo o con signo</strong></p></li></ul></div></li><li><p>Overflow flag OF:</p><div class="ulist"><ul><li><p>se activa si teniendo en cuenta el bit de mayor peso MSB (aunque esté fuera el word size) indicase error en la operación aritmética con <strong>números enteros con signo</strong>. Si no se tiene en cuenta el MSB fuera del word size, la operación es correcta.</p></li></ul></div></li><li><p>Parity Even flag:</p><div class="ulist"><ul><li><p>indica si el número de bits del byte LSB del resultado de la última operación ha sido par.</p></li></ul></div></li><li><p>Sign flag:</p><div class="ulist"><ul><li><p>se activa si el resultado de la última operación ha sido negativo.</p></li></ul></div></li><li><p>Adjust flag:</p><div class="ulist"><ul><li><p>se activa si hay llevada en el nibble LSB del resultado de la última operación</p></li></ul></div></li></ul></div>
<div id="of_cf_unsigned_signed" class="ulist"><ul><li><p>Ejemplos:</p></li></ul></div>
<div class="admonitionblock caution"><table><tr><td class="icon"><i class="fa fa-fire" title="Caution"></i></td><td class="content">Hay que diferenciar los casos suma CON signo y suma SIN signo. En el primer caso detectamos el error matemático únicamente con el flag OF y en el segundo caso detectamos el error matemático únicamente con el flag CF.</td></tr></table></div>
<div class="ulist"><ul><li><p>Números CON signo (complemento a 2):</p><div class="ulist"><ul><li><p>para saber si hay overflow siempre se suma&#8230;&#8203;una resta se puede convertir en suma</p></li><li><p>El carrier flag CF no tiene sentido. Unicamente interpreto OF para saber si hay error en la operación aritmética.</p><div class="listingblock"><div class="content"><pre>  11111111
+ 00000001
__________
 100000000 -&gt; Esta suma NO es correcta, ya que para representar el resultado con 9 bits los operandos tienen que ser de 9 bits y por lo tanto hay que extender el bit de signo de los operandos de 8 bits. La suma con 9 bits sería:

operandos y resultado con 9 bits:
  111111111
+ 000000001
___________
  000000000 -&gt; NO hay Overflow ya que los operandos de la suma son de distinto signo

operandos y resultado con 8 bits:
  11111111
+ 00000001
___________
  00000000 -&gt; NO hay Overflow ya que los operandos de la suma son de distinto signo


Nunca va haber overflow si sumamos datos de signo contrario


 Resta A-B donde
 A=11110000
 B=00010100
 A-B=A+(-B) -&gt; Convierto la resta en suma

 A :    11110000
-B :   +11101100
________________
A–B:    11011100 -&gt; Hay acarreo pero NO overflow. La suman de dos datos negativos da como resultado un número también negativo.CF=1 y OF=0

 A=10000000
 B=10000000
 A+B

 Para hacer la suma con 9 dígitos en lugar de 8 bits, extiendo los dos operandos hasta completar los 9 dígitos
 A :    110000000
 B :   +110000000
_________________
A+B:    100000000

 Observamos que no hay overflow en el caso de que utilizasemos 9 dígitos. Pero si la ALU está operando con registros de 8 bits SÍ HAY overflow. Los dos sumandos son negativos (bit de signo posición 7ª) y el bit de signo del resultado (bit posición 7ª) es positivo luego el resultado es erróneo.</pre></div></div></li></ul></div></li><li><p>números SIN signo</p><div class="ulist"><ul><li><p>El overflow flag OF no tiene sentido. Unicamente interpreto CF para saber si hay error en la operación aritmética.</p><div class="listingblock"><div class="content"><pre>  11111111
+ 00000001
__________
  00000000 -&gt; Hay acarreo en el bit más significativo luego CF=1. Conceptualmente hay overflow por lo que el resultado que obtiene la ALU aunque electrónicamente es correcto, no lo es matemáticamente (511+1=0). El efecto overflow lo detecto con CF=1.

Extiendo los operandos de la operación anterior con 1 bit.
  011111111
+ 000000001
___________
  100000000 -&gt; No hay acarreo -&gt; CF=0. Esta suma es correcta matemáticamente ya que 511+1=512 y por lo tanto no hay overflow -&gt; CF=0</pre></div></div>
<div class="ulist"><ul><li><p>Se ve nuevamente en  el próximo capítulo <a href="#CFR">Programación en Lenguaje Ensamblador (x86)</a></p></li></ul></div></li></ul></div></li></ul></div>
<h level="3">Float Point Unit-FPU</h><div class="ulist"><ul><li><p>Unidad de procesamiento de datos en coma flotante</p></li><li><p>Antiguamente era una unidad no integrada en la CPU denominada coprocesador matemático</p></li><li><p>Utiliza registros específicos denominados SSE distintos de los Registros de Propósito General utilizados por la ALU para realizar operaciones con números enteros.</p></li></ul></div></div></section></section>
<section><section id="_representación_de_las_instrucciones"><h2>5. Representación de las Instrucciones</h2></section><section id="_temario_5"><h2>5.1. Temario</h2><div class="slide-content"><div class="olist arabic"><ol class="arabic"><li><p>Representación de instrucciones</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Lenguaje máquina, lenguaje ensamblador y lenguajes de alto nivel</p></li><li><p>Formato de instrucción</p></li><li><p>Tipos de instrucción y modos de direccionamiento</p></li></ol></div></li></ol></div>
<h level="3">Bibliografía</h><div class="ulist"><ul><li><p>Tema referenciado en el libro de texto W. Stalling</p><div class="ulist"><ul><li><p>Capítulo 10: Conjuntos de Instrucciones : Características y Funciones (Datos, Operandos y Operaciones)</p></li><li><p>Capítulo 11: Conjuntos de Instrucciones: Formatos de instrucciones y Modos de Direccionamiento (Lenguaje Ensamblador)</p></li><li><p>Apéndice B: Lenguaje Ensamblador y Toolchain</p></li></ul></div></li></ul></div></div></section><section id="_objetivos"><h2>5.2. Objetivos</h2><div class="slide-content"><div class="ulist"><ul><li><p>Analizar la arquitectura del repertorio de las instrucciones máquina (Formato de instrucciones, formato de datos, operaciones y direccionamiento de operandos) de arquitecturas ISA en general.</p></li></ul></div>
<h level="3">Requisitos</h><div class="ulist"><ul><li><p>Requisitos:</p><div class="ulist"><ul><li><p>Von Neumann Architecture: Arquitectura de una Computadora, Máquina IAS.</p></li><li><p>Programación en lenguaje ensamblador IAS</p></li><li><p>Representacion de datos</p></li><li><p>Operaciones Aritméticas y Lógicas</p></li></ul></div></li></ul></div></div></section><section id="_lenguajes_de_programación_de_alto_nivel_vs_lenguajes_de_programación_de_bajo_nivel"><h2>5.3. Lenguajes de programación de alto nivel vs Lenguajes de Programación de bajo nivel</h2><div class="slide-content"><h level="3">Lenguajes de alto nivel</h><div class="paragraph"><p>Los lenguajes de alto nivel como Java, Python, C, etc &#8230;&#8203; se desarrollaron para facilitar la tarea de programar algoritmos, estructuras de datos, etc&#8230;&#8203;utilizando un lenguaje sencillo de manejar por los programadores. En cambio, los datos y las instrucciones que manejan las CPU de las computadoras están en otro lenguaje, el lenguaje MAQUINA BINARIO, que depende del tipo de procesador (intel,AMD,RISC-V,etc&#8230;&#8203;) de la computadora. El lenguaje máquina de un procesador intel de nuestra computadora difiere del lenguaje MAQUINA del procesador arm de un smartphone.</p></div>
<div class="paragraph"><p>Al igual que los datos, las instrucciones también es necesario codificarlas en un formato BINARIO. Los programas en lenguaje máquina formados por datos e instrucciones binarias están preparados para ser cargados en la memoria principal RAM y ser procesados por la CPU.</p></div>
<div class="ulist"><ul><li><p>Ejemplos de lenguajes de Programación de alto y bajo nivel:  <a href="#lang_altovsbajo">Apéndice</a>.</p></li></ul></div>
<h level="3">El lenguaje máquina y el lenguaje ensamblador</h><div class="ulist"><ul><li><p>En este tema se trata de la representación e interpretación de las instrucciones en lenguaje máquina y lenguaje ensamblador.</p></li><li><p>Las instrucciones se pueden representar en dos lenguajes</p><div class="ulist"><ul><li><p>Lenguaje máquina en formato binario : 0101010101111111000011111</p><div class="ulist"><ul><li><p>El lenguaje binario implica un <strong>formato de la instrucción</strong>.</p></li></ul></div></li><li><p>Lenguaje símbolico o lenguaje ensamblador en formato texto :  <em>fin: ADD 0x33,resultado</em></p><div class="ulist"><ul><li><p>El lenguaje ensamblador implica una <strong>sintaxis</strong></p></li></ul></div></li></ul></div></li><li><p>La representación de las instrucciones en lenguaje binario permite su almacenamiento en la memoria principal así como facilitar el ciclo de instrucción mediante su decodificación y ejecución por parte de la CPU.</p></li><li><p>La representación de las instrucciones en lenguaje simbólico, como es el texto, tiene como objetivo facilitar la tarea del programador en la interpretación  de las instrucciones y en el desarrollo de programas en lenguaje ensamblador.</p></li><li><p>El estudio de los formatos de las instrucciones máquina de  un procesador específico se enmarca dentro del concepto ISA de la Arquitectura del Procesador <a href="#estr_comp">Ver apéndice</a></p></li></ul></div></div></section><section id="_elementos_de_una_instrucción_máquina"><h2>5.4. Elementos de una Instrucción Máquina</h2><div class="slide-content"><div class="ulist"><ul><li><p>Una instrucción máquina se estructura en diferentes campos: campo de operaciones, campo de operando, etc &#8230;&#8203; El número de campos dependerá del procesador que se esté diseñando.</p><div class="listingblock"><div class="content"><pre>         +------------------------------------------------------------------+
         | Campo de Operaciones |  Campo de Operando  | Campo de ...|       |
         +----------------------------------+-------------------------------</pre></div></div></li><li><p>En el caso de la máquina IAS el formato de instrucción tiene únicamente dos campos: el código de operación y el campo del operando.</p></li><li><p>Código de Operaciones:</p><div class="ulist"><ul><li><p>La instrucción debe de especificar que operación debe de realizar la CPU. Operaciones cómo las aritméticas de suma y resta ,  operaciones lógicas como not y and, operaciones de transferencia de datos entre posiciones de la memoria principal, operaciones de entrada y salida como la transferencia de datos del disco duro a la memoria principal, etc</p></li></ul></div></li><li><p>Source Operand Reference:</p><div class="ulist"><ul><li><p>Una operación puede requerir el procesamiento de uno o más datos. Por ejemplo la operación lógica NOT requiere de un operando, la operación suma ADD requiere de dos operandos, etc</p></li></ul></div></li><li><p>Target Operand Reference:</p><div class="ulist"><ul><li><p>Una operación  de suma requiere de dos operandos, uno es el operando fuente y otro el operando destino.</p></li></ul></div></li><li><p>Result Reference:</p><div class="ulist"><ul><li><p>Una operación de suma requiere salvar el resultado de la operación.</p></li></ul></div></li><li><p>Next Instruction Reference:</p><div class="ulist"><ul><li><p>Una vez finalizada la ejecución de la instrucción es necesario indicar a la CPU donde esta almacenada la próxima instrucción a ejecutar a través del Contador de Programa PC.</p></li></ul></div></li><li><p>Direcciones del operando implícitas: Direcciones que no aparecen explícitamente en la instrucción. Ejemplos:</p><div class="ulist"><ul><li><p>La Próxima instrucción es la dirección almacenada en otro registro: el Contador de Programa</p></li><li><p>El Resultado de la operación se guarda en otro registro: el Acumulador</p></li><li><p>etc</p></li></ul></div></li></ul></div>
<h level="3">Tipos de Arquitecturas de Operando: Ejemplos</h><div class="ulist"><ul><li><p>3 Tipos</p><div class="ulist"><ul><li><p>Arquitectura orientada a <strong>Acumulador</strong>: Un operando está implicitamente en el Acumulador</p></li><li><p>Arquitectura orientada a <strong>Stack</strong> (<a href="#pila">Apéndice Pila</a>):</p><div class="ulist"><ul><li><p>Los operandos se introducen o extraen de la pila interna de la CPU</p></li><li><p>Concepto de pila: push/pop &#8594; empujar/extraer &#8594; el primero en entrar es el último en salir &#8594; First Input Last Output</p></li><li><p>SP: Registro Stack Pointer : registro que apunta al Top de la pila (parte alta de la pila)</p></li></ul></div></li><li><p>Arquitectura orientada a <strong>Registros</strong>:</p><div class="ulist"><ul><li><p>Dos tipos: Reg/Mem y Load/Store, como es el caso de la arquitectura amd64 y arm respectivamente.</p></li><li><p>Reg/Mem : para que la instrucción se ejecute uno de los dos operandos debe de estar en un registro</p></li><li><p>Load/Store: Los dos operandos deben de estar en dos registros para que dicha instrucción se ejecute</p></li></ul></div></li></ul></div></li><li><p>Ejemplo: código para realizar la operación <strong>C=A+B</strong> en 4 arquitecturas de operando diferentes.</p><table class="tableblock frame-topbot grid-all" style="width:80%"><colgroup><col style="width:25%" /><col style="width:25%" /><col style="width:25%" /><col style="width:25%" /></colgroup><thead><tr><th class="tableblock halign-center valign-top">Stack</th><th class="tableblock halign-center valign-top">Acumulator</th><th class="tableblock halign-center valign-top">Register/Memory</th><th class="tableblock halign-center valign-top">Load/Store</th></tr><tbody><tr><td class="tableblock halign-center valign-top"><p class="tableblock"><strong>Push A</strong></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><strong>Load A</strong></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><strong>Load R1,A</strong></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><strong>Load R1,A</strong></p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock"><strong>Push B</strong></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><strong>Add B</strong></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><strong>Add R3,R1,B</strong></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><strong>Load R2,B</strong></p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock"><strong>Add</strong></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><strong>Store C</strong></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><strong>Store R3,C</strong></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><strong>Add R3,R1,R2</strong></p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock"><strong>Pop C</strong></p></td><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-center valign-top"><p class="tableblock"><strong>Store R3,C</strong></p></td></tr></table>
<div class="ulist"><ul><li><p>Los nombres de las variables, A, B,C son referencias a la Memoria Principal.</p></li><li><p>Descripción RTL</p><div class="ulist"><ul><li><p>Stack: M[SP]&#8592;M[A],SP&#8592;SP-1; M[SP]&#8592;M[B],SP&#8592;SP-1;M[SP+1]&#8592;M[SP]+M[SP+1],SP&#8592;SP+1;</p><div class="ulist"><ul><li><p><strong>Add</strong>    &#8594; NO hay referencia ni al operando fuente ni al operando destino.</p></li><li><p>Los operandos han de cargarse previamente en la pila</p></li></ul></div></li><li><p>Acumulator: AC&#8592;M[A];AC&#8592;AC+M[B];C&#8592;M[AC]</p><div class="ulist"><ul><li><p><strong>Add B</strong>   &#8594; NO hay referencia al operando DESTINO</p></li><li><p>El Operando destino a de cargarse previamente en el acumulador.</p></li></ul></div></li><li><p>Reg/Mem: R1&#8592;M[A];R3&#8592;R1+M[B];M[C]&#8592;R3</p><div class="ulist"><ul><li><p><strong>Add R3,R1,B</strong>  &#8594; NO se puede referencia a más de un operando en MEMORIA</p></li></ul></div></li><li><p>Si un operando está almacenado en la memoria, el resto a de cargarse previamente en los registros.</p></li><li><p>Load/Store: R1&#8592;M[A];R2&#8592;M[B];R3&#8592;R1+R2;M[C]&#8592;R3.</p><div class="ulist"><ul><li><p><strong>Add R3,R1,R2</strong> &#8594;Solamente se hacen referencias a REGISTROS, ninguna referencia a memoria</p></li><li><p>Los operandos fuente y destino han de cargarse previamente en los registros</p></li></ul></div></li></ul></div></li></ul></div></li></ul></div>
<div class="admonitionblock note"><table><tr><td class="icon"><i class="fa fa-info-circle" title="Note"></i></td><td class="content">La arquitectura x86 está orientada a Reg/Mem, por lo que no se puede referenciar en la misma instrucción a un operando fuente en MEMORIA y el operando destino también en MEMORIA, es decir, ambos operandos referenciados a MEMORIA.</td></tr></table></div>
<div class="ulist"><ul><li><p>Ejemplo de código para realizar la opeación <strong>(A-B)/(DxE+C)</strong> según 4 arquitecturas ISA diferentes: arquitectura con 3 operandos referenciados, con 2 operandos referenciados, con 1 operando referenciado y ninǵún operando referenciado</p><div class="imageblock"><img src="./images/instrucciones_representacion/addresses_arch.jpg" alt="addresses arch" /></div></li><li><p>4º Caso: Arquitectura de Operando tipo Stack:</p><div class="ulist"><ul><li><p>M[SP]&#8592;M[C];M[SP]&#8592;M[E];M[SP]&#8592;M[D];MUL;ADD;M[SP]&#8592;M[B];M[SP]&#8592;M[A];SUB;DIV</p></li><li><p>push C; push E; push D; mul; add; push B; push A; sub; div;</p></li></ul></div></li></ul></div></div></section><section id="_instrucciones_en_lenguaje_máquina_de_la_arquitectura_x86"><h2>5.5. Instrucciones en lenguaje máquina de la arquitectura x86</h2><div class="slide-content"><div class="ulist"><ul><li><p>Ver el apéndice <a href="#intel_i386_hola_asmbin">Apéndice</a> a modo de comprender un ejemplo. No es posible programar manualmente en lenguaje máquina en una computadora actual.</p></li></ul></div></div></section><section id="_representación_de_las_instrucciones_en_el_lenguaje_ensamblador_asm_para_computadoras_en_general"><h2>5.6. Representación de las instrucciones en el lenguaje ensamblador (ASM) para computadoras en general</h2><div class="slide-content"><h level="3">Introducción</h><div class="ulist"><ul><li><p>Los dos campos más importantes y casi únicos del formato de instrucción son: El código de operación y los modos de direccionamiento de los campos de operandos. El número de operandos puede ser 0,1,2,3,etc</p></li></ul></div>
<h level="3">Códigos de Operación</h><div class="ulist"><ul><li><p>La codificación del conjunto de operaciones depende de cada arquitectura ISA.</p></li><li><p>Categorías según el tipo de operaciones:</p><div class="ulist"><ul><li><p>Data Processing: Arithmetic and logic instructions</p></li><li><p>Data Load/Store: Movement of data into or out of register and/or memory
locations</p></li><li><p>Data Movement: I/O instructions</p></li><li><p>Control: Test and Branch instructions</p></li><li><p>El repertorio puede ser: reducido/extenso, complejo/sencillo.</p></li></ul></div></li><li><p>En el lenguaje ensamblador a la palabra que indica el tipo de opeación, por ejemplo ADD para una suma, se le denomina <strong>mnemónico</strong> y suele estar en lengua inglesa, permitiendo intuir fácilmente de que operación se trata.</p></li><li><p>La mejor forma de prácticar con los mnemónicos del lenguaje ensamblador es programando, lo cual se verá en el siguiente tema <a href="#repertorio_instruc_oper">lenguaje ensamblador x86</a></p></li></ul></div>
<div class="paragraph"><p><span class="image"><img src="./images/instrucciones_representacion/tipos_instrucciones.png" alt="tipos de instrucciones" /></span></p></div>
<h level="3">Operandos: Modos de Direccionamiento</h><h level="4">Localización</h><div class="ulist"><ul><li><p>Posibles ubicaciones de los operandos.</p><div class="ulist"><ul><li><p>En la propia instrucción</p></li><li><p>Memoria interna: registros CPU</p></li><li><p>Memoria Principal: memoria DRAM</p></li><li><p>Memoria i/o: registros en controladores de entrada/salidas denominados puertos.</p></li></ul></div></li><li><p>La instrucción tiene que hacer referencia de alguna forma (modo de direccionamiento) a  la ubicación del operando.</p></li></ul></div>
<h level="4">Direcciones referenciadas durante el ciclo de instrucción</h><div class="ulist"><ul><li><p>Durante el ciclo de instrucción se pueden referenciar:</p><div class="ulist"><ul><li><p>Una dirección para referenciar a la instrucción</p></li><li><p>Una dirección para el operando primero</p></li><li><p>Una dirección para el operando segundo</p></li><li><p>Una dirección para el resultado</p></li><li><p>Una dirección que referencie a la siguiente instrucción</p></li></ul></div></li><li><p>Tipos de  instrucciones según el número de direcciones referenciadas durante su ejecución.</p><div class="ulist"><ul><li><p>Instrucciones sin operando, con un operando, con múltiples operandos.</p></li><li><p>Depende de la arquitectura: Acumulador (Ej: máquina IAS), Registro-Memoria(Ej: máquina x86), Load/Store (Ej:ARM ), Stack (Ej: máquina JVM), Memoria-Memoria</p></li><li><p>referencias implicitas al operando</p></li></ul></div></li></ul></div>
<h level="4">Formato de instrucción: Campos</h><div class="listingblock"><div class="content"><pre>         +--------+-------------------------+--------------+
         | Cod Op |  Mod. Direccionamiento  |      A       |
         +--------+-------------------------+--------------+</pre></div></div>
<div class="ulist"><ul><li><p><strong>Ejemplo particular</strong> de una estructura del formato de instrucción en tres campos en una arquitectura ISA.</p><div class="ulist"><ul><li><p>Código de Operación: mover, cargar, sumar, restar, etc</p></li><li><p>Código A: campo de operando : hace referencia a la localización del operando</p></li><li><p>Código Mod. Direc: representa el modo de interpretar el campo A</p></li></ul></div></li><li><p>EA: Efective Address : Dirección efectiva donde está localizado el operando</p></li><li><p>Op: Operando .Es el dato contenido en la dirección efectiva EA.</p></li><li><p>Los datos <em>operando</em> Op pueden estar almacenados en:</p><div class="olist arabic"><ol class="arabic"><li><p>Memoria externa RAM</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Una dirección de memoria conteniendo un dato.</p></li><li><p>Una dirección de memoria conteniendo una instrucción. El dato es uno de los campos de a propia instrucción. Direccionamieno Inmediato.</p></li></ol></div></li><li><p>Memoria interna GPR</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Registros rax,eax,&#8230;&#8203;</p></li></ol></div></li></ol></div></li></ul></div>
<h level="4">Tipos de direccionamiento</h><div class="ulist"><ul><li><p>La <em>dirección</em> de referencia efectiva E.A. de la ubicación del operando se obtiene según los distintos modos de direccionamiento.</p></li><li><p>El modo de direccionamiento está codificado en el campo M.D.</p></li><li><p>Inmediato:</p><div class="ulist"><ul><li><p>El operando se obtiene del campo de la propia instrucción.</p></li><li><p>EA= no existe</p></li><li><p>Op=A</p></li></ul></div></li><li><p>Directo:</p><div class="ulist"><ul><li><p>El operando está en la memoria externa. El campo de operando contiene la dirección efectiva</p></li><li><p>EA=A</p></li><li><p>Op=M[EA]</p></li></ul></div></li><li><p>Registro:</p><div class="ulist"><ul><li><p>El operando está en la memoria interna. El campo de operando contiene la referencia del Registro.</p></li><li><p>EA=A</p></li><li><p>Op=R</p></li></ul></div></li><li><p>Indirecto:</p><div class="ulist"><ul><li><p>La dirección efectiva esta almacenada en una posición de memoria externa o interna.</p></li><li><p>EA=M[A] o R</p></li><li><p>Op=M[M[A]] o M[R]</p></li></ul></div></li><li><p>Desplazamiento:</p><div class="ulist"><ul><li><p>La dirección efectiva del operando se obtiene mediante una operación aritmética entre una dirección base y un desplazamiento relativo a la dirección base. La dirección base se toma como referencia y el desplazamiento es relativo a la dirección base.</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Relativo al contador de programa PC:</p><div class="ulist"><ul><li><p>La dirección base es implíctamente el contador de programa y el desplazamiento está en el campo de operando.</p></li><li><p>EA=PC+A</p></li><li><p>Op=M[EA]</p></li></ul></div></li><li><p>Relativo a Base:</p><div class="ulist"><ul><li><p>El desplazamiento está en el campo de operando y la dirección base está en el registro.</p></li><li><p>EA=R+A</p></li><li><p>Op=M[EA]</p></li></ul></div></li><li><p>Indexado:</p><div class="ulist"><ul><li><p>El desplazamiento está en el registro y la dirección base está en el campo de operando.</p></li><li><p>EA=A+R</p></li><li><p>Op=M[EA]</p></li></ul></div></li></ol></div></li></ul></div></li><li><p>Para hacer referencia a los operandos fuente o destino la arquitectura de la instrucción es muy <em>flexible</em> ya que se dispone de distintos modos de direccionar dichos operandos.</p></li></ul></div></div></section><section id="gas_sintax_direcci"><h2>5.7. Lenguaje Intel versus Lenguaje  AT&amp;T</h2><div class="slide-content"><h level="3">Lenguajes ensamblador de la arquitectura  i386/amd64</h><div class="ulist"><ul><li><p>El lenguaje en código máquina del repertorio de instrucciones de la arquitectura AMD64 es único pero no así el lenguaje ensamblador correspondiente a dicha arquitectura.</p></li><li><p>En la asignatura "Estructura de Computadores" se utiliza la sintaxis <strong>AT&amp;T</strong> de la compañía telefónica americana AT&amp;T.</p></li></ul></div>
<h level="3">Sintaxis de las instrucciones en el lenguaje INTEL</h><div class="ulist"><ul><li><p>El formato de las instrucciones en lenguaje ensamblador se conoce como <em>sintaxis</em> de las instrucciones.</p></li><li><p>SINTAXIS ASM: Etiqueta-Código de Operación- Operando1- Operando2- Comentario</p></li><li><p>x86-64</p></li><li><p>x86</p><table class="tableblock frame-all grid-all" style="width:100%"><caption class="title">Table 7. Sintaxis Intel</caption><colgroup><col style="width:9.5238%" /><col style="width:19.0476%" /><col style="width:28.5714%" /><col style="width:4.7619%" /><col style="width:23.8095%" /><col style="width:14.2858%" /></colgroup><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>label:</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>op_mnemonic</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>operand_destination</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>,</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>operand_source</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>#comment</code></p></td></tr></table>
<div class="ulist"><ul><li><p>Ejemplo:</p><div class="ulist"><ul><li><p><code>bucle:  sub     rsp,16                ;RSP &#8592; RSP-16. Comienzo del bucle con la operación substraction</code></p></li><li><p><code>je      bucle                 ;je: jump equal: salto si la última operación dió resultado cero</code></p></li><li><p><code>suma:   add     eax,esi               ;EAX &#8592; EAX+M[ESI] . Sumar</code></p></li><li><p><code>mov     ax,[resultado]        ;AX &#8592; M[resultado]. Copiar el resultado</code></p></li></ul></div></li></ul></div></li></ul></div>
<div class="admonitionblock note"><table><tr><td class="icon"><i class="fa fa-info-circle" title="Note"></i></td><td class="content">La sintaxis del lenguaje ensamblador depende del traductor del proceso de ensamblaje (assembler) utilizado, en este caso, se utiliza el assembler NASM. Ver un ejemplo en el <a href="#sum1toN_nasm">Apéndice</a> de un programa en lenguaje ensamblador intel y assembler "NetWide Asm" (nasm)</td></tr></table></div>
<h level="4">GNU Assembly (Gas)</h><div class="ulist"><ul><li><p>Lenguaje desarrollado por la empresa de telefonía AT&amp;T</p></li><li><p>Assembler gas (GNU as)</p><div class="ulist"><ul><li><p>arquitecturas: i386, amd64, mips, 68000, etc</p></li><li><p>Sintaxis: Etiqueta-Código de Operación- Operando1- Operando2- Comentario</p><table class="tableblock frame-all grid-all" style="width:100%"><caption class="title">Table 8. Sintaxis AT&amp;T</caption><colgroup><col style="width:9.5238%" /><col style="width:19.0476%" /><col style="width:23.8095%" /><col style="width:4.7619%" /><col style="width:28.5714%" /><col style="width:14.2858%" /></colgroup><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>label:</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>op_mnemonic</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>operand_source</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>,</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>operand_destination</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>;comment</code></p></td></tr></table></li><li><p>Ejemplo:</p><div class="ulist"><ul><li><p><code>bucle:  subq     $16,%rsp                ;RSP &#8592; RSP-16. Comienzo del bucle con la operación substraction</code></p></li><li><p><code>je       bucle                   ;je: jump equal: salto si la última operación dió resultado cero</code></p></li><li><p><code>suma:   addl     %esi,%eax               ;EAX &#8592; EAX+M[ESI] . Sumar</code></p></li><li><p><code>movw     %ax,resultado           ;AX &#8592; M[resultado]. Copiar el resultado</code></p></li></ul></div></li></ul></div></li><li><p>ETIQUETA</p><div class="ulist"><ul><li><p>Se especifica en la primera columna. Tiene el sufijo <strong>:</strong></p></li></ul></div></li><li><p>CODIGO DE OPERACION: Se utilizan símbolos <em>mnemónicos</em> que ayudan a interpretar intuitivamente la operación. Pej: ADD sumar, MOV mover, SUB restar, &#8230;&#8203;</p></li><li><p>OPERANDO FUENTE Y/O DESTINO</p><div class="ulist"><ul><li><p>dato alfanumérico: representación alfanumérica 	&#8594; 16</p><div class="ulist"><ul><li><p>direccionamiento <em>inmediato</em>: prefijo <strong>$</strong></p></li></ul></div></li><li><p>dirección de memoria externa: etiqueta		&#8594; resultado</p><div class="ulist"><ul><li><p>direccionamiento <em>directo</em></p></li></ul></div></li><li><p>registros internos de la CPU: %rax,%rbx,%rsp,%esi,..</p><div class="ulist"><ul><li><p>El prefijo <strong>%</strong> significa que el nombre hace referencia a un registro</p></li></ul></div></li><li><p>tamaño del dato operando: <strong>sufijos</strong> de los mnemónicos: q(quad):8 bytes, l(long):4 bytes, w(word):2 bytes, b(byte):1 byte.</p></li></ul></div></li></ul></div>
<div class="admonitionblock note"><table><tr><td class="icon"><i class="fa fa-info-circle" title="Note"></i></td><td class="content">La sintaxis del lenguaje ensamblador depende del traductor del proceso de ensamblaje (assembler) utilizado, en este caso, se utiliza el assembler GAS.</td></tr></table></div></div></section><section id="_operandos_modos_de_direccionamiento_2"><h2>5.8. Operandos: Modos de Direccionamiento</h2><div class="slide-content"><h level="3">Localización</h><div class="ulist"><ul><li><p>Ejemplo:</p><div class="ulist"><ul><li><p><code>bucle:  SUBQ     $16,%rsp                ;comienzo del bucle</code></p><div class="ulist"><ul><li><p>Operando fuente: $ indica direccionamiento INMEDIATO .El operando está en la propia instrucción &#8594; Operando=16</p></li><li><p>Operando destino: % indica REGISTRO. El operando está en el registro RSP</p></li></ul></div></li><li><p><code>suma:   ADDW     (%ESI),resultado        ;fin de operación</code></p><div class="ulist"><ul><li><p>Operando fuente: () indica INDIRECCION y % registro .El registro ESI continene la dirección de memoria donde está el operando</p></li><li><p>Operando destino: "resultado" es una etiqueta. Direccionamiento ABSOLUTO. El operando está en la dirección de memoria "resultado".</p></li></ul></div></li></ul></div></li></ul></div>
<h level="3">Modos de Direccionamiento</h><div class="ulist"><ul><li><p>Manual del assembler, apartado directivas dependientes de la arquitectura x86</p><div class="ulist"><ul><li><p><a href="https://sourceware.org/binutils/docs-2.26/as/i386_002dDependent.html#i386_002dDependent" class="bare">https://sourceware.org/binutils/docs-2.26/as/i386_002dDependent.html#i386_002dDependent</a>:</p></li></ul></div></li></ul></div>
<div class="admonitionblock important"><table><tr><td class="icon"><i class="fa fa-exclamation-circle" title="Important"></i></td><td class="content"><strong>RECOMENDABLE</strong> leerse los seis primeros apartados por lo menos</td></tr></table></div>
<div class="ulist"><ul><li><p>Direccionamientos:</p><table class="tableblock frame-all grid-all" style="width:100%"><colgroup><col style="width:20%" /><col style="width:80%" /></colgroup><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>INMEDIATO:</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>El valor del operando está ubicado inmediatamente después del código de operación de la instruccion. Unicamente se especifica el operando fuente.</code></p></td></tr><tr><td class="tableblock halign-left valign-top" rowspan="2"></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>sintaxis: el valor del operando se indica con el prefijo <strong>$</strong> .</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>ejemplo: <strong>movl $0xabcd1234, %ebx</strong>. El operando fuente es el valor 0xABCD1234</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>REGISTRO:</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>El valor del operando está localizado en un registro de la CPU.</code></p></td></tr><tr><td class="tableblock halign-left valign-top" rowspan="2"></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>sintaxis: Nombre del registro con el prefijo <strong>%</strong>.</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>ejemplo: <strong>movl %eax, %ebx</strong>. El operando fuente es el REGISTRO EAX y el destino es el REGISTRO EBX</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>DIRECTO:</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>La dirección efectiva apuntando al operando almacenado en la Memoria Principal es la dirección absoluta referenciada por la etiqueta especificada en el campo de operando. El programador utiliza el direccionamiento directo pero el compilador lo transforma en un direccionamiento relativo al contador de programa. Ver direccionamiento con desplazamiento.</code></p></td></tr><tr><td class="tableblock halign-left valign-top" rowspan="2"></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>sintaxis: una etiqueta definida por el programador</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>ejemplo: <strong>je somePlace</strong>   . Salto a la dirección marcada por la etiqueta somePlace si el resultado de la operación anterior activa el flag ZF=1 del registro RFLAG.</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>INDEXADO:</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>El valor del operando está localizado en memoria. La dirección efectiva apuntando a Memoria es la SUMA del valor del registro_base MAS scale POR el valor en el registro_índice, MAS el offset. <em>EA=Offset+R_Base+R_índice*Scale</em></code></p></td></tr><tr><td class="tableblock halign-left valign-top" rowspan="2"></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>sintaxis: lista de valores separados por coma y entre paréntesis (base_register, index_register, scale) y precedido por un offset.</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>ejemplo: <strong>movl $0x6789cdef, -16(%edx, %eax, 4)</strong> . La dirección efectiva del destino es  EDX + EAX*4 - 16.</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>INDIRECTO:</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Si  el modo general de indexación  lo particularizamos en <code>(base_register)</code> entonces la dirección del operando no se obtiene mediante una indexación sino que la dirección efectiva es el contenido de rdx y por lo tanto se accede al operando indirectamente.</code></p></td></tr><tr><td class="tableblock halign-left valign-top" rowspan="2"></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>sintaxis:  (base_register)</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>ejemplo: <strong>movl $0x6789cdef, (%edx)</strong> . La dirección efectiva del destino es  EDX. EDX es un puntero.</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>RELATIVO: registro base más un offset:</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>El valor del operando está ubicado en memoria. La dirección efectiva del operando es la suma del valor contenido en un registro base más un valor de offset.</code></p></td></tr><tr><td class="tableblock halign-left valign-top" rowspan="2"></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>sintaxis: registro entre paréntesis y el offset inmediatamente antes del paréntesis.</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>ejemplo: <strong>movl $0xaabbccdd, -12(%eax)</strong>  . La dirección efectiva del operando destino es  EAX-12</code></p></td></tr></table></li></ul></div>
<h level="4">Ejemplos</h><table class="tableblock frame-all grid-all" style="width:100%"><caption class="title">Table 9. Modos de Direccionamiento de los Operandos</caption><colgroup><col style="width:33.3333%" /><col style="width:33.3333%" /><col style="width:33.3334%" /></colgroup><thead><tr><th class="tableblock halign-left valign-top">Direccionamiento Operando</th><th class="tableblock halign-left valign-top">Valor Operando</th><th class="tableblock halign-left valign-top">Nombre del Modo</th></tr><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>$0</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Valor Cero</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Inmediato</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>%rax</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>RAX</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Registro</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>loop_exit</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>M[loop_exit]</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Directo</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>data_items(,%rdi,4)</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>M[data_item + 4*RDI]</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Indexado</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>(%rbx)</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>M[RBX]</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Indirecto</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>(%rbx,%rdi,4)</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>M[RBX + 4*RDI]</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Indirecto Indexado</code></p></td></tr></table>
<div class="ulist"><ul><li><p>M[loop_exit]: directo ya que loop_exit es una dirección de memoria externa y M indica la memoria externa.</p></li><li><p>M[RBX]: indirecto ya que RBX es una dirección de memoria interna y M indica memoria externa: A la mem. externa se accede a través de la mem. interna.</p></li></ul></div></div></section><section id="_programas_en_lenguaje_asm_y_lenguaje_binario"><h2>5.9. Programas en lenguaje ASM y lenguaje Binario</h2><div class="slide-content"><div class="ulist"><ul><li><p>Ejemplos en el <a href="#leng_asm">Apéndice</a></p></li></ul></div></div></section></section>
<section><section id="_programación_en_lenguaje_ensamblador_x86_construcciones_básicas_de_los_lenguajes_de_alto_nivel"><h2>6. Programación en Lenguaje Ensamblador (x86): Construcciones básicas de los lenguajes de alto nivel.</h2></section><section id="_temario_6"><h2>6.1. Temario</h2><div class="slide-content"><div class="olist arabic"><ol class="arabic"><li><p>Programación en lenguaje Ensamblador x86</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>x86 :Representación de Datos, Representación de Instrucciones, Modos de direccionamiento.</p></li><li><p>Sentencias de asignación</p></li><li><p>Sentencias condicionales</p></li><li><p>Bucles</p></li><li><p>LLamadas y retorno de funcion o subrutina</p></li></ol></div></li></ol></div></div></section><section id="_introducción_2"><h2>6.2. Introducción</h2><div class="slide-content"><h level="3">Objetivos</h><div class="ulist"><ul><li><p>Analizar la arquitectura del repertorio de las instrucciones máquina (Formato de instrucciones, formato de datos, operaciones y direccionamiento de operandos) de la arquitectura x86-64 para su utilización en el desarrollo práctico de programas en lenguaje ensamblador Gnu_AS(gas).</p></li><li><p>Capacidad para desarrollar pequeños programas en lenguaje ensamblador para la arquitectura x86 (32 bits) tanto en papel impreso como en un entorno de desarrollo computacional bien en el ordenador personal y también en las estaciones de trabajo del Laboratorio de Informática.</p></li></ul></div>
<h level="3">Requisitos</h><div class="ulist"><ul><li><p>Requisitos:</p><div class="ulist"><ul><li><p>Von Neumann Architecture: Arquitectura de una Computadora, Máquina IAS.</p></li><li><p>Programación en lenguaje ensamblador IAS</p></li><li><p>Representacion de datos</p></li><li><p>Operaciones Aritméticas y Lógicas</p></li><li><p>Representación de las Instrucciones</p><div class="ulist"><ul><li><p><a href="#gas_sintax_direcci">Sintaxis y Direccionamiento ASM x86</a>: Sintaxis de las instrucciones en lenguaje ensamblador GnuAS y modos de direccionamiento para la arquitectura x86.</p></li></ul></div></li></ul></div></li></ul></div>
<h level="3">Referencias</h><div class="ulist"><ul><li><p>Manual Assembler as: <a href="#toolchain">Apéndice: Cadena de herramientas Toolchain "as i386"</a></p></li><li><p><strong>Leerse</strong> los ocho primeros apartados del manual "Assembler as": <a href="#assembler_as_i386">Apéndice: Características "as i386"</a></p></li><li><p>Manual Assembler as: <a href="#assembler_as_directivas_i386">Apéndice: Directivas "as i386"</a></p></li><li><p>Referencias a manuales en el <a href="#leng_asm">Apéndice</a></p></li><li><p>Bibliografía: <a href="#prog_ensamblador">Programación Ensamblador</a>.</p></li><li><p>Apuntes completos <a href="#WikiBook">WikiBook</a> de programación en lenguaje AT&amp;T con diversidad de aspectos.</p></li></ul></div></div></section><section id="_estructura_de_la_computadora_con_arquitectura_intel_x86_64"><h2>6.3. Estructura de la  Computadora con Arquitectura Intel x86-64</h2><div class="slide-content"><h level="3">Manuales Intel ISA x86</h><div class="ulist"><ul><li><p><a href="https://www.intel.es/content/www/es/es/architecture-and-technology/64-ia-32-architectures-software-developer-vol-1-manual.html" class="bare">https://www.intel.es/content/www/es/es/architecture-and-technology/64-ia-32-architectures-software-developer-vol-1-manual.html</a></p></li><li><p>8 Volúmenes: 1,2A,2B,2C,3A,3B,3C,3D</p><div class="ulist"><ul><li><p>Volume 1: Basic Architecture</p></li><li><p>Volumes 2A, 2B and 2C: Instruction Set Reference</p></li><li><p>Volumes 3A, 3B, 3C and 3D: System Programming Guide</p></li></ul></div></li></ul></div>
<h level="3">Intro</h><div class="ulist"><ul><li><p>Para poder programar en lenguaje ensamblador GAS x86 eficazmente es necesario tener las nociones básicas de la ISA x86.</p></li><li><p>Se va analizar la arquitectura amd64 de 64 bits que abarca también a la arquitectura i386 de 32 bits.</p></li><li><p>Las empresas Intel y AMD comparten dichas arquitecturas cuyo  mercado abarca tanto ordenadores de sobremesa como servidores.</p></li></ul></div>
<h level="3">CPU-Memoria</h><div class="ulist"><ul><li><p>Ver la estructura general de una computadora en el <a href="#estr_comp">Apéndice</a></p></li></ul></div>
<h level="3">Registros internos a la CPU x86</h><h level="4">introducción</h><div class="ulist"><ul><li><p>Registos NO accesibles por el programador en la arquitectura amd64</p><div class="ulist"><ul><li><p>PC: Contador del Programa : x86 lo denomina RIP: 64 bits</p></li><li><p>IR: Registro de instrucción : 64 bits</p></li><li><p>MBR: Registro buffer de Memoria : 64 bits &#8594; WORD SIZE : 64</p></li><li><p>MAR: Registro de direcciones de Memoria: 40 bits</p><div class="ulist"><ul><li><p>Capacidad de Memoria: 2<sup>40</sup> : 1TB</p></li></ul></div></li></ul></div></li><li><p>Para el caso de la arquitectura i386 sustituir 64 bits por 32 bits y el registro MAR también es de 32 bits.</p></li></ul></div>
<h level="4">Registros visibles al programador</h><table class="tableblock frame-all grid-all" style="width:50%"><colgroup><col style="width:20%" /><col style="width:20%" /><col style="width:20%" /><col style="width:20%" /><col style="width:20%" /></colgroup><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>63-0</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>31-0</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>15-0</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>15-8</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>7-0</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>rax</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>eax</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>ax</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>ah</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>al</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>rbx</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>ebx</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>bx</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>bh</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>bl</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>rcx</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>ecx</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>cx</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>ch</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>cl</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>rdx</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>edx</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>dx</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>dh</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>dl</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>rsi</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>esi</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>si</code></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>sil</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>rdi</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>edi</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>di</code></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>dil</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>rbp</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>ebp</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>bp</code></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>bpl</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>rsp</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>esp</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>sp</code></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>spl</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r8</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r8d</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r8w</code></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r8b</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r9</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r9d</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r9w</code></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r9b</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r10</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r10d</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r10w</code></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r10b</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r11</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r11d</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r11w</code></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r11b</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r12</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r12d</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r12w</code></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r12b</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r13</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r13d</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r13w</code></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r13b</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r14</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r14d</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r14w</code></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r14b</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r15</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r15d</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r15w</code></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r15b</code></p></td></tr></table>
<h level="4">Compatibilidad 32-64</h><div class="ulist"><ul><li><p>En la nominación de los registros de la arquitectura de 64 bits sustituir R  por E y obtenemos la nominación de la arquitectura de 32 bits.</p></li></ul></div>
<table class="tableblock frame-all grid-all" style="width:50%"><colgroup><col style="width:50%" /><col style="width:50%" /></colgroup><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock">64 bits</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">32 bits</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">RIP</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">EIP</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">RAX</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">EAX</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">RFLAG</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">EFLAG</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">&#8230;&#8203;&#8230;&#8203;.</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">&#8230;&#8203;&#8230;&#8203;&#8230;&#8203;&#8230;&#8203;.</p></td></tr></table>
<div class="ulist"><ul><li><p>Hay excepciones</p></li></ul></div>
<h level="4">Control Flag Register</h><div class="ulist"><ul><li><p>Registro de STATUS: La ejecución de una instrucción, activa unos bits denominados banderines que indican consecuencias de la operación realizada. Ejemplo: banderín de overflow : indica que la operación aritmética realizada ha resultado en un desbordamiento del resultado de dicha operación.</p></li><li><p><a href="http://en.wikipedia.org/wiki/FLAGS_register_(computing)">wikipedia</a></p></li><li><p>Unicamente nos fijamos en los flags OSZAPC.</p><table class="tableblock frame-all grid-all" style="width:50%"><caption class="title">Table 10. RFLAG Register</caption><colgroup><col style="width:33.3333%" /><col style="width:33.3333%" /><col style="width:33.3334%" /></colgroup><thead><tr><th class="tableblock halign-left valign-top">Flag</th><th class="tableblock halign-center valign-top">Bit</th><th class="tableblock halign-left valign-top">Name</th></tr><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock">CF</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Carry flag</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">PF</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Parity flag</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">AF</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Adjust flag</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">ZF</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">6</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Zero flag</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">SF</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Sign flag</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">OF</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">11</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Overflow flag</p></td></tr></table></li><li><p>Carry flag:</p><div class="ulist"><ul><li><p>se activa si la llevada afecta a una posición de bit mayor que del ancho de palabra (word size) de la ALU en una operación aritmética de números enteros sin signo o con signo</p></li></ul></div></li><li><p>Overflow flag:</p><div class="ulist"><ul><li><p>se activa si teniendo en cuenta el bit de mayor peso MSB (aunque esté fuera el word size) indicase error en la operación aritmética con números enteros con signo. Si no se tiene en cuenta el MSB fuera del word size, la operación es correcta.</p></li></ul></div></li><li><p>Parity Even flag:</p><div class="ulist"><ul><li><p>indica si el número de bits del byte LSB del resultado de la última operación ha sido par.</p></li></ul></div></li><li><p>Sign flag:</p><div class="ulist"><ul><li><p>se activa si el resultado de la última operación ha sido negativo.</p></li></ul></div></li><li><p>Adjust flag:</p><div class="ulist"><ul><li><p>se activa si hay llevada en el nibble LSB del resultado de la última operación</p></li></ul></div></li></ul></div>
<h level="4">Casos de Overflow</h><div class="admonitionblock important"><table><tr><td class="icon"><i class="fa fa-exclamation-circle" title="Important"></i></td><td class="content">Ejemplos de errores matemáticos por overflow: <a href="#of_cf_unsigned_signed">activación de los flags CF y OF</a></td></tr></table></div>
<h level="4">Otros Registros internos a la CPU x86</h><div class="imageblock"><img src="./images/instrucciones_representacion/registers_1200x800.png" alt="registers 1200x800" /></div>
<div class="ulist"><ul><li><p>Segment Registers: CS,DS,ES,FS,GS,SS</p><div class="ulist"><ul><li><p><a href="https://en.wikipedia.org/wiki/X86_memory_segmentation" class="bare">https://en.wikipedia.org/wiki/X86_memory_segmentation</a></p></li><li><p>Normalmente se utilizan de forma implicita: las instrucciones están en el segmento de código en direcciones relativas al registro CS, los datos están el segment data en direcciones relativas al registro DS, la pila están el segmento stack en direcciones relativas al registro SS.</p></li><li><p>utilización explícita:</p><div class="ulist"><ul><li><p><code>movl $42, %fs:(%eax)  ; M[fs:eax]&#8592;42) ; eax contiene la dirección relativa a la dirección FS</code></p></li></ul></div></li><li><p>El Sistema Operativo utiliza los registros segmento en la gestión de memoria virtual mediante los mecanismos de paginación y segmentación: <a href="https://nixhacker.com/segmentation-in-intel-64-bit/" class="bare">https://nixhacker.com/segmentation-in-intel-64-bit/</a> : La gestión de la memoria es un tema de la segunda parte de la asignatura.</p></li></ul></div></li><li><p>Los registros fp, mmx y xmm se utilizan para ejecutar instrucciones complejas como la tangente que operan con números reales en coma flotante o instrucciones que ejecutan operaciones sobre múltiples datos enteros (Single Instruction Multiple Data) (P.ej producto escalar).</p></li><li><p>Más información en el <a href="#fpu_x87">apéndice FPU_x87</a></p></li></ul></div></div></section><section id="_representación_de_los_datos_en_lenguaje_ensamblador_asm_para_la_arquitectura_i386amd64"><h2>6.4. Representación de los datos en lenguaje ensamblador (ASM) para la arquitectura i386/amd64</h2><div class="slide-content"><h level="3">Tipos de Datos</h><h level="4">Números y Caracteres</h><div class="ulist"><ul><li><p>Número sin signo (naturales): codificación binario natural</p></li><li><p>Números enteros con signo: entero codificados en <strong>complemento a 2</strong></p></li><li><p>Números reales reales codificados en formato <strong>IEEE-754</strong> de simple o doble precisión</p></li><li><p>Caracteres alfanuméricos: código <strong>ASCII</strong></p></li></ul></div>
<h level="4">Directivas de la Sección de Datos</h><div class="ulist"><ul><li><p>Referencia <a href="#assembler_as_directivas_i386">Apéndice</a></p></li></ul></div>
<table class="tableblock frame-all grid-all" style="width:100%"><caption class="title">Table 11. Directivas básicas</caption><colgroup><col style="width:50%" /><col style="width:50%" /></colgroup><thead><tr><th class="tableblock halign-left valign-top">Directivas</th><th class="tableblock halign-left valign-top">descripción</th></tr><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.global o .globl etiqueta</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">variables globales</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.section .data</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">sección de las variables locales estáticas inicializadas</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.section .text</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">sección de las instrucciones</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.section .bss</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">sección de las variables sin inicializar</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.section .rodata</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">sección de las variables de sólo lectura</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.type	  name , type description</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">tipo de variable, p.ej @function</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.common   100</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">reserva 100 bytes sin inicializar y puede ser referenciado globalmente</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.lcomm   bucle, 100</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">reserva 100bytes referenciados con el símbolo local bucle. Sin inicializar.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.space    100</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">reserva 100 bytes inicializados a cero</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.space    100, 3</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">reserva 100 bytes inicializados a 3</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.string  "Hola"</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">añade el byte 0 al final de la cadena</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.asciz   "Hola"</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">añade el byte 0 al final de la cadena</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.ascii   "Hola"</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">no añade le caracter NULL de final de cadena</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.byte    3,7,-10,0b1010,0xFF,0777</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">tamaño 1Byte y formatos decimal,decimal,decimal,binario,hexadecimal,octal</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.2byte    3,7,-10,0b1010,0xFF,0777</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">tamaño 2Bytes</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.word    3,7,-10,0b1010,0xFF,0777</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">tamaño 2Bytes</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.short   3,7,-10,0b1010,0xFF,0777</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">tamaño 2B</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.4byte    3,7,-10,0b1010,0xFF,0777</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">tamaño 4B</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.long    3,7,-10,0b1010,0xFF,0777</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">tamaño 4B</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.int     3,7,-10,0b1010,0xFF,0777</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">tamaño 4B</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.8byte    3,7,-10,0b1010,0xFF,0777</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">tamaño 8B</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.quad    3,7,-10,0b1010,0xFF,0777</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">tamaño 8B</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.octa    3,7,-10,0b1010,0xFF,0777</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">formato octal</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.double  3.14159, 2 E-6</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">precisión doble</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.float   2E-6, 3.14159</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">precisión simple</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.single  2E-6</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">precisión simple</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.include "file"</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">incluye el fichero . Obligatorias las comillas.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.equ     SUCCESS, 0</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">macro que asocia el símbolo SUCCESS al número 0</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.macro macname macargs</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">define el comienzo de una macro de nombre macname y argumentos macargs</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.endmacro</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">define el final de una macro</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.align   n</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">las instrucciones o datos posteriores empezarán en una dirección multiplo de n bytes.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.end</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">fin del ensamblaje</p></td></tr></table>
<div class="ulist"><ul><li><p>Et: Etiqueta</p></li></ul></div>
<h level="3">Tamaño del operando x86</h><div class="ulist"><ul><li><p>Tamaño del operando: sufijos de los MNEMÓNICOS.</p><div class="listingblock"><div class="content"><pre>q (quad) 8bytes
l (long) 4bytes
w (word) 2bytes
b (byte) 1byte</pre></div></div>
<div class="ulist"><ul><li><p>Ejemplos:</p><div class="ulist"><ul><li><p>movq  %rax,resultado</p></li><li><p>movl  %eax,resultado</p></li><li><p>movw  %ax,resultado</p></li><li><p>movb  %ah,resultado</p></li></ul></div></li></ul></div></li></ul></div>
<h level="3">Alineamiento de Bytes: Big-Little Endian</h><div class="ulist"><ul><li><p>Los bytes de un dato de varios bytes se pueden almacenar en memoria en sentido MSB-<em><em>_- LSB ó MSB-</em>_</em>-LSB</p></li><li><p>Alineamiento <em>Little Endian</em>: El byte de menor peso LSB se almacena en la posición de memoria más baja</p></li><li><p>Ejemplo <strong>0x40000: 00 AF BF CF</strong></p><div class="ulist"><ul><li><p>En la posición de memoria principal 0x40000 está almacenado el dato de 4 bytes: <code>00 AF BF CF</code></p><div class="ulist"><ul><li><p>Los bytes se guardan en dirección de memoria ascendente. Cuando se escribe en horizontal, ascendente significa de izda a dcha.</p></li><li><p>En la posición <strong>0x40000</strong> está el byte 00 &#8594; <strong>LSB</strong> (Least Significant Byte)</p></li><li><p>En la posición <strong>0x40001</strong> está el byte AF</p></li><li><p>En la posición <strong>0x40002</strong> está el byte BF</p></li><li><p>En la posición <strong>0x40003</strong> está el byte CF &#8594; <strong>MSB</strong> (Most Significant Byte)</p><div class="listingblock"><div class="content"><pre>DIRECCIONES         CONTENIDO

              +----------------------+
   0x00000    |                      |
              +----------------------+
   0x00001    |                      |
              +----------------------+
   0x00002    |                      |
              +----------------------+
              |                      |
              +----------------------+
              |                      |
              +----------------------+
              |                      |
              +----------------------+
   0x40000    |          00          | LSB
              +----------------------+
   0x40001    |          AF          |
              +----------------------+
   0x40002    |          BF          |
              +----------------------+
   0x40003    |          CF          | MSB
              +----------------------+
              |                      |
              +----------------------+
              |                      |
              +----------------------+
              |                      |
              +----------------------+
   0xfffff    |                      |
              +----------------------+</pre></div></div></li></ul></div></li><li><p>El byte de menor peso se almacena en la posición de memoria más baja. La posición más baja de las cuatro es la 0x4000 donde se almacena el 00, luego este es el byte de menor peso. El dato almacenado en formato little-endian  es el <strong>0xCFBFAF00</strong>.</p></li><li><p>La arquitectura i386/amd64 utiliza LITTLE ENDIAN</p></li></ul></div></li><li><p>Tipos de información que siguen el formato little endian.</p><div class="ulist"><ul><li><p>Para las instrucciones el formato es por campos por lo que no tiene sentido hablar de posiciones de mayor o menor peso de la instrucción por lo que no siguen el formato little endian.</p></li><li><p>Las cadenas de caracteres (strings) no representan un valor y por lo tanto no siguen el formato little endian.</p></li><li><p>Los números enteros se almacenan siguiendo el formato little endian.</p></li><li><p>Los números reales se almacenan siguiendo el formato little endian</p></li><li><p>Las direcciones de memoria se almacenan siguiendo la organización Little Endian.</p></li></ul></div></li><li><p>Formato Big Endian</p><div class="ulist"><ul><li><p>El orden de almacenamiento es el inverso al little endian, es decir, el byte LSB del dato se almacena en la dirección de memoria mayor de la región que ocupa el dato.</p></li></ul></div></li></ul></div>
<h level="3">Ejemplo</h><div class="ulist"><ul><li><p>Analizar el código del programa <a href="#sum1toN_att_32">sum1toN att x86-32</a></p></li></ul></div></div></section><section id="repertorio_instruc_oper"><h2>6.5. Repertorio de Instrucciones en lenguaje ensamblador (ASM) para la arquitectura i386/amd64: Operaciones</h2><div class="slide-content"><h level="3">Ejemplo</h><div class="ulist"><ul><li><p>En cada apartado que se estudia a continuación analizar el código del programa <a href="#sum1toN_att_32">sum1toN att x86-32</a> interpretando los códigos de operación.</p></li></ul></div>
<h level="3">Manual rápido</h><div class="ulist"><ul><li><p><a href="http://www.felixcloutier.com/x86/">manual Intel quick</a>: <strong>recomendado</strong></p></li></ul></div>
<h level="3">Manuales y Tablas</h><div class="ulist"><ul><li><p>Referencias a manuales en el <a href="#leng_asm">Apéndice</a></p></li></ul></div>
<h level="3">Tipo de descripción de Códigos de Operación en el Manual de Intel</h><h level="4">Operación MOV</h><div class="ulist"><ul><li><p><a href="http://www.cs.nyu.edu/~mwalfish/classes/ut/s13-cs439/ref/i386/MOV.htm">MOV</a></p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-sh" data-lang="sh">MOV -- Move Data

Opcode   Instruction       Clocks        Description

88  /r   MOV r/m8,r8       2/2           Move byte register to r/m byte
89  /r   MOV r/m16,r16     2/2           Move word register to r/m word
89  /r   MOV r/m32,r32     2/2           Move dword register to r/m dword
8A  /r   MOV r8,r/m8       2/4           Move r/m byte to byte register
8B  /r   MOV r16,r/m16     2/4           Move r/m word to word register
8B  /r   MOV r32,r/m32     2/4           Move r/m dword to dword register
8C  /r   MOV r/m16,Sreg    2/2           Move segment register to r/m word
8D  /r   MOV Sreg,r/m16    2/5,pm=18/19  Move r/m word to segment register
A0       MOV AL,moffs8     4             Move byte at (seg:offset) to AL
A1       MOV AX,moffs16    4             Move word at (seg:offset) to AX
A1       MOV EAX,moffs32   4             Move dword at (seg:offset) to EAX
A2       MOV moffs8,AL     2             Move AL to (seg:offset)
A3       MOV moffs16,AX    2             Move AX to (seg:offset)
A3       MOV moffs32,EAX   2             Move EAX to (seg:offset)
B0 + rb  MOV reg8,imm8     2             Move immediate byte to register
B8 + rw  MOV reg16,imm16   2             Move immediate word to register
B8 + rd  MOV reg32,imm32   2             Move immediate dword to register
C6       MOV r/m8,imm8     2/2           Move immediate byte to r/m byte
C7       MOV r/m16,imm16   2/2           Move immediate word to r/m word
C7       MOV r/m32,imm32   2/2           Move immediate dword to r/m dword</code></pre></div></div>
<div class="ulist"><ul><li><p>MOV NO afecta a ningún flag</p></li><li><p>dword :double word: 32 bits</p></li><li><p>r8: registro de 8 bits</p></li><li><p>r/m8 : registro de cualquier tamaño o posición de memoria de 8 bits</p></li><li><p>imm8 : operando inmediato de 8 bits</p></li><li><p>reg8 : registro de 8 bits</p></li><li><p>Sreg : registros segmento &#8594; CS,DS,ES,FS,GS,SS</p></li><li><p>The moffs8, moffs16, and moffs32 operands specify a simple offset relative to the segment base, where 8, 16, and 32 refer to the size of the data. The address-size attribute of the instruction determines the size of the offset, either 16 or 32 bits.</p><div class="listingblock"><div class="content"><pre>https://www.intel.es/content/www/es/es/architecture-and-technology/64-ia-32-architectures-software-developer-vol-1-manual.html
3.7.4 Specifying a Segment Selector
The segment selector can be specified either implicitly or explicitly. [...] The processor automatically chooses a segment according to the rules given in Table 3-5.

SS Any memory reference which uses the ESP or EBP register as a base register.

DS All data references, except when relative to stack or string destination.</pre></div></div></li></ul></div></li></ul></div>
<div class="admonitionblock caution"><table><tr><td class="icon"><i class="fa fa-fire" title="Caution"></i></td><td class="content">la sintaxis del lenguage ASM de los manuales  no es  la sintaxis de AT&amp;T sino Intel &#8594;  mnemónico operando_destino, operando fuente</td></tr></table></div></div></section><section id="mnemonicos_basicos_explicados"><h2>6.6. Mnemónicos Básicos (Explicados)</h2><div class="slide-content"><h level="3">Operaciones aritméticas</h><div class="ulist"><ul><li><p><a href="https://www.felixcloutier.com/x86/mul">mul</a>: multiplicación de números naturales, sin signo</p><div class="listingblock"><div class="content"><pre>Performs an unsigned multiplication of the first operand (destination operand) and the second operand (source operand) and stores the result in the destination operand. The destination operand is an implied operand located in register AL, AX or EAX (depending on the size of the operand); the source operand is located in a general-purpose register or a memory location</pre></div></div></li><li><p><a href="https://www.felixcloutier.com/x86/imul">imul</a>: multiplicación de números enteros con signo</p><div class="ulist"><ul><li><p>Puede tener 1,2 o 3 operandos</p></li><li><p><code>imull Etiqueta</code> :  R[ %edx ]:R[ %eax ] ← M[Etiqueta] × R[ %eax ]</p><div class="listingblock"><div class="content"><pre>Performs a signed multiplication of two operands. This instruction has three forms, depending on the number of operands.

    One-operand form — This form is identical to that used by the MUL instruction. Here, the source operand (in a general-purpose register or memory location) is multiplied by the value in the AL, AX, EAX, or RAX register (depending on the operand size) and the product (twice the size of the input operand) is stored in the AX, DX:AX, EDX:EAX, or RDX:RAX registers, respectively.</pre></div></div></li></ul></div></li><li><p><a href="https://www.felixcloutier.com/x86/div">div</a>: división de números naturales, sin signo</p></li><li><p><a href="https://www.felixcloutier.com/x86/idiv">idiv</a>: división de números enteros con signo</p><div class="ulist"><ul><li><p>Puede tener 1,2 o 3 operandos</p><div class="listingblock"><div class="content"><pre>Divides the (signed) value in the AX, DX:AX, or EDX:EAX (dividend) by the source operand (divisor) and stores the result in the AX (AH:AL), DX:AX, or EDX:EAX registers. The source operand can be a general-purpose register or a memory location. The action of this instruction depends on the operand size (dividend/divisor).

Non-integral results are truncated (chopped) towards 0</pre></div></div></li><li><p><code>idiv</code></p><div class="ulist"><ul><li><p>EAX&#8592;Cociente{[EDX:EAX]/M[Op_fuente]} , EDX&#8592;Resto{[EDX:EAX]/M[Op_fuente]}</p></li></ul></div></li></ul></div></li></ul></div>
<h level="3">Extensión del signo</h><div class="ulist"><ul><li><p>movsbw src,Reg &#8594; Mov Sign Byte to Word</p></li><li><p>movsbl src,Reg &#8594; Mov Sign Byte to Long</p></li><li><p>movswl rc,Reg  &#8594; Mov Sign Word to Long</p></li></ul></div>
<h level="3">Cambio de tamaño</h><div class="ulist"><ul><li><p>movzbw src,Reg &#8594; Mov Byte to Word</p></li><li><p>movzbl src,Reg &#8594; Mov Byte to Long</p></li><li><p>movzwl src,Reg &#8594; Mov Word to Long</p></li></ul></div>
<h level="3">Operaciones Booleanas</h><div class="ulist"><ul><li><p><a href="https://www.felixcloutier.com/x86/not">NOT</a></p><div class="ulist"><ul><li><p>no flags</p></li></ul></div></li><li><p><a href="https://www.felixcloutier.com/x86/and">AND</a></p><div class="ulist"><ul><li><p>Clear CF,OF</p></li><li><p>Modifica SF,ZF,PF</p></li></ul></div></li><li><p><a href="https://www.felixcloutier.com/x86/or">OR</a></p><div class="ulist"><ul><li><p>Clear CF,OF</p></li></ul></div></li><li><p><a href="https://www.felixcloutier.com/x86/xor">XOR</a></p><div class="ulist"><ul><li><p>Clear CF,OF</p></li><li><p>Modifica SF,ZF,PF</p></li></ul></div></li></ul></div>
<h level="3">Procesamiento Condicional: CMP,TEST,SETcc</h><h level="4">CMP</h><div class="ulist"><ul><li><p><a href="https://www.felixcloutier.com/x86/cmp">CMP</a></p></li><li><p>Modifica CF,OF,SF,ZF,PF,AF</p></li><li><p>The condition codes used by the Jcc, CMOVcc, and SETcc instructions are based on the results of a CMP instruction</p></li><li><p>Compares the first source operand with the second source operand and sets the status flags in the EFLAGS register according to the results. The comparison is performed by subtracting the second operand from the first operand and then setting the status flags in the same manner as the <strong>SUB instruction</strong>. When an immediate value is used as an operand, it is sign-extended to the length of the first operand.</p><div class="ulist"><ul><li><p>Es decir, hay que saber interpretar la instrucción de resta SUB y en concreto el flag OF  para signed overflow y CF para unsigned overflow.</p></li><li><p>Ejercicios:</p><div class="ulist"><ul><li><p>Realizar el <a href="#cmp_ejercicio">ejercicio instrucción CMP</a> y también en el guión de prácticas que se estudia los saltos realizar la interpretación manual de las instrucciones CMP.</p></li></ul></div></li></ul></div></li></ul></div>
<h level="4">SUB</h><div class="ulist"><ul><li><p><a href="https://www.felixcloutier.com/x86/sub">SUB</a></p></li><li><p>Subtracts the second operand (source operand) from the first operand (destination operand) and stores the result in the destination operand. When an immediate value is used as an operand, it is sign-extended to the length of the destination operand format.</p></li><li><p>The SUB instruction performs integer subtraction.</p></li><li><p>It evaluates the result for both signed and unsigned integer operands and sets the OF and CF flags to indicate an overflow in the signed or unsigned result, respectively. The SF flag indicates the sign of the signed result.</p><div class="ulist"><ul><li><p>Es decir, realiza la resta tanto interpretando los operandos como números naturales y números con signo ya que la representación binaria del resultado es la misma. En caso de overflow utiliza el flag OF para la interpretación con signo y para el overflow sin signo el flag CF.</p></li></ul></div></li></ul></div>
<h level="4">TEST</h><div class="ulist"><ul><li><p><a href="https://www.felixcloutier.com/x86/test">TEST</a></p><div class="ulist"><ul><li><p>Computes the bit-wise logical <strong>AND</strong> of first operand (source 1 operand) and the second operand (source 2 operand)</p></li><li><p>Clear CF,OF</p></li><li><p>Modifica SF,ZF,PF</p></li></ul></div></li></ul></div>
<h level="4">SETcc</h><div class="ulist"><ul><li><p><a href="https://www.felixcloutier.com/x86/setcc">SETcc</a></p><div class="ulist"><ul><li><p>SETcc operand</p></li><li><p>No modifica ningún flag. Modifica el operando si se cumple la condición.</p></li></ul></div></li></ul></div>
<h level="4">MOV</h><div class="ulist"><ul><li><p><a href="https://www.felixcloutier.com/x86/mov">MOV</a></p><div class="ulist"><ul><li><p>La instrucción MOV no afecta a ningún flag del registro EFLAG</p></li></ul></div></li></ul></div>
<h level="3">Saltos</h><h level="4">Condicionales: Jcc</h><div class="ulist"><ul><li><p><a href="https://www.felixcloutier.com/x86/jcc">Jcc</a></p><div class="ulist"><ul><li><p>Comprueba la condición y si se cumple se ejecuta el salto a la dirección referenciada en el campo de operando.</p></li><li><p>jump short: el valor del operando es relativo al PC</p></li><li><p>Chequea los flags CF, OF, PF, SF, and ZF.</p></li><li><p>"less” and “greater”: compara números con signo: jl, jle, jg, jge, etc&#8230;&#8203;</p></li><li><p>“above” and “below” : compara números sin signo: ja, jae, jb, jbe, etc&#8230;&#8203;</p></li></ul></div></li><li><p>Antes de un salto condicional es necesario ejecutar algún tipo de instrucción donde la relación (aritmética, lógica, etc ) de los operandos sea condición para la ejecución del salto. Instrucciones previas pueden ser: CMP y TEST.</p></li></ul></div>
<h level="4">Indirectos</h><div class="paragraph"><p>Símbolo <code>*</code>:</p></div>
<div class="paragraph"><p>El Símbolo asterisco  para indicar indirección en los saltos y diferenciarlos del direccionamiento relativo.</p></div>
<div class="listingblock"><div class="content"><pre>jmp bucle   -&gt; salto relativo a EIP
jmp *bucle
jmp *eax
jmp *(eax)
jmp *(mem)
jmp *table(%ebx,%esi,4)</pre></div></div>
<div class="paragraph"><p>En cambio en los movimientos MOV no hace falta el símbolo asterisco ya que no hay movimientos con direccionamiento relativo.</p></div>
<h level="3">Desplazamiento y rotación</h><div class="ulist"><ul><li><p><code>sar</code>,<code>sal</code> : Shift Arithmetic Right, Shift Arithmetic Left.</p><div class="ulist"><ul><li><p>desplazamiento aritmético: El digito entrante por la izda o dcha es el bit de signo.</p><div class="listingblock"><div class="content"><pre>Shifts the bits in the first operand (destination operand) to the left or right by the number of bits specified in the second operand (count operand). Bits shifted beyond the destination operand boundary are first shifted into the CF flag, then discarded. At the end of the shift operation, the CF flag contains the last bit shifted out of the destination operand.</pre></div></div></li><li><p><code>sarl $31, %edx</code> : desplazamiento de 31 bits a la dcha y el bit entrante es el bit de signo el operando en EDX.</p></li></ul></div></li><li><p><code>shr</code>,<code>shl</code></p></li><li><p>desplazmiento lógico: entran ceros</p><div class="ulist"><ul><li><p>Ejemplos de multiplicación y división</p></li></ul></div></li><li><p>ROL,ROR : rotación hacia la izquierda y rotación hacia la derecha.</p><div class="ulist"><ul><li><p>el bit que sale fuera se copia en CF</p></li><li><p>Aplicación: conversión endianess</p></li></ul></div></li></ul></div>
<h level="3">Cambiar el Endianess</h><div class="listingblock"><div class="content"><pre>## Cambio del endianess en EAX. Previamente guarda el original de EAX y al final restaura EAX
swapbytes:
       xchg (%ebx), %eax
       bswap %eax
       xchg (%ebx), %eax</pre></div></div></div></section><section id="_formato_de_instrucción_isa_intel_x86_64"><h2>6.7. Formato de Instrucción: ISA Intel x86-64</h2><div class="slide-content"><div class="ulist"><ul><li><p>Apéndice <a href="#form_inst">Formato Instrucción</a></p></li></ul></div></div></section><section id="_subrutinas"><h2>6.8. Subrutinas</h2><div class="slide-content"><h level="3">Referencias</h><div class="ulist"><ul><li><p><a href="#ABI_i386">ABI x86-32</a></p></li><li><p><a href="#ms_llamada">Convenio de LLamada MicroSoft</a></p></li></ul></div>
<h level="3">Introducción</h><div class="ulist"><ul><li><p>Las subrutinas en lenguaje ensamblador son el equivalente a las funciones en el lenguaje de programación en C, por lo que es necesario repasar el concepto de función en el lenguaje C.</p></li><li><p>En la sesión de practicas 5 se programarán subrutinas.</p></li></ul></div>
<h level="3">Lenguaje C: Sentencia Función</h><h level="4">Introducción</h><div class="paragraph"><p>El objetivo de las funciones es descomponer el programa en módulos de código para dotar al programa de una estructura organizada que facilite el desarrollo del programa y su mantenimiento.
La librería standard "libc" son colecciones de funciones básicas desarrolladas en el lenguaje C que son reutilizadas por la mayoría de los programas. De esta manera el programador no tiene que inventar la rueda.
Por lo tanto en un programa coexisten funciones desarrolladas por el propio usuario en lenguaje C y funciones de librerías accesibles en código binario.</p></div>
<h level="4">Declaración</h><div class="ulist"><ul><li><p>La <strong>declaración</strong> de una función en lenguaje C se denomina <strong>prototipo</strong>. Ejemplo de prototipo: <code>int sumMtoN(short sumando1, short sumando2)</code>
donde</p><div class="ulist"><ul><li><p>Nombre: el nombre de la función es <em>sumMtoN</em></p></li><li><p>Argumentos: el nombre del primer argumento es <em>sumando1</em> y es del tipo short, el nombre del 2º argumento es <em>sumando2</em> y es del tipo shrot.</p></li><li><p>Tipo del valor de retorno: el tipo del valor de retorno es int.</p></li></ul></div></li></ul></div>
<h level="4">Definición</h><div class="ulist"><ul><li><p>La <strong>definición</strong> de la función <em>sumMtoN</em> consiste en desarrollar el algoritmo mediante sentencias de C, es decir, el cuerpo de la función:</p><div class="listingblock"><div class="content"><pre>int sumMtoN(short sumando1, short sumando2)   {
      //sumando2 &gt; sumando1
      short i;
      int resultado=0; // variable local a la función
      i=sumando2;
        while (i &gt;= sumando1) {
          resultado += i ;
          i--;
        }
      printf("\n\t Subrutina sumMtoN \n");
      return resultado;
    }</pre></div></div>
<div class="ulist"><ul><li><p>resultado es la variable que contiene el valor de retorno</p></li></ul></div></li></ul></div>
<h level="4">LLamada y Retorno</h><div class="ulist"><ul><li><p>La función <em>main()</em> llama a la función <em>sumMtoN()</em> la cual después de ser ejecutada devuelve el resultado de la suma.</p><div class="listingblock"><div class="content"><pre>/*
   Programa: sumMtoN.c
   Compilación: gcc -g -ggdb3 -o sumMtoN sumMtoN.c
                -ggdb3 : inserta en la tabla de símbolos del depurador información de macros
                https://gcc.gnu.org/onlinedocs/gcc-12.2.0/gcc/Debugging-Options.html#Debugging-Options
*/

// Prototipos de las funciones
#include &lt;stdio.h&gt;  // Declaración de la función printf()
#include &lt;stdlib.h&gt;  // Declaración de la función exit()

//Macros
#define SUCCESS   0

//Prototipos: declaración de la función sumMtoN()
int sumMtoN(short sumando1, short sumando2);

// Definición de la Función Principal main()
void main(void) {
       //Inicialización de los argumentos M y N de la función sumMtoN()
       short M=1, N=1, longitud;
       // Llamada a las funciones printf() y sumMtoN()
       longitud=printf("El resultado de la suma es %d \n", sumMtoN(M,N));
       printf("El número de caracteres de la cadena anterior impresa es %d\n",longitud);
       // La evaluación de sumMtoN consiste en:  llamar a la función y capturar el valor de retorno.
       // Llamada a la función exit
       exit(SUCCESS);
     }

// Definición de las Funciones
int sumMtoN(short sumando1, short sumando2)   {
      //sumando2 &gt; sumando1
      short i;
      int resultado=0; // variable local a la función
      i=sumando2;
        while (i &gt;= sumando1) {
          resultado += i ;
          i--;
        }
      printf("\n\t Subrutina sumMtoN \n");
      return resultado;
    }</pre></div></div>
<div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>La <strong>evaluación</strong> de sumMtoN() consiste enobtener el <strong>valor de retorno</strong> de la ejecución de la función <em>sumMtoN()</em></p></li><li><p>printf &#8594; sumMtoN : printf llama a sumMtoN , se evalua sumMtoN y se imprime el resultado de evaluar la función <em>sumMtoN()</em>.</p></li><li><p>El valor de retorno de la función printf() es el número de caracteres de la cadena impresa. Abrir un terminal y ejecutar el manual "man 3" para leer el apartado "RETURN VALUE".</p></li></ol></div></li></ul></div>
<h level="3">Anidamiento de Funciones</h><div class="ulist"><ul><li><p>Anidamiento de llamadas: init() &#8594; main() &#8594; sumMtoN() &#8594; printf() &#8594; write()</p></li><li><p>El shell el sistema operativo GNU/linux llama a la función principal main()  del programa de usuario, que a su vez llama a la función printf() de la librería libc , la cual a su vez llama a la función de usuario sumMtoN() y a la función  write() del sistema operativo.</p></li><li><p>Retorno:</p><div class="listingblock"><div class="content"><pre>write()---&gt;+
           |
           +--&gt;printf() -&gt; main () -&gt; exit()-&gt; shell
           |
sumMtoN()-&gt;+</pre></div></div></li></ul></div>
<h level="3">Pila/Frame</h><div class="ulist"><ul><li><p>Ver concepto de pila en el <a href="#pila">Apéndice</a>.</p></li><li><p>La pila es una <em>sección</em> del programa en ejecución en la memoria principal. A diferencia de la sección de datos y la sección de instrucciones la pila se crea en tiempo de ejecución ,no durante la carga en memoria.</p></li><li><p>Los argumentos M y N de la función <em>sumMtoN()</em> se pasan de la función main() a la función <em>sumMtoN()</em> a través de la pila.</p></li><li><p>Partición de la pila en frames: Cada función del programa tiene su zona limitada dentro del <em>segmento</em> de pila. A cada zona limitada asociada a cada función se le denomina <strong>frame</strong>. Por lo tanto en la sección pila se irán anidando frames cada vez que se llame a un función, e irán desapareciendo frames cada que vez que se retorne de un función.</p><div class="ulist"><ul><li><p>La función <em>main()</em> crea su frame cuando es llamada por el shell y la función <em>sumMtoN</em> crea su propio frame cuando es llamada por main().</p></li><li><p>Los frames se apilan según se anidan las llamadas a subrutinas. Y se desactivan según retornan.</p></li><li><p>Dinamismo: En un momento dado de la ejecución del programa el último frame generado es el frame activo.</p><div class="ulist"><ul><li><p>La parte baja del frame activo esta referenciada por el puntero EBP y la parte alta del frame (top) por el puntero ESP. Los términos bajo y alto hacen referencia a la dirección del <strong>apilamiento</strong> y no a direcciones de memoria. Parte baja y alta del apilamiento.</p></li></ul></div></li></ul></div></li></ul></div>
<h level="3">Argumentos de la subrutina</h><div class="ulist"><ul><li><p>Los argumentos deben de transferirse a través de la pila y antes de realizar la llamada.</p></li><li><p>Los argumentos se apilan uno detrás de otro comenzando por el último argumento y finalizando con el primer argumento.</p></li><li><p>Se apilan mediante la  instrucción <code>push argumento</code> donde el operando es el argumento a transferir.</p><div class="listingblock"><div class="content"><pre>push N
push M</pre></div></div></li></ul></div>
<h level="3">Llamada a la subrutina</h><div class="ulist"><ul><li><p>La rutina llamante <em>main</em> llama a la subrutina <em>sumMtoN</em> mediante la instrucción <code>call sumMtoN</code>. Por lo que la rutina <em>main</em> queda interrumpida hasta que finalice la ejecución de la subrutina <em>sumMtoN</em>.</p></li><li><p>La instrucción <code>call</code> se ejecuta en dos fases:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Apila la dirección de retorno: en la rutina <em>main</em> siguiente instrucción a <code>call sumMtoN</code>: <strong>ESP &#8592; ESP-4</strong> y  <strong>M[ESP] &#8592; PC</strong></p></li><li><p>Salta a la etiqueta <em>sumMtoN</em>: <strong>PC &#8592; sumMtoN</strong></p></li></ol></div></li><li><p>básicamente la instrucción call es una salto con retorno a la dirección donde fue interrumpida la rutina llamante.</p><div class="listingblock"><div class="content"><pre>push N
push M
call sumMtoN</pre></div></div></li></ul></div>
<h level="3">Definición de la subrutina</h><div class="ulist"><ul><li><p>Nombre: <em>sumMtoN</em></p></li><li><p>El nombre de la subrutina es la etiqueta que apunta a la primera instrucción de la subrutina.</p></li><li><p>La subrutina finaliza con la instrucción ret.</p></li><li><p>La subrutina está estructurada en 3 partes:</p><div class="ulist"><ul><li><p>Prólogo:</p><div class="olist lowerroman"><ol class="lowerroman" type="i"><li><p>Salvar los registros que van a ser modificados por el cuerpo de la subrutina.</p></li><li><p>Activar el nuevo frame inicializando los punteros <code>EBP</code> y <code>ESP</code>.</p></li></ol></div></li><li><p>Cuerpo:</p><div class="olist lowerroman"><ol class="lowerroman" type="i"><li><p>Capturar los argumentos y procesarlos</p></li></ol></div></li><li><p>Epílogo:</p><div class="olist lowerroman"><ol class="lowerroman" type="i"><li><p>Salvar el valor de retorno en el registro <code>EAX</code></p></li><li><p>Recuperar el valor de los registros salvados en el Prólogo</p></li><li><p>Activar el frame de la función que ha realizado la llamada actualizando <code>EBP</code> y <code>ESP</code> con sus antiguos valores.</p></li><li><p>Retorno a la función que ha realizado la llamada.</p></li></ol></div></li></ul></div></li><li><p>Código</p><div class="listingblock"><div class="content"><pre># Comienzo de la subrutina
sumMtoN:
# Prólogo
		push  %ebp 	# salvo el bottom del frame de la función llamante en la parte baja del nuevo frame
		mov   %esp,%ebp # configuro el puntero %ebp apuntando a la parte baja del nuevo frame
		push   xxx      # Si fuera necesario: salvar registros que se utilizarán en el Cuerpo de la subrutina
		push   xxx
# Cuerpo
		mov 8(%ebp),%ebx	#capturo el 1º argumento
		mov 12(%ebp),%ecx	#capturo el 2º argumento
		xxx xxx
		xxx xxx
# Epílogo
		mov resultado,%eax	#inicializo el valor de retorno
                pop   xxx               #recuperar registros que se salvaron en el prólogo
		pop   xxx
                mov %ebp,%esp
                pop %ebp
		ret</pre></div></div></li></ul></div>
<h level="3">Animación: anidamiento de llamadas</h><div class="ulist"><ul><li><p><a href="https://diveintosystems.org/book/C8-IA32/recursion.html" class="bare">https://diveintosystems.org/book/C8-IA32/recursion.html</a></p><div class="ulist"><ul><li><p>Programación de sum1toN por programación recurrente: la subrutina sum se llama así misma.</p></li><li><p>Visualización del crecimiento y decrecimiento de la pila con las sucesivas llamadas y retornos.</p></li></ul></div></li></ul></div>
<h level="3">Registros a Preservar</h><h level="4">Rutina llamante: arquitectura i386</h><div class="ulist"><ul><li><p>La rutina que realiza la llamada (caller routine) está obligada a preservar los siguientes registros si los está utilizando:</p><div class="ulist"><ul><li><p>EAX-ECX-EDX</p></li></ul></div></li></ul></div>
<div class="admonitionblock caution"><table><tr><td class="icon"><i class="fa fa-fire" title="Caution"></i></td><td class="content">Es decir, dichos registros pueden ser utilizados libremente por la subrutina llamada. En caso de no ser utilizados por la subrutina no sería necesario preservarlos. En caso de ser utilizados por la rutina principal se copiarían en la pila <strong>antes de realizar la llamada</strong> a la subrutina y serían recuperados al finalizar la subrutina.</td></tr></table></div>
<div class="ulist"><ul><li><p>Ejemplo:</p><div class="listingblock"><div class="content"><pre>mov $0,%edx     # asigno el valor cero al registro EDX
call subrutina
# AL VOLVER DE LA SUBRUTINA EDX no tiene porque valor CERO
add %edx,%edx # la operación no tiene porque ser 0+0</pre></div></div>
<div class="ulist"><ul><li><p>solución:</p><div class="listingblock"><div class="content"><pre>mov $0,%edx     # asigno el valor cero al registro EDX
push %edx	# salvo el valor de EDX en la pila

call subrutina

pop %edx	# recupero el valor de EDX desde la pila
add %edx,%edx   # realiza la operación 0+0</pre></div></div></li><li><p>lo mismo para los registros EAX y ECX</p></li></ul></div></li></ul></div>
<h level="4">Subrutina llamada: arquitectura i386</h><div class="paragraph"><p>La subrutina llamada (callee routine) está obligada a preservar los siguientes registros:</p></div>
<div class="ulist"><ul><li><p>EBX-ESP-EBP-ESI-EDI y X87CW</p></li></ul></div>
<div class="paragraph"><p>Es decir, dichos registros al finalizar la subrutina de mantener el mismo valor que antes de la llamada. En caso de no utilizarlos no sería necesario preservarlos</p></div>
<h level="4">Arquitectura amd64</h><div class="paragraph"><p>Caller routine: The registers RAX, RCX, RDX, R8, R9, R10, R11 are considered volatile and must be considered destroyed on function calls (unless otherwise safety-provable by analysis such as whole program optimization).</p></div>
<div class="paragraph"><p>Callee routine: The registers RBX, RBP, RDI, RSI, RSP, R12, R13, R14, and R15 are considered nonvolatile and must be saved and restored by a function that uses them.</p></div>
<h level="3">Retorno de la subrutina</h><div class="ulist"><ul><li><p>La última instrucción de la subrutina es <strong>RET</strong> cuya ejecución por la Unidad de Control de la CPU realiza las siguientes órdenes:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p><strong>PC &#8592; M[ESP]</strong> : extrae de la pila la dirección de retorno guardada por la instrucción <strong>CALL</strong> y la carga en el Contador de Programa, por lo que se ejecutará el ciclo de instrucción de la instrucción posterior a <strong>call sumMtoN</strong></p></li><li><p>Actualiza el stack pointer: <strong>ESP &#8592; ESP + 4</strong></p></li></ol></div></li><li><p>Es necesario que en el epílogo de la subrutina, antes de la ejecución de RET el stack pointer apunte a la dirección de la pila donde está almacenada la dirección de retorno.</p></li></ul></div>
<h level="3">Estado de la pila</h><h level="4">Análisis</h><div class="ulist"><ul><li><p>La pila es una estructura dinámica cuyo estado (registros puntero EIP,EBP,ESP) cambian según se realizan llamadas y retornos de subrutinas. Razonar el contenido de dichos registros y verificarlo con el depurador GDB.</p></li></ul></div>
<h level="4">Previo al salto  de la llamada a la subrutina</h><div class="ulist"><ul><li><p>Estado de la pila ejecutando la <em>rutina main</em> justo antes de ejecutar la instrucción <code>call sumMtoN</code>:</p><div class="ulist"><ul><li><p>El frame activo de la pila es el correspodiente a main.</p></li><li><p>Los últimos datos apilados en el <em>frame main</em> son los argumentos de <em>sumMtoN</em></p><div class="listingblock"><div class="content"><pre>	push N
	push M
	call sumMtoN</pre></div></div></li></ul></div></li><li><p>Analizar el contenido de los  registros EIP,EBP,ESP:</p><div class="ulist"><ul><li><p>EIP: instruction pointer    &#8594;</p></li><li><p>EBP: stack bottom pointer   &#8594;</p></li><li><p>ESP: stack top pointer      &#8594;</p></li></ul></div></li></ul></div>
<h level="4">Posterior al salto de la llamada a la subrutina</h><div class="ulist"><ul><li><p>Estado de la pila ejecutando la <em>subrutina sumMtoN</em> justo después de ejecutar el salto <code>call sumMtoN</code>:</p><div class="ulist"><ul><li><p>El frame activo de la pila es el correspodiente a main.</p></li><li><p>El último dato apilado en el frame main es la <em>dirección de retorno</em> a main desde sumMtoN</p></li></ul></div></li><li><p>Analizar el contenido de los  registros EIP,EBP,ESP:</p><div class="ulist"><ul><li><p>EIP: instruction pointer    &#8594;</p></li><li><p>EBP: stack bottom pointer   &#8594;</p></li><li><p>ESP: stack top pointer      &#8594;</p></li></ul></div></li></ul></div>
<h level="4">Creación del nuevo frame <em>sumMtoN</em></h><div class="ulist"><ul><li><p>Estado de la pila después de ejecutar:</p><div class="listingblock"><div class="content"><pre>sumMtoN:
	push %ebp
	mov  %esp,%ebp</pre></div></div></li><li><p>Analizar el contenido de los  registros EIP,EBP,ESP:</p><div class="ulist"><ul><li><p>EIP: instruction pointer    &#8594;</p></li><li><p>EBP: stack bottom pointer   &#8594;</p></li><li><p>ESP: stack top pointer      &#8594;</p></li></ul></div></li></ul></div>
<h level="4">Previo al salto de retorno</h><div class="ulist"><ul><li><p>Estado de la pila ejecutando la <em>subrutina sumMtoN</em> justo antes de ejecutar la instrucción <code>ret</code>:</p><div class="ulist"><ul><li><p>El frame activo de la pila es el correspodiente a sumMtoN.</p></li><li><p>El puntero del top <em>ESP</em>  del frame sumMtoN apunta a la dirección de pila que contiene la <em>dirección de retorno</em></p></li></ul></div></li><li><p>Analizar el contenido de los  registros EIP,EBP,ESP:</p><div class="ulist"><ul><li><p>EIP: instruction pointer    &#8594;</p></li><li><p>EBP: stack bottom pointer   &#8594;</p></li><li><p>ESP: stack top pointer      &#8594;</p></li></ul></div></li></ul></div>
<h level="4">Posterior al salto de retorno</h><div class="ulist"><ul><li><p>Estado de la pila ejecutando la <em>subrutina sumMtoN</em> justo después de ejecutar la instrucción <code>ret</code>:</p><div class="ulist"><ul><li><p>La ejecución de <code>ret</code> ha realizado las siguientes operaciones:</p><div class="ulist"><ul><li><p><code>pop %irp</code></p></li></ul></div></li><li><p>El frame activo de la pila es el correspodiente a main.</p></li></ul></div></li><li><p>Analizar el contenido de los  registros EIP,EBP,ESP:</p><div class="ulist"><ul><li><p>EIP: instruction pointer    &#8594;</p></li><li><p>EBP: stack bottom pointer   &#8594;</p></li><li><p>ESP: stack top pointer      &#8594;</p></li></ul></div></li></ul></div>
<h level="3">Ejercicios de programación práctica</h><div class="ulist"><ul><li><p>Ir al capítulo de <a href="#ejer_llamada_subru">Ejercicios</a></p></li></ul></div></div></section><section id="_llamadas_al_sistema_operativo"><h2>6.9. Llamadas al Sistema Operativo</h2><div class="slide-content"><h level="3">Introducción</h><div class="ulist"><ul><li><p>Se conoce con el nombre de <em>llamadas al sistema</em> a las Llamadas que realizar el programa de usuario a subrutinas del Kernel del Sistema Operativo.</p></li><li><p>Para realizar funciones privilegiadas del sistema operativo como el acceso a los dispositivos i/o de la computadora es necesario que los programas de usuario llamen al kernel para que sea éste quien realice la operación de una manera segura y eficaz. De esta forma se evita que el programador de aplicaciones acceda al hardware y al mismo tiempo se facilita la programación.</p></li><li><p>Ejemplos de llamadas</p><div class="ulist"><ul><li><p><strong>exit</strong> : el kernel suspende la ejecución del programa eliminando el proceso</p></li><li><p><strong>read</strong> : el kernel lee los datos de un fichero accediendo al disco duro</p></li><li><p><strong>write</strong>: el kernel escribe en un fichero</p></li><li><p><strong>open</strong> : el kernel abre un fichero</p></li><li><p><strong>close</strong>: el kernel cierra el proceso</p></li><li><p>más ejemplos de llamada en el listado <code>man 2 syscalls</code></p></li></ul></div></li><li><p>La llamada a los servicios del kernel denominados <em>syscalls</em> se puede realizar de dos formas: <strong>directa</strong> o <strong>indirecta</strong></p><div class="ulist"><ul><li><p>Directa: desde ASM mediante la instrucción <code>syscall</code></p></li><li><p>Indirecta: desde C o ASM mediante funciones de la librería <code>libc</code>: wrappers de las llamadas directas</p></li></ul></div></li><li><p>API/ABI</p><div class="listingblock"><div class="content"><pre> system call wrapper () -&gt; C function
          |
          | INDIRECTA
          v
+------------------------+
|     C library libc     |    syscall -&gt; assembly instruction
|         |              |
|         |              |      |
|         |              |      |DIRECTA
|         |              |      |
+---------|--------------+------|----+-------ABI
|         v                     v    |
|              kernel                |
|        (syscall functions)         |
+------------------------------------+
               HW</pre></div></div></li></ul></div>
<h level="3">Arquitectura amd64</h><h level="4">Códigos de llamada</h><div class="ulist"><ul><li><p>'/usr/include/asm/unistd_64.h ': declaración de macros con el código de la llamada en la arquitectura x86-64</p></li><li><p><em>/usr/include/bits/syscall.h</em>  : macros antiguas también válidas en la arquitectura x86-32</p></li></ul></div>
<h level="4">Argumentos</h><div class="ulist"><ul><li><p>Ejemplo arquitectura <strong>amd64</strong></p><div class="ulist"><ul><li><p>Para pasar los argumentos no se utiliza la pila (memoria externa) sino los registros RPG (memoria interna de la CPU)</p></li><li><p>Los 6 primeros argumentos se pasan a través de los registros: [RAX-RDI-RSI-RDX-R10-R8-R9] previamente a la instrucción de la llamada <code>syscall</code></p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">* printf() -&gt; write(int fd, const void *buf, size_t count) -&gt; [RAX-RDI-RSI-RDX-R10-R8-R9,syscall] -&gt; kernel syscall write
* API      -&gt;        wrapper function                      -&gt;                ABI                  -&gt;  kernel syscall</code></pre></div></div></li></ul></div></li></ul></div>
<h level="4">Ejemplos amd64</h><div class="ulist"><ul><li><p>Ver en el <a href="#llamadas_SO">Apéndice</a></p></li></ul></div>
<h level="3">Arquitectura i386</h><h level="4">Norma</h><div class="ulist"><ul><li><p>ABI SystemV i386: Aplication Binary Interface (ABI)</p><div class="ulist"><ul><li><p>La norma ABI SystemV i386 es la norma oficial donde se describe la interfaz binaria, es decir, como se comunican los distintos módulos de un programa a nivel binario, a  nivel de lenguaje máquina.</p></li><li><p>La llamada al kernel se realiza mediante la instrucción <code>int $0x80</code> donde int es el mnemónico de interrupción (se interrumpe el programa de usuario en ejecución para llamar a una función del kernel)</p></li></ul></div></li></ul></div>
<h level="3">Códigos de llamada</h><div class="ulist"><ul><li><p><em>/usr/include/asm/unistd_32.h</em> : declaración de macros con el código de la llamada</p><div class="ulist"><ul><li><p><em>/usr/include/bits/syscall.h</em>: macros antiguas también válidas</p></li></ul></div></li><li><p>llamadas típicas:</p><div class="ulist"><ul><li><p><strong>exit-fork-read-write-open-close-&#8230;&#8203;</strong></p><table class="tableblock frame-all grid-all" style="width:80%"><colgroup><col style="width:10%" /><col style="width:10%" /><col style="width:80%" /></colgroup><thead><tr><th class="tableblock halign-center valign-top" colspan="3">exit - terminate current process</th></tr><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock">In</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">eax</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock">ebx</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">return code</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Out</p></td><td class="tableblock halign-left valign-top" colspan="2"><p class="tableblock">(This call does not return)</p></td></tr><tr><td class="tableblock halign-center valign-top" colspan="3"><p class="tableblock"><strong>fork - create child process</strong></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">In</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">eax</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Out</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">eax</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">0 in the clone; process id of clone or EAGAIN or ENOMEM in caller</p></td></tr><tr><td class="tableblock halign-center valign-top" colspan="3"><p class="tableblock"><strong>read - read from file or device</strong></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">In</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">eax</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock">ebx</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">file descriptor</p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock">ecx</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">address of the buffer to read into</p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock">edx</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">maximum number of bytes to read</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Out</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">eax</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">number of bytes actually read  :  EAGAIN  :  EBADF  :  EFAULT  :  EINTR  :  EINVAL  :  EIO  :  EISDIR</p></td></tr><tr><td class="tableblock halign-center valign-top" colspan="3"><p class="tableblock"><strong>write - write to file or device</strong></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">In</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">eax</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock">ebx</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">file descriptor</p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock">ecx</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">address of the buffer to write from</p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock">edx</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">maximum number of bytes to write</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Out</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">eax</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">number of bytes actually sent  :  EAGAIN  :  EBADF  :  EFAULT  :  EINTR  :  EINVAL  :  EIO  :  ENOSPC  :  EPIPE</p></td></tr><tr><td class="tableblock halign-center valign-top" colspan="3"><p class="tableblock"><strong>open - open, create, or truncate a file or device</strong></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">In</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">eax</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock">ebx</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">address of zero-terminated pathname</p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock">ecx</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">file access bits</p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock">edx</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">file permission mode</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Out</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">eax</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">file descriptor of opened file  :  EACCESS  :  EEXIST  :  EFAULT  :  EISDIR  :  ELOOP  :  EMFILE,  :  ENAMETOOLONG  :  ENFILE  :  ENOENT  :  ENODEV  :  ENODIR  :  ENOMEM  :  ENOSPC  :  ENXIO  :  EROFS  :  ETXTBSY</p></td></tr><tr><td class="tableblock halign-center valign-top" colspan="3"><p class="tableblock"><strong>close - close a file or device</strong></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">In</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">eax</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">6</p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock">ebx</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">file descriptor</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Out</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">eax</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">zero for success  :  EBADF</p></td></tr><tr><td class="tableblock halign-center valign-top" colspan="3"><p class="tableblock"><strong>waitpid - wait for a processes to terminate</strong></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">In</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">eax</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">7</p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock">ebx</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">process id of the process to wait for</p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock">ecx</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">0, or address of buffer to hold exit state</p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock">edx</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">option flags  :  0  :  WNOHANG  :  WUNTRACED</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Out</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">eax</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">pid of finished process  :  ECHILD  :  EINVAL  :  ERESTART</p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock">ecx</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">exit state of finished process, if non-zero value was input in ecx</p></td></tr><tr><td class="tableblock halign-center valign-top" colspan="3"><p class="tableblock"><strong>create - create a file</strong></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">In</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">eax</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">8</p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock">ebx</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">address of zero-terminated pathname</p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock">ecx</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">file permission mode</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Out</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">eax</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">file descriptor of opened file  :  EACCESS  :  EEXIST  :  EFAULT  :  EISDIR  :  ELOOP  :  EMFILE,  :  ENAMETOOLONG  :  ENFILE  :  ENOENT  :  ENODEV  :  ENODIR  :  ENOMEM  :  ENOSPC  :  ENXIO  :  EROFS  :  ETXTBSY</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Note</p></td><td class="tableblock halign-left valign-top" colspan="2"><p class="tableblock">This call is identical to calling open with access bits O_CREATE : O_WRONLY : O_TRUNC</p></td></tr><tr><td class="tableblock halign-center valign-top" colspan="3"><p class="tableblock"><strong>link - create a hard link to a file</strong></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">In</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">eax</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">9</p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock">ebx</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">address of zero-terminated pathname of existing file name</p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock">ecx</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">address of zero-terminated pathname of new name</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Out</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">eax</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">0  :  EACCESS  :  EIO  :  EPERM  :  EEXIST  :  EFAULT  :  ELOOP  :  EMLINK  :  ENAMETOOLONG  :  ENOENT  :  ENOMEM  :  ENOSPC  :  ENOTDIR  :  EPERM  :  EROFS  :  EXDEV</p></td></tr><tr><td class="tableblock halign-center valign-top" colspan="3"><p class="tableblock"><strong>unlink - delete a name and remove file when not busy</strong></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">In</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">eax</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock">ebx</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">address of zero-terminated pathname of existing file name</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Out</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">eax</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">0  :  EACCES  :  EFAULT  :  EIO  :  EISDIR  :  ELOOP  :  ENAMETOOLONG  :  ENOENT  :  ENOMEM  :  ENOTDIR  :  EPERM  :  EROFS</p></td></tr><tr><td class="tableblock halign-center valign-top" colspan="3"><p class="tableblock"><strong>execve - execute a program</strong></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">In</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">eax</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">11</p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock">ebx</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">address of zero-terminated pathname of program</p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock">ecx</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">address of zero-terminated list of addresses of zero-terminated argument strings</p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock">edx</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">address of zero-terminated list of addresses of zero-terminated environment strings</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Out</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">eax</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">If success, no return because the new program inherits resources and overwrites caller; otherwise: E2BIG  :  EACCES  :  EINVAL  :  EIO  :  EISDIR  :  ELIBBAD  :  ELOOP  :  ENFILE  :  ENOEXEC  :  ENOENT  :  ENOMEM  :  ENOTDIR  :  EFAULT  :  ENAMETOOLONG  :  EPERM  :  ETXTBUSY</p></td></tr><tr><td class="tableblock halign-center valign-top" colspan="3"><p class="tableblock"><strong>chdir - change working directory</strong></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">In</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">eax</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">12</p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock">ebx</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">address of zero-terminated pathname of existing directory</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Out</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">eax</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">0  :  EACCES  :  EBADF  :  EFAULT  :  EIO  :  ELOOP  :  ENAMETOOLONG  :  ENOENT  :  ENOMEM  :  ENOTDIR</p></td></tr></table></li></ul></div></li><li><p>File descriptors</p><div class="ulist"><ul><li><p>0 (STDIN): The standard input for the terminal device (normally the keyboard). Diferenciar la macro STDOUT_FILEIN de la macro stdin.</p></li><li><p>1 (STDOUT): The standard output for the terminal device (normally the terminal screen). Diferenciar la macro STDOUT_FILENO de la macro stdout.</p></li><li><p>2 (STDERR): The standard error output for the terminal device (normally the terminal screen)</p></li></ul></div></li></ul></div>
<h level="4">Como pasar los argumentos</h><div class="ulist"><ul><li><p>Para pasar los argumentos no se utiliza la pila (memoria externa) sino los registros RPG (memoria interna de la CPU)</p></li><li><p>Los 6 primeros argumentos se pasan a través de los registros: [EBX-ECX-EDX-ESI-EDI-EBP] previamente a la instrucción de la llamada <code>int $0x80</code></p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">* printf() -&gt; write(int fd, const void *buf, size_t count) -&gt; [EBX-ECX-EDX-ESI-EDI-EBP,int 0x80] -&gt; kernel syscall write
* API      -&gt;        wrapper function                      -&gt;                ABI                  -&gt;  kernel syscall</code></pre></div></div></li><li><p>Pasar los argumentos 1º-2º-3º-4º-5º-6º a través de los registros <em>EBX-ECX-EDX-ESI-EDI-EBP</em> en el orden indicado en el prototipo de la función en C:</p></li><li><p>Ej: llamada a la <em>syscall exit</em> del kernel desde un módulo fuente en lenguaje ASM:</p><div class="ulist"><ul><li><p><code>man 3 exit</code></p></li><li><p><code>syscall(exit_code,int status)</code></p></li><li><p>módulo asm</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-nasm" data-lang="nasm">mov $1,%eax
mov $status_value,%ebx
int $0x80</code></pre></div></div></li></ul></div></li><li><p>Ej: llamada a la <em>syscall write</em> del kernel desde un módulo fuente en lenguaje ASM:</p><div class="ulist"><ul><li><p><code>man 2 write</code></p></li><li><p><code>syscall(write_code,int fd, const void *buf, size_t count)</code></p></li><li><p>módulo asm</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-nasm" data-lang="nasm">mov $4,%eax
mov $1,%ebx
mov $buffer_address_label,%ecx
mov size,%edx
int $0x80</code></pre></div></div></li></ul></div></li><li><p>Valor de Retorno</p><div class="ulist"><ul><li><p>El valor de retorno se pasa a través del registro <em>EAX</em></p></li></ul></div></li></ul></div>
<h level="4">LLamadas a las funciones de la librería standard de C</h><div class="ulist"><ul><li><p>Desde ASM se puede llamar a las funciones de la librería de C instalada en linux: <em>libc</em></p></li><li><p>Para llamar a la función <em>printf()</em> utilizamos la instrucción <code>call printf</code></p></li><li><p>Los argumentos de la función se pasan previamente a la llamada.</p><div class="ulist"><ul><li><p>Los argumentos se pasan a través de la <strong>pila</strong> en el sentido Dcha&#8594;Izda a como estan definidos.</p></li></ul></div></li><li><p>Es necesario linkar el módulo objeto con la librería <em>libc</em></p></li><li><p>Ej:</p><div class="ulist"><ul><li><p>Programación C</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">planetas = 9;
printf("El número de planetas es %d \n", planetas);</code></pre></div></div></li><li><p>Programación ASM</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-nasm" data-lang="nasm">     .section .data
cadena:
     .asciz "El número de planetas es %d \n"
planetas:
     .long 0
     .section .text
_start:
     movl $9,planetas
     push planetas
     push $cadena
     call printf
     call exit
     .end</code></pre></div></div></li></ul></div></li></ul></div>
<h level="4">Línea de comandos</h><div class="ulist"><ul><li><p>Process Initialization</p></li><li><p>en el kernel está declarada la función main(): <code>extern int main (int argc , char* argv[] , char* envp[]) ;</code></p><div class="ulist"><ul><li><p>declaración y definición del módulo principal</p></li><li><p><em>argc</em> is a non-negative argument count;</p></li><li><p><em>argv</em> is an array of argument strings, with argv[argc]==0;</p></li><li><p><em>envp</em> is an array of environment strings, also terminated by a null pointer.</p></li></ul></div></li><li><p>Stack Initialization</p><table class="tableblock frame-all grid-all" style="width:50%"><caption class="title">Table 12. Convenio ABI: Stack</caption><colgroup><col style="width:50%" /><col style="width:50%" /></colgroup><thead><tr><th class="tableblock halign-left valign-top">Stack Reference</th><th class="tableblock halign-center valign-top">Interpretation</th></tr><tbody><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-center valign-top"><p class="tableblock">arguments strings</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">4n(%esp)</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">- pointer to nº string</p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-center valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">8(%esp)</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">- pointer to 2º argument string</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">4(%esp)</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">- pointer to 1º argument string</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">0(%esp)</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">- argc</p></td></tr></table></li></ul></div>
<h level="3">Ejemplo</h><div class="ulist"><ul><li><p>Introducir los datos del programa suma.s a través de 	a línea de comandos</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-scala" data-lang="scala">### función: sumar dos números enteros de un dígito.
###          los sumandos se pasan a través de la línea de comandos
        ## gcc -m32 -nostartfiles -g -o sum_input sum_imput.s
        ## run 5 7
        ##  x /a  (char**)($esp+4)  -&gt; 0xffffd0a4:	0xffffd26e
        ##  x /c  *(char**)($esp+4) -&gt; 0xffffd26e:	47 '/'
        ##  x /s  *(char**)($esp+4) -&gt; 0xffffd26e:	 "/home/candido/tutoriales/as_tutorial/algoritmos_x86-32/basicos/sum_input"
        ##  p /s *(char**)($esp+4)  -&gt; 0xffffd26e "/home/candido/tutoriales/as_tutorial/algoritmos_x86-32/basicos/sum_input"
        ##  x /s  *(char**)($esp+8) -&gt; 0xffffd2b7:	 "5"
        ##  x /s  *(char**)($esp+12) -&gt; 0xffffd2b9:	 "7"

        .section .text
	.globl _start
_start:

        ## instrucciones aclaratorias

	leal 8(%esp),%eax       #eax contiene argv[1] la dirección de la pila que contiene el pointer al argumento string
        movl 8(%esp),%ebx       #ebx tiene el contendio de la pila= dirección del string
        xor %ecx,%ecx
        movb (%ebx),%cl        #caracter ASCII

        ## string argument pointers
        movl 8(%esp),%eax       #eax tiene el contendio de la pila= dirección del string. argv[1]
        movl 12(%esp),%ebx       #eax tiene el contendio de la pila= dirección del string. argv[2]
        ## fetch string indirect
        ## convert ascii numbers to values
        xor %ecx,%ecx
        xor %edx,%edx
        movb (%eax),%cl         # indirección para acceder al string referenciado por argv[1]
        movb (%ebx),%dl         # indirección para acceder al string referenciado por argv[1]
        subl $0x30,%ecx
        subl $0x30,%edx

        push %ecx
        push %edx

        call suma

	## salida
        movl %eax,%ebx
	movl  $1, %eax	    #1 is the exit() syscall
	int   $0x80


### Función que calcula el máximo entre dos valores
	.type suma, @function
	.section .text
suma:
	## prologo
	push %ebp
	movl %esp,%ebp
	subl $1,%esp            #reserva de memoria
	push %ebx
	push %edi
	push %esi
	## captura de argumentos
	movl 8(%ebp),%eax      #1º argumento
	movl 12(%ebp),%ecx     #2º argumento
	## cuerpo
	addl %ecx,%eax          #
	## guardar resultado

	## el resultado está en EAX
	## epilogo
	pop %esi
	pop %edi
	pop %ebx
	mov %ebp,%esp           # frame anterior
	pop %ebp
	ret                     # recuperar dirección de retorno</code></pre></div></div></li></ul></div></div></section></section></div></section>
<section id="_ii_unidades_básicas_procesador_central_unidad_de_memoria_mecanismos_entradasalida"><h2>II Unidades Básicas: Procesador Central, Unidad de Memoria, Mecanismos Entrada/Salida.</h2><div class="slide-content"><section><section id="_procesador_central"><h2>7. Procesador Central</h2></section><section id="_temario_7"><h2>7.1. Temario</h2><div class="slide-content"><div class="olist arabic"><ol class="arabic" start="7"><li><p>Arquitectura y organización de las Computadora IAS de Von Neumann y 4004 de Intel.</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Repaso</p></li></ol></div></li><li><p>Arquitectura y organización de la CPU</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Conjunto de instrucciones</p></li><li><p>Arquitecturas CISC, RISC y VLIW</p></li><li><p>Fases de ejecución de una instrucción</p></li><li><p>Ruta de datos</p></li></ol></div></li></ol></div></div></section><section id="_refs"><h2>7.2. Refs</h2><div class="slide-content"><div class="ulist"><ul><li><p>Apuntes : Tema 2: Arquitectura von Neumann (unidad de control)</p></li><li><p>Libro de Texto: Estructura y Organización de Computadores .William Stalling. Capítulo 12.</p></li></ul></div></div></section><section id="_introducción_7"><h2>7.3. Introducción</h2><div class="slide-content"><div class="ulist"><ul><li><p>A modo de repaso y como introducción al tema se va a ver la computadora Von Neumann del año 1951 como arquitectura de referencia hasta nuestros días y el primer procesador integrado comercial de Intel, la cpu 4004, a en el año 1971. El resto de CPUs hasta nuestros días son una evolución de dichos procesadores.</p></li><li><p>El objetivo principal de la CPU es la implementación del <em>ciclo de instrucción</em>. Es el soporte hardware para poder llevar a cabo todas las operaciones que conllevan las intrucciones de un programa.</p></li><li><p>Unidad Central de Proceso (CPU) o Procesador.</p><div class="ulist"><ul><li><p>Nombres: Procesador, microprocesador (El componente electrónico básico es el transistor con un tamaño en sus origenes del orden de la micra ), ..</p></li><li><p>Central porque la computadora tiene varios procesadores: Por ejemplo el controlador de la memoria y  los controladores de los periféricos.</p></li></ul></div></li><li><p>Arquitectura Von-Neumann.</p><div class="ulist"><ul><li><p>La CPU es una de las unidades básicas que conforman la arquitectura Von-Neumann (CPU-MP-IO) y Buses.</p></li></ul></div></li><li><p>La CPU se puede  ver desde el punto de vista del programador o desde el punto de vista del diseñador de procesadores (microarquitectura)</p><div class="olist arabic"><ol class="arabic"><li><p>Desde el punto de vista del <em>programador</em> interesa conocer:</p><div class="ulist"><ul><li><p>La Arquitectura del Repertorio  de Instrucciones (ISA). Hoy en días los procesadores se pueden clasificar según su la complejidad o sencillez de la ISA en arquitecturas CISC y RISC. Ejemplo de la arquitectura ISA CISC (Complex Instruction Set Computer) es la arquitectura de Intel x86 ampliamente utilizada en ordenadores personales y ejemplo de la arquitectura ISA RISC (Complex Instruction Set Computer) son los procesadores ARM ampliamente utilizados en los teléfonos móviles.</p></li><li><p>Registros: registros de propósito general accesibles por el programador (acumulador, registro índice, punteros pila, etc), registro de estado,  registros de coma flotante, registros multimedia, resgistros de segmentación de memoria, registros no accesibles como el contador de programa, tamaño de los registros, etc</p></li><li><p>Modos de Funcionamiento de la CPU: modo superusuario, modo usuario, modo interrupción. Los distintos modos de funcionamiento permiten proteger el buen funcioamiento de la cpu según se realicen tareas de usuario, de administrador, de compartición de recursos, etc ..</p></li></ul></div></li><li><p>Desde el punto de vista de la <em>Microarquitectura</em> u organización interna de la CPU.</p><div class="ulist"><ul><li><p>Las unidades básicas de la CPU son: Unidad de Control (UC), y la Ruta de Datos (ALU,FPU,MMU,Registros y circuitos de enrutamiento como multiplexores, conmutadores,  etc).</p></li><li><p>La microarquitectura de la CPU puede implementar más de una ruta de datos permitiendo así la ejecución simultánea de más de una instrucción. Los procesadores que utilizan dicha tecnología se denominan procesadores superescalares.</p></li><li><p>El ciclo de instrucción puede ser secuencial o segmentado, permitiendo el solapamiento en el tiempo de la ejecución de más de una instrucción (técnicas de paralelismo a nivel de instrucción, ILP)</p></li></ul></div></li></ol></div></li><li><p>Técnicas HW de optimización de la ejecución de un programa <strong>(Performance)</strong></p><div class="ulist"><ul><li><p>El objetivo básico a la hora de diseñar nuevas versiones de la CPU es incrementar su rendimiento, es decir, el número de instrucciones que se ejecutan por unidad de tiempo y por ende el tiempo de ejecución de los programas. Diversas técnicas han sido desarrolladas a nivel de la microarquitectura de la computadora con tal objetivo, como:</p></li><li><p><a href="https://en.wikipedia.org/wiki/Instruction_pipelining">Segmenación-Pipelining</a>: organizar el ciclo de instrucción en fases o segmentos y ejecutarlos en paralelo.</p></li><li><p><a href="https://en.wikipedia.org/wiki/Superscalar_processor">superscalar processor</a></p></li><li><p><a href="https://es.wikipedia.org/wiki/Ejecuci%C3%B3n_fuera_de_orden">Ejecución fuera de Orden OoO</a>: Run time</p></li><li><p><a href="https://es.wikipedia.org/wiki/Renombre_de_registros">Renombre de Registros</a>: Compiler &amp; Run time</p></li><li><p><a href="https://en.wikipedia.org/wiki/Branch_predictor">Branch Predictor</a>: Run time</p></li></ul></div></li></ul></div>
<div class="imageblock" style="text-align: center"><img src="images/cpu/puntosdevista_isa_uarch.svg" alt="puntosdevista isa uarch" width="900" height="500" /></div><div class="title">Figure 26. Puntos de Vista: SW y HW</div></div></section><section id="_computadora_desde_el_punto_de_vista_del_programador_i"><h2>7.4. Computadora desde el punto de vista del Programador (I)</h2><div class="slide-content"><h level="3">Conjunto de Instrucciones</h><h level="4">Arquitectura (ISA)</h><div class="ulist"><ul><li><p>Recordatorio de la primera parte de la asignatura:</p><div class="ulist"><ul><li><p>Temas: arquitectura von neumann, representación de datos, operaciones aritmetico-lógicas, representación de las instrucciones y programación en lenguaje ensamblador.</p></li></ul></div></li><li><p>Instruction Set Arquitecture (ISA)</p><div class="ulist"><ul><li><p>La arquitectura del repertorio de instrucciones define: códigos de operación, tipos de operando, modos de direccionamiento, etc</p></li><li><p>Son las instrucciones máquina ejecutables directamente por la CPU en código binario.: <em>lenguaje máquina</em></p></li><li><p>La instrucción a ejecutar está almacenada en código binario en el registro RI de la Unidad de Control.</p></li></ul></div></li><li><p>El repertorio de instrucciones está especificado en el manual del programador de la CPU:</p><div class="ulist"><ul><li><p>Programamos en <em>lenguaje Ensamblador</em> en lugar de en <em>lenguaje máquina</em></p></li><li><p>El manual contiene la definición de la Arquitectura del Repertorio de Instrucciones.</p><div class="ulist"><ul><li><p>el listado y descripción de todas las instrucciones ejecutables por el microprocesador</p><div class="ulist"><ul><li><p>categorías de las instrucciones: transferencia(mov), control(jmpz,loop),aritméticas(add), lógicas(xor), i/o (in/oout)</p><div class="ulist"><ul><li><p>Mnemónicos del código de operación</p></li></ul></div></li><li><p>Modos de direccionamiento: inmediato, directo, indirecto, desplazamiento</p></li><li><p>Tipos de datos: entero, real, alfanumérico</p></li></ul></div></li><li><p>Formatos binarios</p><div class="ulist"><ul><li><p>De las instrucciones: campos de operación, operando, modo direccionamiento</p></li><li><p>De los datos: complemento a 2, coma flotante</p></li></ul></div></li></ul></div></li></ul></div></li></ul></div>
<h level="3">Ejemplos: Intel x86, Motorola 68000, MIPS, ARM</h><div class="ulist"><ul><li><p>Ver <a href="#leng_asm">Apéndice Lenguajes Ensamblador</a></p></li></ul></div></div></section><section id="_microarquitectura_unidades_funcionales_desde_la_perspectiva_hw"><h2>7.5. Microarquitectura: Unidades Funcionales desde la perspectiva HW</h2><div class="slide-content"><h level="3">Introducción</h><div class="ulist"><ul><li><p>Se conoce con el nombre microarquitectura a la arquitectura interna del microprocesador.</p><div class="ulist"><ul><li><p>La microarquitectura es el diseño e implementación del ciclo de instrucción del conjunto de instrucciones definido por ISA.</p></li><li><p>Ejemplos</p><div class="ulist"><ul><li><p>IAS</p></li><li><p>Intel: 4004, 8008, 8051, x86</p></li><li><p>AMD: x86</p></li><li><p>ARM: Cortex</p></li></ul></div></li></ul></div></li><li><p>El prefijo micro (microelectrónica, microprocesador, microarquitectura, microbus, microprograma, microcódigo, micro-operación, etc) está relacionado con el tamaño de los transistores, de los primeros circuitos integrados o chips, que eran del orden de decenas de MICROMETROS. Todo lo que ocurre en el entorno de la computadora en esa dimensión suele llevar el prefijo micro</p></li></ul></div>
<h level="3">Fases de Ejecución de una Instrucción</h><h level="4">Estructura</h><div class="imageblock" style="text-align: center"><img src="./images/von_neumann/ias_architecture.png" alt="ias architecture" /></div><div class="title">Figure 27. IAS_Architecture</div>
<h level="4">Ciclo / Diagrama / Fases</h><div class="imageblock" style="text-align: center"><img src="./images/cpu/12_5.jpg" alt="12 5" /></div><div class="title">Figure 28. Diagrama de Estados</div>
<div class="ulist"><ul><li><p>Ciclos: El Ciclo de instrucción es una secuencia de Fases ó Ciclos de Máquina. Cada ciclo de máquina se puede ejecutar en uno o más ciclos de reloj de la CPU.</p></li><li><p>Fases del ciclo de instrucción ó Ciclos máquina:</p><div class="olist arabic"><ol class="arabic"><li><p>Fetch Instruction : FI</p><div class="ulist"><ul><li><p>Inicialmente hay que volcar al bus de direcciones de memoria el contenido del Contador de Programa (PC)</p></li><li><p>Captar la instrucción</p></li><li><p>PC &#8592; PC+1</p></li></ul></div></li><li><p>Instruction Decode : ID</p><div class="ulist"><ul><li><p>interpretar la instrucción</p></li></ul></div></li><li><p>Fetch Operand      : OF</p><div class="ulist"><ul><li><p>captar datos, captar los operandos</p></li><li><p>resolver la dirección efectiva</p></li></ul></div></li><li><p>Execute  Instruction : EI</p><div class="ulist"><ul><li><p>procesar la instrucción con los datos</p></li></ul></div></li><li><p>Write Operand: WO</p><div class="ulist"><ul><li><p>almacencar el resultado</p></li><li><p>resolver la dirección efectiva</p></li></ul></div></li><li><p>Interruption       : II</p><div class="ulist"><ul><li><p>El programa puede ser interrumpido por la prioridad de ejecutar otro programa de atención a periféricos, etc..Una vez atendida la interrupción el programa continua con el siguiente ciclo de instrucción.</p></li></ul></div></li><li><p>Next Instruction   : NI</p></li></ol></div></li><li><p>Ciclo de instrucción</p><div class="ulist"><ul><li><p>Después de la fase de captación de la instrucción (FI) le sigue la fase de Ejecución (EI) ó la Fase de determinación de la Dirección Efectiva del Operando y Obtención del operando (OF)</p></li><li><p>Después de la fase de ejecución puede haber un ciclo de atención a una interrupción.</p></li></ul></div></li></ul></div>
<h level="4">Diagrama de Microoperaciones</h><div class="ulist"><ul><li><p>Microoperaciones: operaciones realizadas por la CPU internamente, al ejecutar una Instrucción Máquina.</p><div class="ulist"><ul><li><p>Ejemplos: escribir en el registro MAR, orden de lectura a la MPrincipal, leer de MBR, interpretar de IR, incrementar PC, etc</p></li><li><p>Ejecución Síncrona con el reloj de la CPU:</p><div class="listingblock"><div class="content"><pre>          T = 1/f
&lt;--------------------&gt;

               +-----+               +-----+               +-----+               +-----+
               |     |               |     |               |     |               |     |
               |     |               |     |               |     |               |     |
               |     |               |     |               |     |               |     |
               |     v               |     v               |     v               |     v
               |     |               |     |               |     |               |     |
               |     |               |     |               |     |               |     |
               |     |               |     |               |     |               |     |
+--------------+     +---------------+     +---------------+     +---------------+     +</pre></div></div>
<div class="ulist"><ul><li><p>Flancos de reloj: Cambio de nivel 0&#8594;1 (positivos) o  1&#8594;0 (negativos)</p></li><li><p>IAS no es síncrona: una microoperación no comienza con ningún patrón de tiempos.</p></li></ul></div></li><li><p>Descripción de las micro-operaciones: Register Transfer Language (RTL)</p><div class="imageblock" style="text-align: center"><img src="./images/von_neumann/ias_operation.png" alt="ias operation" /></div><div class="title">Figure 29. IAS Operation</div></li></ul></div></li><li><p>Operación de la máquina IAS:</p><div class="ulist"><ul><li><p>El ciclo de instrucción tiene dos FASES</p></li><li><p>La primera fase es común a todas las instrucciones.</p></li></ul></div></li><li><p>Ejemplos de instrucciones</p><div class="ulist"><ul><li><p>X: referencia del operando</p></li><li><p>AC &#8592; M(X)</p></li><li><p>GOTO M(X,0:19): salto incondicional a la dirección X. X apunta a dos instrucciones. X,0:19 es la referencia de la Instrucción de la izda.</p></li><li><p>If AC&gt;0 goto M(X,0:19): salto condicional</p></li><li><p>AC &#8592; AC+M(x).</p></li></ul></div></li></ul></div>
<h level="3">Ejemplo: máquina IAS de Von-Neumann</h><div class="ulist"><ul><li><p>Tema 2: <a href="../von_neumann/upna_von_neumann.html">Arquitectura Von-Neumann</a></p></li><li><p>Cada instrucción de la computadora IAS se ejecuta siguiendo una secuencia de fases. Dicha secuencia se repite para cada instrucción y se conoce como el ciclo de instrucción de la unidad central de proceso (CPU).</p></li><li><p>La unidad de control es la unidad de la CPU que implementa cada fase del ciclo de instrucción.</p></li><li><p>La unidad de control controla la ruta de datos de la CPU mediante microordenes.</p></li><li><p>Internamente está formada por el circuito generador de microordenes y por los registros : contador de programa y registro de instrucción.</p></li></ul></div>
<h level="3">Implementación del ciclo de instrucción: CPU</h><h level="4">¿Cómo implementar el ciclo de instrucción?</h><div class="ulist"><ul><li><p>Mediante un Circuito Electrónico Digital secuencial: Máquina de estados finitos FSM que implementa la secuencia del diagrama de estados y que recibe el nombre de Unidad de Control.</p></li><li><p>La Unidad de Control es una secuencia de estados que van realizando las distintas fases del ciclo de instrucción.</p></li><li><p>Las distintas fases del ciclo de instrucción utilizan distintas unidades funcionales como: registros, ALU, etc</p></li><li><p>La interpretación de distintas instrucciones máquina dará lugar a diferentes secuencias de estados en la Unidad de Control.</p></li></ul></div>
<h level="4">Estructura de la CPU</h><div class="ulist"><ul><li><p>Tres recursos básicos: Unidad de Control, <strong>Unidad de Ejecución</strong> y Registros.</p></li><li><p>Dos Bloques básicos de la CPU</p><div class="ulist"><ul><li><p>Unidad de Control (UC) y  la Ruta de Datos (DataPath).</p></li></ul></div></li><li><p>La unidad de control esta formada por</p><div class="ulist"><ul><li><p>generador de las microoperaciones que implementan el ciclo de instrucción</p></li><li><p>registros: registro de instrucción IR, registro contador de programa PC</p></li></ul></div></li><li><p>La Ruta de Datos esta formada por</p><div class="ulist"><ul><li><p><strong>Unidad de Ejecución UE :</strong></p><div class="ulist"><ul><li><p>Unidad Aritmetico Lógica ALU: cálculos números enteros</p></li><li><p>Unidad de Punto Flotante FPU: cálculos números reales</p></li><li><p>Unidad Load/Store LSU: cálculos de la dirección efectiva y acceso a la memoria principal</p><div class="ulist"><ul><li><p>Memory Management Unit (MMU): cálculo de la dirección efectiva FISICA de la MP. Traduce las direcciones virtuales de memoria utilizadas por la cpu  en direcciones físicas de la memoria principal.</p></li></ul></div></li></ul></div></li><li><p>los Registros</p><div class="ulist"><ul><li><p>Registros de propósito general GPR accesibles por el programador</p></li><li><p>Registros de estado SR</p></li><li><p>Registros : de Propósito General (rax,mmx,sse,xmm,..), control (usuario,superusuario,paginación,interrupción,&#8230;&#8203;) y status (rflags, ..).</p><div class="ulist"><ul><li><p>Los registros de control no son accesibles por el usuario, son accesibles por el sistema operativo.</p></li></ul></div></li></ul></div></li></ul></div></li><li><p>Memoria interna</p><div class="ulist"><ul><li><p>Memoria Cache L0</p></li><li><p>Memory Management Unit (MMU)</p></li></ul></div></li><li><p>Sincronismo</p><div class="ulist"><ul><li><p>Reloj para sincronizar las tareas: facilita el diseño del Hardware.</p></li></ul></div></li></ul></div>
<h level="4">Intel</h><div class="ulist"><ul><li><p>Intel nomina a las distintas Unidades o Circuitos electrónicos que componen la CPU según su implicación en cada fase del ciclo de instrucción con los siguiente es nombres:</p><div class="ulist"><ul><li><p>Address Unit (AU) : se encarga de obtener la dirección efectiva de la instrucción o dato</p></li><li><p>Bus Unit (BU): se encarga de acceder a los buses de comunicacióń con la memoria principal</p></li><li><p>Instruction Unit (IU): se encarga de interprertar y gestionar la instrucción a ejecutar</p></li><li><p>Execution Unit (EU): se encarga de procesar la instrucción o instrucciones en curso.</p></li><li><p>El Control Unit es el encargado de utilizar y sincronizar las unidades UA-UB-IU-EU para llevar a cabo correctamente los ciclos de instrucción.</p></li></ul></div></li></ul></div>
<h level="4">Unidad de Control</h><div class="ulist"><ul><li><p>The control unit (sometimes called the fetch / decode unit) is responsible for retrieving individual instructions from their location in memory, then translating them into commands that the CPU can understand.   These commands are commonly referred to as machine-language instructions, but are sometimes called <strong>micro-operations</strong>, or UOPs.  When the translation is complete, the control unit sends the UOPs to the execution unit for processing.</p></li><li><p>Señales de control de la UC</p><div class="ulist"><ul><li><p>Señales digitales binarias</p></li></ul></div></li><li><p>Ejemplo: Microoperaciones de la Fase de captación del ciclo de instrucción.</p><div class="ulist"><ul><li><p>Se realiza la lectura de una instrucción mediante las siguientes acciones que son activadas por la Unidad de control:</p><div class="ulist"><ul><li><p>El Contador de Programa (PC) o Instruction Pointer (IP) contiene la dirección de referencia de la instrucción a captar</p></li><li><p>El Memory Address Register (MAR) se carga con el contenido del (PC)</p></li><li><p>El bus de direcciones del sistema se carga con el contenido de MAR</p></li><li><p>Se vuelca  el contenido de la dirección apuntada al Buffer i/o de memoria, de ahí al bus de datos transfiriendose así al Memory Buffer Register (MBR)</p></li></ul></div></li></ul></div></li></ul></div>
<div class="imageblock" style="text-align: center"><img src="./images/cpu/12_6.jpg" alt="12 6" width="600" height="400" /></div><div class="title">Figure 30. Flujo de Datos. Ciclo de Captación</div>
<div class="ulist"><ul><li><p>Secuencia de las microordenes en el ejemplo:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>MAR &#8594; address bus</p></li><li><p>UC &#8594; control bus</p></li><li><p>data bus &#8594; MBR</p></li><li><p>MBR &#8594; IR y UC &#8594; PC</p></li><li><p>al finalizar la ejecución: PC &#8594; MAR</p></li></ol></div></li></ul></div>
<h level="4">Unidad de Ejecucion (EU)</h><div class="ulist"><ul><li><p>The execution unit is responsible for performing the third step of the instruction cycle, namely, executing, or performing the operation that was specified by the instruction.</p></li><li><p>Incluye: ALU+FPU+LSU+RPG</p><div class="ulist"><ul><li><p>Operaciones: Aritméticas, Lógicas, Transferencia,</p></li></ul></div></li></ul></div>
<h level="4">Ruta de Datos</h><div class="ulist"><ul><li><p>Es la ruta  que realizan los datos ( instrucciones, campos del formato de instrucciones, operando, dirección, etc &#8230;&#8203;) a través del procesador, internamente al procesador, dirigidos por la Unidad de Control.</p></li><li><p>Es necesario interconectar las distintas unidades y subunidades de la CPU para poder transferir y procesar los bits y conjuntos de bits entre ellas.</p></li><li><p>Los microcomandos de la UC en forma de señal transportan y procesan dichos datos.</p><div class="ulist"><ul><li><p>Ejemplos de microcomandos: abrir puerta, conectar bus, multiplexar datos, etc &#8230;&#8203;microordenes de control del hardware</p></li><li><p>Dicho transporte y procesamiento  dependerá de la interpretación de la instrucción en ejecución y del diseño de la  microarquitectura.</p></li></ul></div></li><li><p>Los componentes básicos de la Ruta de Datos son :</p><div class="ulist"><ul><li><p>Unidades de transporte: BUS, conmutador, multiplexor, etc</p></li><li><p>Unidad de memoria: cálculo de la dirección efectiva, interfaz con la memoria externa</p></li><li><p>Unidades de procesamiento: ALU</p></li><li><p>Unidades de almacenamiento: registros</p></li></ul></div></li><li><p>RTL: Register Transfer Language</p><div class="ulist"><ul><li><p>Lenguaje para indicar las acciones de transporte, procesamiento y almacenamiento.</p><div class="ulist"><ul><li><p>AC &#8592; [PC]+ M[CS:SP]</p></li></ul></div></li></ul></div></li><li><p>Esquema de la Ruta de Datos</p><div class="imageblock" style="text-align: center"><img src="./images/cpu/datapath.jpg" alt="datapath" /></div><div class="title">Figure 31. Datapath</div>
<div class="ulist"><ul><li><p>Líneas gruesas: bus de datos</p></li><li><p>Líneas finas:   bus de control &#8594; chip select, microorden sumar, cargar registro, etc ..</p></li></ul></div></li><li><p>Ver <em>applet</em> de la ruta de datos del apartado Imágenes</p></li><li><p>Diseño del datapath</p><div class="ulist"><ul><li><p>determinar que microunidades son necesarias</p></li><li><p>cómo conectarlas</p></li><li><p>Qué microseñales accionar y cuándo en cada microoperación. Paralelismo a nivel de microoperaciones</p></li><li><p>ubicación y temporización de los datos según la secuencia del diagrama de estados de la UC</p><div class="ulist"><ul><li><p>AC &#8592; [PC]+ M[CS:SP] &#8658; microoperaciones asociadas y diagrama de tiempos</p></li></ul></div></li></ul></div></li></ul></div>
<h level="3">Unidad de Control Microprogramada</h><div class="ulist"><ul><li><p>Unidad de Control Microprogramada vs Cableada</p></li><li><p>Microcableada: El secuenciados o FSM de la unidad de control ejecuta <em>directamente</em> las instrucciones en código máquina almacenadas en la memoria principal</p></li><li><p>Microprogramada:</p><div class="ulist"><ul><li><p>Las instrucciones máquina (ISA) almacenadas en la memoria principal y cuya secuencia consituye el <strong>código máquina</strong> del programa del usuario no son ejecutadas directamente por la UC. En su lugar cada instrucción en código máquina es traducida en una secuencia de <strong>microinstrucciones</strong> y cada microinstrucción genera las microoperaciones o microseñales de la unidad de control que conforman el ciclo de instrucción.</p></li><li><p>La secuencia de microinstrucciones asociadas a una microinstrucción constituye el <strong>microcódigo</strong> que se encuentra almacenada en una memoria de sólo lectura (Read Only Memory ROM) interna de la Unidad de control.</p></li><li><p>Cambiando o añadiendo microcódigo a nuestra Unidad de Control conseguimos nuevas arquitecturas ISA de una manera más flexible que con la unidad de control cableada.</p><div class="ulist"><ul><li><p><a href="http://en.wikipedia.org/wiki/Microcode">microcode</a></p></li></ul></div></li></ul></div></li></ul></div>
<div class="admonitionblock note"><table><tr><td class="icon"><i class="fa fa-info-circle" title="Note"></i></td><td class="content">Aunque se sigue utilizando el nombre de CPU, hoy en día la función de las primeras CPU las realizan los núcleos o Cores. Las CPU de hoy en día además del procesador central o core también integran otro tipo de funciones como memoria caché, controladores E/S, etc por lo que realmente se debieran de llamar Sistemas Integrados (system on chip, etc ).</td></tr></table></div>
<div class="ulist"><ul><li><p>Hay dos tipos de Unidades de Control Microprogramadas: Horizontal y Vertical</p></li><li><p>Formato de una "microinstrucción horizontal" de la unidad control</p><div class="ulist"><ul><li><p>Tiene tantos bits como microseñales de control. Más de 256 microseñales.</p></li><li><p>Cada bit de la microinstrucción activa una señal de control:</p><div class="ulist"><ul><li><p>bit INC activa la señal incrementar en 1 de la ALU</p></li><li><p>bit READ activa la señal READ de la Memoria principal DRAM</p></li></ul></div></li></ul></div></li></ul></div>
<div class="imageblock" style="text-align: center"><img src="./images/cpu/microinstruction_horizontal.gif" alt="microinstruction horizontal" width="600" height="400" /></div><div class="title">Figure 32. microinstrucción_horizontal</div>
<div class="ulist"><ul><li><p>Formato de una "microinstrucción vertical"</p><div class="ulist"><ul><li><p>No todas las microseñales se activan simultaneamente, por lo que el número de combinaciones posibles es mucho menor que 2<sup>Nº_de_microseñales</sup>, por ejemplo si el número de microseñales es 256, el número de combinaciones posibles es mucho menor que 2<sup>256</sup></p></li><li><p>Si el número de combinaciones posibles fuese 64=2<sup>6</sup>, entonces se podría codificar todos los casos con 6 bits en lugar de 256 bits, por lo que la longitud de la microinstrucción se reduce de 256 a 6. El inconveniencte es que hay que decodificar cada microinstrucción vertical.</p></li></ul></div></li></ul></div></div></section><section id="_ejemplos_de_cpu_ias_y_4004_de_intel"><h2>7.6. Ejemplos de CPU: IAS y 4004 de Intel</h2><div class="slide-content"><h level="3">IAS</h><div class="ulist"><ul><li><p><a href="https://es.wikipedia.org/wiki/IAS_machine" class="bare">https://es.wikipedia.org/wiki/IAS_machine</a></p></li><li><p>Development Programmer&#8217;s View of Computer Architecture:</p><div class="listingblock"><div class="content"><pre>ISA:
  - instrucciones: códigos de operación y modos de direccionamiento
  - formato de datos
  - formato de instrucciones
  - organización de la memoria
  - registros</pre></div></div></li><li><p>Microarchitecture: HW (no electronics, functional units) View of Computer Architecture</p><div class="listingblock"><div class="content"><pre>Ciclo de Instrucción
 FI-ID-EI
Unidades
 CU
  uoperations bus
  udata bus
 AU
  PC
 BU
  MAR
  MBR
 IU
  IR, IBR
 EU
  ALU
  AC, QC</pre></div></div></li><li><p>Platform architecture</p><div class="listingblock"><div class="content"><pre>CPU
MEMORY
memory BUS: address, data, control (R/W)</pre></div></div></li></ul></div>
<h level="3">Intel 4004</h><h level="4">introducción</h><div class="ulist"><ul><li><p>Intel: Intel fue fundada el 18 de julio de 1968 como Integrated Electronics Corporation</p></li><li><p>El primer microprocesador integrado i4004 formó parte de la familia "4001, 4002, 4003, &amp; 4004 Micro Computer Set" <strong>MCS-4 chipset</strong>.</p></li><li><p><a href="https://es.wikipedia.org/wiki/Intel_4004" class="bare">https://es.wikipedia.org/wiki/Intel_4004</a></p></li><li><p>Miscellaneous</p><div class="listingblock"><div class="content"><pre>Fecha: Diciembre 1971
Coste: 60$
Tecnología: nodo 10 um
Arquitectura de 4 bits</pre></div></div></li></ul></div>
<h level="4">ISA</h><div class="ulist"><ul><li><p>Development Programmer&#8217;s View of Computer Architecture:</p><div class="ulist"><ul><li><p>ISA:</p><div class="listingblock"><div class="content"><pre>  - instrucciones: códigos de operación y modos de direccionamiento
  --- El conjunto de instrucciones está formado por 46 instrucciones
  --- Modos de direccionamiento: directo, indirecto, inmediato.
  - formato de datos
  --- Datos de 4 bits de ancho
  - formato de instrucciones
  --- 41 instrucciones son de 8 bits de ancho y 5 de 16 bits de ancho.
  - organización de la memoria
  --- datos e instrucciones separados en memorias diferentes -&gt; Arquitectura Harvard, no Neumann.
  - registros
  --- 16 registros de proposito general
  --- 3 registros de 12 bits para apuntar a distintos frames del stack</pre></div></div></li><li><p>tools</p><div class="listingblock"><div class="content"><pre>assembly language
assembler translate</pre></div></div></li></ul></div></li></ul></div>
<h level="4">Microarquitectura</h><div class="ulist"><ul><li><p>Microarchitecture: HW (no electronics, functional units) View of Computer Architecture</p><div class="listingblock"><div class="content"><pre>Architecture Size : 4 bits
Ciclo de Instrucción
 FI-ID-EI
Unidades
 CU
  uoperations bus
  udata bus -&gt; 4 bits
 AU
  PC -&gt; 12 bits
  stack pointers -&gt; 12 bits
 BU
  memory Address_bus/Data_bus -&gt;
    ATENCIÓN: un único bus para las direcciones y para los datos -&gt; bus compartido, por lo que son necesarios ciclos diferentes en el tiempo.
    direcciones de 12 bits y bus de direcciones de 4 bits:  (multiplexación temporal de 3 ciclos de 4 bits para completar la dirección)
  MAR/MBR : un único registro con doble funcionalidad -&gt; 4 bits
  4 bancos de memoria: Memory Bank -&gt; memory control bus (chip_select, R/W) de la unidad de control
 IU
  IR, IBR
 EU
  ALU
  AC, QC
 Registers
  RPG (General-Purpose Registers)
  Stack
Clock Frequency: 740KHz
Chipset MSC-4</pre></div></div></li></ul></div>
<h level="4">Memoria</h><div class="ulist"><ul><li><p>(Se verá en el tema siguiente sobre la unidad de memoria)</p></li><li><p>Organización de la memoria</p><div class="ulist"><ul><li><p>Bus compartido data/address:un único bus de datos y direcciones de 4 bits.</p></li><li><p>Address multiplexing &#8594; dirección de 12bits=4bits/ciclo x 3ciclos, es decir, la unidad de control necesita 3 ciclos de reloj para completar los 12 bits de direcciones.</p></li><li><p>Tanto la memoria de programa en ROM como de programa en RAM tienen capacidad de 2<sup>12</sup> Bytes, 4KBytes</p></li><li><p>En cambio la memoria de datos en RAM tiene otro tipo de direccionamiento y capacidad de 5120 bits</p></li></ul></div></li><li><p><strong>Chipset</strong>: constelación de chips.</p><div class="listingblock"><div class="content"><pre>the i4004 microprocessor chip, which integrates the instruction sequencer, instruction decoder, subroutine stack, ALU, and sixteen 4 bit data registers. This was the first single-chip microprocessor in history.
the i4001 ROM chip combines a 256x8 bit mask-programmable ROM and four software-controllable input/output ports.
the i4002 RAM chip with 320 bits of RAM (4 registers of 20 words of 4 bit) and four software-controllable output ports:
  Bus compartido para datos y direcciones
the i4003 output expander, basically a 10-bit serial-in parallel-out shift-register.</pre></div></div>
<div class="ulist"><ul><li><p>A minimal MCS4 system consists of one i4004 CPU and one i4001 ROM chip (and a few external components like the two-phase clock generator), while the largest system  sixteen ROM chips (4 KBytes) and sixteen 4002 RAM chips (640 Bytes).</p><div class="ulist"><ul><li><p>A diferencia de las arquitecturas actuales, se observa que el chipset incluye la memoria y esta es controlada por la propia CPU a través de instrucciones de gestión de memoria como las instrucciones DCL y SRC que se utilizaban para seleccionar el banco de memoria primero y la dirección del dato después antes de proceder a realizar operaciones con dicho dato.</p></li><li><p>La organización de la memoria RAM en bancos/chips/registro/palabra es como sigue (se verá en el tema siguiente sobre la unidad de memoria):</p></li></ul></div></li><li><p>el objetivo de los Bancos de Memoria es incrementar la capacidad de memoria por encima de la limitación del Contador de Programa y del Bus de Direcciones.</p><div class="listingblock"><div class="content"><pre>A cada banco (línea CM de la cpu 4004) se pueden conectar hasta 4 chips RAM 4002
El sistema se puede configurar que tenga 4 o 8 bancos.
Por lo tanto el máximo de chips que admite el sistema es de 32.
Cuando se selecciona una instrucción o dato de memoria RAM, se selecciona uno de los bancos,  para el banco seleccionado se selecciona uno de los chips y para el chip seleccionado la palabra (instrucción o dato) de uno de los 4 registros del chip.</pre></div></div></li></ul></div></li></ul></div></div></section><section id="_la_computadora_desde_el_punto_de_vista_del_programador_ii"><h2>7.7. La Computadora desde el punto de vista del programador (II)</h2><div class="slide-content"><h level="3">Niveles o Capas de Abstracción</h><div class="ulist"><ul><li><p>El programador de sistemas se abstrae (en parte) de la implementación del Hardware gracias al Kernel del Sistema Operativo. El programador interactua con el Sistema Operativo para acceder a los recursos HW de la computadora.</p></li><li><p>El programador que desarrolla aplicaciones como compiladores, linkers, recursos del kernel como los drivers de los controladores , gestores del kernel de acceso al hw como configuración de la CPU, de la memoria, etc.. necesitan conocer el Hardware a nivel funcional y no a nivel físico o electrónico y esto se consigue mediante la capa más baja a nivel software, es decir, el lenguaje máquina que consigue abstraer la capa física o electrónica de la computadora.</p></li><li><p>Abstracción de la Máquina : mediante las instrucciones ISA / especificaciones ABI</p><div class="ulist"><ul><li><p><strong>ABI</strong> : "Application Binary Interface" . Es un documento que especifica las características binarias del software, es decir, el nivel más bajo del software. Por ejemplo especifica el convenio de llamadas a subrutinas, cómo está estructurada la pila, cómo realizar las llamadas al sistema, el formato binario del módulo objeto ejecutable, etc &#8230;&#8203; El compilador, linker y loader han de conocer la interfaz ABI con todo detalle.</p></li><li><p>Desde el punto de vista del programador de aplicaciones de bajo nivel: La interfaz con la máquina son las llamadas al sistema (ABI) y el repertorio "user ISA"</p></li></ul></div></li><li><p>Abstracción a niveles superiores</p><div class="ulist"><ul><li><p>La interfaz con la librería son los prototipos de las funciones de la librería (Application Programming Interface - <strong>API</strong>)</p></li></ul></div></li><li><p>Esquema con las Interfaces de las aplicaciones desarrolladas en <strong>lenguajes de bajo nivel</strong>:</p></li></ul></div>
<div class="listingblock"><div class="content"><pre>+--------------------------------------+
|                                      |
|            Applications              |
|                                      |
+---------API---------+                |
|                     |                |
|         Lib C     &lt;---+-- ASM_user   |
|                     | |      |       |
|                     | |      |       |  SOFTWARE
|                     | |      |       |
+-ABI--(System_Calls)-+-|-+    |       |
|                       v |    |       |
|                         |    |       |
|                         |    |       |
| Sistema Operativo       |    |       |
| (ASM_privileges)        |    |       |
| (Drivers)               |    |       |
| (Kernel ó Núcleo)       |    |       |
|                         |    v       |
+-------privileges--------+----user----+--------&gt;  ISA
|                                      |
|   UC,ALU,FPU,MMU,.....               |
|   RPG,EFLAGS,..                      |  HARDWARE
|   PC,IR,MAR,MBR,...                  |
|   I/O Controllers                    |
|   Caché,M.P.,Ports,M.S.              |
|                                      |
+--------------------------------------+</pre></div></div>
<div class="ulist"><ul><li><p>Desde el punto de vista del sistema operativo S.O.:</p><div class="ulist"><ul><li><p>La interfaz con la máquina es <strong>ISA (system isa y user isa)</strong></p></li><li><p>La interfaz con el programador es <strong>ABI</strong></p></li></ul></div></li><li><p>Desde el punto de vista del programador</p><div class="ulist"><ul><li><p>si no hay S.O. la interfaz con la máquina será equivalente a la del S.O.</p></li><li><p>si hay S.O. y librerías la interfaz con la máquina:</p><div class="ulist"><ul><li><p>en lenguaje C : <strong>API</strong> y <strong>ABI</strong> específicos de C</p></li><li><p>en lenguaje ASM: <strong>API &#169;</strong> y <strong>ABI</strong> específico de asm</p><div class="ulist"><ul><li><p>La programación de bajo nivel requiere tener algunos conocimientos del Hardware de la máquina no siendo posible su completa abstracción. Por lo tanto es necesario estudiar la CPU desde el punto de vista del programador.</p></li></ul></div></li></ul></div></li></ul></div></li></ul></div>
<div class="imageblock" style="text-align: center"><img src="images/cpu/abstraction_layers.svg" alt="abstraction layers" width="600" height="400" /></div><div class="title">Figure 33. Abstraction Layers</div>
<div class="ulist"><ul><li><p>¿Cual sería el esquema de niveles o capas visto por los siguientes niveles de abstracción superiores?</p><div class="ulist"><ul><li><p>Escritorio</p></li><li><p>Lenguaje de Programación Java</p></li></ul></div></li></ul></div>
<h level="3">Compatibilidad Software</h><h level="4">Compatibilidad</h><div class="ulist"><ul><li><p>Cada procesador tiene su repertorio de instrucciones</p></li><li><p>Si dos procesadores tienen el mismo repertorio de instrucciones, es decir, la misma arquitectura, el módulo fuente en lenguaje ensamblador será compatible para los dos procesadores aunque la estructura interna de la CPU sea diferente: Ejemplo: Intel IA64 y AMD64</p></li></ul></div>
<h level="4">Ejemplos</h><div class="ulist"><ul><li><p>El programador necesita conocer el trío ARCH-KERNEL-LIBC</p><div class="ulist"><ul><li><p>Arch se refiere a la arquitectura de la computadora &#8594; ISA</p></li><li><p>Kernel: núcleo del sistema operativo. Implementa las llamadas del sistema</p></li><li><p>Libc: librería para el programador de aplicaciones. Implementa las llamadas al sistema</p></li><li><p>Tanto el Kernel como la Librería tienen asociados sus interfaces de nivel alto (API) como de nivel bajo (ABI)</p></li></ul></div></li><li><p>Ejemplos arch/kernel/libc</p><div class="ulist"><ul><li><p>amd64-linux-gnu</p></li><li><p>arm-linux-gnueabi</p></li></ul></div></li></ul></div></div></section><section id="_personal_pc_laptop_t560"><h2>7.8. Personal PC: Laptop T560</h2><div class="slide-content"><div class="imageblock" style="text-align: center"><img src="images/laptop_T560/laptop_view_up.jpg" alt="laptop view up" /></div><div class="title">Figure 34. Laptop_T560: Vista interna</div>
<div class="imageblock" style="text-align: center"><img src="images/laptop_T560/plataforma_hardisk_off.jpg" alt="plataforma hardisk off" /></div><div class="title">Figure 35. plataforma_hardisk_off</div>
<h level="3">linux commands</h><div class="ulist"><ul><li><p>HW &#8592; Kernel &#8594; File system (/proc, /sys /dev ) &#8592; linux command &#8594; user system info</p></li><li><p>list</p><div class="listingblock"><div class="content"><pre>sudo lshw  --help
 man lshw
sudo hwinfo  --help
 man hwinfo
sudo dmidecode --help
 man hwinfo
sudo inxi</pre></div></div></li></ul></div>
<h level="3">apps</h><div class="ulist"><ul><li><p><code>cpu-x</code></p></li></ul></div>
<h level="3">Web info</h><div class="ulist"><ul><li><p>wikipedia</p></li><li><p>intel</p><div class="ulist"><ul><li><p><a href="https://ark.intel.com/content/www/us/en/ark.html" class="bare">https://ark.intel.com/content/www/us/en/ark.html</a></p></li><li><p><a href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html" class="bare">https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html</a></p></li></ul></div></li><li><p><a href="https://www.cpu-world.com/" class="bare">https://www.cpu-world.com/</a></p></li><li><p><a href="https://agner.org/" class="bare">https://agner.org/</a></p></li></ul></div>
<h level="3">Operating system</h><div class="ulist"><ul><li><p><code>uname -a</code></p><div class="listingblock"><div class="content"><pre>Ubuntu/GNU/linux 20.04
kernel linux 5.4.0-131-generic</pre></div></div></li></ul></div>
<h level="3">Platform</h><h level="4">comandos</h><div class="ulist"><ul><li><p>listado</p><div class="listingblock"><div class="content"><pre>sudo lshw -X
sudo lshw | more
sudo lshw &gt; miplataforma.txt
sudo lshw -html
sudo lshw -short
sudo dmidecode -system
uname -a
arch
sudo cpu-x
inxi
inxi -c 0 -ACdGMNSz</pre></div></div></li></ul></div>
<h level="4">informe Lenovo Thinkpad T560</h><div class="ulist"><ul><li><p>listado de características básicas</p><div class="listingblock"><div class="content"><pre>modelo computadora: 20F1S0H400 (LENOVO_MT_20F1_BU_Think_FM_ThinkPad L560)
modelo CPU : Intel(R) Core(TM) i5-6300U CPU @ 2.40GHz
Arquitectura CPU: x86_64 -&gt; comando arch
Word width : 64
Capacidad de Memoria: 12GiB System Memory -&gt; 4+8
Chipset or PCH: Sunrise Point-LP
  USB 3.0 xHCI Controller
  SATA Controller [AHCI mode]
  PCI Express Root Port
  LPC Controller
  HD Audio
Graphics: Skylake GT2 [HD Graphics 520]
Network:
  Wireless 8260
  Ethernet Connection I219-LM
Frecuencia reloj : 2.40 GHz

Memoria Cache
	64KiB L1 cache
	64KiB L1 cache
	512KiB L2 cache
	3MiB L3 cache</pre></div></div></li></ul></div>
<h level="3">cpu</h><div class="imageblock" style="text-align: center"><img src="images/laptop_T560/cpu_package.jpg" alt="cpu package" /></div><div class="title">Figure 36. cpu_package</div>
<div class="imageblock" style="text-align: center"><img src="images/laptop_T560/skylake-family-table.jpg" alt="skylake family table" /></div><div class="title">Figure 37. skylake-family-table</div>
<h level="4">comandos</h><div class="ulist"><ul><li><p>list</p><div class="listingblock"><div class="content"><pre> sudo lshw -C cpu
 lscpu
 sudo dmidecode -t processor
 cpuid
 cat /proc/cpuinfo
sudo cpu-x</pre></div></div></li></ul></div>
<h level="4">web info</h><div class="ulist"><ul><li><p><a href="https://www.cpu-world.com/CPUs/Core_i5/Intel-Core%20i5-6300U%20Mobile%20processor.html">cpu-world</a></p></li><li><p><a href="https://ark.intel.com/content/www/es/es/ark/products/series/88393/6th-generation-intel-core-i5-processors.html">Intel: procesadores core i5 6ª generación</a></p><div class="ulist"><ul><li><p><a href="https://ark.intel.com/content/www/es/es/ark/products/88190/intel-core-i56300u-processor-3m-cache-up-to-3-00-ghz.html">Intel: Core i5-6300U</a></p></li></ul></div></li></ul></div>
<h level="4">informe</h><div class="ulist"><ul><li><p>listado de características básicas</p><div class="listingblock"><div class="content"><pre>modelo CPU: Intel(R) Core(TM) i5-6300U CPU @ 2.40GHz
Arquitectura: x86_64
Socket(s):                       1  -&gt; Soldado o
Byte Order:                      Little Endian
Address sizes:                   39 bits physical, 48 bits virtual
Número de núcleos: 2
Número de hebras: 2 por núcleo
Frecuencia:
   clock: 100MHz  -&gt; frecuencia de la Placa Base
   2.4GHz -&gt; marketing
   600 MHz -&gt; frecuencia de la cpu en el momento de ejecución del comando
   Multiplicador : valor máximo 24 -&gt; freq_cpu=24xFreq_motherboard -&gt; el multiplicador es dinámico, cambia continuamente de valor.
Microarquitectura: Skylake 14 nm -&gt; Skylake-U
Package: BGA
Virtualization:   VT-x  -&gt; cpu soporta Intel Virtualization
Flags :
  lm : long mode -&gt; funcionamiento de la CPU en modo 64 bits
  x86_64 : arquitectura -&gt; word width
  SSE, AVX -&gt; Extensión de la ISA base con más instrucciones
  vmx: virtualización enabled by BIOS
CPUIDs	406E3 -&gt; código identificador de la CPU -&gt; necesario para actualizar el microcódigo
Maximum operating temperature  	100°C
Thermal Design Power   	15 Watt  _&gt; consumo</pre></div></div></li><li><p>Intel Core&#8482; i5-6300U &#8594; significado del código comercial</p><div class="ulist"><ul><li><p>para realizar búsquedas en Google utilizo el nombre comercial "i5-6300U"</p></li><li><p>Inter Corporation</p></li><li><p>brand: core</p></li><li><p>family: i5</p></li><li><p>Generación 6ª: 6</p><div class="ulist"><ul><li><p>versión: 6000</p></li></ul></div></li><li><p>segmento notebook (portátiles): U</p></li></ul></div></li><li><p>Fecha: 2015 3º cuatrimestre.</p></li><li><p>El frecuencia de la CPU es el ciclo de reloj de los ciclos máquina del ciclo de instrucción.</p><div class="ulist"><ul><li><p>la duración de los ciclos de instrucción y sus fases se expresan en ciclos de reloj, no en MHz.</p></li></ul></div></li><li><p>A destacar el codename de la microarquitectura: <strong>Skylake-U</strong></p><div class="ulist"><ul><li><p>nos da información de todos los recursos hardware de la CPU.</p></li></ul></div></li></ul></div>
<h level="4">nivel de integracion: cpu-chipset</h><div class="imageblock" style="text-align: center"><img src="images/laptop_T560/esquema_chipset100_cpu6gen.png" alt="esquema chipset100 cpu6gen" /></div><div class="title">Figure 38. Esquema CPU Chipset discreto</div>
<div class="imageblock" style="text-align: center"><img src="images/laptop_T560/esquema_skylake-u-mobile-diagram.png" alt="esquema skylake u mobile diagram" width="100%"" /></div><div class="title">Figure 39. Esquema CPU Chipset integrado, scaledwidth=</div>
<div class="ulist"><ul><li><p>On chip (integración de módulos en el mismo chip): <strong>la integración de módulos en el mismo chip es importante</strong></p><div class="listingblock"><div class="content"><pre>Cores -&gt; 2 núcleos
x87 FPU on chip  -&gt; Float Point Unit : procesa números reales a diferencia de la ALU que procesa enteros
Chipset or PCH (Platform Hub)</pre></div></div></li></ul></div>
<div class="admonitionblock important"><table><tr><td class="icon"><i class="fa fa-exclamation-circle" title="Important"></i></td><td class="content">La cpu y el chipset están en el mismo chip pero en "dies" diferentes. Cada uno integrado en un substrato de silicio diferente.</td></tr></table></div>
<h level="4">Socket</h><div class="ulist"><ul><li><p>socket: <a href="https://globalamericaninc.com/types-of-cpu-sockets/" class="bare">https://globalamericaninc.com/types-of-cpu-sockets/</a></p><div class="ulist"><ul><li><p><a href="https://www.cpu-world.com/CPUs/Core_i5/Intel-Core%20i5-6300U%20Mobile%20processor.html">cpu-world</a></p><div class="ulist"><ul><li><p>Package : 1356-ball micro-FCBGA</p></li><li><p>Socket BGA1356 &#8594;  BGA &#8594; soldado a la placa base &#8594; no actualizable</p></li><li><p>los 1356 pines del chip pertenecen a todos los módulos integrados en el mismo chip:  los 2 núcleos y a los controladores del chipset.</p></li></ul></div></li><li><p><code>sudo hwinfo | grep -i socket</code> &#8594; "U3E1"  &#8594; ¿no encuentro info?</p></li><li><p><code>sudo dmidecode -t processor | grep -i socket</code> &gt; Socket designation: "U3E1"</p></li></ul></div></li></ul></div>
<h level="4">Datos erróneos</h><div class="ulist"><ul><li><p><code>sudo lshw -C cpu</code> &#8594; size: 975MHz</p></li><li><p><code>sudo dmidecode -t processor | grep -i freq</code> &#8594; me dice que la frecuencia máxima son 8GHz</p></li></ul></div></div></section><section id="_instruction_level_parallelism_ilp"><h2>7.9. Instruction Level Parallelism (ILP)</h2><div class="slide-content"><div class="ulist"><ul><li><p><a href="http://en.wikipedia.org/wiki/Instruction-level_parallelism">wikipedia</a></p><div class="ulist"><ul><li><p>Instruction-level parallelism (ILP) es la medida de cuantas instrucciones de un programa pueden ser ejecutadas simultáneamente. El solapamiento de la ejecución de las instrucciones recibe el nombre de instruction level parallelism (ILP)</p></li><li><p>Son dos los mecanismos para conseguir el ILP</p><div class="ulist"><ul><li><p>Hardware</p></li><li><p>Software</p></li></ul></div></li></ul></div></li><li><p>Técnicas de diseño de microarquitecturas que persiguen un solape ILP</p><div class="ulist"><ul><li><p>VLIW</p></li><li><p>Superscalar</p></li><li><p>Pipelining (Segmentación)</p></li><li><p>Out-of-order execution</p></li><li><p>etc</p></li></ul></div></li></ul></div>
<h level="3">Pipeline (Segmentacion)</h><div class="ulist"><ul><li><p>Pipeline: cauce o tubería. Segmentación en serie.</p></li><li><p>Ejemplo de Lavado de coches</p><div class="ulist"><ul><li><p>Fases: Humedecer - Enjabonar - Cepillar - Aclarar - Secar - Abrillantar</p></li></ul></div></li><li><p>Máquina Secuencial</p><div class="ulist"><ul><li><p>Cola de coches ante la máquina</p></li><li><p>Si un coche está en cualquiera de las fases no entra el siguiente coche.</p></li><li><p>El intervalo de tiempo de salida de coches será la suma de todas las fases. ¿Cada cuanto tiempo sale un coche del lavadero?</p></li><li><p><strong>Througput (Producción)</strong>: Número de coches de salida por unidad de tiempo</p></li></ul></div></li><li><p>Segmentación frente a Secuencial.</p><div class="ulist"><ul><li><p>En lugar de tener una máquina que realice todas la fases tenemos máquinas independientes que realizan cada fase.</p></li><li><p>El intervalo de tiempo de salida de coches será el de la duración de la fase de mayor duración.</p></li><li><p>El througput, del número de coches atendidos por unidad de tiempo, aumenta.</p></li></ul></div></li><li><p>Flujo de Instrucciones con segmentación en 2 etapas</p></li></ul></div>
<div class="imageblock" style="text-align: center"><img src="./images/cpu/12_9.jpg" alt="12 9" width="960" height="600" /></div><div class="title">Figure 40. Segmentación en 2 etapas</div>
<div class="ulist"><ul><li><p>En caso de que los tiempos de cada etapa sean distintos o halla penalización por saltos en el flujo , se producirán tiempos de espera.</p></li></ul></div>
<div class="imageblock" style="text-align: center"><img src="./images/cpu/12_10.jpg" alt="12 10" width="960" height="600" /></div><div class="title">Figure 41. Diagrama de tiempos con segmentación de 6 etapas</div>
<div class="imageblock" style="text-align: center"><img src="./images/cpu/12_11.jpg" alt="12 11" width="960" height="600" /></div><div class="title">Figure 42. Diagrama de tiempos. Salto incondicional</div>
<div class="imageblock" style="text-align: center"><img src="./images/cpu/12_12.jpg" alt="12 12" width="960" height="600" /></div><div class="title">Figure 43. Flujo de instrucciones con segmentación de 6 etapas</div>
<div class="ulist"><ul><li><p>Un salto obliga a vaciar la tubería &#8594; nueva microrden para la Unidad de Control &#8594; empty pipe</p></li></ul></div>
<h level="3">VLIW vs Superscalar</h><h level="4">VLIW</h><div class="ulist"><ul><li><p>Very Long Instruction Words</p></li><li><p>La CPU contiene múltiples Unidades de Ejecución</p></li><li><p>Una palabra contiene tantas instrucciones como unidades de ejecución.</p><div class="ulist"><ul><li><p>A la palabra se le denomina Instruction Word, la cual contiene múltiples instrucciones máquina.</p></li><li><p>El <em>compilador</em> crea las Instrucciones Word con las múltiples instrucciones <strong>asignando</strong> a cada una de ellas una Unidad de Ejecución distinta.</p><div class="ulist"><ul><li><p>Múltiples Instrucciones en Paralelo</p></li></ul></div></li></ul></div></li></ul></div>
<h level="4">Superscalar</h><div class="ulist"><ul><li><p>La arquitectura superescalar significa que la CPU tiene múltiples Rutas de Datos (múltiples Unidades de Ejecución (UE) y enrutamiento ), no confundir con múltiples núcleos (core), y es la <em>propia CPU</em> la que <strong>asigna</strong> en tiempo de ejecución distintas UEs y otros recursos de la máquina a las distintas instrucciones .</p></li><li><p>Dicha arquitectura permite la ejecución simultánea de múltiples instrucciones.</p></li><li><p>Una CPU superscalar <strong>n-way</strong> significa que puede ejecutar simultáneamente n instrucciones.</p></li><li><p>Superscalar no significa multinúcleo. Un único núcleo es superscalar.</p></li></ul></div>
<h level="4">Comparativa Superscalar-VLIW</h><div class="ulist"><ul><li><p>One of the great debates in computer architecture is static vs. dynamic. <strong>static</strong> typically means "let&#8217;s make our compiler take care of this", while <strong>dynamic</strong> typically means "let&#8217;s build some hardware that takes care of this". Each side has its advantages and disadvantages. the compiler approach has the benefit of time: a compiler can spend all day analyzing the heck out of a piece of code. however, the conclusions that a compiler can reach are limited, because it doesn&#8217;t know what the values of all the variables will be when the program is actually run. As you can imagine, if we go for the hardware approach, we get the other end of the stick. there is a limit on the amount of analysis we can do in hardware, because our resources are much more limited. on the other hand, we can analyze the program when it actually runs, so we have complete knowledge of all the program&#8217;s variables.</p></li><li><p><strong>VLIW</strong> approaches typically fall under the "static" category, where the compiler does all the work.</p></li><li><p><strong>Superscalar</strong> approaches typically fall under the "dynamic" category, where special hardware on the processor does all the work. consider the following code sequence:</p></li></ul></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">sw $7, 4($2)
lw $1, 8($5)

$ significa direccionamiento directo
() direccionamiento indirecto indexado</code></pre></div></div>
<div class="ulist"><ul><li><p>suppose  we can run two memory operations in <strong>parallel</strong> [but only if they have <strong>no dependencies</strong>, of course]. are there dependencies between these two instructions? well, it depends on the values of $5 and $2, es decir, del contenido de las direcciones de memoria 5 y 2. Si el contenido de la dirección $5 is 0, y el contenido de la dirección $2 is 4, then they <strong>depend</strong> on each other: we must run the store before the load y <strong>no</strong> se pueden ejecutar en paralelo.</p><div class="ulist"><ul><li><p>in a <strong>VLIW</strong> approach, our compiler decides which instructions are safe to run in parallel. there&#8217;s no way our compiler can tell for sure if there is a dependence here. so we must stay on the safe side, and dictate that the store must always run before the load. if this were a bigger piece of code, we could analyze the code and try to build a proof that shows there is no dependence. [modern parallelizing compilers actually do this!]</p></li><li><p>if we decide on a <strong>SUPERSCALAR</strong> approach, we have a piece of hardware on our processor that decides whether we can run instructions in parallel. the problem is easier, because this dependence check will happen in a piece of hardware on our processor, as the code is run. so we will know what the values of $2 and $5 are. this means that we will always know if it is safe to run these two instructions in parallel. Por lo tanto unas veces las dos instrucciones serán ejecutadas en paralelo y otras no.</p><div class="ulist"><ul><li><p>Hopefully you see some of the tradeoffs involved. dynamic approaches have more program information available to them, but the amount of resources available for analysis are very limited. for example, if we want our superscalar processor to search the code for independent instructions, things start to get really hairy. static approaches have less program information available to them, but they can spend lots of resources on analysis. for example, it&#8217;s relatively easy for a compiler to search the code for independent instructions.</p></li></ul></div></li></ul></div></li></ul></div>
<div class="imageblock" style="text-align: center"><img src="./images/cpu/vliwpipeline.svg.png" alt="vliwpipeline.svg" width="400" height="300" /></div><div class="title">Figure 44. VLIW</div>
<div class="imageblock" style="text-align: center"><img src="./images/cpu/superscalarpipeline.svg.png" alt="superscalarpipeline.svg" width="400" height="300" /></div><div class="title">Figure 45. Superscalar de dos vías (2-way)</div>
<h level="4">Aplicaciones VLIW</h><div class="ulist"><ul><li><p>La aplicación típica de la técnica VLIW son los procesadores "Digital Processing Signal DSP" como el TI’s TMS320C6x y el ADI’s Tiger-SHARC que procesan digitalmente y en tiempo real señales de audio, video, comunicaciones, etc. No son procesadores genéricos sino que la ISA y la microarquitectura están especializados en realizar operaciones matemáticas a gran velocidad y con gran número de datos. Hoy en día su gran mercado es la telefonía móvil. Por ejemplo: Cadence® Tensilica® Vision P6 DSP for its 10nm Kirin 970 mobile application processor, which debuted in Huawei’s new Mate 10 Series mobile phones. Due to its wide VLIW SIMD architecture, highly optimized instruction set and expertly tuned imaging library, the DSP is an ideal platform for emerging imaging applications such as 3D sensing, human/machine interface, AR/VR and biometric identification for the mobile platform.</p></li></ul></div></div></section><section id="_arquitecturas_ciscrisc"><h2>7.10. Arquitecturas CISC/RISC</h2><div class="slide-content"><h level="3">Introducción</h><div class="ulist"><ul><li><p>CISC: Complex Instruction Set Computer</p></li><li><p>RISC: Reduced Instruction Set Computer</p></li><li><p>CISC y RISC son dos filosofías de diseño de un computador, dos arquitecturas.</p></li></ul></div>
<h level="3">CISC</h><div class="ulist"><ul><li><p>Ejemplos: Motorola 68k, Intel x86.</p></li><li><p>El objetivo fué conseguir programas que ocupasen poca memoria DRAM, ya que en los inicios la memoria era costosa. Había que conseguir instrucciones que realizasen operaciones complejas para que el programa no fuese muy largo.</p></li><li><p>El repertorio abarca Instrucciones de varios bytes y no uniformes.</p></li><li><p>Necesita un HW complejo que ocupa mucho espacio y necesita muchos ciclos de reloj.</p></li><li><p>La arquitectura del lenguaje ensamblador está próxima a un lenguaje de alto nivel cómo el lenguaje C por lo que facilita la tarea a los compiladores y a los programadores de lenguaje ensamblador.</p></li><li><p>En cambio complica el diseño e implementación de elementos hardware como la CPU.</p></li></ul></div>
<h level="3">RISC</h><div class="ulist"><ul><li><p>Ejemplos: PowerPC, ARM, MIPS and SPARC</p></li><li><p>El origen fue diseñar un microprocesador con bajo presupuesto por lo que la apuesta fue una microarquitectura con un Hardware sencillo que ejecutase instrucciones también sencillas, regulares.</p><div class="ulist"><ul><li><p>Un HW sencillo es rápido y ocupa poca área del chip. Es fácil incrementar el número de etapas pipeline.</p></li><li><p>La consecuencia fue un micro de bajo consumo que más adelante se haría con todo el mercado de telefonía móvil.</p></li><li><p>El repertorio de instrucciones es reducido con pocos códigos de operación y direccionamientos sencillos, lo que daría lugar a programas con un gran número de instrucciones máquina.</p></li></ul></div></li><li><p>Inconveniente:</p><div class="ulist"><ul><li><p>Requiere de más capacidad de memoria para almacenar programas extensos. Deja de ser un inconveniente si se abaratan las unidades de memoria DRAM.</p></li><li><p>Gran número de accesos a memoria para capturar las instrucciones, los operandos y  el resultado. Deja de ser un inconveniente si se utilizan memorias de latencia reducida.</p></li><li><p>Solución: incrementar la memoria interna: el número de Registros internos y la memoria caché. Para lo cual hay espacio debido al core de area reducida</p></li></ul></div></li><li><p>Core de área reducida permite:</p><div class="ulist"><ul><li><p>incrementar la capacidad de memoria interna ultrarápida.</p></li><li><p>incrementar el número de vías de la arquitectura superescalar.</p></li></ul></div></li></ul></div>
<h level="3">Cuestiones</h><div class="ulist"><ul><li><p>Qué arquitectura optimiza el tamaño de bytes del programa</p></li><li><p>Qué arquitectura optimiza el tiempo de ejecución del cada instrucción</p></li><li><p>Qué arquitectura optimiza el tamaño y coste de fabricación de la CPU</p></li><li><p>Qué arquitectura optimiza el consumo</p></li><li><p>Qué arquitectura optimiza el número de capturas a memoria. ¿Existe indepencia entre captura y ejecución de instrucciones?</p></li></ul></div>
<h level="3">SW</h><div class="ulist"><ul><li><p>Un programa ensamblador de una arquitectura RISC tiene más instrucciones que un CISC</p></li><li><p>Cada instrucción RISC se ejecuta en menor tiempo que una CISC.</p></li></ul></div>
<h level="3">Tabla Comparativa</h><div class="ulist"><ul><li><p><a href="http://cs.stanford.edu/people/eroberts/courses/soco/projects/risc/risccisc/">RISC vs CISC</a></p></li></ul></div></div></section><section id="_microarquitecturas_modernas"><h2>7.11. Microarquitecturas Modernas</h2><div class="slide-content"><div class="ulist"><ul><li><p>En el <a href="#apendice_cpu">Apéndice</a> se comentan las siguientes microarquitecturas:</p><div class="ulist"><ul><li><p>Computadora ThinkPad TL560:  microarquitectura Skylake de la CPU intel x86-64</p></li><li><p>Teléfono Huawei 30 Pro: ARM Cortex-A76 y ARM Cortex-A55</p></li></ul></div></li></ul></div></div></section><section id="_ejercicios"><h2>7.12. Ejercicios</h2><div class="slide-content"><div class="ulist"><ul><li><p>Capítulo 12 del libro de texto William Stalling.</p></li><li><p>Capítulo 13 del libro de texto William Stalling</p></li><li><p><a href="#ejercicios">Ejercicios</a></p></li></ul></div></div></section></section>
<section><section id="_mecanismos_de_entradasalida"><h2>8. Mecanismos de Entrada/Salida</h2></section><section id="_temario_8"><h2>8.1. Temario</h2><div class="slide-content"><div class="olist arabic"><ol class="arabic" start="8"><li><p>Sistema de entrada / salida</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Sincronización por encuesta</p></li><li><p>Sincornización por interrupción</p></li><li><p>Vector de interrupciones</p></li><li><p>Acceso directo a memoria DMA</p></li><li><p>Programación en lenguaje ensamblador de rutinas de entrada/salida</p></li></ol></div></li></ol></div></div></section><section id="_bibliografia"><h2>8.2. Bibliografia</h2><div class="slide-content"><div class="ulist"><ul><li><p>Libro de Texto:</p><div class="ulist"><ul><li><p>Estructura y Organización de Computadores. William Stalling: Capítulo 7</p></li></ul></div></li></ul></div></div></section><section id="_periféricos"><h2>8.3. Periféricos</h2><div class="slide-content"><h level="3">Ejemplos</h><div class="ulist"><ul><li><p>Teclado</p></li><li><p>Monitor</p></li><li><p>Disco Duro</p></li><li><p>Red</p><div class="ulist"><ul><li><p>LAN</p></li><li><p>Wifi</p></li></ul></div></li><li><p>Periférico externo</p><div class="ulist"><ul><li><p>Pen-Drive</p></li></ul></div></li><li><p>De cada ejemplo info de:</p><div class="ulist"><ul><li><p>modelo y link a características</p></li><li><p>interfaz: bus eléctrico, protocolo de comunicaciones</p></li><li><p>ancho de banda</p></li></ul></div></li></ul></div>
<h level="3">Modelo</h><div class="ulist"><ul><li><p>Media : Magnético (HD), Mecánico (Robot), Optico (CD), Eléctrico (pen drive), etc</p><div class="ulist"><ul><li><p>Electrónica analógica.</p></li></ul></div></li><li><p>Driver HW</p><div class="ulist"><ul><li><p>Interfaz con el media:</p><div class="ulist"><ul><li><p>las señales que actuan sobre el media son de distinto tipo: optica (luz), mecánica (pneumático), acústica, etc. Estas señales se obtienen normalmente de la transformación de una señal eléctrica: interfaz eléctrico/optico, eléctrico/mecánico, eléctrico/acústico</p></li><li><p>Ej: Un altavoz</p></li><li><p>Ej: Un Láser con el disco óptico.</p></li><li><p>Ej: El modulador electrónico del láser</p></li></ul></div></li></ul></div></li><li><p>Controlador del Periférico (<strong>MCU: MicroController Unit</strong>)</p><div class="ulist"><ul><li><p><a href="http://en.wikipedia.org/wiki/Disk_buffer">Imagen de un controlador de disco</a></p></li><li><p>El Controlador  da órdenes al Driver HW</p></li><li><p>Es un secuenciador que interpreta <strong>Comandos</strong> (lenguaje específico para tareas del periférico) cuya ejecución realizará funciones propias del periférico.</p><div class="ulist"><ul><li><p>Lenguaje de comandos. Command Set Architecture (CSA) ¿ISA?</p><div class="ulist"><ul><li><p><a href="http://en.wikipedia.org/wiki/SCSI_command">Lenguaje SCSI</a></p></li><li><p><a href="https://ata.wiki.kernel.org/index.php/Developer_Resources">Lenguaje ATA / ATAPI</a></p></li><li><p>ATA Command Set (ACS): ejemplo de comandos IDENTIFY, READ DMA, WRITE DMA and FLUSH CACHE commands</p></li></ul></div></li><li><p>comandos de transferencia de datos, de control (operaciones mecánicas como girar), de test (estado del periférico: conectado, desconectado)</p></li></ul></div></li><li><p>Ej: en el caso de un disco el comando "girar a determinadas revoluciones". El disco integra un secuenciador propio, un MCU.</p></li></ul></div></li><li><p>Firmware</p><div class="ulist"><ul><li><p>El set de comandos del periférico son interpretados por el software (firmware) cargado en la memoria del controlador MCU. Dicho software ha sido grabado por el fabricante del periférico. El usuario únicamente podrá escribir en el periférico algunos parámetros de configuración del periférico siendo accesible el Firmaware unicamente por el fabricante.</p></li></ul></div></li></ul></div></div></section><section id="_teclado"><h2>8.4. Teclado</h2><div class="slide-content"><div class="ulist"><ul><li><p>Estructura</p><div class="listingblock"><div class="content"><pre>+-------------------+     +-------------------+    +----------------------+          +-------+
| Keyboard  Layout  | -&gt;  | Keyboard Encoder  | -&gt; | Keyboard Controller  |    -&gt;    | CPU   |
+-------------------+     +-------------------+    +----------------------+          +-------+</pre></div></div></li><li><p>Códigos</p><div class="listingblock"><div class="content"><pre>+---------------+     +-----------+    +-----------+      +------------------+
| Key mechanic  | -&gt;  | Scan Code | -&gt; | Key Code  | -&gt;   | Character Code   |
+---------------+     +-----------+    +-----------+      +------------------+</pre></div></div></li><li><p>Driver</p></li></ul></div></div></section><section id="_arquitectura_computadora"><h2>8.5. Arquitectura Computadora</h2><div class="slide-content"><h level="3">Von Neumann</h><div class="ulist"><ul><li><p>3 unidades básicas</p></li><li><p>Controlador i/o</p><div class="ulist"><ul><li><p>Controlador auxiliar, no central, con dedicación específica a las operaciones E/S.</p></li></ul></div></li><li><p>Subsistema de Entrada/Salida : es uno de los 3 componentes del modelo Von Neumann</p></li><li><p>Es necesario acceder a la máquina para:</p><div class="ulist"><ul><li><p>Introducir el programa : Desde un soporte de almacenamiento (papel,disco,etc) ha de cargarse el programa en la memoria</p></li><li><p>Extraer el resultado generado por la máquina: Desde la memoria los resultados han de almacenarse en un soporte de almacenamiento (disco, impresora, etc), visualizarse (pantalla, etc), transferirse (red, etc).</p></li></ul></div></li><li><p>Dispositivos Periféricos</p><div class="ulist"><ul><li><p>Son recursos hardware que complementan y extienden los servicios del tándem CPU-MEMORIA facilitando las tareas del progamador y del usuario.</p></li><li><p>Gran diversidad: teclado, monitor, ratón, discos, tarjeta video, tarjeta red, &#8230;&#8203;</p></li><li><p>diferencia de complejidad entre un teclado y un disco duro</p></li></ul></div></li><li><p>La CPU normalmente es un recurso único compartido por todos los programas y por todos los periféricos.</p></li></ul></div>
<h level="3">Conexión CPU-E/S</h><div class="ulist"><ul><li><p>La arquitectura está formada, por lo tanto, por dos controladores: CPU y MCU. La CPU tiene un controlador generalista (CPU) mientras que el periférico tiene un controlador (MCU) muy específico. El lenguaje máquina de la CPU es generalista mientras que el lenguaje máquina del periférico es muy específico.</p><div class="ulist"><ul><li><p>El periférico se comporta como una máquina <strong>servidor</strong> con su propio procesador. Podemos hablar de la máquina <strong>host</strong> (anfitrión) y de la máquina <strong>server</strong> . El controlador host es la CPU de la computadora y el controlador server es la MCU del periférico.</p></li><li><p>La CPU no se comunica directamente con el MCU sino que delega la tarea de los periféricos a procesadores no centrales, es decir, a los controladores I/O. La arquitectura típica de la computadora es la de un Procesador Central y un Set de controladores i/o que Intel denomina <strong>Chipset</strong></p><div class="listingblock"><div class="content"><pre>+------------------------------+    +----------------------+          +--------------------------------+
| Unidad de Control de la CPU  | -&gt; |    Controlador I/O   |    -&gt;    | Controlador del Periférico  MCU|
+------------------------------+    +----------------------+          +--------------------------------+</pre></div></div></li><li><p>Ejemplo: Disco Duro</p><div class="ulist"><ul><li><p><a href="http://disctech.com/Seagate-ST9500420AS-SATA-Hard-Drive">Seagate Momentus 7200.4 500GB 7.2K 2.5-inch SATA Hard Drive ST9500420AS </a></p></li><li><p><a href="http://theithollow.com/2013/11/disk-latency-concepts/">video del movimiento del brazo</a></p></li><li><p><a href="http://en.wikipedia.org/wiki/Disk_buffer">Disk buffer</a>: memoria interfaz entre la transferencia del drive y la transferencia i/o del puerto.</p></li><li><p><a href="http://www.atmel.com/Images/ATA_HardDrive.pdf">Controlador Atmel casero</a>: Disco Sata con controladora Atmel e interfaz ethernet.</p></li></ul></div></li></ul></div></li></ul></div>
<h level="3">Controlador I/O</h><h level="4">Introducción</h><div class="ulist"><ul><li><p>Periférico remoto:</p><div class="ulist"><ul><li><p>Ej:PC---&#8594;SATA---&#8594;Compact Disc</p></li></ul></div></li><li><p>Controlador I/O del PC :</p><div class="ulist"><ul><li><p>NO es la Unidad de Control de la CPU</p></li><li><p>Es uno de los 3 elementos básicos de la arquitectura Von Neumann</p></li><li><p>La CPU delega en otro controlador denominado controlador I/O la ejecución de las instrucciones máquina de entrada/salida.</p></li><li><p>Es necesario una INTERFAZ entre la CPU y el PERIFERICO</p></li><li><p>ISA:Instrucciones máquina de entrada salida de la cpu: de lectura (IN) y de escritura (OUT). Comunicación en ambos sentidos.</p><div class="ulist"><ul><li><p>Se transfieren tanto los DATOS como los COMANDOS del periférico.</p></li></ul></div></li><li><p>William denomina al controlador I/O con el nombre Módulo de E/S</p></li><li><p>Es el controlador I/O el que transfiere los comandos y los datos al controlador del periférico.</p><div class="ulist"><ul><li><p>El controlador del periférico interpretará los COMANDOS recibidos del controlador I/O y escribirá o/y leerá los DATOS.</p></li><li><p>Ejemplo:The Advanced Host Controller Interface (AHCI) is a technical standard defined by Intel that specifies the operation of Serial ATA (SATA) io controller (host bus adapters).</p></li></ul></div></li></ul></div></li><li><p>Estructura</p><div class="listingblock"><div class="content"><pre>+---------------+    +---------------+    +------+   +----------------------+     +---------+    +-----+
|Controlador CPU| -&gt; |Controlador I/O| -&gt; |Puerto|-&gt; |Controlador Periférico|  -&gt; |Driver HW| -&gt; |Media|
+-----+---------+    +---------------+    +------+   +----------------------+     +---------+    +-----+
      |                                                          |
  +---+---+                                                  +---+---+
  |Memoria|                                                  |Memoria|
  +-------+                                                  +-------+
    Driver                                                    Firmware</pre></div></div></li></ul></div>
<h level="4">Puertos</h><div class="ulist"><ul><li><p>Los puertos son registros de memoria implementados en el controlador i/o.</p><div class="ulist"><ul><li><p>Un puerto está formado por distintos tipos de registros: entrada de datos, salida de datos, estado del periférico, control del periférico</p><div class="listingblock"><div class="content"><pre>controlador i/o
puerto

               +------------+
               |  IN        |&lt;--periférico
               +------------+
               |  OUT       |--&gt;periférico
               +------------+
        cpu &lt;--|  STATUS    |
               +------------+
        cpu --&gt;|  CONTROL   |
               +------------+</pre></div></div></li></ul></div></li><li><p>El <strong>controlador I/O</strong> controla y ejecuta las comunicaciones a través de sus puertos.</p><div class="ulist"><ul><li><p>Ej: Controlador I/O con puerto SATA</p></li></ul></div></li><li><p><strong>Puerto</strong> de comunicaciones: Acceso al otro interlocutor (el periférico en este caso)</p></li><li><p>Un controlador I/O puede tener varios puertos y controlar las comunicaciones con varios periféricos.</p></li><li><p>Un puerto puede ser compartido por varios periféricos</p></li><li><p>Linux</p><div class="ulist"><ul><li><p><code>cat /proc/ioports</code></p></li></ul></div></li></ul></div>
<h level="3">Espacio de direcciones</h><div class="ulist"><ul><li><p>Las direcciones i/o del puerto del controlador i/o se puede implementar de dos formas:</p><div class="ulist"><ul><li><p>puertos mapeados en la memoria principal &#8594; <strong>MMIO</strong></p></li><li><p>direcciones de los puertos en un espacio diferente de la memoria principal: espacio i/o. <strong>IO</strong> ó <strong>PMIO</strong></p></li></ul></div></li></ul></div>
<h level="4">Memory-Mapped I/O (MMIO)</h><div class="ulist"><ul><li><p>Main Memory Address Space</p></li><li><p>El bus del sistema shares memory address space between I/O devices and program memory</p></li><li><p>Interface to the I/O is treated as a set of primary memory locations (Memoria principal)</p></li><li><p>Software drivers determine meaning of data stored or retrieved.</p></li><li><p>Loss of some memory space (8086 - 300K) because it is reserved for I/O interfaces. Less important with 4GiB address space.</p></li><li><p>All instruction modes available &#8594; Todo el repertorio de instrucciones, no solo IN,OUT.</p></li><li><p>May slow overall memory bus access down.</p></li><li><p>Can limit or complicate contiguous memory range.</p></li><li><p>Original x86 architecture had a 1MiB boundary because I/O was mapped above 640K.</p></li></ul></div>
<h level="4">Port mapped I/O (PMIO)</h><div class="ulist"><ul><li><p>I/O Address Space</p></li><li><p>CPU has separate set of instructions that access specific pin on CPU that act as ports or that cause a demux to connect the address and data pin-outs to a different set of lines tied to i/o.</p></li><li><p>Separate bus tied to I/O devices. CPU can go back to using memory bus while I/O devices responds.</p></li><li><p>Adds complexity to CPU design.</p></li><li><p>Often limited set of instructions. May need to write to memory before other actions can be taken.</p></li></ul></div>
<h level="4">Direcciones de los periféricos</h><div class="ulist"><ul><li><p>Driver</p><div class="ulist"><ul><li><p>El programa driver es un proceso i/o que utiliza el mecanismo de memoria virtual igual que el resto de procesos.</p></li><li><p>Mapa en el fichero <em>/proc/iomem</em></p></li></ul></div></li><li><p>Periférico</p></li><li><p>Al espacio de direcciones utilizado por los periféricos se le denomina <strong>devices address</strong>  ya que son direcciones visibles para el periférico, es su espacio de direcciones independiente de la computadora.</p></li><li><p>Hará falta mapear, traducir, direcciones device a direcciones virtuales visibles para la cpu</p><div class="ulist"><ul><li><p>Mapa en el fichero <em>/proc/ioports</em></p><div class="listingblock"><div class="content"><pre>               CPU                               DEVICE
             Virtual                            Address
             Address                             Space
              Space

            +-------+                          +------+
            |       |                Offset    |      |
            |       |  Virtual       applied   |      |
          C +-------+ --------&gt;    ----------&gt; +------+ A
            |       |  mapping     Controlador |      |
  +-----+   |       |                   io     |      |   +--------+
  |     |   |       |                          |      |   |        |
  | CPU |   |       |                          |      |   | Device |
  |     |   |       |                          |      |   |        |
  +-----+   +-------+                          +------+   +--------+
            |       |                Mapping   |      |
          X +-------+ --------     &lt;---------- +------+ Z
            |       |               Controlador
            |       |                   io
            |       |
            +-------+</pre></div></div></li></ul></div></li></ul></div>
<h level="3">Buses</h><div class="ulist"><ul><li><p>Tipos de buses</p><div class="ulist"><ul><li><p>del procesador: bus interno a a la cpu</p></li><li><p>de memoria: bus entre el controlador de memoria y la memoria principal</p></li><li><p>del sistema: bus externo a la cpu para el interconexiado de dispositivos externos como la memoria principal y los controladores i/o de los periféricos.</p></li><li><p>local: bus i/o corto que permite elevados anchos de banda</p></li><li><p>de expansión: bus i/o largo que permite la conexión de múltiples <em>tarjetas</em></p></li><li><p>periférico: bus i/o que permite conectar dispositivos externos a la computadora</p><div class="listingblock"><div class="content"><pre>+-------+    Expansion Bus i/o      +---------------------+    Peripheral Bus     +------------+
|  CPU  | ------------------------&gt; |   Controlador I/O   | ------------------&gt;   | Periférico |
+-------+                           +---------------------+                       +------------+</pre></div></div></li></ul></div></li><li><p>Bus i/o local; vlb,PCI, AGP</p></li><li><p>Bus i/o de expansión:ISA, EISA</p><div class="ulist"><ul><li><p>Conexión directa de la tarjeta i/o al bus de expansión de la placa base a través de <em>slots</em>:</p></li></ul></div></li><li><p>Bus periférico:  SCSI, SATA, USB, RS232</p><div class="ulist"><ul><li><p>Conexión externa a través de un <em>cableado</em></p></li></ul></div></li><li><p>La arquitectura del bus io  la componen</p><div class="ulist"><ul><li><p>Interfaz (cable y conector)</p></li><li><p>Protocolo de comunicaciones: set of standardized rules for consistent interaction between system and i/o devices, including physical properties, access methods, data formats, etc. El Bus  da nombre al protocolo.</p></li><li><p>Lenguaje de comandos</p></li></ul></div></li><li><p>Ejemplos prácticos</p><div class="ulist"><ul><li><p>ISA</p><div class="ulist"><ul><li><p>Industry Standard Architecture</p></li><li><p>PC/XT 8086 (1983) 8 bits</p><div class="ulist"><ul><li><p>4 canales DMA</p></li></ul></div></li><li><p>PC/AT i286 (1984) 16 bits</p><div class="ulist"><ul><li><p>16 MB/s</p></li><li><p>7 canales DMA</p></li><li><p>11 líneas IRQ</p></li></ul></div></li></ul></div></li><li><p>EISA</p><div class="ulist"><ul><li><p>Extended Industry Standard Architecture</p></li><li><p>PC Clon: i386-i486 (1988)</p></li><li><p>32 Bits</p></li><li><p>Alternativa de los clónicos al propietario MCA de IBM en su PS/2</p></li><li><p>33 MB/s de velocidad de transferencia para buses maestros y dispositivos DMA</p></li><li><p>7 canales DMA</p></li><li><p>15 líneas IRQ</p></li></ul></div></li><li><p>MCA</p><div class="ulist"><ul><li><p>Micro Channel Architecture</p></li><li><p>IBM PS/2 (1987)</p></li><li><p>32 bits</p></li></ul></div></li><li><p>PCI: Peripheral Component Interconnect</p></li><li><p>PCI Express</p></li><li><p><a href="http://en.wikipedia.org/wiki/List_of_device_bit_rates#Computer_buses">listado de anchos de banda</a></p></li></ul></div></li><li><p><a href="http://www.karbosguide.com/hardware/module2b2.htm" class="bare">http://www.karbosguide.com/hardware/module2b2.htm</a></p><div class="ulist"><ul><li><p>El controlador i/o se conecta indirectamente al bus del sistema (CPU-MP) a través de los puentes (bridges)</p></li></ul></div></li><li><p><a href="http://en.wikipedia.org/wiki/Platform_Controller_Hub">Intel</a></p><div class="ulist"><ul><li><p>Intel ha evolucionado de los puentes <a href="http://en.wikipedia.org/wiki/I/O_Controller_Hub">ICH</a> con el puente <a href="http://en.wikipedia.org/wiki/Southbridge_%28computing%29">Sur</a> y <a href="http://en.wikipedia.org/wiki/Northbridge_%28computing%29">Norte</a> a un Concentrador Central PCH</p><div class="ulist"><ul><li><p>Observar que la CPU integra el controlador de memoria integrado (IMC) y controladores i/o de video (PCI-E Graphics)</p></li></ul></div></li></ul></div></li></ul></div>
<h level="3">Analisis:  Lenovo T520 - Disco Duro</h><div class="ulist"><ul><li><p>Ruta de la transferencia de datos entre el disco duro y la memoria principal en la computadora Lenovo T520</p></li><li><p>Disco (ATA disk, ST9500420AS Seagate)&#8594; Driver Mecánico/Electrico/Magnético &#8594; Micro del Disco (SATA Interface, Seagate)  &#8594; Bus i/o serie(SATA 6Gb/s)&#8594; Host Adapter (Platform_Controller_Hub PCH, ChipSet 200C/6 Series, SATA AHCI Controller)&#8594; Flexible Display Interface (FDI) &#8594; CPU (Intel Core i5)</p></li><li><p>SATA: Serial Advanced Technology Attachment is a computer bus interface that connects host bus adapters (controladora de disco) to mass storage devices (MCU, MicroControllerUnit) such as hard disk</p></li></ul></div>
<div class="imageblock" style="text-align: center"><img src="./images/io/Intel_5_Series_architecture.png" alt="Intel 5 Series architecture" /></div><div class="title">Figure 46. Lenovo T520</div></div></section><section id="_programa_es"><h2>8.6. Programa E/S</h2><div class="slide-content"><div class="ulist"><ul><li><p>Programmed i/o (PIO)</p><div class="ulist"><ul><li><p>Las transferencias de datos mediante mecanismos de E/S por consulta la realiza un programa i/o (PIO) que ejecuta la CPU. La CPU en cada transferencia de datos entre la memoria y el periférico debe de ESPERAR a que dicha transferencia termine.</p></li></ul></div></li></ul></div>
<h level="3">Módulo fuente</h><div class="ulist"><ul><li><p>Transferencia de 512 bytes entre el puerto 0x380 y un buffer.</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">      mov %bx,buf ; destination address. BX es un puntero a un buffer
      mov $512,%si ; count. Número de bytes a transferir
      mov $0x380,%dx ; source port. DX es un puntero al puerto
loop:
      in %dx,%al ; get byte from i/o port. AL&lt;-DX
      mov %al,(%bx) ; store in buffer      M[bx]&lt;-AL
      inc %bx ; next memory location in buf
      dec %si ; decrement bytes left
      jnz loop</code></pre></div></div></li></ul></div>
<h level="4">ISA</h><div class="ulist"><ul><li><p>IN: leer un dato del puerto</p></li><li><p>OUT: escribir un dato en el puerto</p></li></ul></div></div></section><section id="_driver_sistema_operativo"><h2>8.7. Driver: Sistema Operativo</h2><div class="slide-content"><h level="3">Gestor E/S: jerarquía</h><div class="ulist"><ul><li><p>La gestión de las operaciones E/S las realiza el Sistema Operativo</p></li><li><p>La estructura del programa  gestor E/S del sistema operativo se basa en una estructura jerárquica por niveles:</p><div class="ulist"><ul><li><p>Nivel más bajo: controlador sw (módulo driver) del controlador hw i/o del periférico.</p></li><li><p>Nivel más alto: Sistema virtual de ficheros. Las aplicaciones acceden a los periféricos mediante la abstracción de estos en ficheros virtuales.</p></li></ul></div></li></ul></div>
<h level="3">Código Fuente</h><div class="ulist"><ul><li><p>Pseudo-código</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">While (STATUS == BUSY)
   ; // wait until device is not busy . Puerto ocupado.
Write data to DATA register // dato a transmitir el puerto out
Write command to COMMAND register  // registro de control
   // Doing so starts the device and executes the command
While (STATUS == BUSY)
   ; // wait until device is done with your request</code></pre></div></div></li></ul></div>
<h level="3">Concepto</h><div class="ulist"><ul><li><p>El programa que implementa las funciones del periférico es un <em>módulo del kernel</em> denominado DRIVER</p><div class="ulist"><ul><li><p>Driver del teclado, monitor, disco duro,</p></li></ul></div></li><li><p>Capas SW:</p></li></ul></div>
<div class="listingblock"><div class="content"><pre>+---------------+      +--------------------------------------+      +----------------------------+
| Aplicación Sw |  -&gt;  |       Fichero tipo Device            |  -&gt;  |      Kernel Driver Sw      |
|               |      |(abstracción de cualquier periférico) |      |(específico del periférico) |
+---------------+      +--------------------------------------+      +----------------------------+

Periférico: Fichero virtual
Tipos:  bloque (disco duro), caracter (teclado)</pre></div></div>
<div class="ulist"><ul><li><p>Ejemplo: Escritura de un fichero en el disco duro</p><div class="ulist"><ul><li><p>write &#8594; syscall &#8594; OUT &#8594; comando propio del HD</p><div class="listingblock"><div class="content"><pre>+---------------+    +----------------------+            +------+             +-------------------------------------+
|     write     | -&gt; |       syscall        |    -&gt;      | OUT  |      -&gt;     |Comando propio del disco duro y Datos|
+---------------+    +----------------------+            +------+             +-------------------------------------+
                                                  |                     |
               Espacio de Usuario                 |    Espacio Kernel   |          Espacio Periférico
                                                  |                     |</pre></div></div>
<div class="ulist"><ul><li><p>Espacio de usuario: write (función de escritura de datos), syscall (llamada al módulo gestor de E/S del Sistema Operativo)</p></li><li><p>Espacio kernel del S.O.: Driver: Orden interpretada por la CPU y ejecutada por el controlador I/O para transferir datos (comandos y datos) entre Memoria y el Controlador Periférico</p></li><li><p>Espacio periférico: Comandos a Interpretar por el Periférico (Firmware) y transferencia de Datos.</p></li></ul></div></li></ul></div></li></ul></div>
<h level="3">Utilizacion del Driver</h><div class="ulist"><ul><li><p>El driver está protegido por el Sistema Operativo. Hay funciones como ioctl que permite al usuario interactuar con el driver.</p><div class="ulist"><ul><li><p>La interfaz entre el usuario y el driver son las llamadas al sistema operativo.</p><div class="ulist"><ul><li><p>Mediante la instrucción máquina SYSCALL (x86-64) o int 0x80 (x86-32) llamamos indirectamente a las funciones del driver a través del sistema operativo.</p></li></ul></div></li></ul></div></li><li><p>Ejemplo</p><div class="ulist"><ul><li><p>Imprimir en la pantalla: open, write, close &#8594; open y close interactuan con el sistema de ficheros virtual.</p></li></ul></div></li></ul></div></div></section><section id="_mecanismos_de_implementación_de_la_interfaz_es"><h2>8.8. Mecanismos de Implementación de la Interfaz E/S</h2><div class="slide-content"><h level="3">Introduccion</h><div class="ulist"><ul><li><p>All data manipulation not directly performed in the CPU or between CPU and primary memory is I/O.</p></li><li><p>PIO:Polling</p></li><li><p>Interruption</p></li><li><p>DMA: Direct Memory Access</p></li></ul></div>
<h level="3">Sincronización por Encuesta</h><div class="ulist"><ul><li><p>Polling: encuesta</p></li><li><p>Query: encuesta</p></li><li><p>Mecanismo</p><div class="ulist"><ul><li><p>Comprobación del estado o <em>encuesta-polling</em></p><div class="ulist"><ul><li><p>La CPU consulta el registro de estado de cada puerto al que están conectados los periféricos. Comprueba si algún periférico requiere el servicio de la CPU. Reserves a register for each I/O device. Each register is continually polled to detect data arrival.</p></li></ul></div></li><li><p>Es necesario ejecutar programas de atención al periférico cuando este lo requiera: <strong>Sincronización</strong> . Sincronizar significa especificar o indicar cuando se va a realizar la transferencia entre el host(anfitrión) y el periférico.</p></li><li><p>El anfitrión consulta el bit de estado del controlador i/o</p></li><li><p>Identificación</p><div class="ulist"><ul><li><p>Una vez aceptada la petición del cliente (controlador i/o)</p><div class="ulist"><ul><li><p>El controlador identifica el periférico que solicita el servicio</p></li><li><p>Comunica al S.O. qué periferico</p></li></ul></div></li></ul></div></li></ul></div></li><li><p>Estructura</p><div class="ulist"><ul><li><p>CPU:</p><div class="ulist"><ul><li><p>Ejecuta el programa i/o: un programa que controla DIRECTAMENTE la operación E/S: Programmed I/O &#8594; PIO</p></li><li><p>realiza las transferencias entre la memoria principal y el  controlador i/o</p></li><li><p><em>espera</em> al periférico hasta que termine. La CPU espera hasta que concluya la operación E/S.</p></li></ul></div></li><li><p>Memoria principal: almacena el programa i/o</p></li><li><p>Controlador i/o</p><div class="ulist"><ul><li><p>Puerto: Un puerto está compuesto por REGISTROS del tipo datos, control, test</p></li><li><p>transfiere los datos al periférico</p></li></ul></div></li></ul></div></li></ul></div>
<h level="3">Sincronización por Interrupción</h><div class="ulist"><ul><li><p>Interrupt-Driven I/O (Mecanismo de E/S por Interrupción)</p></li><li><p>Estructura</p><div class="ulist"><ul><li><p>CPU:</p><div class="ulist"><ul><li><p>Ejecuta el programa de atención a la interrupción. Un programa que controla DIRECTAMENTE la operación E/S.</p></li><li><p>realiza las transferencias entre la memoria principal y el controlador i/o</p></li><li><p><strong>no espera</strong> al periférico hasta que termine. Es <em>interrumpido</em> cada vez que es necesario realizar una transferencia</p><div class="ulist"><ul><li><p>Al finalizar el ciclo de instrucción de cada instrucción que ejecuta la CPU, se comprueba si la señal de petición de interrupción está activada.</p></li></ul></div></li></ul></div></li><li><p>Memoria principal: almacena el programa i/o</p></li><li><p>Controlador i/o</p><div class="ulist"><ul><li><p>Puertos: datos, control, test</p></li><li><p>transfiere los datos al periférico</p></li></ul></div></li></ul></div></li><li><p>allows the CPU to do other things until I/O is requested</p><div class="ulist"><ul><li><p>Interrupt request - Driven I/O  (Still PIO - CPU has to move data)</p></li><li><p>I/O devices can request the attention of CPU with an interrupt at any time, but only when needed.</p></li><li><p>CPU can dedicate extended time for particular device.</p></li><li><p>CPU does not have to check in on I/O that does not need attention.</p></li><li><p>CPU can delay processing of I/O request.</p></li><li><p>Newer systems - cpu hands off transfer of data to secondary controller, which only interrupts cpu on completion of task or problem.</p></li><li><p>Requires external circuitry.</p><div class="ulist"><ul><li><p>e.g 8259A programmable interrupt controller (PIC). CPU may have to communicate with the PIC to identify requesting device.</p></li></ul></div></li></ul></div></li><li><p>Programmed input/output (PIO) is a method of transferring data between the CPU and a peripheral such as a network adapter or an ATA storage device. In general, programmed I/O happens when software running on the CPU uses i/o instructions that access I/O address space to perform data transfers to or from an I/O device. This is in contrast to Direct Memory Access (DMA) transfers.</p></li><li><p>The best known example of a PC device that uses programmed I/O is the ATA interface;</p></li></ul></div>
<h level="3">Direct Memory Access (DMA)</h><div class="ulist"><ul><li><p>Estructura</p><div class="listingblock"><div class="content"><pre>+---------------+    +---------------+    +------+   +----------------------+     +---------+    +-----+
|Controlador CPU| -&gt; |Controlador I/O| -&gt; |Puerto|-&gt; |Controlador Periférico|  -&gt; |Driver HW| -&gt; |Media|
+-----+---------+    +---------------+    +------+   +----------------------+     +---------+    +-----+
      |                    ^                                     |
  +---+---+                |                                 +---+---+
  |Memoria|&lt;---------------+                                 |Memoria|
  +-------+                                                  +-------+
    Driver                                                    Firmware</pre></div></div></li><li><p>Mapeo de direcciones</p></li><li><p>Hará falta una unidad hardware de traducción del espacio de direcciones del DISPOSITIVO a direcciones físicas de la Memoria Principal : <strong>iommu</strong></p><div class="listingblock"><div class="content"><pre>               CPU                  CPU                 DEVICE
             Virtual              Physical             Address
             Address              Address               Space
              Space                Space

            +-------+             +------+             +------+
            |       |             |MMIO  |   Offset    |      |
            |       |  Virtual    |Space |   applied   |      |
          C +-------+ --------&gt; B +------+ ----------&gt; +------+ A
            |       |  mapping    |      |   by host   |      |
  +-----+   |       |             |      |   bridge    |      |   +--------+
  |     |   |       |             +------+             |      |   |        |
  | CPU |   |       |             | RAM  |             |      |   | Device |
  |     |   |       |             |      |             |      |   |        |
  +-----+   +-------+             +------+             +------+   +--------+
            |       |  Virtual    |Buffer|   Mapping   |      |
          X +-------+ --------&gt; Y +------+ &lt;---------- +------+ Z
            |       |  mapping    | RAM  |   by IOMMU
            |       |             |      |
            |       |             |      |
            +-------+             +------+</pre></div></div></li><li><p>Estructura</p><div class="ulist"><ul><li><p>CPU:</p><div class="ulist"><ul><li><p>Ejecuta el programa i/o. El programa no controla la transferencia pero sí la inicializa (número de bytes a transferir, localización en la memoria principal, localización en el periférico, control errores, etc)</p></li><li><p>Cede el control de las transferencias al controlador DMA (DMAC)., offloads I/O processing to a special-purpose chip that takes care of the details. La transferencia la controla y realiza el DMAC por Hardware &#8594; No es por programa como el PIO.</p></li></ul></div></li><li><p>Memoria principal: almacena el programa i/o</p></li><li><p>Controlador i/o</p><div class="ulist"><ul><li><p>es el controlador DMA</p></li><li><p>Puertos: los puertos  ahora no son para los datos de transferencia, unicamente para el control CPU-DMA</p></li><li><p>transfiere los datos entre la memoria principal y el periférico</p></li><li><p>el controlador no espera al periférico</p></li><li><p>Direct Memory Access controller.</p><div class="literalblock"><div class="content"><pre>      Handles I/O interaction without the intervention of the CPU after initial
        CPU interaction. Uses interrupts to report status back to CPU.
      Requires separate arbitration protocol - shares buses with CPU.
      Predefined standardized tasks.
      CPU NOT occupied but may have to compete for resources.</pre></div></div></li></ul></div></li></ul></div></li></ul></div>
<h level="3">Channel I/O</h><div class="ulist"><ul><li><p>uses dedicated I/O processors</p><div class="ulist"><ul><li><p>Channel I/O (Mainframe or Supercomputer)</p><div class="ulist"><ul><li><p>Estructura: integra la unidad DMA más un procesador específico.</p></li><li><p>Programable: ejecuta el <em>channel program</em> almacenado en la memoria principal. (Diferencia con DMA).</p></li><li><p>Transfiere datos ( Memoria principal &lt;&#8594; Periférico) independientemente de la CPU</p></li></ul></div></li></ul></div></li></ul></div>
<h level="4">Memory Shared</h><div class="ulist"><ul><li><p>Estructura</p><div class="ulist"><ul><li><p>CPU</p><div class="ulist"><ul><li><p>cede el control de las transferencias al procesador o canal i/o</p></li></ul></div></li><li><p>Memoria principal: almacena el programa i/o</p></li><li><p>Procesador i/o</p><div class="ulist"><ul><li><p>Es el canal i/o</p></li><li><p>Ejecuta el programa i/o almacenado en la memoria principal</p></li><li><p>Puertos: los puertos  ahora no son para los datos de transferencia, únicamente para la control CPU-DMA</p></li><li><p>transfiere los datos entre la memoria principal y el periférico</p></li></ul></div></li><li><p>Memoria Principal</p><div class="ulist"><ul><li><p>Compartida entre la CPU y el Canal_IO</p></li></ul></div></li></ul></div></li></ul></div>
<h level="4">Memory Independent</h><div class="ulist"><ul><li><p>Estructura</p><div class="ulist"><ul><li><p>CPU</p><div class="ulist"><ul><li><p>cede el control de las transferencias al procesador o canal i/o</p></li></ul></div></li><li><p>Memoria principal: almacena el programa i/o</p></li><li><p>Procesador i/o</p><div class="ulist"><ul><li><p>Es el canal i/o</p></li><li><p>Ejecuta el programa i/o almacenado en la memoria principal</p></li><li><p>Puertos: los puertos  ahora no son para los datos de transferencia, unicamente para el control CPU-DMA</p></li><li><p>transfiere los datos entre la memoria principal y el periférico</p></li></ul></div></li><li><p>Memoria Principal</p><div class="ulist"><ul><li><p>Accesible sólo por la CPU</p></li></ul></div></li><li><p>Memoria IO</p><div class="ulist"><ul><li><p>Accesible sólo por el canal_IO</p></li></ul></div></li></ul></div></li></ul></div></div></section><section id="_sincronizacion_por_interrupcion"><h2>8.9. Sincronizacion por Interrupcion</h2><div class="slide-content"><div class="ulist"><ul><li><p>Extensión del apartado anterior sobre  implementación de la interfaz i/o driven-interruption.</p></li></ul></div>
<h level="3">Concepto</h><div class="ulist"><ul><li><p>El inconveniente del Polling es que la CPU realiza la consulta aunque el periférico no requiera sus servicios.</p></li><li><p>El periférico toma la iniciativa y solicita la INTERRUPCION del programa que este ejecutando para ejecutar el programa requerido por el periférico</p></li></ul></div>
<h level="3">Mecanismo de Interrupcion</h><div class="ulist"><ul><li><p>El periférico a través de una línea eléctrica de entrada de la CPU, solicita al controlador i/o los servicios del kernel</p><div class="ulist"><ul><li><p>El kernel va a ser <strong>INTERRUMPIDO</strong></p></li></ul></div></li><li><p>La CPU tiene dos líneas de interrupción:</p><div class="ulist"><ul><li><p>Línea Interrupt ReQuest <em>(IRQ)</em> : Maskable</p></li><li><p>Línea Non Maskable Interrupt <em>(NMI)</em></p></li><li><p>La CPU en el ciclo de instrucción tiene en su última fase la fase de Chequeo de Interrupción</p><div class="ulist"><ul><li><p>Si se está solicitando un servicio al kernel, la CPU entra en modo atención a la interrupción y pasa el control al módulo de <strong>Gestión de Interrupciones</strong> del Kernel</p></li></ul></div></li></ul></div></li><li><p>Las lineas de los periféricos para solicitar la interrupción se denominan <em>(IRQ)</em>.</p></li></ul></div>
<h level="3">Controlador de Interrupciones</h><h level="4">PIC</h><div class="ulist"><ul><li><p>Controlador de Interrupciones Programable</p><div class="ulist"><ul><li><p><a href="http://wiki.osdev.org/8259_PIC">PIC</a>  : Programmable Interrupt Controller</p><div class="ulist"><ul><li><p>Se utiliza en arquitecturas cuya CPU tiene un único núcleo.</p></li><li><p>Tiene como entrada todas las líneas de interrupción de los periféricos</p></li><li><p>Salidas: INT (petición de interrupción) y D0-D7 (Control,Status and Interrupt-Vector )</p></li></ul></div></li></ul></div></li><li><p>Ejemplo : <a href="http://pdos.csail.mit.edu/6.828/2005/readings/hardware/8259A.pdf">PIC 8259</a></p></li><li><p>Conexión daisy-chain</p><div class="ulist"><ul><li><p>Maestro - Esclavo</p><div class="listingblock"><div class="content"><pre>+---------+
|         |
|   CPU   |
|         |
|   INT   |
+----+----+
     |
     ^
     |      +--------+
     |      |        |
     +----&lt;-+ INT    +&lt;--- IRQ0
            |        |
            |        +&lt;--- IRQ1
            |        |
            |        +&lt;--- IRQ2
            |        |
            | PIC    +&lt;--- IRQ3
            | MAESTRO|
            |        +&lt;--- IRQ4
            |        |
            |        +&lt;--- IRQ5
            |        |
            |        +&lt;--- IRQ6    +--------+
            |        |             |        |
            |        +&lt;--- IRQ7----+        +&lt;--- IRQ8
            |        |             |        |
            +--------+             | PIC    +&lt;--- IRQ9
                                   | ESCLAVO|
                                   |        +&lt;--- IRQ10
                                   |        |
                                   |        +&lt;--- IRQ11
                                   |        |
                                   |        +&lt;--- IRQ12
                                   |        |
                                   |        +&lt;--- IRQ13
                                   |        |
                                   |        +&lt;--- IRQ14
                                   |        |
                                   |        +&lt;--- IRQ15
                                   |        |
                                   +--------+</pre></div></div></li></ul></div></li><li><p>Acciones  que realiza el controlador PIC</p><div class="ulist"><ul><li><p>Chequea si se activa alguna señal (Monitorización). En caso de activarse más de una se dar prioridad a la de menor nivel y procede:</p><div class="ulist"><ul><li><p><strong>Convierte</strong> la línea activada IRQn en un vector (0x00-0xFF)</p></li><li><p>Escribe en el puerto i/o del PIC el vector. El puerto es accesible por parte de la CPU. El vector se apunta a la entrada de una tabla que contiene un puntero a la rutina de atención a la interrupción (ISR)</p></li><li><p>Activa la señal INTR de la CPU</p></li><li><p>Si la CPU lee el valor del vector se desactiva la señal INTR</p></li></ul></div></li></ul></div></li><li><p>A la línea IRQn le corresponde, por defecto según Intel, el vector <em>n+32</em>. Este mapeo se puede alterar programando el PIC.</p><div class="ulist"><ul><li><p>A la línea IRQ0 le corresponde el vector 0x20</p></li></ul></div></li><li><p>Cada línea IRQ se puede desautorizar por programa pero dicha interrupción no se pierde.</p></li><li><p>Mediante la instruccion <code>cli</code> se hace un clear del flag IF del registro EFLAGS, ignorando la CPU todas las interrupciones hardware.</p><div class="ulist"><ul><li><p>Mediante la instrucción <code>sli</code> hacemos un set de IF.</p></li></ul></div></li></ul></div>
<h level="4">NMI</h><div class="ulist"><ul><li><p>Non-Maskable Interrupt (NMI)</p></li><li><p>Es una señal de entrada de la cpu.</p></li><li><p>The NMI (is a hardware driven interrupt much like the PIC interrupts but the NMI goes directly the cpu, and not via the PIC controller. No se puede enmascarar y anular este servicio, por lo tanto se utiliza para casos críticos.</p></li><li><p>Aplicaciones</p><div class="ulist"><ul><li><p>Temporizador watchdog</p><div class="ulist"><ul><li><p>Es un temporizador que hay que poner a cero regularmente. Si la cpu está bloqueada no podrá resetear el temporizador y este generará un interrupción nmi con lo que el contador de programa se cargará con una dirección que apunta a la rutina de atención a la interrupción NMI cuya ejecución  desbloqueará el estado de la cpu.</p></li></ul></div></li></ul></div></li></ul></div>
<h level="4">Intel</h><div class="ulist"><ul><li><p>Intel</p><div class="ulist"><ul><li><p>1º generation of interrupts (XT-PIC): only supported 15 interrupts.</p></li><li><p>2º generation (IO-APIC): number of supported interrupts to 24.</p><div class="ulist"><ul><li><p><a href="http://wiki.osdev.org/APIC">APIC</a> : Advanced Programmable Interrupt Controller: Utilizado en modernas arquitecturas multinúcleo.</p></li></ul></div></li><li><p>3º generation, MSI: number of available interrupts to 224.</p></li></ul></div></li></ul></div>
<h level="3">Gestor de Interrupciones</h><div class="ulist"><ul><li><p>El Gestor de Interrupciones está implementado por el S.O.: entry.S en la versión linux 2.x</p></li><li><p>Identifica al solicitador de la interrupción para poder ejecutar la rutina específica de antención a dicha interrupción.</p></li><li><p>Anula la posibilidad de ser interrumpido por otros dispositivos no prioritarios, a través del flag IF , bit 9 del registro de control rflags de la CPU.</p></li><li><p>Consulta el Vector de interrupciones (Tabla de punteros a las rutinas de atención a la interrupción.</p></li><li><p>Salva el entorno del programa en ejecución que va a ser interrumpido.</p></li><li><p>Activa la rutina Interrupt Service Routine <em>(ISR)</em>.</p><div class="ulist"><ul><li><p>Autoriza nuevamente las interrupciones</p></li><li><p>Dicha rutina estará implementada en el módulo driver del kernel.</p></li></ul></div></li></ul></div>
<h level="3">Tipos de Interrupciones</h><div class="ulist"><ul><li><p>Intel define dos tipos de Interrupt Signals</p><div class="ulist"><ul><li><p><strong>Sincronas</strong></p><div class="ulist"><ul><li><p>Son originadas por la propia CPU al final del ciclo de instrucción en respuesta a un evento. El ciclo de instrucción por lo tanto tiene una fase más: la fase de interrupción</p></li><li><p>Se denominan <em>exceptions</em></p><div class="ulist"><ul><li><p><em>Software Interrupt</em> : originadas por la instrucción <code>syscall</code> en la arquitectura x86-64 y por la instrucción <code>int $0x80</code> en la arquitectura x86-32: Se interrumpe al kernel mediante las Llamadas al Sistema.</p></li><li><p>Originadas por un <em>Error</em>: Fault, Trap, Abort, Segment Violation.</p></li></ul></div></li></ul></div></li><li><p><strong>Asíncronas</strong></p><div class="ulist"><ul><li><p>Originadas por los periféricos o  hardware que no es la CPU</p></li><li><p>Se denominan <em>interruptions</em> o <em>hardware interruptions</em></p><div class="ulist"><ul><li><p>Maskable: IRQ &#8594; se pueden desactivar durante el intervalo de tiempo que no queremos que nos interrumpan.</p></li><li><p>Non-Maskable: NMI &#8594; no se pueden desactivar.</p></li></ul></div></li></ul></div></li></ul></div></li></ul></div>
<h level="3">Tabla de los Vectores de interrupciones</h><h level="4">Modo Real: Tabla IVT</h><div class="ulist"><ul><li><p>En plataformas con S.O. al encender la computadora (arranque con bootloader) la CPU está operando inicialmente en  <em>Modo Real</em>   y en plataformas sin S.O.  (arranque con BIOS) la cpu opera permanentemente en Modo Real. En plataformas con S.O. el arranque se inicia en modo real y se configura la computadora para pasar al modo protegido antes de cargar el S.O. en la memoria principal.</p><div class="ulist"><ul><li><p>Real Mode :</p></li><li><p>Is a simplistic 16-bit mode that is present on all x86 processors: Equivale a comportarse como la antigua cpu 8086.</p></li><li><p>la cpu 8086 tiene 20 bits de direcciones y 16 bits de datos.</p></li><li><p>A real mode pointer is defined as a 16-bit segment address and a 16-bit offset into that segment</p><div class="ulist"><ul><li><p>El segmento se expande a 20 bits multiplicando x4.</p></li></ul></div></li><li><p>2<sup>20</sup>:El Código tiene que estar en el primer Mega de la memoria RAM</p></li></ul></div></li><li><p>Permite el acceso a funciones de la BIOS.</p><div class="ulist"><ul><li><p><a href="https://es.wikipedia.org/wiki/Llamada_de_interrupci%C3%B3n_del_BIOS#Tabla_de_interrupciones">Tabla de interrupciones BIOS</a></p></li><li><p><a href="http://www.zator.com/Hardware/H2_4_1.htm">Tecnología del PC</a></p></li></ul></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">MOV AH, 0Eh   ; Imprime carácter en la pantalla
MOV AL, '!'   ; carácter a imprimir
INT 10h       ; Llamada a las funciones de video del BIOS</code></pre></div></div></li><li><p>Tabla IVT.</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-sh" data-lang="sh">Interrupt Address 	Type            Description

00h 	0000:0000h 	Processor 	Divide by zero
01h 	0000:0004h 	Processor 	Single step
02h 	0000:0008h 	Processor 	Non maskable interrupt (NMI)
03h 	0000:000Ch 	Processor 	Breakpoint
04h 	0000:0010h 	Processor 	Arithmetic overflow
05h 	0000:0014h 	Software 	Print screen
06h 	0000:0018h 	Processor 	Invalid op code
07h 	0000:001Ch 	Processor 	Coprocessor not available
08h 	0000:0020h 	Hardware 	System timer service routine
09h 	0000:0024h 	Hardware 	Keyboard device service routine
0Ah 	0000:0028h 	Hardware 	Cascade from 2nd programmable interrupt controller
0Bh 	0000:002Ch 	Hardware 	Serial port service - COM post 2
0Ch 	0000:0030h 	Hardware 	Serial port service - COM port 1
0Dh 	0000:0034h 	Hardware 	Parallel printer service - LPT 2
0Eh 	0000:0038h 	Hardware 	Floppy disk service
0Fh 	0000:003Ch 	Hardware 	Parallel printer service - LPT 1
10h 	0000:0040h 	Software 	Video service routine
11h 	0000:0044h 	Software 	Equipment list service routine
12h 	0000:0048H 	Software 	Memory size service routine
13h 	0000:004Ch 	Software 	Hard disk drive service
14h 	0000:0050h 	Software 	Serial communications service routines
15h 	0000:0054h 	Software 	System services support routines
16h 	0000:0058h 	Software 	Keyboard support service routines
17h 	0000:005Ch 	Software 	Parallel printer support services
18h 	0000:0060h 	Software 	Load and run ROM BASIC
19h 	0000:0064h 	Software 	DOS loading routine
1Ah 	0000:0068h 	Software 	Real time clock service routines
1Bh 	0000:006Ch 	Software 	CRTL - BREAK service routines
1Ch 	0000:0070h 	Software 	User timer service routine
1Dh 	00000074h 	Software 	Video control parameter table
1Eh 	0000:0078h 	Software 	Floppy disk parameter routine
1Fh 	0000:007Ch 	Software 	Video graphics character routine
20h-3Fh 0000:0080f-0000:00FCh SW        DOS interrupt points
40h 	0000:0100h 	Software 	Floppy disk revector routine
41h 	0000:0104h 	Software 	hard disk drive C: parameter table
42h 	0000:0108h 	Software 	EGA default video driver
43h 	0000:010Ch 	Software 	Video graphics characters
44h 	0000:0110h 	Software 	Novel Netware API
45h 	0000:0114h 	Software 	Not used
46h 	0000:0118h 	Software 	Hard disk drive D: parameter table
47h 	0000:011Ch - 	Software 	Not used
48h 	  	Software 	Not used
49h 	0000:0124h 	Software 	Not used
4Ah 	0000:0128h 	Software 	User alarm
4Bh-63h 	0000:012Ch - 	Software 	Not used
64h 	  	Software 	Novel Netware IPX
65h-66h 	  	Software 	Not used
67h 	  	Software 	EMS support routines
68h-6Fh 	0000:01BCh 	Software 	Not used
70h 	0000:01c0h 	Hardware 	Real time clock
71h 	0000:01C4h 	Hardware 	Redirect interrupt cascade
72h-74h 	0000:01C8h - 0000:01D0h 	Hardware 	Reserved - Do not use
75h 	0000:01D4h 	Hardware 	Math coprocessor exception
76h 	0000:01D8h 	Hardware 	Hard disk support
77h 	0000:01DCh 	Hardware 	Suspend request
78h-79h 	0000:01E0h - 	Hardware 	Not used
7Ah 	  	Software 	Novell Netware API
78h-FFh 	0000:03FCh 	Software 	Not used</code></pre></div></div>
<div class="ulist"><ul><li><p>El contenido de la tabla depende de la generación de la cpu de intel</p></li><li><p>Primera columna: Número del vector de interrupción. Número de la entrada a la tabla de vectores.</p></li><li><p>Segunda columna: el offset en la tabla del número de vecto de interrupción</p></li><li><p>Columna X: Falta en la tabla.</p><div class="ulist"><ul><li><p>El vector de 4 bytes: <strong>Es un puntero a la rutina de atención a la interrupción ISR</strong></p></li><li><p>La dirección es segmentada. Segmento:Offset. Dos bytes para el segmento y otros dos para el offset</p></li></ul></div></li><li><p>Direccionamiento:</p><div class="ulist"><ul><li><p>El Registro IDTR apunta a la primera entrada de la tabla.</p></li><li><p>The IVT table is typically located at 0000:0000H, and is 400H bytes in size (<strong>4 bytes for each interrupt of 265 interruptions</strong>).</p></li><li><p>Observamos que podemos obtener la dirección relativa múltiplicando el número de interrupción x4.</p></li><li><p>Al vector 9 le corresponde el offset IVT 36, es decir, 0x24 &#8594; en forma segmentada 0000:0024h</p></li><li><p>El offset de la última entrada será = 4 x 0xFF = 0x400-4 =0x3FC</p></li></ul></div></li></ul></div></li><li><p>Tipos de interrupciones</p><div class="ulist"><ul><li><p>The first 32 vectors are reserved for the processor&#8217;s internal <em>exceptions</em> (0x00-0x1F)</p></li><li><p>Las interrupciones 0x20-0xFF son interrupciones <em>hadware</em> IRQ.</p></li><li><p>PIC</p><div class="ulist"><ul><li><p>El controlador PIC es el encargado de mapear la señal IRQ a un vector de entrada a la tabla.</p></li><li><p>Periférico IRQ0 &#8594; PIC vector 0x20 &#8594; Tabla IVT puntero 0000:0080f (RAM) &#8594; llamada a la función ISR de atención al periférico IRQ0 (RAM)</p></li></ul></div></li></ul></div></li></ul></div>
<h level="4">Modo Protegido: Tabla IDT</h><div class="ulist"><ul><li><p>En las plataformas con S.O. una vez finalizadas las operaciones en modo real el bootloader finaliza la carga del sistema operativo y la cpu se configura en modo protegido no pudiendo el usuario: ejecutar módulos del S.O como los drivers, acceder a cualquier región de la memoria física, registros privilegiados, instrucciones privilegiadas,&#8230;&#8203;</p></li><li><p>El S.O. configura la tabla de descripción de interrupciones IDT con la misma función que la IVT pero distinto contenido.</p></li><li><p><a href="https://en.wikipedia.org/wiki/Interrupt_descriptor_table">Interrupt Descriptor Table IDT</a></p><div class="listingblock"><div class="content"><pre>IDT Offset | INT #     | Description
-----------+-----------+-----------------------------------
0x0000     | 0x00      | Divide by 0
0x0004     | 0x01      | Reserved
0x0008     | 0x02      | NMI Interrupt
0x000C     | 0x03      | Breakpoint (INT3)
0x0010     | 0x04      | Overflow (INTO)
0x0014     | 0x05      | Bounds range exceeded (BOUND)
0x0018     | 0x06      | Invalid opcode (UD2)
0x001C     | 0x07      | Device not available (WAIT/FWAIT)
0x0020     | 0x08      | Double fault
0x0024     | 0x09      | Coprocessor segment overrun
0x0028     | 0x0A      | Invalid TSS
0x002C     | 0x0B      | Segment not present
0x0030     | 0x0C      | Stack-segment fault
0x0034     | 0x0D      | General protection fault
0x0038     | 0x0E      | Page fault
0x003C     | 0x0F      | Reserved
0x0040     | 0x10      | x87 FPU error
0x0044     | 0x11      | Alignment check
0x0048     | 0x12      | Machine check
0x004C     | 0x13      | SIMD Floating-Point Exception
0x00xx     | 0x14-0x1F | Reserved
0x0xxx     | 0x20-0xFF | User definable   -&gt; IRQ, SW interrupts</pre></div></div>
<div class="ulist"><ul><li><p>El contenido depende del kernel del S.O.</p></li><li><p>Primera columna: offset a la rutina de antención a interrupción ISR</p></li><li><p>Segunda columna: número del vector de interrupción.</p></li><li><p>tipos de interrupción</p><div class="ulist"><ul><li><p>0-0x1F: <em>exceptions ERROR</em> y NMI</p></li><li><p>0x20-0x2F: INT maskable: IRQ0-----IRQ15</p></li><li><p>0x30-0xFF: <em>exceptions SW</em></p></li><li><p>0x80 &#8594; LLAMADAS AL SISTEMA</p><div class="ulist"><ul><li><p>isa x86-64: <em>syscall</em></p></li><li><p>isa x86: <em>int $0x80</em></p></li></ul></div></li></ul></div></li><li><p>¿A que rutina apunta el vector 0x0E? &#8594; Page Fault</p></li><li><p>Descripción de las Entradas</p><div class="ulist"><ul><li><p>IDTR: registro que apunta a la primera entrada de la tabla</p></li><li><p>Cada entrada son 8 bytes que intel llama gates.</p></li><li><p>Contiene un selector de segmento que identifica un descriptor de segmento de la tabla de descriptores de segmentos (ver segmentación intel)</p></li></ul></div></li></ul></div></li></ul></div>
<h level="4">IRQ</h><div class="ulist"><ul><li><p>XT-PIC  interrupts use a pair of Intel  8259  programmable interrupt controllers (PIC)</p><div class="ulist"><ul><li><p>PIC configurado por el kernel <strong>Linux</strong> : <a href="https://www.oreilly.com/library/view/understanding-the-linux/0596002130/ch04s06.html">Understanding the Linux Kernel, Second Edition by Marco Cesati, Daniel P. Bovet</a></p></li><li><p>Example XT-PIC IRQ Assignment , <a href="http://www.intel.co.jp/content/dam/www/public/us/en/documents/white-papers/msg-signaled-interrupts-paper.pdf">intel interrupts paper</a>: Esta configuración es un ejemplo, es decir, el SO puede <strong>reprogramarla</strong> y variar su configuración.</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-sh" data-lang="sh">IRQ 	Interrupt Hardware Device (vector de la tabla)
0 	32 Timer
1 	33 Keyboard
2 	34 PIC Cascade
3 	35 Second Serial Port (COM2)
4 	36 First Serial Port (COM 1)
5 	37 &lt;Free&gt;
6 	38 Floppy Disk
7 	39 &lt;Free&gt;
8 	40 System Clock
9 	41 &lt;Free&gt;
10 	42 Network Interface Card(NIC)
11 	43 USB Port, and Sound Card
12 	44 Mouse (PS2)
13 	45 Math Co-Processor
14 	46 IDE Channel 1
15 	47 IDE Channel 2

Note: Linux* requires IRQ 0, 2, and 13 to be as shown.</code></pre></div></div></li><li><p>Master 8259 (PC compatible)</p><div class="listingblock"><div class="content"><pre>IVT Offset | INT # | IRQ # | Description
-----------+-------+-------+------------------------------
0x0020     | 0x08  | 0     | PIT
0x0024     | 0x09  | 1     | Keyboard
0x0028     | 0x0A  | 2     | 8259A slave controller
0x002C     | 0x0B  | 3     | COM2 / COM4
0x0030     | 0x0C  | 4     | COM1 / COM3
0x0034     | 0x0D  | 5     | LPT2
0x0038     | 0x0E  | 6     | Floppy controller
0x003C     | 0x0F  | 7     | LPT1</pre></div></div>
<div class="ulist"><ul><li><p>Segunda columna: número de interrupción en el PIC</p></li><li><p>Tercera columna: número de interrupción IRQ</p></li><li><p>Primera columna: offset de esa entrada respecto de la primera entrada. Número de Vector.</p></li></ul></div></li><li><p>Slave 8259</p><div class="listingblock"><div class="content"><pre>IVT Offset | INT # | IRQ # | Description
-----------+-------+-------+------------------------------
0x01C0     | 0x70  | 8     | RTC
0x01C4     | 0x71  | 9     | Unassigned
0x01C8     | 0x72  | 10    | Unassigned
0x01CC     | 0x73  | 11    | Unassigned
0x01D0     | 0x74  | 12    | Mouse controller
0x01D4     | 0x75  | 13    | Math coprocessor
0x01D8     | 0x76  | 14    | Hard disk controller 1
0x01DC     | 0x77  | 15    | Hard disk controller 2</pre></div></div>
<div class="ulist"><ul><li><p>Segunda columna: número de interrupción en el PIC</p></li><li><p>Tercera columna: número de interrupción IRQ</p></li><li><p>Primera columna: offset de esa entrada respecto de la primera entrada. Número de Vector.</p></li></ul></div></li></ul></div></li></ul></div>
<h level="4">Linux</h><div class="ulist"><ul><li><p>Interrupciones configuradas por el kernel : <code>cat /proc/interrupts</code></p></li></ul></div>
<h level="4">Lineas compartidas</h><div class="ulist"><ul><li><p><a href="https://nptel.ac.in/courses/Webcourse-contents/IIT-%20Guwahati/comp_org_arc/web/module06_io/lect_03_intr/lect_03.htm" class="bare">https://nptel.ac.in/courses/Webcourse-contents/IIT-%20Guwahati/comp_org_arc/web/module06_io/lect_03_intr/lect_03.htm</a></p></li><li><p>Si una línea de interrupción está compartida por varios dispositivos, cuando uno de los dispositivos envía la señal de interrupción por la línea común, la CPU puede identificar el dispositivo que solicita la interrupción de varias maneras:</p><div class="ulist"><ul><li><p>sondeo por software a cada miembro de la línea</p></li><li><p>la línea de concesión de la CPU hacia los dispositivos colocados en modo daisy-chain (se pasan la concesión entre ellos, de uno en uno), cuando la concesión llegue al miembro que solicita, este devuelve su identificación.</p></li></ul></div></li></ul></div>
<h level="3">Proceso de atención a las interrupciones</h><h level="4">Flujo de operaciones</h><div class="imageblock"><img src="./images/io/interruption_flow.jpg" alt="interruption flow" /></div><div class="title">Figure 47. Flujo de Operaciones</div>
<h level="4">Ejemplo: Procesamiento de la interrupción originada por el teclado.</h><div class="imageblock"><img src="./images/io/keyboard_interruption.jpg" alt="keyboard interruption" /></div><div class="title">Figure 48. Interrupción del Teclado</div>
<div class="olist arabic"><ol class="arabic"><li><p>Se pulsa una tecla y el controlador del teclado activa la señal IRQ1 del PIC</p></li><li><p>El PIC examina si la IRQ1 está autorizada a interrumpir y si no hay interrupciones de mayor prioridad. En tal caso, el PIC activa la entrada INTR de la CPU</p></li><li><p>La CPU interrumpe (suspende) la ejecución del proceso main_application.</p></li><li><p>La CPU comprueba que el flag IF autoriza la interrupción, confirma al PIC la aceptación de la interrupción y solicita el vector de interrupción asociado a la IRQ1.</p></li><li><p>El PIC envía al bus de direcciones el vector 129 (0x81)</p></li><li><p>El PIC desactiva la solicitud de interrupción INTR a la CPU para poder gestionar otra IRQ.</p></li><li><p>La CPU guarda en el Interrupt Stack el contexto (Flag Register,Code Segment,Instruction Pointer)</p></li><li><p>La CPU resetea el flag IF (IF=0) desautorizando ser interrumpido durante el cambio de contexto del proceso interrumpido por el contexto de la rutina ISR. Captura el vector de interrupción 129 de la tabla de vectores de interrupción&#8594; captura de la tabla la entrada 129x4 &#8594; 0x81*4=0x204 que contiene la dirección de La Interruption Service Routine ISR asociada al periférico teclado.</p></li><li><p>La CPU actualiza CS:IP (0x206:0x204)  para saltar a la dirección de la ISR 129 y comienza su ejecución</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>La ISR salva los "registros no modificables" en el Interrupt Stack &#8594;  Frame: Saved registers . Autoriza las interrupciones IF=1 (Posibilidad de anidamiento de interrupciones)</p></li><li><p>La ISR accede al periférico y se captura el valor de la tecla pulsada a través del data bus.</p></li><li><p>Fin de la ISR . Se desautorizan las interrupciones (IF=0) durante la recuperación del anterior contexto. La CPU recupera los "registros no modificables" del Interrupt Stack &#8594; Frame: Saved registers</p></li></ol></div></li><li><p>Se recupera el anterior contexto y por lo tanto también la dirección de retorno actualizando el contador de programa CS:IP</p></li><li><p>Continua la ejecución del programa interrumpido main_application</p></li></ol></div></div></section><section id="_acceso_directo_a_memoria_dma"><h2>8.10. Acceso Directo a Memoria DMA</h2><div class="slide-content"><h level="3">Funcionalidad</h><div class="ulist"><ul><li><p>Realizar las transferencias de datos liberando así a la CPU</p></li><li><p>Aplicación: Transferencias de datos entre el disco duro y la memoria principal</p></li><li><p>Unidad: DMAC (DMA Controller)</p><div class="ulist"><ul><li><p>Puede tener varios canales DMA: cada canal se ocupa de la transferencia de un periférico.</p></li></ul></div></li></ul></div>
<h level="3">Transferencias</h><div class="ulist"><ul><li><p>Modo ráfaga</p><div class="ulist"><ul><li><p>Una vez que el DMAC toma el control del bus del sistema no lo cede hasta que la transferencia de todo el bloque es completada</p></li><li><p>Mientras el bus del sistema está ocupado por el DMAC la CPU puede operar con la memoria caché.</p></li></ul></div></li><li><p>Modo robo de ciclo</p><div class="ulist"><ul><li><p>El DMAC devuelve el control del bus del sistema a la CPU cada vez que transfiere una palabra.</p></li><li><p>El bus es compartido en el tiempo: útil en sistemas críticos en tiempo real</p></li></ul></div></li><li><p>Modo transparente</p><div class="ulist"><ul><li><p>El DMAC únicamente se adueña del bus cuando está libre y no lo necesita la CPU.</p></li></ul></div></li></ul></div>
<h level="3">Sincronización</h><div class="ulist"><ul><li><p>La CPU puede iniciar una operación DMA en los límites del ciclo de bus de lectura o escritura. Por lo tanto se puede iniciar una operación DMA durante el ciclo de instrucción .</p></li></ul></div>
<h level="3">Operación del controlador DMA</h><h level="4">Secuencia de pasos a nivel alto</h><div class="ulist"><ul><li><p>Cuando un proceso realiza una llamada <em>read</em>, el driver le asigna una región de memoria principal (DMA buffer) y genera la señales hw para solicitar la transferencia de datos al DMA buffer. El proceso queda en estado <em>sleep</em>.</p></li><li><p>El DMAC transfiere los datos al buffer DMA y activa una señal de interrupción cuando finaliza</p></li><li><p>El gestor de interrupciones ubica los datos del buffer al lugar definitivo, avisa de interrupción atendida y despierta al proceso, el cual ya puede leer los datos de la memoria principal.</p></li></ul></div>
<h level="4">Secuencia de pasos a nivel bajo</h><div class="ulist"><ul><li><p>Tres parámetros a programar:</p><div class="ulist"><ul><li><p>dirección inicial de MPrincipal del bloque de datos a transferir: AR</p></li><li><p>Número de datos a transferir: WC</p></li><li><p>Modo de transferencia</p></li></ul></div></li><li><p>Pasos</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>La <em>CPU</em> durante el arranque de la computadora inicializa el DMAC programando los parámetros.</p></li><li><p>El <em>controlador del periférico</em> solicita su servicios.</p></li><li><p>El <em>periférico</em> realiza una petición de DMA al DMAC (DMA Controller): <em>DMA Request</em>.</p></li><li><p>El DMAC le responde con una señal de aceptación</p></li><li><p>El DMAC activa la línea de petición de DMA a la <em>CPU</em>: <em>Bus Request</em></p></li><li><p>Al final del <em>ciclo del bus</em> en curso, el procesador pone las líneas del bus del sistema en alta impedancia y activa la sesión de DMA: <em>Bus Grant</em></p></li><li><p>El DMAC asume el <em>control del bus del sistema</em></p></li><li><p>El dispositivo de E/S transmite una nueva palabra de datos al registro intermedio de datos del DMAC (un pequeño <em>buffer</em> en el DMAC)</p></li><li><p>El DMAC ejecuta un ciclo de escritura en memoria para transferir el contenido del registro intermedio a la posición M[AR].</p></li><li><p>El DMAC decrementa WC e incrementa AR.</p></li><li><p>El DMAC libera el bus y desactiva la línea de petición de DMA.</p></li><li><p>El DMAC compara WC con 0:</p></li><li><p>Si WC &gt; 0, se repite desde el paso 2.</p></li><li><p>Si WC = 0, el DMAC se detiene y envía una petición de interrupción al procesador.</p></li></ol></div></li></ul></div>
<h level="3">Problemas de coherencia en la memoria cache</h><div class="ulist"><ul><li><p>El controlador DMA al transferir datos entre el periférico y la memoria Principal provoca que las líneas de la memoria caché no sean copia de los bloques de la memoria principal. Será necesario que la controladora de la caché actualice la memoria caché después de una operación DMA.</p></li></ul></div></div></section><section id="_buses_2"><h2>8.11. Buses</h2><div class="slide-content"><div class="ulist"><ul><li><p>La arquitectura i/o ha ido evolucionando en dos direcciones</p><div class="ulist"><ul><li><p>incremento del ancho de banda de los buses</p></li><li><p>integración de los controladores i/o en un único chip</p></li></ul></div></li></ul></div>
<h level="3">ISA</h><div class="imageblock" style="text-align: center"><img src="./images/io/isa_8086.png" alt="isa 8086" /></div><div class="title">Figure 49. Arquitectura Bus ISA</div>
<div class="imageblock" style="text-align: center"><img src="./images/io/isa_8086_interfaz.png" alt="isa 8086 interfaz" /></div><div class="title">Figure 50. Interfaz Bus ISA</div>
<h level="3">PCI</h><div class="imageblock" style="text-align: center"><img src="./images/io/pci_80x86.png" alt="pci 80x86" /></div><div class="title">Figure 51. Arquitectura Bus PCI</div>
<h level="3">North-South Bridge</h><div class="imageblock" style="text-align: center"><img src="./images/io/north_south_bridge.png" alt="north south bridge" /></div><div class="title">Figure 52. North and South Bridges</div>
<h level="3">Chipset x58</h><div class="ulist"><ul><li><p><a href="https://en.wikipedia.org/wiki/Intel_X58" class="bare">https://en.wikipedia.org/wiki/Intel_X58</a></p></li><li><p>PCH: Platform Controller Hub</p></li><li><p>FSB: Front Side Bus</p></li><li><p>BSB: Back Side Bus</p></li><li><p>FDI: Flexible Display Interface (para CPU que integran la controladora gráfica)</p></li><li><p>DMI: Direct Media Interface</p></li><li><p>ICH: i/o Controller Hub</p></li><li><p>IOH: i/o Hub</p></li></ul></div>
<div class="imageblock" style="text-align: center"><img src="./images/io/x58blockdiagram_corei7.jpg" alt="x58blockdiagram corei7" /></div><div class="title">Figure 53. corei7 x58 chipset: año 2008</div>
<div class="paragraph"><p>Chipsets supporting LGA 1366, LGA 2011, and LGA 2011-v3 CPUs.: X58 (2008), X79 (2011), X99 (2014).</p></div></div></section><section id="_programacion_de_rutinas_de_entradasalida"><h2>8.12. Programacion  de rutinas de entrada/salida</h2><div class="slide-content"><h level="3">Software jerarquico del sistema operativo</h><div class="ulist"><ul><li><p>El driver o controlador sw es el nivel más bajo de la estructura sw: depende fuertemente del hardware de la computadora: programación en lenguaje C o ensamblador.</p></li></ul></div>
<h level="3">Instruction Set Architecture</h><div class="ulist"><ul><li><p>I/O access</p><div class="ulist"><ul><li><p>OUTx : Sends a byte (or word or dword) on a I/O location. Traditional names are <em>outb</em>, <em>outw</em> and <em>outl</em> respectively. The "a" modifier enforces <em>val</em> to be placed in the eax register before the asm command is issued and "Nd" allows for one-byte constant values to be assembled as constants, freeing the edx register for other cases.</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">static inline
void outb( unsigned short port, unsigned char val )
{
    asm volatile( "outb %0, %1"
                  : : "a"(val), "Nd"(port) );
}</code></pre></div></div>
<div class="ulist"><ul><li><p>El programa fuente en C incluye lenguaje ASM: Programa fuente en C con inline-asm.</p></li><li><p>%0 hace referencia a la primera variable "a", %i hace referencia a la i-nésima variable.</p></li></ul></div></li><li><p>INx : Receives a byte (or word or dword) from an I/O location. Traditional names are <em>inb</em>, <em>inw</em> and <em>inl</em> respectively.</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">static inline
unsigned char inb( unsigned short port )
{
    unsigned char ret;
    asm volatile( "inb %1, %0"
                  : "=a"(ret) : "Nd"(port) );
    return ret;
}</code></pre></div></div></li></ul></div></li><li><p>The register I/O instructions IN (input from I/O port) and OUT (output to I/O port) move data between I/O ports
and the EAX register (32-bit I/O), the AX register (16-bit I/O), or the AL (8-bit I/O) register. The address of the I/O
port can be given with an immediate value or a value in the DX register.</p></li></ul></div>
<h level="4">Intel Manual</h><div class="ulist"><ul><li><p>This instruction is only useful for accessing I/O ports located in the processor’s I/O address space. See Chapter 16 or 14, “Input/Output,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for more infor-mation on accessing I/O ports in the I/O address space.</p></li><li><p>I/O ports can be mapped so that they appear in the I/O address space or the physical-memory address space (memory mapped I/O) or both.</p></li><li><p><strong>memory-mapped</strong>:</p><div class="ulist"><ul><li><p>mediante una línea del bus de control se especifica si la dirección es de memoria principal o port i/o, en algún procesador mediante el M/IO# pin.</p></li><li><p>When using memory-mapped I/O, caching of the address space mapped for I/O operations must be prevented</p></li></ul></div></li><li><p><strong>I/O mapped</strong></p><div class="ulist"><ul><li><p>i/o devices don&#8217;t collide with memory, as they use a different <em>address space</em>, with different instructions to read and write values to addresses (ports). CPU  decode the memory-I/O bus transaction instructions to select I/O ports These devices cannot be addressed using machine code instructions that targets memory. What is happening is that there are two different signals: <em>MREQ</em> and <em>IOREQ</em>. The first one is asserted on every memory instruction, the second one, on every I/O instruction. So this code&#8230;&#8203;</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">MOV DX,1234h
MOV AL,[DX]    ;reads memory address 1234h (memory address space)
IN AL,DX       ;reads I/O port 1234h (I/O address space)</code></pre></div></div></li><li><p>The I/O device at port 1234h is connected to the system bus so that it is enabled only if the address is 1234h, RD (Read Data) is asserted and IOREQ is asserted.</p></li><li><p>(64K) individually addressable 8-bit I/O ports</p></li></ul></div></li><li><p><strong>Protection</strong></p><div class="ulist"><ul><li><p>Port Mapped</p><div class="ulist"><ul><li><p>Here, kernel and the device drivers are allowed to perform I/O, while less privileged device drivers and application programs are denied access to the I/O address space. Application programs must then make <em>calls</em> to the operating system to perform I/O.</p></li></ul></div></li><li><p>Memory mapped</p><div class="ulist"><ul><li><p>the normal segmentation and paging protection affect the i/o port access.</p></li></ul></div></li></ul></div></li></ul></div>
<h level="3">Programación del Controlador de Interrupciones Programable</h><div class="ulist"><ul><li><p><a href="http://www.superfrink.net/athenaeum/OS-FAQ/os-faq-pics.html">programación del pic</a></p><div class="ulist"><ul><li><p>Mapeo del <a href="http://wiki.osdev.org/8259_PIC">PIC</a></p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">/* remap the PIC controller interrupts to our vectors
   rather than the 8 + 70 as mapped by default */

#define	PIC1		0x20
#define	PIC2		0xA0
#define	PIC1_COMMAND	PIC1
#define	PIC1_DATA	(PIC1+1)
#define	PIC2_COMMAND	PIC2
#define	PIC2_DATA	(PIC2+1)
#define	PIC_EOI		0x20

#define	ICW1_ICW4	0x01		/* ICW4 (not) needed */
#define	ICW1_SINGLE	0x02		/* Single (cascade) mode */
#define	ICW1_INTERVAL4	0x04		/* Call address interval 4 (8) */
#define	ICW1_LEVEL	0x08		/* Level triggered (edge) mode */
#define	ICW1_INIT	0x10		/* Initialization - required! */

#define	ICW4_8086	0x01		/* 8086/88 (MCS-80/85) mode */
#define	ICW4_AUTO	0x02		/* Auto (normal) EOI */
#define	ICW4_BUF_SLAVE	0x08		/* Buffered mode/slave */
#define	ICW4_BUF_MASTER	0x0C		/* Buffered mode/master */
#define	ICW4_SFNM	0x10		/* Special fully nested (not) */

void remap_pics(int pic1, int pic2)
{
	UCHAR	a1, a2;

	a1=inb(PIC1_DATA);
	a2=inb(PIC2_DATA);

	outb(PIC1_COMMAND, ICW1_INIT+ICW1_ICW4);
	io_wait();
	outb(PIC2_COMMAND, ICW1_INIT+ICW1_ICW4);
	io_wait();
	outb(PIC1_DATA, pic1);
	io_wait();
	outb(PIC2_DATA, pic2);
	io_wait();
	outb(PIC1_DATA, 4);
	io_wait();
	outb(PIC2_DATA, 2);
	io_wait();

	outb(PIC1_DATA, ICW4_8086);
	io_wait();
	outb(PIC2_DATA, ICW4_8086);
	io_wait();

	outb(PIC1_DATA, a1);
	outb(PIC2_DATA, a2);
}</code></pre></div></div></li></ul></div></li></ul></div>
<h level="3">Driver del Teclado</h><div class="ulist"><ul><li><p>Fijarse cómo se programa teniendo en cuenta el mecanismo de atención a las interrupciones.</p></li><li><p>Buscar el código fuente de un kernel sencillo.</p></li></ul></div>
<h level="3">paralell port</h><h level="4">Desde Espacio de Usuario</h><div class="ulist"><ul><li><p>Es necesario realizar llamadas al sistema ya que no podemos acceder desde el espacio de usuario directamente al HW</p></li><li><p><a href="http://es.wikipedia.org/wiki/Direcciones_base_de_entrada/salida">Direcciones base de los puertos</a></p></li><li><p>Acceso a un puerto en linux desde el espacio de usuario</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">/* led_bloq_mayus.c: very simple example of port I/O
 *
 * This code active LED keyboard CAP, just a port write, a pause,
 * and a port read. Compile with `gcc -O2 -o led_bloq_mayus led_bloq_mayus.c',
 * and run as root with `sudo ./led_bloq_mayus'.
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/io.h&gt;

#define BASEPORT 0x0060 /* keyboard */

int main()
{
        /* Get access to the ports */
        if (ioperm(BASEPORT, 3, 1)) {perror("ioperm"); exit(1);}
        printf("\n\t\t Port -&gt; registro status: %d\n", inb(BASEPORT + 1));

        /* Set the data signals (D0-7) of the port to all low (0) */
        outb(0xED, BASEPORT);

        /* Sleep for a while (100 ms) */
        usleep(1000);
        printf("\n \t\tActiva el LED de la tecla BLOQ MAYUS \n ");
        outb(0x07, BASEPORT);

        usleep(1000);

        /* We don't need the ports anymore */
        if (ioperm(BASEPORT, 3, 0)) {perror("ioperm"); exit(1);}
    exit(0);
}</code></pre></div></div>
<div class="ulist"><ul><li><p><a href="http://tldp.org/HOWTO/IO-Port-Programming-2.html" class="bare">http://tldp.org/HOWTO/IO-Port-Programming-2.html</a></p></li><li><p>man ioperm</p></li><li><p>man inb</p></li><li><p><code>cat /proc/ioports</code></p></li></ul></div></li><li><p><a href="http://opensourceforu.efytimes.com/2011/07/accessing-x86-specific-io-mapped-hardware-in-linux/" class="bare">http://opensourceforu.efytimes.com/2011/07/accessing-x86-specific-io-mapped-hardware-in-linux/</a></p></li></ul></div>
<h level="3">Serial communication RS-232</h><div class="ulist"><ul><li><p><a href="http://deans-avr-tutorials.googlecode.com/svn/trunk/InterruptUSART/Output/InterruptUSART.pdf">tutorial</a></p><div class="ulist"><ul><li><p>Tarjeta Avr Atmega 8bits &#8594; Pej Arduino One</p></li><li><p>Dos casos: Polling i/o e interrupt-driven i/o</p></li></ul></div></li><li><p>Puerto UART (RS-232)</p><div class="ulist"><ul><li><p>Conector físico</p></li><li><p>Comunicación semiduplex entre dos terminales: DTE (PC) y DCE (Arduino)</p></li><li><p>Señales Tx Rx</p></li><li><p>Registros del puerto</p><div class="ulist"><ul><li><p>Control</p></li><li><p>Estado</p></li><li><p>Datos Rx y Tx: UDR</p></li></ul></div></li></ul></div></li><li><p>Programación</p><div class="ulist"><ul><li><p>Librería</p></li><li><p>Cross toolchain</p></li><li><p>Algoritmo: Diagrama de flujo</p><div class="ulist"><ul><li><p>Casos Polling y Interruption</p></li></ul></div></li><li><p>Estructura modular: dos módulos</p></li><li><p>Símbolos</p><div class="ulist"><ul><li><p>Buffer de datos i/o</p></li><li><p>Nombre del vector de interrupción</p></li></ul></div></li></ul></div></li></ul></div></div></section><section id="_ejercicios_2"><h2>8.13. Ejercicios</h2><div class="slide-content"><div class="ulist"><ul><li><p>Capítulo 7 del libro de texto William Stalling.</p></li></ul></div></div></section></section>
<section><section id="_unidad_de_memoria"><h2>9. Unidad de Memoria</h2></section><section id="_introducción_12"><h2>9.1. Introducción</h2><div class="slide-content"><h level="3">Temario</h><div class="olist arabic"><ol class="arabic" start="9"><li><p>Organización de la memoria</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Jerarquía de memoria</p></li><li><p>Latencia y ancho de banda</p></li><li><p>Memoria cache</p></li><li><p>Memoria virtual</p></li></ol></div></li></ol></div>
<h level="3">Libro: William Stalling</h><div class="olist arabic"><ol class="arabic"><li><p>Introducir conceptos de William.</p><div class="ulist"><ul><li><p>William tiene un capítulo para la memoria principal y otro para memoria cache</p></li><li><p>Capítulo 4 : Caché</p><div class="ulist"><ul><li><p>La introducción de la memoria cache tiene Conceptos Generales</p></li></ul></div></li><li><p>Capítulo 5 : Memoria Interna (DRAM)</p></li><li><p>Capítulo 6 : Memoria Externa (Almacenamiento Periférico)</p></li><li><p>Capítulo 8 : Sistemas Operativos: Gestión de Memoria</p></li></ul></div></li></ol></div>
<h level="3">Refs</h><div class="ulist"><ul><li><p>What Every Programmer Should Know About Memory. Ulrich Drepper. Red Hat, Inc.</p><div class="ulist"><ul><li><p>su lectura completa requiere un nivel avanzado</p></li></ul></div></li></ul></div>
<h level="3">Historia</h><div class="ulist"><ul><li><p>El gran avance del Ingeniero John Von Neumann fue desarrollar la computadora IAS en la cual los programas no eran cableados sino almacenados electrónicamente en una unidad de memoria denominada Selectron. Los programas eran "editados" mediante la escritura de tarjetas de cartón perforadas que posteriormente eran convertidas en secuencias de digitos binarios para poder ser almacenadas en código binario en la unidad de memoria Selectrón. De esta manera surgió el concepto de "programa almacenado" o software y el desarrollo de las <strong>unidades de memoria</strong>.</p></li><li><p>La memoria no consistía de una única unidad sino que se estructuraba en distintos niveles:</p><div class="ulist"><ul><li><p>Nivel cpu: registros PC,MAR,MBR, IR, IBR, Acumuladores AC y AR : registros con capacidad para almacenar una instrucción y un dato.</p></li><li><p>Memoria principal: memoria Selectron con capacidad para almacenar programas agrupando en una sección las instrucciones y en otra sección los datos. Capacidad para direccionar 4K palabras de 40 bits cada palabra</p></li><li><p>Memoria secundaria: Tambores magnéticos "drum" con capacidad para almacenar una colección de programas.</p></li></ul></div></li></ul></div>
<h level="3">Interés</h><div class="ulist"><ul><li><p>Programación en un lenguaje de alto nivel</p><div class="ulist"><ul><li><p>¿Tenemos en cuenta el concepto memoria? &#8594; Abstracción de los mecanismos de gestión de memoria por parte del S.O, hardware, etc</p></li><li><p>Tener conocimientos de la estructura, organización y gestión de la memoria ayuda a la hora de programar &#8594; Fase de depuración, diseño, etc</p></li><li><p>Ingeniería de programación y de sistemas</p></li></ul></div></li><li><p>Conocimientos previos sobre memoria: temas previos de la asignatura Estructura de Computadores.</p><div class="ulist"><ul><li><p>variable, puntero,  registros, secciones, direccionamiento, violación de segmento, linker, &#8230;&#8203;</p></li></ul></div></li><li><p>Conocimiento de S.O.</p><div class="ulist"><ul><li><p>Gestión de la memoria de los procesos, paginación, memoria virtual, TLB, etc</p></li></ul></div></li><li><p>Objetivo</p><div class="ulist"><ul><li><p>Qué: Almacenar: datos e instrucciones &#8594; programas &#8594; ficheros &#8594; procesos</p></li><li><p>Para qué:</p><div class="ulist"><ul><li><p>Arquitectura von-Neumann: programa almacenado.</p></li><li><p>Ciclo de Instrucción: Captura (datos, instrucciones) de la CPU. Esquema de bloques CPU-RAM.</p></li></ul></div></li><li><p>Cómo: Cómo se almacenan ,cómo se capturan?</p></li></ul></div></li><li><p>Físicamente la memoria es</p><div class="ulist"><ul><li><p>chip de semiconductor conectado a la CPU.</p></li><li><p>memoria semiconductor interna a la CPU</p></li><li><p>memoria magnética de almacenamiento masivo</p></li></ul></div></li><li><p>El tema Memoria está aislado del resto de:</p><div class="ulist"><ul><li><p>la arquitectura de la computadora?:</p><div class="ulist"><ul><li><p>de la CPU? del kernel?</p></li></ul></div></li><li><p>la programación?</p><div class="ulist"><ul><li><p>instrucciones y datos?</p></li><li><p>qué es un array?</p></li><li><p>un goto?</p></li><li><p>en ensamblador que es la directiva .text?</p></li><li><p>qué es la pila?</p></li></ul></div></li></ul></div></li></ul></div>
<h level="3">Perspectivas</h><div class="ulist"><ul><li><p>El concepto de memoria puede ser estudiado en función de diferentes perspectivas.</p></li><li><p>Gestión de la Memoria  de los procesos en ejecución por parte del kernel del sistema operativo vs Organización de Memoria (ficheros,secciones,jerarquía de memoria ,..)</p></li><li><p>ISA: acceso a memoria, modos de direccionamiento, little endian, etc</p></li><li><p>Software:</p><div class="ulist"><ul><li><p>Programación:</p><div class="ulist"><ul><li><p>variables (reserva e inicialización de memoria), punteros, asignación dinámica de la memoria malloc(), secciones de memoria (text,data,rodata,bss,etc..), pila, ..</p></li></ul></div></li><li><p>Herramientas:</p><div class="ulist"><ul><li><p>Compilador, Linker (direcciones reubicables, resolución direcciones, segmentos de memoria,.. ), Cargador (memoria física, mapa de memoria, etc ..), volcado de memoria (objdump, ..)</p></li></ul></div></li><li><p>Sistema Operativo:</p><div class="ulist"><ul><li><p>Gestor de memoria virtual</p></li><li><p>Gestión del sistema de ficheros virtual</p></li></ul></div></li></ul></div></li><li><p>Hardware:</p><div class="ulist"><ul><li><p>Unidad de gestión de memoria MMU (Memory Management Unit): Convertidor del espacion de direcciones virtual en físico.</p></li><li><p>Módulos de Memoria</p><div class="ulist"><ul><li><p>tarjetas,chips,conexión buses</p></li><li><p>características: capacidad, velocidad, consumo, tecnología</p></li></ul></div></li></ul></div></li></ul></div>
<h level="3">Jerarquía de Memoria</h><div class="ulist"><ul><li><p>Hoy en día la tecnología de semiconductor ha conseguido avances en capacidad y memoria manteniendo la estructura por niveles en la siguente jerarquía:</p><div class="olist arabic"><ol class="arabic"><li><p>Jerarquía memoria</p></li></ol></div></li><li><p>Niveles: L0,L1,L2,L3,L4</p></li><li><p>Memoria Registros CPU &#8594; L0</p></li><li><p>Memoria Cache &#8594; L1,L2,L3</p></li><li><p>Memoria Principal</p></li><li><p>Memoria Secundaria: disco, pen-drive</p></li><li><p>Características</p><div class="ulist"><ul><li><p>Capacidad ascendente top-down</p></li><li><p>Tiempo del ciclo de memoria ascendente top-down</p></li></ul></div></li></ul></div>
<div class="imageblock" style="text-align: center"><img src="./images/memoria/MemoryHierarchy.png" alt="MemoryHierarchy" width="600" height="400" /></div><div class="title">Figure 54. Memory Hierarchy</div></div></section><section id="_registros_2"><h2>9.2. Registros</h2><div class="slide-content"><h level="3">ISA</h><div class="ulist"><ul><li><p>Los  registros son unidades de memoria de capacidad una única palabra (instrucción, dato, dirección de memoria, resultado temporal, etc ) y de latencia del orden de 1 ns. Nominación típica de estos registros son el Contador de Programa, el Registro de Instrucción, el Acumulador, el Buffer de Datos, etc&#8230;&#8203;. Son utilizados por la Unidad de Control en la ruta de datos de la microarquitectura de la CPU como parte fundamental del ciclo de instrucción. Estos registros no  son accesibles por el programador.</p></li><li><p>Los registros accesibles por el programador son el nivel L0 de la jerarquía de memoria de la arquitectura de la computadora. Son conocidos los Registros de Propósito General referenciados en el campo de dirección del formato de instrucción de la Arquitectura del Repertorio de Instrucciones (ISA). En el caso de la arquitectura x86-32 están los registros de propósito general de EXtensión: EXA, EXB, EXC, ESP, ESI, etc&#8230;&#8203;. (extensión de la arquitectura anterior de 16 bits AX,BX,CX, etc&#8230;&#8203;).</p></li><li><p>Debido a que los  registros forman parte de la microarquitectura de la cpu, este apartado se podría estudiar también dentro del tema dedicado a la CPU.</p></li></ul></div>
<h level="3">Arquitectura amd64</h><div class="imageblock"><img src="./images/instrucciones_representacion/registers_1200x800.png" alt="registers 1200x800" /></div><div class="title">Figure 55. x86 registers</div>
<div class="imageblock" style="text-align: center"><img src="./images/memoria/Table_of_x86_Registers_svg.png" alt="Table of x86 Registers svg" width="1000" height="500" /></div><div class="title">Figure 56. Registers x86</div>
<div class="imageblock text-center" style="text-align: center"><img src="./images/memoria/instruction_extensions_simd.png" alt="instruction extensions simd" width="600" height="300" /></div><div class="title">Figure 57. SIMD instructions evolution</div>
<div class="ulist"><ul><li><p>Observar que al igual que rax incluye a eax y eax incluye ax y ax incluye al, también zmm incluye a ymm e ymm incluye a xmm</p></li><li><p><a href="https://en.wikipedia.org/wiki/X86#x86_registers">wiki x86</a></p></li><li><p><a href="./basicos_x86_Registers.html">General Purpose Registers x86</a></p><div class="ulist"><ul><li><p>RAX,etc</p></li><li><p>RFLAGS</p></li><li><p>CS-DS-SS-</p></li><li><p>ST0-ST7</p><div class="ulist"><ul><li><p>Float Point Registers</p></li><li><p>alias de los registros FPU</p></li><li><p>eight 80-bit wide registers: 32-, 64-, or 80-bit floating point, 16-, 32-, or 64-bit (binary) integer, and 80-bit packed decimal integer.</p></li></ul></div></li><li><p>MMX</p><div class="ulist"><ul><li><p>ya en desuso y superados por XMM.</p></li><li><p>MMX instructions: <em>integer SIMD</em> (Single Instruction Multiple Data). MMX is a  instruction set designed by Intel, introduced in 1997 with its P5-based Pentium line of microprocessors.  a single instruction can then be applied to two 32-bit integers, four 16-bit integers, or eight 8-bit integers at once.</p></li><li><p>MM0-MM7 (64 bits).  Each register is 64 bits wide and can be used to hold either 64-bit integers, or multiple smaller integers in a "packed" format.</p></li><li><p>packed data types: two 32-bit integers, four 16-bit integers, or eight 8-bit integers concurrently &#8594; solo enteros.</p></li><li><p>Trabaja sólo con enteros pero por causas de compatibilidad en los cambios de contexto de los S.O. se creo un alias entre los MMX y los FPU generando el problema de no poder utilizar en una misma aplicación los FP y los MMX ya que las operaciones de uno afecta al otro.</p></li><li><p>Los registros FP del FPU x87 tiene acceso modo pila mientras que los MMX tienen acceso aleatorio.</p></li></ul></div></li><li><p>XMM</p><div class="ulist"><ul><li><p>Ya en desuso y superados por YMM.</p></li><li><p>XMM0–XMM15 (128 bits)</p></li><li><p>SSE (Streaming SIMD Extensions) instruction. Is an <em>floating point SIMD</em> instruction set extension to the x86 architecture introduced on 1999 with Pentium III.</p></li><li><p>Evolución de los MMX. Equivalente a MMX pero con datos de tipo coma flotante.</p></li><li><p>Se puede operar simultaneamente con los FP,MMX y XMM.</p></li></ul></div></li><li><p>YMM</p><div class="ulist"><ul><li><p>YMM0-YMM15 (256 bits)</p></li><li><p>La extensión de los XMM a 256 bits</p></li><li><p><a href="https://en.wikipedia.org/wiki/Advanced_Vector_Extensions">AVX</a>: Advanced Vector Extensions instructions</p></li><li><p>Unicamente datos en coma flotante: <em>floating point SIMD</em></p></li><li><p>AVX introduces a three-operand SIMD instruction format, where the destination register is distinct from the two source operands</p></li><li><p>Compatibilidad: The AVX instructions support both 128-bit and 256-bit SIMD</p></li><li><p>Intel comienza con este set en el 2011: Sandy Bridge processor, Q1 2011.</p></li><li><p><a href="https://software.intel.com/en-us/blogs/2011/06/13/haswell-new-instruction-descriptions-now-available/">AVX2</a></p><div class="ulist"><ul><li><p>Haswell microarchitecture año 2013: Haswell processor, Q2 2013</p></li><li><p>AVX2 - <em>Integer</em> data types expanded to 256-bit SIMD</p></li></ul></div></li></ul></div></li><li><p>ZMM</p><div class="ulist"><ul><li><p>(ZMM0-ZMM31) : 512 bits</p></li><li><p><a href="https://software.intel.com/en-us/blogs/2013/avx-512-instructions">Intel AVX-512</a>: Julio 2013</p><div class="ulist"><ul><li><p>Programs can pack eight double precision or sixteen single precision floating-point numbers, or eight 64-bit integers, or sixteen 32-bit integers within the 512-bit vectors. This enables processing of twice the number of data elements that AVX/AVX2 can process with a single instruction and four times that of SSE.</p></li></ul></div></li><li><p><a href="https://en.wikipedia.org/wiki/Advanced_Vector_Extensions">AVX-512 instructions</a></p></li></ul></div></li></ul></div></li><li><p><a href="https://en.wikipedia.org/wiki/Control_register">Control Registers x86</a>:CRx</p><div class="ulist"><ul><li><p>Controlar por ejemplo la paginación de memoria.</p></li></ul></div></li><li><p><a href="https://en.wikipedia.org/wiki/X86_debug_register">Debug Registers x86</a>:DRx</p><div class="ulist"><ul><li><p>Se utilizan para implementar por ejemplo las direcciones de los puntos de ruptura: DR0-DR3</p></li></ul></div></li><li><p>Check</p><div class="ulist"><ul><li><p>En linux con la instrucción <code>cpuid</code> podemos chequear la compabilidad de la cpu con la extensiones ISA: mmx,sse,avx,etc</p></li></ul></div></li><li><p>Conceptos</p><div class="ulist"><ul><li><p>SIMD: Single instruction multiple data.</p></li><li><p>Vectorizing code: instrucción que operan con vectores &#8594; una operación sobre múltiples datos simultáneamente.</p></li><li><p>DSP: Digital Signal Processor</p></li></ul></div></li><li><p>Tipos de registros</p><div class="ulist"><ul><li><p><a href="https://en.wikibooks.org/wiki/Microprocessor_Design/Register_File" class="bare">https://en.wikibooks.org/wiki/Microprocessor_Design/Register_File</a></p></li><li><p>Register File: memoria estática formada por una secuencia de registros con un bus de direcciones que mediante un decodificador selecciona uno de los registros.</p></li><li><p>Register Banking: dos posibles interpretaciones.</p><div class="ulist"><ul><li><p>Banked Registers for Interrupt Handling: En lugar de utilizar la memoria principal (pila) para  salvar y recuperar los registros cuando es interrumpido la ejecución de un proceso debido a una interrupción externa, utilizamos registros internos de la CPU para tal propósito: Se incrementa la velocidad de respuesta a una interrupción. La forma de implementar esta técnica es renombrando los registros utilizados por la rutina que interrumpe respecto de la rutina interrumpida.</p></li><li><p>Agrupamiento por bancos: El conjunto de registros se agrupa por bancos que pueden ser accedidos simultáneamente.</p></li></ul></div></li></ul></div></li></ul></div></div></section><section id="_memoria_principal_ram_dinámica_dram"><h2>9.3. Memoria Principal (RAM Dinámica DRAM)</h2><div class="slide-content"><h level="3">Tipos de Memoria de Semicoductor</h><table class="tableblock frame-topbot grid-all" style="width:90%"><colgroup><col style="width:20%" /><col style="width:20%" /><col style="width:20%" /><col style="width:20%" /><col style="width:20%" /></colgroup><thead><tr><th class="tableblock halign-left valign-top">Memory Type</th><th class="tableblock halign-left valign-top">Category</th><th class="tableblock halign-left valign-top">Erasure</th><th class="tableblock halign-left valign-top">Write Mechanism</th><th class="tableblock halign-left valign-top">Volatility</th></tr><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Random-access memory (RAM)</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Read-write memory</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Electrically, byte-level</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Electrically</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Volatile</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Read-only memory (ROM)</code></p></td><td class="tableblock halign-left valign-top" rowspan="2"><p class="tableblock"><code>Read-only memory</code></p></td><td class="tableblock halign-left valign-top" rowspan="2"><p class="tableblock"><code>Not possible</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Masks</code></p></td><td class="tableblock halign-left valign-top" rowspan="5"><p class="tableblock"><code>Nonvolatile</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Programmable ROM (PROM)</code></p></td><td class="tableblock halign-left valign-top" rowspan="4"><p class="tableblock"><code>Electrically</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Erasable PROM (EPROM)</code></p></td><td class="tableblock halign-left valign-top" rowspan="3"><p class="tableblock"><code>Read-mostly memory</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>UV light,chip-level</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Electrically Erasable PROM (EEPROM)</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Electrically, byte-level</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Flash memory</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Electrically,block-level</code></p></td></tr></table>
<div class="ulist"><ul><li><p>Random Access: se puede acceder a cualquier dirección de memoria de forma ALEATORIA, no secuencial (para acceder a la posición 3ª no es necesario acceder antes a la 1ª y 2ª)</p></li><li><p>Volátil: si se quita la alimentación, el contenido de la memoria se borra.</p></li><li><p>ROM: Read Only Memory &#8594; El contenido de la memoria se escribe en la fábrica y el usuario únicamente puede leerla.</p></li><li><p>PROM: ROM Programable &#8594; Los programas de usuario sólo pueden leer la memoria pero el administrador la puede actualizar. Por ejemplo la BIOS.</p></li><li><p>Erasable: la memoria ROM programable se debe de borrar antes de escribir &#8594; se borra con luz ultravioleta</p></li><li><p>EE: electrycaly erasable . La PROM se borra eléctricamente en lugar de con luz UV</p></li><li><p>Flash: la memoria en lugar de borrarse secuencialmente, de palabra en palabra, lo cual es lento, se borra por grandes bloques. Un gran bloque se borrar en un instánte (efecto flash)</p></li><li><p>SSD: Solide State Drive : Memoria flash de alta capacidad</p><div class="ulist"><ul><li><p>SLC, TLC y MLC (Single-, Triple- y Multi- level cell)</p></li></ul></div></li></ul></div>
<h level="3">Memoria PRINCIPAL semiconductora</h><div class="ulist"><ul><li><p>Un programa almacenado en una memoria secundaria (disco externo) ha de ser cargado por el sistema operativo en la Memoria Principal para poder ser ejecutado por la CPU. La Unidad de Control captura instrucciones/datos que están en la memoria principal.</p></li><li><p>Las operaciones que realiza la CPU con la memoria principal son la <strong>LECTURA</strong> y la <strong>ESCRITURA</strong> (Read/Write) de datos e instrucciones binarias.</p></li><li><p>RAM:</p><div class="ulist"><ul><li><p>Semiconductor Silicio: transistores.</p></li><li><p>Random Acces Memory</p></li><li><p>Operaciones de lectura y escritura</p></li><li><p>Volátil</p></li><li><p>Tipos</p><div class="ulist"><ul><li><p>SRAM: <strong>Static</strong> RAM.</p><div class="ulist"><ul><li><p>Mientras está alimentada la información no se pierde. No tiene fugas, no es necesaria refrescar la información cada unos pocos milisegundos.</p></li><li><p>Estructura de la Celda 6T: seis transistores. Tamaño y consumo elevados. Latencia y capacidad reducidas.</p><div class="ulist"><ul><li><p>Memoria caché.</p></li></ul></div></li></ul></div></li><li><p>DRAM: <strong>Dynamic</strong> RAM .</p><div class="ulist"><ul><li><p>Estructura de la celda: 1C1T: un condensador y un transistor. Tamaño y consumo reducidos.Latencia y capacidad elevadas.</p></li><li><p>Memoria principal: Los programas se cargan en dicha memoria para ser ejecutados por la CPU.</p></li><li><p>Las celdas bit (condensadores) tienen fugas por lo que necesita periódicamente una reescritura (DINAMISMO).</p></li><li><p>Asíncrona DRAM:</p></li><li><p><strong>Síncrona SDRAM</strong>: Las operaciones R/W se realizan en instantes de tiempo marcados por un</p></li></ul></div></li></ul></div></li></ul></div></li></ul></div>
<div class="imageblock text-center" style="text-align: center"><img src="images/dram/tarjeta_micron_1.png" alt="tarjeta micron 1" /></div><div class="title">Figure 58. Dual Inline Memory Module (DIMM)</div>
<div class="paragraph"><p>Cada módulo se inserta en un slot de la placa base de la computadora.</p></div>
<div class="imageblock text-center" style="text-align: center"><img src="images/dram/tarjeta_micron_2.png" alt="tarjeta micron 2" /></div><div class="title">Figure 59. Dual Inline Memory Module (DIMM)</div>
<div class="paragraph"><p>Una tarjeta ó Módulo es un agrupamiento por chips. Los chips suelen estar soldados por ambas caras del módulo DIMM.</p></div>
<div class="imageblock text-center" style="text-align: center"><img src="images/dram/tarjeta_esquema.png" alt="tarjeta esquema" /></div><div class="title">Figure 60. Dual Inline Memory Module (DIMM)</div>
<h level="4">Organización</h><div class="ulist"><ul><li><p>Celda de memoria:</p><div class="ulist"><ul><li><p>es la unidad básica de almacenamiento de un bit (Binary digIT). El bit es un valor lógico <em>High</em> o <em>Low</em>, <em>1</em> o <em>0</em></p></li><li><p>acceso a la celda:</p><div class="ulist"><ul><li><p>la línea de direcciones selecciona la celda a leer o escribir</p></li><li><p>la línea de bit es la línea de entrada/salida del bit a leer o escribir.</p></li></ul></div></li></ul></div></li><li><p>Matriz: las celdas de memoria se organizan en una estructura 2D matricial formadas por filas y columnas</p></li><li><p>Bus del Sistema: bus de interconexión entre el <strong>controlador MC</strong> (Memory Controller) y la CPU.</p><div class="ulist"><ul><li><p>La unidad de control de la CPU no se comunica directamente con la Memoria Principal. La Unidad de Control de la CPU da ordenes de lectura y escritura, pero se desentiende de acciones más primitivas y específicas de la organización y tecnología de la Memoria Principal. Para dichas tareas específicas de las memorias DRAM está el <strong>controlador MC</strong></p></li></ul></div></li><li><p>Bus de Memoria: bus de interconexión entre el controlador MC y la MP</p><div class="ulist"><ul><li><p>Bus Direcciones:</p><div class="ulist"><ul><li><p>El bus de direcciones transfiere el código de la palabra a seleccionar</p></li><li><p>La dirección se almacena temporalmente en el buffer de direcciones de la memoria</p></li><li><p>El bus de direcciones se conecta al buffer de direcciones de la memoria</p></li><li><p>El buffer de direcciones se conecta a la entrada del decodificador de  direcciones de la memoria</p></li><li><p>La dirección se decodifica. La salida del decodificador activa la dirección de memoria del dato/instrucción a leer o escribir</p></li></ul></div></li><li><p>Bus Datos:</p><div class="ulist"><ul><li><p>El dato de salida o entrada se almacena temporalmente en el buffer de datos i/o de la memoria</p></li><li><p>Las celdas no se conectan directamente al buffer de datos i/o de la memoria</p><div class="ulist"><ul><li><p>las salidas de las celdas seleccionadas son amplificadas para detectar si almacenan <em>0</em> o <em>1</em></p></li></ul></div></li><li><p>El bus de datos esta conectado al buffer de datos de la memoria</p></li></ul></div></li><li><p>Bus Control:</p><div class="ulist"><ul><li><p>Es necesario alimentar la memoria con una tensión continua de unos pocos voltios (1v)</p></li><li><p>Señal de lectura y escritura que activa la CPU o el controlador E/S</p></li><li><p>Señal de reloj de sincronismo. Sincroniza las tareas a realizar entre la MP y el controlador de memoria (MC)</p></li></ul></div></li><li><p>Bus chip select:</p><div class="ulist"><ul><li><p>Señal <em>Chip Select</em> (CS) de selección del módulo de memoria que lo conecta a los buses de direcciones y de datos . Si la señal CS no está activa el módulo de memoria está desconectado de los buses.</p></li></ul></div></li></ul></div></li></ul></div>
<div class="imageblock text-center" style="text-align: center"><img src="images/dram/system.png" alt="system" /></div><div class="title">Figure 61. Computer System</div>
<div class="ulist"><ul><li><p>Controlador de Memoria (MC)</p><div class="ulist"><ul><li><p>La MP no se conecta directamente a la CPU. El controlador MC hace de intermediario.</p></li><li><p>El controlador MC se conecta por un lado a la CPU y por otro lado a la memoria MP.</p></li><li><p>La CPU envía comandos al controlador MC para que actue sobre la MP.</p></li><li><p>El controlador MC es un secuenciador que sabe cómo actuar sobre la estructura interna de la memoria para:</p><div class="ulist"><ul><li><p>qué módulo seleccionar, qué chip selececcionar, que palabra seleccionar.</p></li><li><p>leer y escribir un dato</p></li><li><p>otras acciones sobre la memoria como mantenimiento, chequeo, detección de errores, etc</p></li></ul></div></li></ul></div></li></ul></div>
<div class="imageblock text-center" style="text-align: center"><img src="images/dram/System_Bus_Structure_RAM_Controller.gif" alt="System Bus Structure RAM Controller" /></div><div class="title">Figure 62. Memory Controller</div>
<div class="ulist"><ul><li><p>Memory Management Unit (MMU)</p><div class="ulist"><ul><li><p>Las direcciones con que opera la Unidad de Control de la CPU en sus registros de próposito general, contador de programa, etc, no son físicas &#8594; son <strong>direcciones virtuales</strong></p></li><li><p>Cuando programamos, el programador, el compilador, el linker, el desensamblador, el depurador, etc trabajan en el espacio virtual. El módulo ejecutable ELF y los procesos hacen referencia al espacio virtual.</p></li><li><p>Los procesos (programas que están siendo ejecutados por la CPU) operan con direcciones del espacio virtual &#8594; memoria virtual del proceso</p></li><li><p>MMU: circuito electrónico HW que <strong>traduce direcciones</strong> del espacio virtual (CPU) en direcciones físicas de la MP y que serán las que se transfieran al bus del controlador de la caché y al controlador de memoria MC para poder acceder a la memoria física.</p></li></ul></div></li></ul></div>
<h level="4">DRAM (Dynamic Random Access Memory)</h><div class="ulist"><ul><li><p>Celda</p><div class="ulist"><ul><li><p>Estructura física:</p><div class="ulist"><ul><li><p>Es un condensador Metal-Dielectrico-Metal(Polysilicio) fabricado en un substrato de Silicio.</p></li><li><p>Su capacidad es del orden de femto-faradios: C=10~(-15)F</p></li><li><p>Si le aplicamos una tensión de 1mv la carga almacenada  Q=CV= 1mv*1fF =1*10(-18) culombios que equivale a una decena de electrones.</p></li><li><p>Su forma es la de un cilindro empotrado en el substrato.</p></li><li><p>La sección transversal del condensador es del orden de 30 nm en el año 2010</p><div class="ulist"><ul><li><p><a href="https://en.wikipedia.org/wiki/3_nm_process">evolución proceso tecnológico</a>: 3nm node en el año 2023</p></li></ul></div></li><li><p>La densidad de condensadores es del orden del giga &#8594; 10~9 condensadores.</p></li><li><p>Es necesario conectar el condensador a las líneas de direcciones y de bit para acceder a él. Se conecta a través de UN transistor CMOS que hace de interruptor.</p></li></ul></div></li></ul></div></li></ul></div>
<div class="imageblock text-center" style="text-align: center"><img src="images/dram/cell_1t1c.png" alt="cell 1t1c" /></div><div class="title">Figure 63. cell_1t1c</div>
<div class="imageblock text-center" style="text-align: center"><img src="images/dram/cell_capacitor.png" alt="cell capacitor" /></div><div class="title">Figure 64. cell_capacitor</div>
<h level="4">DRAM (Operaciones de lectura-escritura-refresco)</h><div class="ulist"><ul><li><p>Almacenamiento:</p><div class="ulist"><ul><li><p>el condensador inicialmente no está conectado a ninguna línea ya que su interruptor está abierto</p><div class="ulist"><ul><li><p>en circuito abierto el condensador almacena la carga mientras está alimentado &#8594; volátil</p></li><li><p>el condensador tiene FUGAS y se descarga a través del substrato. Es necesario reescribir el bit cada 64 ms: DYNAMIC (la información que almacena no puede ser estática, hay que REFRESCARLA PERIODICAMENTE)</p></li></ul></div></li><li><p>Escritura:</p><div class="ulist"><ul><li><p>Cerramos el interruptor (línea de dirección) para conectar el condensador a la línea de bit ( línea de dato)</p></li><li><p>A través de  la línea de bit cargamos (<em>H</em> ) o descargamos (<em>L</em>) el condesador</p></li></ul></div></li><li><p>Lectura:</p><div class="ulist"><ul><li><p>Una vez seleccionada la celda a leer, está se conecta al Sensor de Carga (amplificador) que detecta su estado y lo escribe en el buffer i/o</p></li><li><p>Esta <strong>lectura es DESTRUCTIVA</strong>, dejando el condensador descargado. Es necesario que el amplificador realimente el condensador a su estado original. La escritura del buffer i/o y la RE-escritura del condensador se dan simultáneamente.</p></li></ul></div></li><li><p>Refresco</p><div class="ulist"><ul><li><p>Es necesario leer y reescribir todos los condensadores. Esta operación la realiza el sensor de carga.</p></li><li><p>Es necesario reescribir todas las celdas en un tiempo inferior a los 64ms.</p></li></ul></div></li></ul></div></li></ul></div>
<h level="4">Ejemplo de Estructura</h><div class="ulist"><ul><li><p><a href="https://www.anandtech.com/print/3851/everything-you-always-wanted-to-know-about-sdram-memory-but-were-afraid-to-ask" class="bare">https://www.anandtech.com/print/3851/everything-you-always-wanted-to-know-about-sdram-memory-but-were-afraid-to-ask</a></p></li></ul></div>
<h level="4">DRAM Matriz(Array 2D)</h><div class="ulist"><ul><li><p>Ejemplo: un bus de direcciones de 30 líneas puede direccionar una de las 2<sup>30</sup> CELDAS, a seleccionar UNA de ellas.</p></li><li><p>Mediante un DEMULTIPLEXOR de 30 entradas binario (Bus de direcciones) y 2<sup>30</sup> salidas (se activa sólo una salida) podemos seleccionar 1 fila que contine una celda o bit de memoria.</p></li></ul></div>
<div class="imageblock" style="text-align: center"><img src="images/dram/demux.png" alt="demux" /></div><div class="title">Figure 65. Demultiplexor/Decoder</div>
<div class="ulist"><ul><li><p>Un demultiplexor de 2<sup>30</sup> salidas (1.073.741.824 de salidas) es imposible de fabricar</p></li><li><p>Solución:</p><div class="ulist"><ul><li><p>organizar las CELDAS en un array 2D : Filas y columnas: 1 DEMUX o DECODIFICADOR para filas y 1 DEMUX/MUX o DECODIFICADOR para las columnas</p></li><li><p>2<sup>30</sup> = 2<sup>15</sup>*2<sup>15</sup> = Ahora el número de salidas de cada demux se ha reducido de 2<sup>30</sup> a 2<sup>15</sup>, es decir, se ha reducido a 32.768 salidas, un factor raíz cuadrada. Un multiplexor con 32.768 salidas es posible de fabricarse.</p></li><li><p>word line selecciona todas las columnas de una fila (ROW) de celdas</p></li><li><p>bit line selecciona una de las columnas (COL) de la fila seleccionada</p></li><li><p>el resultado es seleccionar una CELDA del ARRAY y cargar (LECTURA) el BUFFER I/O</p></li></ul></div></li><li><p>Bus de direcciones muy denso: ejemplo de 30 líneas</p><div class="ulist"><ul><li><p>Podemos diseñar un bus con la mitad de líneas y multiplexar en dos tiempos el código de direcciones(parte que selecciona la fila y parte que selecciona la columna).</p></li><li><p>Multiplexación temporal de la dirección de filas y la dirección de columnas: REDUCIMOS EL NUMERO DE LINEAS EN LA PLACA BASE</p></li><li><p>RAS: Row Address Strobe : Señal que válida el bus de direcciones indicando que es el código que selecciona la FILA del array.</p></li><li><p>CAS: Row Address Strobe : Señal que válida el bus de direcciones indicando que es el código que selecciona la COLUMNA del array.</p></li></ul></div></li><li><p>Burst (ráfaga)</p><div class="ulist"><ul><li><p>Una vez seleccionada una fila de celdas (OPEN ROW) si queremos celdas consecutivas de la misma columna podemos leer o escribirlas consecutivamente en cada ciclo de reloj . Bloque de palabras a transferir a/desde la memoria Caché. El controlador de memoria ha tenido que enviar un comando a la memoria para configurar el número de palabras de la ráfaga.</p></li></ul></div></li></ul></div>
<div class="imageblock text-center" style="text-align: center"><img src="images/dram/array1.png" alt="array1" /></div><div class="title">Figure 66. Array de celdas</div>
<div class="ulist"><ul><li><p>Organización de celdas en una dimensión: 1D:  Filas.</p></li><li><p>Un circuito decodificador de filas</p></li><li><p>1024 filas y cada fila son 16 celdas.</p></li><li><p>El <strong>buffer i/o</strong> es de 16 bits.</p></li><li><p>Al direccionar una fila se conectan las 16 celdas al buffer i/o ó gating i/o</p></li></ul></div>
<div class="admonitionblock important"><table><tr><td class="icon"><i class="fa fa-exclamation-circle" title="Important"></i></td><td class="content">Las celdas (condensadores) almacenan muy poco carga (picoculombios) y por lo tanto no se pueden conectar directamente al bus de direcciones, es necesario un amplificador o sensor de CARGA. A la salida de dicho amplificador está el registro ó registros (BUFFER) de entrad/salida i/o. Es decir, el contenido binario de las celdas se vuelca en el BUFFER I/O. El buffer i/o está hecho en una tecnología capaz de conducir las líneas del bus de DATOS de la placa base.</td></tr></table></div>
<div class="imageblock text-center" style="text-align: center"><img src="images/dram/array2.png" alt="array2" /></div><div class="title">Figure 67. Array de celdas 2D</div>
<div class="ulist"><ul><li><p>Organización de celdas en dos dimensiones: 2D: matriz de filas y columnas</p></li><li><p>Dos decodificadores: un decodificador de filas y un decodificador de columnas.</p></li><li><p>Cada par (fila, columna) accede a una celda.</p></li></ul></div>
<h level="4">Logica del Chip (Figura 5.3 del libro)</h><div class="ulist"><ul><li><p>Componentes:</p><div class="ulist"><ul><li><p>buffers: direcciones y columnas</p></li><li><p>decodificadores: decodifican el código de direccion de fila y de columna y seleccionan (fila,columna) una celda.</p></li><li><p>sensor de carga (amplificador): detecta si la celda está cargada o descargada y da como salida un <em>H</em> o <em>L</em> en el buffer i/o.</p></li><li><p>4 señales de control: RAS, CAS, WE, OE</p><div class="ulist"><ul><li><p>la combinación de señales de control (2<sup>4</sup>) se utiliza también para codificar los <a href="http://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">comandos</a> del controlador de memoria.</p></li><li><p>COMANDOS: son ordenes a los módulos de memoria donde las características de la memoria como el timing (tiempos de latencia, ciclo, etc) y el burst length (número de palabras por bloque, longitud de la ráfaga) son programables y por lo tanto la CPU puede configurar estos parámetros.</p></li></ul></div></li><li><p>circuitería de refresco:</p><div class="ulist"><ul><li><p>contador de direcciones y temporizador</p></li><li><p>la asociación JEDEC recomienda un refresco completo cada 64 ms.</p></li></ul></div></li></ul></div></li></ul></div>
<h level="4">Encapsulado</h><div class="ulist"><ul><li><p>La memoria de semiconductor ocupa unos pocos mm<sup>2</sup> que debe de ser protegido (térmica y mecánica) y permitir que la conexiones sean robustas para permitir su soldadura a las líneas externas por lo que require un encapsulado de plástico.</p></li><li><p>Los terminales del encapsulado se denominan PIN y son soldados a la tarjeta de memorias.</p><div class="ulist"><ul><li><p>pines o terminales:</p><div class="ulist"><ul><li><p>address bus (A0-A29)</p></li><li><p>data bus (DQ0-DQ7) : los chips no tienen 64 pines de datos : 1,2,4,8.</p></li><li><p>alimentación Vcc</p></li><li><p>masa Vss</p></li><li><p>chip select /CS</p></li><li><p>write enable (/WE): <em>L</em>(escritura) <em>H</em> (lectura)</p></li><li><p>output enable (/OE): <em>L</em>(los pines de datos se conectan al bus de datos)</p></li></ul></div></li></ul></div></li></ul></div>
<h level="4">Temporización de la operación de lectura/escritura</h><div class="ulist"><ul><li><p>En el <a href="#apendice_temporizacion_dram">Apéndice</a> hay información detallada sobre las distintas señales que controla la temporización de las operaciones del controlador de memoria MC con la tarjeta de memoria.</p></li><li><p>Los tiempos o latencias tRAS, tCAS, etc son retardos que se deben de respetar entre todas la señales que controlan los intervalos de tiempo en que se activa las distintas señales de <strong>control temporal</strong> para seleccionar direcciones de la memoria y esperar el tiempo necesario para que finalice el ciclo de lectura o de escritura en la memoria.</p></li><li><p>Sincronismo</p><div class="ulist"><ul><li><p>El bus de control de la memoria tiene un hilo que es el <strong>reloj</strong> de las operaciones de lectura y escritura de la memoria principal. No confundir con el reloj de la Unidad de Control de la CPU.</p></li><li><p>SDRAM : Synchronous Dynamic RAM, adding a <strong>clock</strong> (and a clock enable) line. All other signals are received on the <em>rising edge</em> of the clock. No responde tan rápido como es posible, sino que espera al flanco de subida.</p></li></ul></div></li><li><p>El módulo de memoria MP es programable por lo que podemos alterar los tiempos tCL-tRCD-tRP-tRAS y también la longitud de la ráfaga(burst o bloque)</p></li><li><p>El módulo de memoria MP suele indicar la secuencia tCL-tRCD-tRP-tRAS con valores típicos de ciclos del reloj de memoria.</p></li></ul></div>
<h level="4">Agrupamientos: Módulos-Rank-Chips-Bank</h><div class="ulist"><ul><li><p>Jerarquía: Estructura de la memoria DRAM en agrupamientos de direcciones</p></li></ul></div>
<h level="5">Channel</h><div class="ulist"><ul><li><p>Channel :</p><div class="ulist"><ul><li><p>interfaces del controlador de memoria con el bus del sistema.</p></li><li><p>Cada canal tiene su propio bus de memoria físico.</p></li><li><p>El controlador tiene acceso al bus del sistema y a más de un bus de memoria.</p></li><li><p>Todos lo canales de un mismo controlador de memoria conforman todo el espacio de memoria física, por lo tanto un controlador tiene asignado un canal lógico (todo el espacio de memoria) formado por varios físicos ( distintos espacios de memoria)</p></li></ul></div></li></ul></div>
<h level="5">Module DIMM</h><div class="ulist"><ul><li><p>Dual Inline Memory Module (DIMM):</p><div class="ulist"><ul><li><p>Dual Inline significa que la tarjeta o módulo tiene conectores en ambas caras de la tarjeta.</p></li><li><p>Proporciona la conexión física al bus de datos ( palabra de 64 bits), al bus de direcciones, al bus de control y al bus de chip-select (CS)  del BUS de MEMORIA.</p></li><li><p>Es la tarjeta de memoria encapsulada que se inserta en el socket de la placa base conectándose al bus de memoria del controlador de memoria (MC)</p></li><li><p>Para los PC la conexión de los módulos de memoria es <a href="http://en.wikipedia.org/wiki/DIMM">DIMM</a> y para los portátiles <a href="http://en.wikipedia.org/wiki/SO-DIMM">SO-DIMM</a>. El encapsulamiento DIMM permite disponer de conectores y de chips en ambos lados de la tarjeta (front-side y back-side)</p></li><li><p>En el módulo están interconectados todos los  chips de memoria de la tarjeta.</p></li><li><p>Un canal del controlador puede contectarse a más de un módulo de memoria: P.ej dos módulos de 4GB cada uno.Si un canal tiene más de un modulo, todos los modulos comparten el mismo BUS DE MEMORIA. Cada módulo implementa direcciones de memoria diferentes.</p></li></ul></div></li></ul></div>
<h level="5">Rank</h><div class="ulist"><ul><li><p>Rank	:</p><div class="ulist"><ul><li><p>Es un conjunto o <em>agrupamiento de bancos</em> dentro de todo el sistema de memoria (todos los módulos DIMM ,no cada módulo DIMM). Donde los bancos están implementados en Chips. Para seleccionar los bancos de un rank hay contectar los chips de dichos bancos de tal forma que la señal chip select (CS) sea común a todos ellos, compartiendo así el mismo espacio de direcciones.</p></li><li><p>Así organizados, todos los bancos de los chips del mismo rank pueden responder AL UNISONO al mismo bus de direcciones (filas,columnas). Al activar la señal CS y seleccionar una Fila , se consigue activar todas las columnas de todas las filas de todos los arrays de todos los bancos de los chips del mismo rank. Este es el objetivo del agrupamiento.</p></li><li><p>Un rank es independiente del resto, con direcciones de memoria <em>diferentes</em>, compartiendo el mismo bus de direcciones y bus de chip select. Un rank al ser INDEPENDIENTE puede ser precargado, refrescado, activado, etc al mismo que el resto de ranks.</p></li></ul></div></li></ul></div>
<div class="imageblock text-center" style="text-align: center"><img src="images/dram/rank1.png" alt="rank1" /></div><div class="title">Figure 68. Rank: agrupamiento de chips en el módulo de memoria DIMM</div>
<div class="paragraph"><p><strong>RANK</strong>:</p></div>
<div class="ulist"><ul><li><p>4 módulos DIMM con 4 chips cada uno.</p></li><li><p>Agrupamiento de los bancos de los chips en el SISTEMA de memoria ( todos los módulo de memoria DIMM).</p></li><li><p>En este caso cada Rank agrupa todos los chips del mismo módulo y por lo tanto todos los bancos de cada chip.</p></li><li><p>Cada chip select selecciona un rank diferente.</p></li></ul></div>
<div class="imageblock text-center" style="text-align: center"><img src="images/dram/rank2.png" alt="rank2" /></div><div class="title">Figure 69. Rank</div>
<h level="5">Chip</h><div class="ulist"><ul><li><p>Chip	:</p><div class="ulist"><ul><li><p>Es el circuito integrado que contiene el <em>die</em> de semiconductor  donde están implemetadas las celdas de memoria (condensadores) y los interrruptores (transistores).</p></li><li><p>El número de pins del chip dependerá del tamaño del dato proporcionado y de la capacidad de almacenamiento de datos.</p></li><li><p>El número de bits <em>"N"</em> del dato proporcionado por el chip a través del buffer i/o, se indica diciendo que el chip es <em>xN</em>: x2,x4,x8,x16,x32</p></li><li><p>Esta formado por <em>MULTIPLES bancos</em>, un <em>buffer i/o</em>, un <em>demux</em> de filas, un <em>demux</em> de columnas y la lógica de control.</p></li></ul></div></li></ul></div>
<div class="imageblock text-center" style="text-align: center"><img src="images/dram/bank2.png" alt="bank2" /></div><div class="title">Figure 70. Chipx16</div>
<div class="ulist"><ul><li><p>Chipx16 formado por 4 bancos y 1 buffer i/o de 16 bits.</p></li><li><p>Cada banco son 16 arrays 2D &#8594; el 16 es la 3D, y 8196x512 es cada array 2D</p></li><li><p>Cada array tiene 8192 filas y 512 columnas. 2<sup>13</sup> filas x  2<sup>9</sup> columnas = 2<sup>22</sup> celdas</p></li><li><p>Capacidad de cada banco 3D: 2<sup>22</sup> celdas x 16 bits = 4*2<sup>20</sup>*2Bytes=8MBytes</p></li><li><p>Cada banco 3D es un espacio de direcciones de 8MB independiente.</p></li><li><p>Chipx16 : 4 Bancos : 32 MB &#8594; 16M x2Bytes DRAM &#8594; 16M x16bits DRAM</p><div class="ulist"><ul><li><p>bus de datos: 16 bits &#8594; 2 bytes</p></li><li><p>bus de direcciones: para una capacidad de 32 MB : 2<sup>25</sup> &#8594; 25 hilos</p></li></ul></div></li></ul></div>
<h level="5">Bank</h><div class="ulist"><ul><li><p>Este término es confuso ya que depende del contexto e incluso hay diversas interpretaciones.</p><div class="ulist"><ul><li><p>En el caso de la cpu de intel 4004 es &#8230;&#8203; (ver Tema CPU apartado i4004)</p></li><li><p>En el entorno linux si ejecutamos el comando "lshw -C memory" aparece información de los distintos bancos, donde en este entorno banco esta asociado a slot de memoria de la placa base.</p></li></ul></div></li><li><p>Bank:</p><div class="ulist"><ul><li><p>Un chip se estructura en bancos.</p></li><li><p>Los bancos se agrupan de forma lógica en Ranks conectando el mismo orden o número de banco de distintos chips.</p></li><li><p>Un banco es un conjunto, <em>agrupamiento de arrays 2D</em>,al agrupar arrays 2D tenemos una estructura 3D.</p></li></ul></div></li></ul></div>
<div class="admonitionblock important"><table><tr><td class="icon"><i class="fa fa-exclamation-circle" title="Important"></i></td><td class="content">Al dibujar la estructura 3D observar que para dirección (fila-columna) tenemos un dato de tamaño el número de arrays del banco.</td></tr></table></div>
<div class="ulist"><ul><li><p>Si cada array contribuye con un bit al buffer i/o, entonces, el número de arrays del banco será el mismo que el número de bits del buffer i/o.</p></li><li><p>Así organizados, todos los arrays del mismo orden de banco de distintos chips pueden responder AL UNISONO al mismo bus de direcciones (filas,columnas). Cada array del banco proporciona el bit de la celda seleccionada por lo que el número de bits del dato proporcionado por el banco será el número de arrays del banco.</p></li><li><p><strong>Todos</strong> los bancos del chip forman parte del <strong>mismo</strong> buffer i/o del chip.</p></li><li><p>El número de bits <em>"n"</em> , del dato proporcionado por el banco a través del buffer i/o, se indica diciendo que el chip es <em>xn</em>: x2,x4,x8,x16,x32</p></li><li><p>Bancos de distintos chips son independientes unos de otros, con direcciones de memoria <em>diferentes</em>, compartiendo el mismo bus de direcciones y bus de chip select. Un banco al ser INDEPENDIENTE del resto puede ser precargado, refrescado, activado, etc al mismo tiempo que el resto de bancos del mismo rank: PARALELISMO a nivel de Bancos, con el objetivo de reducir los tiempos de acceso a la memoria DRAM.</p></li></ul></div>
<div class="imageblock text-center" style="text-align: center"><img src="images/dram/bank1.png" alt="bank1" /></div><div class="title">Figure 71. Bank: Array en el chip de memoria DIMM</div>
<div class="paragraph"><p>Tres chips. Cada Chip esta formado por un <strong>BANCO</strong>. Un banco es un agrupamiento de Arrays.</p></div>
<div class="paragraph"><p>Chip x2 DRAM:</p></div>
<div class="ulist"><ul><li><p>x2 significa un chip con un buffer i/o de 2 bits &#8594; bus de datos de 2 bits</p></li><li><p>Un banco con 2 arrays. Cada array proporciona 1 bit.</p></li></ul></div>
<div class="paragraph"><p>Chip x4 DRAM:</p></div>
<div class="ulist"><ul><li><p>x4 significa un chip con un buffer i/o de 4 bits &#8594; bus de datos de 4 bits</p></li><li><p>Un banco con 4 arrays. Cada array proporciona 1 bit.</p></li></ul></div>
<div class="paragraph"><p>Chip x8 DRAM:</p></div>
<div class="ulist"><ul><li><p>x8 significa un chip buffer i/o de 8 bits &#8594; bus de datos de 8 bits</p></li><li><p>Un banco con 8 arrays. Cada array proporciona 1 bit.</p></li></ul></div>
<h level="5">Página / Row-Buffer</h><div class="imageblock text-center" style="text-align: center"><img src="images/dram/page.png" alt="page" /></div><div class="title">Figure 72. Page</div>
<div class="ulist"><ul><li><p>No confundir con las páginas virtuales del Sistema Operativo</p></li><li><p>Cada conjunto de Bancos del mismo orden (pej Banco número 3) de diferentes chips del mismo Rank, tienen asocidado un "registro virtual" denominado ROW-BUFFER. Es virtual o lógico ya que abarca distintos chips físicos.</p></li><li><p>Una página abarca los datos (misma fila, misma columna de los distintos arrays del banco) de la misma dirección de fila (Pej número 2) de diferentes bancos con el mismo orden o número de banco (Pej número 3). Al conjunto de filas de todos los  banco se denomina <strong>página</strong> (una página está formada por filas). Por lo tanto el contenido del ROW-BUFFER es el de una página. Al row-buffer se descargan más columnas que la requerida, de esta forma el row-buffer hace de CACHE (copia) guardando datos adyacentes al solicitado, pero que no son requeridos inicialmente. Posteriormente se seleccionan todas las columnas del mismo orden (pej columna 2) de cada fila del row-buffer y se cargan en el buffer i/o.  En el siguiente acceso a memoria puede que el dato requerido ya esté en el buffer, por lo que NO es necesaria descargar el dato de las celdas del array y por lo tanto se reduce la latencia y la lectura del dato es mucho más rápida. Por ejemplo en el caso de querer leer un array si el array ha sido almacenado en un página se podría leer toda la página con un solo acceso a las celdas y posteriormente transferir el contenido del buffer por ráfagas.</p></li></ul></div>
<h level="5">Array</h><div class="ulist"><ul><li><p>Array:</p><div class="ulist"><ul><li><p>Son agrupamientos o conjuntos de celdas organizados en filas y columnas.</p></li><li><p>Una dirección de memoria (fila,columna) selecciona una celda del array.</p></li></ul></div></li></ul></div>
<h level="5">Celda</h><div class="ulist"><ul><li><p>Celdas:</p><div class="ulist"><ul><li><p>Una celda de memoria almacena la información de 1 o más (2,4,8,16) bits. Inicialmente, mientras no se especifique lo contrario, almacenará un único bit.</p></li></ul></div></li></ul></div>
<h level="4">LECTURA de una palabra de la memoria MP</h><h level="5">Selección de Chip/Banco/Filas/Columna</h><div class="ulist"><ul><li><p>Ejemplo de Lectura: Memoria de 4 chipsx4 con 8 bancos por chip y bancos con 4 arrays 1024x512 cada uno. La memoria está organizada en 1 rank de 32 bancos.</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>El controlador de Memoria recibe una dirección física en el espacio lineal y lo mapea al espacio Rank/Bank/Row/Column</p></li><li><p>Se selecciona un número de rank:  (pej 1)</p></li><li><p>Se selecciona un número de banco entre 1 y 8: (pej 3)</p></li><li><p>Se selecciona una fila entre 1 y 1024: (pej 2)</p></li><li><p>Quedan seleccionadas todas las filas (pej fila 2) de todos los bancos (pej banco número 3) del mismo rank (pej rank número 1)</p></li><li><p>los datos (4 bits: b<sub>3</sub>b<sub>2</sub>b<sub>1</sub>b<sub>0</sub>) de todas las columnas (512 columnas)  de las filas seleccionadas (la <strong>fila 2</strong>)  del banco seleccionado (el <strong>banco 3</strong>) de cada chip ( chips) se descargan en el <strong>ROW-BUFFER</strong>.</p></li><li><p>Se selecciona un número de columna (pej 2)</p></li><li><p>Todas las columnas de orden 2 se descargan en los 4 bufferes i/o (uno de cada chip). Dato de 4bits/columna x 4chips = 16 bits</p></li><li><p>La salida de los 4 bufferes i/o (16bits) activan las líneas del bus de datos (16 hilos).</p></li></ol></div></li></ul></div>
<div class="imageblock" style="text-align: center"><img src="images/dram/row-buffer.png" alt="row buffer" /></div><div class="title">Figure 73. Page on Row-Buffer: Rank Nº1/Banco Nº3/Fila Nº2</div>
<h level="5">Precarga/OpenRow</h><div class="ulist"><ul><li><p>Fases:</p><div class="ulist"><ul><li><p>la dirección de memoria proporcionada por la CPU es convertida en dirección física por el circuito MMU</p></li><li><p>El circuito MP debe de descomponer la dirección física de memoria en los códigos:</p><div class="ulist"><ul><li><p>RANK-BANK-ROW-COLUMN</p></li><li><p>Los códigos están asociados a: dentro del módulo de memoria un rank específico, dentro del rank un bank específico, dentro del bank una fila específica y dentro de la fila una columna específica.</p></li></ul></div></li><li><p>Una vez que han sido identificados el rank-bank-row, se PRECARGAN los bit_lines del banco (se polarizan con la tensión media que hay entre un cero lógico y un uno lógico).</p></li><li><p>Una vez precargado el banco se ACTIVA (OPEN) la fila: la fila queda abierta cuando los miles de amplificadores sensores de carga detectan los contenidos de los miles de celdas de  las filas seleccionadas de todos los arrays del banco. La página esta abierta cuando las salidas de los amplificadores recuperan los valores sensados y activan las line_bit con los datos almacenados.</p><div class="ulist"><ul><li><p>Esta acción comienza con la activación de la señal /RAS y la espera del tiempo tRCD</p></li></ul></div></li><li><p>Una vez transcurrido el tRCD se selecciona las columnas específicas de todos los arrays del banco (x4,x8,..) y se carga el buffer i/o con el dato seleccionado.</p><div class="ulist"><ul><li><p>Esta acción comienza con la activación de la señal /CAS.</p></li></ul></div></li></ul></div></li></ul></div>
<h level="4">Ejemplo</h><div class="ulist"><ul><li><p>Si un sistema tiene una capacidad de memoria principal de 16GB y la estructuramos en 4 módulos cuyos chipsx16 se organizan en 4 ranks con 16 chips/rank, 8 bancos/chip, 16 arrays/banco. Calcular el número de bits/array.</p><div class="ulist"><ul><li><p>2<sup>4</sup> x 2<sup>30</sup> x 2<sup>3</sup> bits/byte = 2<sup>2</sup> (ranks/canal) x 2<sup>4</sup> (chips/rank) x 2<sup>3</sup> (bancos/chip) x 2<sup>4</sup> (array/banco)x N (bits/array) &#8594; N = 2<sup>(4+30+3-2-4-3-4)</sup> = 2^24 bits organizados en un array 2D</p></li></ul></div></li></ul></div>
<div class="admonitionblock note"><table><tr><td class="icon"><i class="fa fa-info-circle" title="Note"></i></td><td class="content">Los 4 módulos al completo se organizan en 4 ranks</td></tr></table></div>
<div class="ulist"><ul><li><p>Una posible solución sería 2<sup>12</sup> filas x 2<sup>12</sup> columnas.</p></li><li><p>El buffer i/o de transferencia de datos al bus de memoria tiene el tamaño x16, es decir, 16 bits.</p></li></ul></div>
<h level="3">Organización avanzada de memorias DRAM</h><div class="ulist"><ul><li><p>Información detallada en el <a href="#apendice_organizacion_dram">Apéndice</a></p></li></ul></div>
<h level="4">SDRAM (Synchronous DRAM)</h><h level="5">Introducción</h><div class="ulist"><ul><li><p>El flanco del reloj es el patrón de comienzo y fin de las operaciones</p></li><li><p><strong>DDR (Double Data Rate)</strong></p><div class="ulist"><ul><li><p>Permite transferir el bit tanto en el flanco de <strong>bajada</strong> como de <strong>subida</strong> del reloj (<strong>doble bombeo</strong>)</p></li></ul></div></li><li><p>frecuencia del buffer i/o</p><div class="ulist"><ul><li><p>El buffer i/o de la memoria pude ir a frecuencias x2, x4 y x8 respecto de la frecuencia de acceso a la celda.</p></li><li><p><strong>Supercelda</strong> ó <strong>Macrocelda</strong>:Ahora una selección (fila,columna) de un array supone no la seleccion de 1 celda sino la de 2, 4 u 8 CELDAS del array.</p></li><li><p>DDR1: una macrocelda de 2<sup>1</sup> celdas &#8594; 2 celdas</p><div class="ulist"><ul><li><p>1ª Generación:  año 2000</p></li></ul></div></li><li><p>DDR2: una macrocelda de 2<sup>2</sup> celdas &#8594; 4 celdas</p><div class="ulist"><ul><li><p>2ª Generación:  año 2006</p></li></ul></div></li><li><p>DDR3: una macrocelda de 2<sup>3</sup> celdas &#8594; 8 celdas</p><div class="ulist"><ul><li><p>3ª Generación:  año 2011</p></li></ul></div></li><li><p>DDR4: una macrocelda de 2<sup>4</sup> celdas &#8594; 16 celdas</p><div class="ulist"><ul><li><p>4ª Generación:  año 2014</p></li></ul></div></li><li><p>DDR5: una macrocelda de 2<sup>5</sup> celdas &#8594; 32 celdas</p><div class="ulist"><ul><li><p>5ª Generación:  año 2020</p></li></ul></div></li></ul></div></li></ul></div>
<div class="imageblock" style="text-align: center"><img src="./images/dram/ddr1_frequency.png" alt="ddr1 frequency" /></div><div class="title">Figure 74. Velocidad de transferencia DDR</div>
<h level="5">Macroceldas &#8594; Buffer i/o</h><div class="ulist"><ul><li><p>Las celdas (condensadores) almacenan muy poco carga (picoculombios) y por lo tanto no se pueden conectar directamente al bus de direcciones, es necesario un amplificador o sensor de CARGA. A la salida de dicho amplificador está el registro ó registros (BUFFER) de entrad/salida i/o. Es decir, el contenido binario de las celdas se vuelca en el BUFFER I/O. El buffer i/o está hecho en una tecnología capaz de conducir las líneas del bus de DATOS de la placa base.</p></li><li><p>Cada bit de un registro i/o almacenaría el contenido de una única celda.  Por lo que para leer macroceldas son necesarios un registro por cada celda de la macrocelda. Se llama BUFFER al conjunto de registros. Una memoria DDR3 tendrá por lo tanto un buffer i/o de 8 Registros y en cada registro se almacena una palabra. Si el chip de la memoria es x16, en cada registros se almacenaran palabras de 16 bits.</p></li></ul></div>
<div class="admonitionblock important"><table><tr><td class="icon"><i class="fa fa-exclamation-circle" title="Important"></i></td><td class="content">Cuando programamos una instrucción como "movw sum,%ax", el controlador de memoria MC de una memoria DDR3 no se limita a leer sólo el dato sum de 2 bytes, sino que lee por lo menos 8 palabras consecutivas y las lee simultáneamente en un solo acceso depositándolas en el buffer i/o contectado al bus de datos.</td></tr></table></div>
<div class="ulist"><ul><li><p>El buffer i/o puede almacenar hasta una página de datos. El buffering permite que el dato a capturar ya esté en la salida de la memoria sin tener que acceder a las celdas. En definitiva, el buffer es una cache (copia) de las celdas próximas a los datos que están siendo capturados. De esta forma se reducen los tiempos de acceso a la memoria, ya que realmente sólo se está accediendo al buffer i/o.</p></li></ul></div>
<h level="5">Velocidad de transferencia</h><div class="ulist"><ul><li><p>BW (bits/s) = BF(ciclos/s)*CW(bits/channel)*TC(transferencias/ciclo)</p><div class="ulist"><ul><li><p>FE: Frecuencia efectiva: Frecuencia de las Transferencias</p></li><li><p>BF: Frecuencia del bus del sistema (próximo a 1GHz en el año 2000)</p></li><li><p>CW: número de bits del data bus del canal. Típicamente 64 bits (año 2000) &#8594; arquitectura x86-64</p></li><li><p>TC: en un ciclo del reloj del bus del sistema el número de transferencias. Típicamente 1 transferencia (flanco de subida) o 2 transferencias(flancos de subida y bajada) por ciclo del reloj del bus BF.</p></li><li><p>BW (bits/s) = frecuencia efectiva*anchura bus datos= 400MHz*2*64 = 51200*10~6 bits/s = 51.2Gbps = 6400 MBps &#8592; sistema decimal (habitual)</p></li><li><p>NC: número de celdas/macrocelda</p></li><li><p>CA: frecuencia de acceso a las celdas = FE/NC</p></li></ul></div></li></ul></div>
<div class="imageblock" style="text-align: center"><img src="./images/dram/clock.png" alt="clock" /></div><div class="title">Figure 75. Velocidad de transferencia</div>
<h level="4">Ejemplo de módulo de Memoria:  PC2-6400 (DDR2-800) 5-5-5-16</h><div class="ulist"><ul><li><p>Módulo PC2-6400 (DDR2-800) 5-5-5-16</p></li><li><p>PC2 : SDRAM de segunda generación &#8594; Double_Data_Rate x2 &#8594; macroceldas de 4 celdas.</p></li><li><p>6400 MB/s de <strong>ancho de banda</strong> ó <strong>througput</strong> &#8594; BW= 6400 MB/s</p></li><li><p>FE=800MHz de ciclo efectivo de reloj del bus del sistema: doble que la frecuencia de bus BF &#8594; 800MHz=2*BF</p><div class="ulist"><ul><li><p>DDR: en cada ciclo BF se realizan dos transferencias &#8594; TC=2</p></li><li><p>Cada palabra de 64 bits se transfiere en un ciclo de 800MHz &#8594; CW=800MHz</p></li><li><p>Ciclo de Reloj del Bus de memoria BF=800MHz/2 &#8594; BF=400MHz</p></li><li><p>Clock cycle time = 1/400MHz = 2.5ns</p></li></ul></div></li><li><p>5-5-5-16 son los <strong>ciclos de reloj</strong> (400MHz&#8592;&#8594;2.5ns) de los tiempos tCL-tRCD-tRP-tRAS &#8594; 12.5ns-12.5ns-12.5ns-40ns</p></li><li><p>DDR2 &#8594; NC=2<sup>2</sup> &#8594; 4 celdas por macrocelda</p><div class="ulist"><ul><li><p>CA=FE/NC=800MHz/4=200MHz &#8594; frecuenica de acceso a las macroceldas</p></li></ul></div></li></ul></div>
<div class="imageblock" style="text-align: center"><img src="./images/dram/ddr2_frequency.png" alt="ddr2 frequency" /></div><div class="title">Figure 76. Velocidad de transferencia DDR2</div>
<h level="4">Ejemplo de módulo de Memoria: DDR3-800 / PC3-6400 5-5-5</h><div class="ulist"><ul><li><p>módulo de memoria DDR3-800 ó PC3-6400</p><div class="ulist"><ul><li><p>timing 5-5-5</p></li><li><p>800MHz es la frecuencia efectiva del bus de datos &#8594; 800MT/s</p></li><li><p>6400 MB/s es el ancho de banda</p></li><li><p>DDR &#8594; La frecuencia del bus de memoria es la mita de la frecuencia efectiva = 800/2 = 400MHz. Equivale a un ciclo de reloj  de 1/400MHz = 2.5ns</p></li><li><p>5-5-5: son los ciclos de reloj, a la frecuencia real del bus de 400MHz, de los parámetros timing tCL-tRCD-tRP</p></li></ul></div></li></ul></div>
<div class="imageblock" style="text-align: center"><img src="./images/dram/ddr3_frequency.png" alt="ddr3 frequency" /></div><div class="title">Figure 77. Velocidad de transferencia DDR3</div>
<table class="tableblock frame-topbot grid-all" style="width:100%"><caption class="title">Table 13. DDR3</caption><colgroup><col style="width:11.1111%" /><col style="width:11.1111%" /><col style="width:11.1111%" /><col style="width:11.1111%" /><col style="width:11.1111%" /><col style="width:11.1111%" /><col style="width:11.1111%" /><col style="width:11.1111%" /><col style="width:11.1112%" /></colgroup><thead><tr><th class="tableblock halign-left valign-top">Standard name</th><th class="tableblock halign-left valign-top">Memory clock(MHz)</th><th class="tableblock halign-left valign-top">Cycle time(ns)</th><th class="tableblock halign-left valign-top">I/O bus clock(MHz)</th><th class="tableblock halign-left valign-top">Data rate(MT/s)</th><th class="tableblock halign-left valign-top">Module name</th><th class="tableblock halign-left valign-top">Peak transfer rate(MB/s)</th><th class="tableblock halign-left valign-top">Timings(CL-tRCD-tRP)</th><th class="tableblock halign-left valign-top">CAS latency(ns)</th></tr><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>DDR3-800D</code></p></td><td class="tableblock halign-left valign-top" rowspan="2"><p class="tableblock"><code>100</code></p></td><td class="tableblock halign-left valign-top" rowspan="2"><p class="tableblock"><code>10</code></p></td><td class="tableblock halign-left valign-top" rowspan="2"><p class="tableblock"><code>400</code></p></td><td class="tableblock halign-left valign-top" rowspan="2"><p class="tableblock"><code>800</code></p></td><td class="tableblock halign-left valign-top" rowspan="2"><p class="tableblock"><code>PC3-6400</code></p></td><td class="tableblock halign-left valign-top" rowspan="2"><p class="tableblock"><code>6400</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>5-5-5</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>12½</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>DDR3-800E</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>6-6-6</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>15 </code></p></td></tr></table>
<div class="paragraph"><p>El 4º dígito es tRAS (mínimo retardo entre la activación y la precarga) no ha sido proporcionado. La cuarta columna proporciona tCL en nanosegundos.</p></div>
<div class="ulist"><ul><li><p>Parámetros:</p><div class="ulist"><ul><li><p>Memory clock: 100MHz: frecuencia de acceso a las palabras. Transferencia celda &#8594; buffer i/o</p></li><li><p>Cycle time: 10ns: en esta tabla se refiere  al período del memory clock y no tiene el significado de la definición de ciclo de memoria</p></li><li><p>I/O bus clock: 400MHz:reloj del bus de memoria cuyos flancos(positivo,negativo) sincronizan las transferencias de las palabras.</p><div class="ulist"><ul><li><p>ciclo de bus = 1/400Mhz = 2.5ns = este es el facto de tiempo de los retardos o latencias tCL,tRCD, etc</p></li></ul></div></li><li><p>Data rate: 800MT/s &#8594; Las transferencias se realizan a la frecuencia efectiva.</p></li><li><p>Peak transfer rate: ancho de banda BW:6400MB/s</p></li><li><p>timings: número de ciclos del reloj i/o bus clock de duración de los eventos:5-5-5-12½</p><div class="ulist"><ul><li><p>tCL = 5 ciclos de reloj = 5 x 2.5 = 12.5ns</p></li><li><p>tRCD = 5 ciclos de reloj = 5 x 2.5 = 12.5ns</p></li><li><p>tRP = 5 ciclos de reloj = 5 x 2.5 = 12.5ns</p></li><li><p>tRAS = no se ha proporcionado</p></li></ul></div></li></ul></div></li></ul></div>
<h level="4">Ejemplo PC3-22400 11-14-14-35</h><div class="ulist"><ul><li><p><a href="http://www.corsair.com/es-es/dominator-platinum-with-corsair-link-connector-1-65v-16gb-dual-channel-ddr3-memory-kit-cmd16gx3m4a2800c11">Dominator® Platinum with Corsair Link Connector — 1.65V 16GB Dual Channel DDR3 Memory Kit (CMD16GX3M4A2800C11)</a>:</p></li><li><p>Memory Type: DDR3</p></li><li><p>Speed Rating: PC3-22400 (2800MHz)</p></li><li><p>Tested Latency: 11-14-14-35</p></li><li><p>Our Price:80€</p></li><li><p>16GB Kit (4 x 4GB)</p></li><li><p>Dual Channel</p></li><li><p>Características deducidas:</p><div class="ulist"><ul><li><p>Ancho de banda de pico = 22400MB/s</p></li><li><p>Data rate (1data=8Bytes) = 2800MT/s</p></li><li><p>I/O bus effective clock = 2800MHz. I/O hace referencia al bus del buffer i/o de la memoria.</p></li><li><p>I/O bus clock = 2800MHz / 2 = 1400MHz</p></li><li><p>I/O bus cycle time= 1/1400MHz = 710ps</p></li><li><p>Latencies</p><div class="ulist"><ul><li><p>tCL  = 11 ciclos = 11 x 710ps = 7.8ns</p></li><li><p>tRCD = 14 ciclos = 14 x 710ps = 10ns</p></li><li><p>tRP  = 14 ciclos = 14 x 710ps = 10ns</p></li><li><p>tRAS = 35 ciclos = 35 x 710ps = 24.8ns</p></li></ul></div></li></ul></div></li><li><p>Mejora PC3-22400 vs PC3-6400</p><div class="ulist"><ul><li><p>Mejora del I/O bus cycle time = 710ps frente a 2.5ns = una reducción de 1.79ns = 1.79/2.5 = 71%</p></li></ul></div></li></ul></div>
<h level="4">Diferencia entre PC2-6400 y PC3-6400</h><div class="ulist"><ul><li><p>No ha diferencias en cuanto a latencias ya que un 5-5-5 en los dos casos se refiere a una frecuencia del bus de memoria de 400MHz.</p></li><li><p>Hay diferencias en cuanto a pines, tensión de alimentación, etc</p></li></ul></div>
<h level="4">Anchos de banda standard</h><div class="ulist"><ul><li><p>Módulos DDR1 SDRAM: PC-3200/PC-2700/PC-2100/PC-1600</p></li><li><p>Módulos DDR2 SDRAM: PC2-6400/PC2-5300/PC2-4200/PC2-3200</p></li><li><p>Módulos DDR3 SDRAM:</p><div class="ulist"><ul><li><p>PC3-22400/PC3-21300/PC3-19200/PC3-17066/PC3-15000/PC3-12800/PC3-10600/PC3-8500/PC3-6400</p></li><li><p>DDR3-2800/DDR3-2666/DDR3-2400/DDR3-2133/DDR3-1866/DDR3-1600/DDR3-1325/DDR3-1065/DDR3-800/</p></li></ul></div></li></ul></div>
<h level="4">Capacidad</h><h level="5">Registered/Buffered Memory</h><div class="ulist"><ul><li><p><a href="http://en.wikipedia.org/wiki/Registered_memory" class="bare">http://en.wikipedia.org/wiki/Registered_memory</a></p></li><li><p>Registered: RDIMM: Entre el controlador de memoria y el módulo de memoria hay un registro que memoriza la info de las líneas de control. Se manda el comando de control previamente a la transferencia, añadiendo un ciclo extra de bus. De esta forma se eliminan las líneas de control para la transferencia de comandos al controlador y así se disminuye la carga del bus de memoria del controlador de memoria y se consigue conectar más módulos al canal del controlador aumentando la capacidad de memoria.</p></li><li><p>Unbuffered: UDIMM: No se latchea las info de la líneas de control.</p></li><li><p>fully buffered:</p><div class="ulist"><ul><li><p>Se registra tanto la info de las señales de control como de las señales de datos y direcciones con una reducción considerable de la carga de todos los buses del canal del controlador de memoria.</p></li><li><p>Los datos se transfieren en serie en lugar de en paralelo reduciendo el número de líneas y por lo tanto aumentando el número de módulos de memoria conectados al canal.</p></li></ul></div></li></ul></div>
<h level="4">Bank Switching</h><div class="ulist"><ul><li><p><a href="https://en.wikipedia.org/wiki/Bank_switching">Bank Switching</a></p><div class="ulist"><ul><li><p>En arquitecturas limitadas de 8 y 16 bits (Por ejemplo intel 4004) se utiliza la técnica <em>memory banking</em> para aumentar la capacidad de memoria.</p></li><li><p>En lugar de incrementar anchura del bus de direcciones incrementando el tamaño de palabra de la CPU y el bus de la placa base, se añaden más dispositivos de memoria direccionables mediante el mismo bus y un nuevo registro que selecciona uno de los dispositivos de memoria (Bank). <strong>No confundir</strong> con los bancos de los chips de memoria ni con los bancos de registros.</p></li><li><p>Bank switching significa cambiar de banco de memoria.</p></li></ul></div></li></ul></div>
<h level="3">Info complementaria</h><div class="ulist"><ul><li><p>Información complementaria en el <a href="#apendice_organizacion_dram">Apéndice</a>.</p></li></ul></div>
<h level="3">Thinkpad T560</h><h level="4">comandos</h><div class="ulist"><ul><li><p>listado</p><div class="listingblock"><div class="content"><pre>sudo lshw -short -C memory
sudo lshw -class memory
lspci | grep -i mem -&gt; memory controller -&gt; chipset
sudo inxi -m
sudo cpu-x
sudo dmidecode -t memory
sudo dmidecode -t 16
lsmem
free
cat /proc/meminfo
 https://access.redhat.com/solutions/406773</pre></div></div></li></ul></div>
<h level="4">análisis</h><div class="ulist"><ul><li><p><code>sudo dmidecode -t 17</code></p><div class="listingblock"><div class="content"><pre>  DDR3
  Transfer rate 1600 MT/s
  channel A
  channel B
  bank locator bank0
  bank locator bank2
  SODIMM DDR3 Synchronous 1600 MHz (0,6 ns)
  -bank:0 -&gt; slot: ChannelA-DIMM0
  -bank:2 -&gt; slot: ChannelB-DIMM0</pre></div></div>
<div class="ulist"><ul><li><p>slot: A memory slot is each individual plug for memory</p></li><li><p>bank: A bank, is just a grouping of memory slots</p></li><li><p>channel: A channel is a memory bus that is dedicated for data to travel from the CPU to the RAM modules</p></li></ul></div></li><li><p><code>sudo hwinfo | grep -i mem -A 10</code></p></li></ul></div></div></section><section id="_memoria_cache"><h2>9.4. Memoria Cache</h2><div class="slide-content"><h level="3">Bibliografia</h><div class="ulist"><ul><li><p>Libro William Stalling</p><div class="ulist"><ul><li><p>Capítulo 4.</p></li></ul></div></li></ul></div>
<h level="3">Introducción</h><div class="ulist"><ul><li><p>Objetivo</p><div class="ulist"><ul><li><p>Principio de Localidad: Espacial y Temporal</p></li></ul></div></li><li><p>Ejercicio: Tiempo de acceso (probabilidad fallo ó exito)</p></li><li><p>Tecnología: 6T</p></li><li><p>Estructura</p><div class="ulist"><ul><li><p>Controladora: función</p></li></ul></div></li><li><p>Espacios de direcciones</p><div class="ulist"><ul><li><p>memoria principal</p></li><li><p>memoria cache</p></li></ul></div></li><li><p>Funciones de correspondencia entre espacios de direcciones:</p><div class="ulist"><ul><li><p>Mapeo Directo</p></li><li><p>Asociación total</p></li><li><p>Asociación por conjuntos</p></li></ul></div></li></ul></div>
<h level="3">Principios Basicos</h><h level="4">Tecnologia</h><div class="ulist"><ul><li><p>Cell: SRAM-6T</p></li></ul></div>
<div class="imageblock text-center" style="text-align: center"><img src="images/cache/sram_cell_6T.png" alt="sram cell 6T" /></div><div class="title">Figure 78. SRAM-cell</div>
<h level="4">Funcionalidad</h><div class="ulist"><ul><li><p>Cuello de Botella von Neumann: la latencia del ciclo de instrucción es mucho menor que la latencia de acceso a la memoria principal &#8594; tiempos muertos de la CPU.</p></li><li><p>Memoria Cache:</p><div class="ulist"><ul><li><p>Integrada en la CPU con tiempos de accesos un orden de magnitud menor que la memoria DRAM.</p></li><li><p>Es la Copia de regiones o bloques de la memoria principal.</p></li><li><p>Acierto-Fallo: Si la instrucción/dato a la que apunta la dirección de memoria principal DRAM está en la memoria caché, la cpu captura la instrucción o dato de la Memoria caché interna a la cpu cuyo tiempo de acceso es mucho menor que la memoria externa DRAM.</p></li><li><p>Hit-Miss</p></li><li><p>Ejemplo 4.1 del libro</p></li></ul></div></li><li><p>Principio de Localidad</p><div class="ulist"><ul><li><p>Espacial: bucles, subrutinas, arrays &#8594; almacenamiento de instrucciones y datos en direcciones próximas.</p></li><li><p>Temporal: histórico &#8594; secuencia de acceso a datos e instrucciones en direcciones próximas.</p></li></ul></div></li></ul></div>
<h level="4">Jerarquía</h><div class="ulist"><ul><li><p>Niveles de Cache</p><div class="ulist"><ul><li><p>Level L1: Interna a la CPU : SRAM : memorias separadas para instrucciones y memoria para datos</p></li><li><p>Level L2: Externa/Interna a la CPU:</p></li><li><p>Level L3: Externa a la CPU</p></li></ul></div></li></ul></div>
<div class="imageblock" style="text-align: center"><img src="./images/cache/cache_levels.jpg" alt="cache levels" /></div><div class="title">Figure 79. 3 Levels</div>
<div class="ulist"><ul><li><p>Para aumentar la velocidad de conmutación de los transistores de las celdas de la memoria SRAM caché es necesario incrementar la corriente que circula por ellos y para ello es necesario aumentar el tamaño de dichos transistores, consumiendo más superficie de Silicio. Esta es una de las limitaciones de la capacidad de la memoria de alta velocidad a unas de decenas de Kbytes. Para mejorar esta limitación surgen los distintos niveles a distintas velocidades, siendo el nivel L1 el de mayor velocidad. Los nivels L2 y L3 de menor velocidad están fabricados con transistores de menor tamaño permitiendo aumentar su capacidad al orde de los Mbytes.</p></li></ul></div>
<h level="4">Interconexion</h><div class="ulist"><ul><li><p>En serie CPU&#8594;L1&#8594;L2&#8594;L3&#8594;SDRAM</p></li><li><p>CPU&#8594;L : transferencia de Palabras</p></li><li><p>L&#8594;SDRAM: bloques</p></li></ul></div>
<div class="imageblock" style="text-align: center"><img src="./images/cache/cache_cpu_dram.png" alt="cache cpu dram" /></div><div class="title">Figure 80. Interconexión</div>
<div class="imageblock" style="text-align: center"><img src="./images/cache/cache_cpu_dram_connection.png" alt="cache cpu dram connection" /></div><div class="title">Figure 81. Interconexión</div>
<div class="imageblock" style="text-align: center"><img src="./images/cache/cache_mmu_dram.png" alt="cache mmu dram" /></div><div class="title">Figure 82. MMU</div>
<h level="4">Estructura Cache/Principal</h><div class="imageblock" style="text-align: center"><img src="./images/cache/cache_dram_block.png" alt="cache dram block" /></div><div class="title">Figure 83. Estructura de agrupamiento</div>
<div class="ulist"><ul><li><p>Cache: bytes &#8594; palabras &#8594; líneas</p></li><li><p>MP: bytes &#8594; palabras &#8594; bloques</p></li><li><p>Se copian bloques de la Memoria Principal en líneas de la Memoria Caché, por lo que, el tamaño de un bloque y de una línea es el mismo.</p></li></ul></div>
<h level="5">Principal</h><div class="ulist"><ul><li><p>Dirección: n bits : bus de direcciones del sistema &#8594;Capacidad=2<sup>n</sup> palabras &#8594; OJO: no bytes</p></li><li><p>Direccionable: palabras : bus de datos del sistema</p></li><li><p>Organizada en Bloques de K palabras</p></li><li><p>Número de bloques : Capacidad en palabras / K</p></li></ul></div>
<h level="5">Cache</h><div class="ulist"><ul><li><p>Dirección: Nº de Línea y Palabra</p></li><li><p>Direccionable: Palabra</p></li><li><p>Capacidad: C Líneas</p></li><li><p>Organizada en Líneas de K palabras y 1 etiqueta</p></li><li><p>Etiqueta: Asociación Línea con Bloque de la Memoria Principal</p></li></ul></div>
<h level="4">Operacion de Lectura</h><div class="imageblock"><img src="./images/cache/cache_read_operation.png" alt="[align="center"" /></div><div class="title">Figure 84. Read Operation (RA: Read Address)</div>
<div class="ulist"><ul><li><p>Organigrama de operaciones</p></li><li><p>Controladora de la Caché</p></li></ul></div>
<h level="3">Elementos de Diseño de la Cache</h><div class="ulist"><ul><li><p>Elementos:</p><div class="ulist"><ul><li><p>Tamaño de la Caché, Función de Correspondencia, Algoritmos de Sustitución, Política de Escritura, Tamaño de Línea, Número de Cachés</p></li></ul></div></li></ul></div>
<h level="4">Tamaño</h><div class="ulist"><ul><li><p>Contradicción: Cuanto más grande más lenta y más probabilidades de acierto.</p></li><li><p>L1: KB</p></li><li><p>L2: MB</p></li><li><p>L3: MB</p></li></ul></div>
<h level="4">Funcion de Correspondencia Memoria_Principal/Memoria_Caché</h><div class="ulist"><ul><li><p>Distintas formas de asociar los bloques de la Memoria Principal con las líneas de la Memoria Caché.</p></li><li><p>Tipos de correspondencia Bloque &lt;&#8594; Línea:</p><div class="ulist"><ul><li><p>Directa (Direct mapping), Totalmente Asociativa (Full associative), Asociativa en Grupo (Set associative)</p></li></ul></div></li></ul></div>
<h level="5">Ejemplo</h><div class="ulist"><ul><li><p>Libro W.Stalling. Capítulo 4. Ejemplo 4.2</p></li><li><p>Ejemplo para los 3 casos:</p><div class="ulist"><ul><li><p><em>m</em>:caché de capacidad 64 KB= 4*2<sup>14</sup> bytes</p></li><li><p>MP :</p><div class="ulist"><ul><li><p>word size : 1 byte</p></li><li><p>palabras/bloque = 4.</p></li><li><p>capacidad = 16MB = 2<sup>24</sup>bytes= 2<sup>24</sup>bytes / (4bytes/bloque)= 2<sup>22</sup> bloques = 4M bloques</p></li></ul></div></li></ul></div></li><li><p>La capacidad <em>m</em> de la caché = 4*2<sup>14</sup> bytes / (4bytes/línea) = 2<sup>14</sup> líneas = 16K líneas</p></li><li><p>Como un bloque de la MP equivale a un línea de la Caché &#8594; La relación de capacidad caché/MP es 16K/4M = 1/(2<sup>8</sup>)</p></li></ul></div>
<h level="5">Asociación Directa</h><div class="ulist"><ul><li><p>Estructura de direcciones</p><div class="ulist"><ul><li><p>Memoria principal : bloques de palabras</p></li><li><p>Memoria cache : líneas de palabras</p></li><li><p>El tamaño de un bloque de la memoria principal es el mismo que el tamaño de una línea de la Caché.</p></li></ul></div></li><li><p>Función de correspondecia de la controladora de la Caché:</p><div class="ulist"><ul><li><p>determinista - ningún grado de libertad en la elección de la línea correspondiente a un bloque determinado.</p></li><li><p>el <strong>campo de línea</strong> de la dirección de memoria principal apunta a la única línea de la Caché donde puede estar la palabra que busca la controladora. Si el <strong>campo tag</strong> de la dirección de memoria principal coincide con el campo tag de la línea de la Caché, significa que la palabra buscada está en esa línea y puede ser capturada de la línea caché ya que es una copia del bloque de la memoria principal, se dice que ha habido un "hit". En caso de fallo ("miss") habrá que capturar la palabra de la Memoria Principal, por lo que la latencia será la suma del tiempo empleado en comprobación del tag más el de accesso a la palabra de la memoria principal.</p></li></ul></div></li></ul></div>
<div class="imageblock"><img src="./images/cache/cache_directmap.png" alt="[align="center"" /></div><div class="title">Figure 85. Direct Map Structure</div>
<div class="ulist"><ul><li><p>i: número de línea de caché</p></li><li><p>j: número de bloque de la memoria principal</p></li><li><p>m: número de líneas en la caché</p></li><li><p>Función de correspondencia</p><div class="ulist"><ul><li><p>i = j módulo m</p></li></ul></div></li><li><p>Organización de la caché</p><div class="ulist"><ul><li><p>Memoria_Caché/Controladora_Caché/Memoria_Principal</p><div class="imageblock"><img src="./images/cache/cache_directmap_controller.png" alt="[align="center"" /></div><div class="title">Figure 86. Direct Map Controller</div></li></ul></div></li><li><p>Formato de direcciones</p><div class="ulist"><ul><li><p>Dirección física de la memoria principal: bloque-palabra</p></li><li><p>Dirección física de la memoria cache: tag-línea-palabra</p></li></ul></div></li><li><p>Operación de búsqueda de una palabra en la memoria caché.</p><div class="ulist"><ul><li><p>Determinar los campos de etiqueta, línea y palabra del formato de direcciones de la memoria caché.</p></li><li><p>La palabra pudiera estar en únicamente en la línea asignada, por lo que es necesario comparar únicamente la etiqueta de dicha línea con la etiqueta del formato de direcciones.</p></li></ul></div></li><li><p>Ejemplo 4.2</p><div class="ulist"><ul><li><p>Apartado a)</p></li><li><p>Formato de la dirección de memoria en campos:</p><div class="listingblock"><div class="content"><pre>2^2^ palabras -&gt; campo palabra de 2 bits
2^14^ líneas  -&gt; campo de línea de 14 bis
resto de bits (24-14-2)=8 -&gt; campo de etiqueta de 8 bits</pre></div></div></li><li><p>&#8230;&#8203;continuar</p></li></ul></div></li></ul></div>
<h level="5">Totalmente Asociativa</h><div class="imageblock"><img src="./images/cache/cache_fullassociative_controller.png" alt="[align="center"" /></div><div class="title">Figure 87. "Full Associative Controller!</div>
<div class="ulist"><ul><li><p>La correspondencia totalmente asociativa significa que no hay correspondencia</p><div class="ulist"><ul><li><p>NO HAY NORMA &#8594; CADA BLOQUE DE MP PUEDE SER ASIGNADA A CUALQUIER LINEA DE LA CACHE</p></li><li><p>LIBRE: un bloque de MP no tiene asignada ninguna línea específica y el controlador cache puede seleccionar qué línea será asignada a dicho bloque.</p></li></ul></div></li><li><p>La dirección de memoria tiene únicamente dos campos</p><div class="ulist"><ul><li><p>s bits= etiqueta: orden del bloque de MP : desde 1 hasta 4M.</p></li><li><p>w bits= orden de la palabra dentro del bloque: desde 1 hasta 4.</p></li></ul></div></li><li><p>controlador de caché</p><div class="ulist"><ul><li><p>todas las etiquetas de las líneas de caché son SIMULTANEAMENTE comparadas con la etiqueta de la palabra referenciada.</p><div class="ulist"><ul><li><p>en caso de éxito, s apunta a la línea que contiene la palabra referenciada y w apunta a la palabra referenciada.</p></li><li><p>en caso de fracaso, s apunta al bloque de la MP que contiene la palabra referenciada y w apunta a la palabra referenciada.</p></li></ul></div></li></ul></div></li><li><p>Formato de direcciones</p><div class="ulist"><ul><li><p>Dirección física de la memoria principal: bloque-palabra</p></li><li><p>Dirección física de la memoria cache: tag-palabra</p></li></ul></div></li><li><p>Operación de búsqueda de una palabra en la memoria caché.</p><div class="ulist"><ul><li><p>Determinar los campos de etiqueta y palabra del formato de direcciones de la memoria caché.</p></li><li><p>La palabra puede estar en cualquier línea, por lo que es necesario comparar las etiquetas de todas las líneas</p></li></ul></div></li><li><p>Diferencia con el mapeo directo:</p><div class="ulist"><ul><li><p>el campo de etiqueta tiene s bits &gt;&gt; s-r bits</p></li><li><p>la comparación es entre todas las etiquetas (etiquetas de gran longitud) &#8594; hardware complejo &#8594; coste</p></li><li><p>Ejemplo 4.2 : Formato de la dirección de memoria en campos:</p><div class="listingblock"><div class="content"><pre>2^2^ palabras -&gt; campo palabra de 2 bits
resto de bits (24-2)=22 -&gt; campo de etiqueta de 22 bits</pre></div></div></li><li><p>&#8230;&#8203;continuar</p></li></ul></div></li></ul></div>
<h level="5">Asociativa por Conjuntos</h><div class="imageblock"><img src="./images/cache/cache_setassociative.png" alt="Set Associative" /></div>
<div class="ulist"><ul><li><p>compromiso entre el rigor de la correspondencia directa y la flexibilidad de la correspondencia totalmente asociativa.</p><div class="ulist"><ul><li><p>La dirección de memoria tiene 3 campos:TAG-SET-WORD &#8594; (s-d-w)/d/w</p><div class="ulist"><ul><li><p>k líneas por conjunto.</p></li><li><p>w bits : orden de la palabra. Con 2<sup>w</sup> palabras formo un bloque</p></li><li><p>d bits :</p><div class="ulist"><ul><li><p>CONJUNTO de bloques o SET de bloques o SUPERbloque o SUPERlínea.</p></li><li><p>d &lt; l :dividimos la cache en v superbloques.</p></li><li><p>Con v=2<sup>d</sup> superbloques de k líneas/bloque formo la memoria cache.</p></li><li><p>Al número k de líneas de cada superbloque se le denomina VIA (WAY)</p></li></ul></div></li></ul></div></li><li><p>estructura de la MP:  queda dividida en bloques y superbloques.</p><div class="ulist"><ul><li><p>2<sup>s</sup> es el número de bloques de la MP,  que si los agrupo en sets de k bloques tendré en la MP 2<sup>t</sup> agrupamientos de 2<sup>d</sup> sets cada uno &#8594;
2<sup>s</sup>*2<sup>w</sup> = 2<sup>t</sup>*2<sup>d</sup>*k*2<sup>w</sup> &#8594; 2<sup>s</sup>=2<sup>t</sup>*2<sup>d</sup>*k &#8594; Nº de bloques en MP = Nº de gruposX*Nºsets en la Caché*Líneas en el Set</p></li><li><p>s-d bits: nº de bits de la etiqueta</p></li></ul></div></li><li><p>función de correspondencia</p><div class="ulist"><ul><li><p>i = j modulo v &#8594; NORMA SEMIRIGIDA: CADA BLOQUE TIENE ASIGNADO UN CONJUNTO ESPECIFICO DE LINEAS PERO NO TIENE ASIGNADA LA LINEA DENTRO DEL CONJUNTO</p></li><li><p>donde <em>v</em> es el número de superbloques, <em>j</em> es el número de bloque en MP e <em>i</em> el número de superbloque en la caché.</p></li><li><p>dentro del superbloque <em>i</em> hay flexibilidad para asignarle una de las líneas o vías dentro del superbloque.</p></li></ul></div></li></ul></div></li><li><p>número de vías</p><div class="ulist"><ul><li><p>si el número de vías fuese 1 no habría ninguna libertad de asignación y estaríamos en el caso de correspondencia directa</p></li><li><p>si el número de vías fuese 2 habría lago de libertad ya que habría que elegir una línea a sustituir de dos líneas posibles.</p></li><li><p>si el número de vías fuese la capacidad de la caché el grado de libertad sería máximo, a sustituir una línea de m posibles.</p></li></ul></div></li></ul></div>
<div class="imageblock"><img src="./images/cache/cache_setassociative_controller.png" alt="[align="center"" /></div><div class="title">Figure 88. Set Associative Controller</div>
<div class="ulist"><ul><li><p>Formato de direcciones</p><div class="ulist"><ul><li><p>Dirección física de la memoria principal: bloque-palabra</p></li><li><p>Dirección física de la memoria cache: tag-set-palabra</p></li></ul></div></li><li><p>Operación de búsqueda de una palabra en la memoria caché.</p><div class="ulist"><ul><li><p>Determinar los campos de etiqueta y set del formato de direcciones de la memoria caché.</p></li><li><p>La palabra puede estar en cualquier línea pero únicamente del set asignado, por lo que es necesario comparar las etiquetas únicamente de las líneas de dicho set.</p></li></ul></div></li><li><p>Ejemplo 4.2 : sets con 2 vías</p><div class="ulist"><ul><li><p>Formato de la dirección de memoria en campos:</p><div class="listingblock"><div class="content"><pre>2^2^ palabras -&gt; campo palabra de 2 bits
k=2
El número de Sets en la caché -&gt; m / k = 2^14^/2 = 2^13^ conjuntos en la Caché -&gt; d=13 bits
Etiqueta : resto de bits = (24-13-2)= 9 bits</pre></div></div></li><li><p>&#8230;&#8203;continuar</p></li></ul></div></li></ul></div>
<h level="5">Comparativa de los 3 tipos de funciones</h><div class="ulist"><ul><li><p>En la función de correspondencia de mapeo directo no hay ninguna libertada a la hora de seleccionar la línea de la cache, esta viene determinada por la función de correspencia. En el caso de función asociativa total la libertad es total pudiendo elegir la línea a ocupar siguiendo criterios estadísticos, etc. En el caso de función asociativa por conjuntos no hay ninguna libertad en la asignación del conjunto de líneas determinado por la función pero sí en la elección de la línea dentro del conjunto asignado por la función.</p></li><li><p>Los dos primeros casos, mapeo directo y asociativa total, son los casos extremos de la asociativa por conjuntos:</p><div class="ulist"><ul><li><p>Asociativa por conjuntos con un set de una línea sería el caso de mapeo directo</p></li><li><p>Asociativa por conjuntos con un set de todas las líneas de la caché sería el caso de asociativa total</p></li></ul></div></li></ul></div>
<div class="imageblock"><img src="./images/cache/cache_assoc_size.png" alt="[align="center"" /></div><div class="title">Figure 89. Probabilidad de éxito en función del tamaño y la función de asociación</div>
<h level="3">Políticas</h><h level="4">Reemplazo</h><div class="ulist"><ul><li><p>La política de reemplazo de la controladora de la caché es según la cual cuando se produce un "miss" se tiene que seleccionar un línea de la caché para ser eliminada de la caché y dejar sitio al bloque capturado de la memoria principal. La política más popular es la  <strong>least-recently used (LRU)</strong> según la cual se descartan primero los elementos menos usados recientemente</p></li></ul></div>
<h level="4">Escritura</h><div class="ulist"><ul><li><p>Al igual que con la Lectura, con la Escritura la CPU escribe en la Caché, por lo que el contenido de la línea donde se ha realizado la escritura no coincide con el bloque asociado en la Memoria Principal. La política de Escritura consiste en especificar cuando se realiza la copia de la línea de la cache y los bloques de memoria asociados con diferente contenido. La política <strong>Write-Back</strong> consiste en realizar la actualización o copia en el momento en el que se va a descartar dicha línea según la política de Reemplazo.</p></li></ul></div>
<h level="3">Ejemplo de Optimización</h><h level="4">Producto Matricial</h><div class="ulist"><ul><li><p><a href="https://johnnysswlab.com/make-your-programs-run-faster-by-better-using-the-data-cache/" class="bare">https://johnnysswlab.com/make-your-programs-run-faster-by-better-using-the-data-cache/</a></p><div class="ulist"><ul><li><p>El producto matricial en lenguaje C implementado mediante un bucle que accede a los Arrays de datos es un ejemplo de cómo tener en cuenta la organización de la memoria Caché a la hora de programar el algoritmo. En el ejemplo se ve la técnica "loop interchange" para modificar el orden de captura de los elementos de los arrays.</p></li></ul></div></li></ul></div>
<h level="3">Thinkpad L560</h><div class="ulist"><ul><li><p><code>cpuid | more</code></p><div class="listingblock"><div class="content"><pre>  --- cache 0 ---
      cache type                           = data cache (1)
      cache level                          = 0x1 (1)
      ways of associativity                = 0x8 (8)
      number of sets                       = 0x40 (64)
      (size synth)                         = 32768 (32 KB)
      ¿tamaño de línea?                    32KB=2^15^Bytes= 64sets x 8líneas/set x n_bytes/línea=512*n=2^9^*n -&gt; n=2^6^=64Bytes
      Mode: 0x01 (Write Back)
 --- cache 1 ---
      cache type                           = instruction cache (2)
      cache level                          = 0x1 (1)
      ways of associativity                = 0x8 (8)
      number of sets                       = 0x40 (64)
      (size synth)                         = 32768 (32 KB)
      Mode: 0x01 (Write Back)
--- cache 2 ---
      cache type                           = unified cache (3)
      cache level                          = 0x2 (2)
      ways of associativity                = 0x4 (4)
      number of sets                       = 0x400 (1024)
      (size synth)                         = 262144 (256 KB)
      ¿tamaño de línea?                    256KB=2^18^Bytes= 1024sets x 4líneas/set x n_bytes/línea=2^12^*n -&gt; n=2^6^=64Bytes
      --- cache 3 ---
      cache type                           = unified cache (3)
      cache level                          = 0x3 (3)
      ways of associativity                = 0xc (12)
      number of sets                       = 0x1000 (4096)
      (size synth)                         = 3145728 (3 MB)</pre></div></div></li><li><p><code>getconf LEVEL1_DCACHE_LINESIZE</code></p></li><li><p><code>getconf LEVELTABTAB</code></p></li><li><p><code>sudo hwinfo | grep -i cache -A 10</code></p></li><li><p><code>sudo dmidecode -t 17</code></p><div class="ulist"><ul><li><p>cache &#8594; write-back instruction</p></li></ul></div></li></ul></div></div></section><section id="_memoria_virtual"><h2>9.5. Memoria Virtual</h2><div class="slide-content"><h level="3">Introducción</h><div class="ulist"><ul><li><p>Información detallada se puede consultar en el <a href="#apendice_memvirtual">Apéndice</a></p></li><li><p>La memoria virtual se estudia detalladamente en la asignatura de Sistemas Operativos, por lo que aquí únicamente se van a recordar un par de ideas fundamentales.</p></li></ul></div>
<h level="3">Punto de vista del Programador y CPU</h><div class="ulist"><ul><li><p>Cuando el programador programa en el lenguaje ensamblador, cuando se trabaja con el debugger, etc y se visualizan direcciones de memoria, dichas direcciones de memoria pertenecen al espacio de direcciones VIRTUAL, no al espacio de direcciones físico.</p></li><li><p>De la misma forma la CPU opera con direcciones virtuales. Por ejemplo el contador de programa trabaja con direcciones virtuales</p><div class="ulist"><ul><li><p>Por ello es necesario un circuito hardware que traduzca direcciones virtuales a direcciones físicas y se las entregue al controlador de memoria MC. Dicho traductor hardware se denomina Memory Managment Unit (MMU).</p></li></ul></div></li></ul></div>
<h level="3">Espacio virtual de direcciones de memoria</h><div class="ulist"><ul><li><p>El compilador, linker, etc cuando traducen lenguajes de programación de alto nivel como el lenguaje C o bajo nivel como el lenguaje ASM, etc y lo convierten en lenguaje máquina tienen que asignar direcciones de memoria a las instrucciones, variables, estructuras de datos, punteros, etc.. Está asignación se realiza de forma totalmente libre, sin tener en cuenta la memoria física de la computadora. Se asignan direcciones de forma abstracta, es decir, como si fuesen las entradas de una tabla donde el contenido de la tabla son las instrucciones y los datos.</p></li></ul></div>
<h level="3">Organización lógica de un programa en lenguaje máquina: Secciones y Segmentos</h><div class="ulist"><ul><li><p>Información sobre las secciones (data,text,rodata&#8230;&#8203;) y los segmentos (código, datos, pila, heap ) en el <a href="#apendice_segmentos_secciones">Apéndice</a></p></li><li><p>La organización lógica de los módulos de los programas en secciones y de un programa/proceso en segmentos facilita la traducción (compilador, linker, ensamblador) y también la asignación de memoria virtual al proceso.</p></li></ul></div></div></section></section></div></section>
<section id="_iii_ejercicios_de_teoría"><h2>III Ejercicios de Teoría</h2><div class="slide-content"><section><section id="_ejercicios_3"><h2>10. Ejercicios</h2></section><section id="ejercicios"><h2>10.1. Lista de Ejercicios Mínima</h2><div class="slide-content"><h level="3">Parte I</h><div class="ulist"><ul><li><p>El siguiente listado selecciona un número de ejercicios mínimo que hay que realizar:</p><div class="listingblock"><div class="content"><pre>1. Arquitectura de Von Neumann: 1.1,1.2,1.3,1.4,1.6,2.1,2.2,2.3
2. Representación de los datos: 2,3,4,5
3. Operaciones Aritméticas: 2,5,8,10
4. Operaciones Lógicas: 1,2,3
5. Representación de las instrucciones:1,2,5,7,9,15,16
6. Programación en Ensamblador: 1.1,2.1,2,2</pre></div></div></li></ul></div>
<h level="3">Parte II</h><div class="ulist"><ul><li><p>El siguiente listado selecciona un número de ejercicios mínimo que hay que realizar:</p><div class="listingblock"><div class="content"><pre>1. Arquitectura de Von Neumann: 2.5,2.6
7. CPU: 12.4,12.9,12.11,13.4
8. Memoria: DRAM (Ejemplos del tema de teoría), Cache (1,2,3,4,5,)
9. Entrada/Salida:</pre></div></div></li></ul></div></div></section><section id="_arquitectura_von_neumann_3"><h2>10.2. Arquitectura von Neumann</h2><div class="slide-content"><h level="3">Computadoras: IAS, ENIAC, ..</h><div class="olist arabic"><ol class="arabic"><li><p>You are to write an IAS program to compute the results of the following equation.
 Y = Sum{X} para X=1 hasta X=N. Assume that the result of the computation does not arithmetic overflow and that X, Y,
and N are positive integers with N &gt; 1. Note: The IAS did not have assembly language only machine language.</p><div class="olist loweralpha"><ol class="loweralpha"><li><p>Use the equation <strong>Sum(Y)= N(N+1)/2</strong> when writing the IAS program. Comentar los conceptos de: datos, instrucciones, memoria principal, registros, secciones, operación, operando, campo de operaciones, campo de operando, dirección de memoria, contenido de memoria, referencia al operando, operando implicito, direccionamiento del operando, direccionamiento directo del operando, código binario, código hexadecimal, código de operación, código del campo de operando. Ejecutar el programa fuente con el emulador IASSIm.</p><div class="ulist"><ul><li><p>Desarrollo:</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-nasm" data-lang="nasm">; Suma de los primeros N numeros enteros. Y=N(N+1)/2
; CPU IAS
; lenguaje ensamblador: simaulador IASSim
; Ejercicio 2.1 del libro de William Stalling, Estructura de Computadores


; El algoritmo que seguimos es : primero la suma N+1, a continuación la multiplicación N(N+1) y finalmente la división. Cada resultado se guarda en la memoria principal si fuera necesario.

; Describimos el programa en 4 lenguajes: lenguaje ensamblador iassim, lenguaje máquina binario, lenguaje RTL y lenguaje ensamblador WStalling

; SECCION DE INSTRUCCIONES
 S(x)-&gt;Ac+ n    ;        01 n   ;        AC    &lt;- M[n]      ;LOAD   M(n)
 S(x)-&gt;Ah+ uno  ;        05 uno ;        AC    &lt;- AC+1      ;ADD    M(uno)
 At-&gt;S(x) y     ;        11 y   ;        M[y]  &lt;- AC        ;STORE  M(y)
 S(x)-&gt;R y      ;        09 y   ;        AR    &lt;- M[y]      ;LOAD   MQ,M(y)
 S(x)*R-&gt;A n    ;        0B n   ;        AC:AR &lt;- AR*M[n]   ;MUL    M(n)
 R-&gt;A           ;        0A     ;        AC    &lt;- AR        ;LOAD   MQ
 A/S(x)-&gt;R dos  ;        0C 2   ;        AR    &lt;- AC/2      ;DIV    M(dos)
 R-&gt;A           ;        0A     ;        AC    &lt;- AR        ;LOAD   MQ
 At-&gt;S(x) y     ;        11 y   ;        M[y]  &lt;- AC        ;STORE  y
 halt
; como el número de instrucciones  es par no es necesaria la directiva .empty


; SECCION DE DATOS
; Declaracion e inicializacion de variables
y:     .data 0  ;resultado

; Declaracion de las Constantes
n:    .data 5   ;parametro N
uno:  .data 1
dos:  .data 2</code></pre></div></div></li></ul></div></li><li><p>Do it the “hard way” without using the equation from part (a): \(\sum_{i=1}^{5}i\)</p><div class="ulist"><ul><li><p>Desarrollo:</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-nasm" data-lang="nasm">; adds up the values n+...+3+2+1(+0) in a loop and stores
; the sum in memory at the location labeled "sum"

loop:   S(x)-&gt;Ac+  n    ;load n into AC
        Cc-&gt;S(x)   pos  ;if AC &gt;= 0, jump to pos
        halt            ;otherwise done
        .empty          ;a 20-bit 0
pos:    S(x)-&gt;Ah+  sum  ;add n to the sum
        At-&gt;S(x)   sum  ;put total back at sum
        S(x)-&gt;Ac+  n    ;load n into AC
        S(x)-&gt;Ah-  one  ;decrement n
        At-&gt;S(x)   n    ;store decremented n
        Cu-&gt;S(x)   loop ;go back and do it again

n:     .data 5  ;will loop 6 times total
one:   .data 1  ;constant for decrementing n
sum:   .data 0  ;where the running/final total is kept</code></pre></div></div></li></ul></div></li></ol></div></li><li><p>On the IAS, what would the machine code instruction look like to load the contents of memory address 2 to the accumulator? How many trips to memory does the CPU need to make to complete this instruction during the instruction cycle?</p><div class="ulist"><ul><li><p>Desarrollo:</p><div class="ulist"><ul><li><p>0x01002: Código de Operación 01 y referencia al operando 002</p></li><li><p>Dos accesos a la memoria principal: captura de la instrucción y captura del operando</p></li></ul></div></li></ul></div></li><li><p>On the IAS, describe in English the process that the CPU must undertake to <strong>read</strong> a value from memory and to <strong>write</strong> a value to memory in terms of what is put into the MAR, MBR, address bus, data bus, and control bus.</p><div class="ulist"><ul><li><p>Desarrollo:</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-sh" data-lang="sh">Lectura
MAR         &lt;- address
Address Bus &lt;- MAR
Control Bus &lt;- Read
Data Bus    &lt;- Data
MBR         &lt;- Data Bus

Escritura
MAR         &lt;- address
Data Bus    &lt;- MBR
Control Bus &lt;- Write</code></pre></div></div>
<div class="ulist"><ul><li><p>A esta descripción del flujo de información se le denomina ruta de datos de la CPU.</p></li></ul></div></li></ul></div></li><li><p>Given the memory contents of the IAS computer shown below,</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-sh" data-lang="sh">Address Contents
08A 010FA110FB
08B 010FA0F08D
08C 020FA110FB</code></pre></div></div>
<div class="ulist"><ul><li><p>show the assembly language code for the program, starting at address 08A. Explain what this program does.</p></li><li><p>Desarrollo:</p><table class="tableblock frame-all grid-all" style="width:100%"><colgroup><col style="width:16.6666%" /><col style="width:16.6666%" /><col style="width:16.6666%" /><col style="width:16.6666%" /><col style="width:16.6666%" /><col style="width:16.667%" /></colgroup><thead><tr><th class="tableblock halign-left valign-top">Address</th><th class="tableblock halign-left valign-top">Contents</th><th class="tableblock halign-left valign-top" colspan="2">RTL</th><th class="tableblock halign-left valign-top" colspan="2">Instructions</th></tr><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock">08A</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">010FA110FB</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">AC&#8592;M[0FA]</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">M[0FB]&#8592;AC</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">LOAD  M[0FA]</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">STORE M[0FB]</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">08B</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">010FA0F08D</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">AC&#8592;M[0FA]</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">AC&gt;0:PC &#8592; 0x08D(0:19)</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">LOAD  M[0FA]</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">JMP   +M[08D(0:19)]</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">08C</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">020FA110FB</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">AC&#8592;-M[0FA]</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">M[0FB]&#8592;AC</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">LOAD -M[0FA]</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">STORE M[0FB]</p></td></tr></table>
<div class="ulist"><ul><li><p>Contents: instrucción izda 010FA (Cod Op 01 Address 0FA) e instrucción dcha 110FB -</p></li><li><p>A este proceso inverso a ensamblar (lenguaje ensamblador &#8594; código binario) se le denomina desensamblar (código binario &#8594; lenguaje ensamblador)</p></li></ul></div></li><li><p>El programa realiza la siguiente función:</p><div class="ulist"><ul><li><p>Si el contenido de 0x0FA es positivo copia el contenido de memoria de la posición 0x0FA a la posición 0xFB y salta a la posición 0x08D, dejando en el acumulador el contenido de 0xFA. Si el contenido de 0x0FA es negativo  copia el contenido de memoria de la posición 0x0FA a la posición 0xFB cambiado de signo y salta a la posición 0x08D, dejando en el acumulador el contenido de 0xFA en positivo, es decir, el módulo.</p></li></ul></div></li></ul></div></li><li><p>Indicate the width, in bits, of each data path (e.g., between AC and ALU) of IAS microarchitecture.</p><div class="ulist"><ul><li><p>Desarrollo:</p><div class="ulist"><ul><li><p>AC, AR y MBR  40 bits</p></li><li><p>IBR 20 bits</p></li><li><p>MAR y PC 12 bits</p></li><li><p>IR 8 bits</p></li></ul></div></li></ul></div></li><li><p>Considerar una computadora con las siguientes instrucciones:</p><table class="tableblock frame-all grid-all" style="width:50%"><colgroup><col style="width:50%" /><col style="width:50%" /></colgroup><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Código de Operación</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Descripción</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>0001</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Load AC from memory</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>0010</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Store AC to memory</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>0101</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Add to AC from memory</code></p></td></tr></table>
<div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Describir las fases de los ciclos de instrucción de la CPU al ejecutar dicho programa teniendo en cuenta la siguiente figura:</p><div class="imageblock" style="text-align: center"><img src="./images/ejercicios/ciclo_instruccion_1.png" alt="ciclo instruccion 1" /></div><div class="title">Figure 90. Ciclos de Instrucción</div></li><li><p>¿Cuál es el formato de instrucciones? ¿ Cuál es el tamaño de los registros contador de programa y registro de instrucciones? ¿Cuál es el tamaño del bus de datos y del bus de direcciones?</p></li></ol></div></li><li><p>The ENIAC was a <strong>decimal machine</strong>, where a register was represented by a ring of 10 vacuum tubes. At any time, only one vacuum tube was in the ON state, representing one of the 10 digits. Assuming that ENIAC had the capability to have multiple vacuum tubes in the ON and OFF state simultaneously, why is this representation “wasteful” and what range of integer values could we represent using the 10 vacuum tubes?</p><div class="ulist"><ul><li><p>Desarrollo: Con 10 tubos únicamente podemos representar los digitos 0-9</p></li></ul></div></li><li><p>A benchmark program is run on a 40 MHz processor. The executed program consists
of 100,000 instruction executions, with the following instruction mix and clock cycle
count:</p><table class="tableblock frame-all grid-all" style="width:80%"><colgroup><col style="width:33.3333%" /><col style="width:33.3333%" /><col style="width:33.3334%" /></colgroup><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Instruction_Type</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Instruction_Count</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Cycles_per_Instruction</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Integer_arithmetic</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">45,000</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">data_transfer</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">32,000</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Floating_point</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">15,000</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Control_transfer</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">8000</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td></tr></table>
<div class="ulist"><ul><li><p>Determine the effective CPI, MIPS rate, and execution time for this program.</p></li><li><p>Desarrollo:</p><div class="ulist"><ul><li><p>Reloj de la CPU</p><div class="listingblock"><div class="content"><pre>          T = 1/f
&lt;--------------------&gt;

               +-----+               +-----+               +-----+               +-----+
               |     |               |     |               |     |               |     |
               |     |               |     |               |     |               |     |
               |     |               |     |               |     |               |     |
               |     v               |     v               |     |               |     |
               |     |               |     |               |     |               |     |
               |     |               |     |               |     |               |     |
               |     |               |     |               |     |               |     |
+--------------+     +---------------+     +---------------+     +---------------+     +</pre></div></div></li><li><p>T=1/f= 25ns: ciclo del reloj de la CPU: duración mínima de una microoperación.</p></li><li><p>CPI: ciclos por instrucción: valor medio = 1*(45/100)+2*(32/100)+2*(15/100)+2*(8/100)=0,45+0,64+0,30+0,16=1.55 cpi</p></li><li><p>MIPS: Millones de Inst. por seg: (1/CPI)(inst/ciclo)* F_clock(ciclos/seg)*10<sup>-6</sup>=(1/1.55)*40*10<sup>6</sup>*10<sup>-6</sup>=25.8 mips</p></li><li><p>T=(1/MIPS)(seg/millones de instr)*100.000*10<sup>-6</sup>=3.87ms</p></li></ul></div></li></ul></div></li></ol></div>
<h level="3">Interconexión CPU-Memoria</h><div class="olist arabic"><ol class="arabic"><li><p>Consider a hypothetical microprocessor generating a 16-bit address (for example, assume
that the program counter and the address registers are 16 bits wide) and having
a 16-bit data bus.</p><div class="olist loweralpha"><ol class="loweralpha"><li><p>What is the maximum memory address space that the processor can access directly
if it is connected to a “16-bit memory”?</p></li><li><p>What is the maximum memory address space that the processor can access directly
if it is connected to an “8-bit memory”?</p></li><li><p>What architectural features will allow this microprocessor to access a separate
“I/O space”?
many 8-bit I/O ports can the microprocessor support? How many 16-bit I/O
ports? Explain.</p><div class="ulist"><ul><li><p>Tener en cuenta que:</p><div class="ulist"><ul><li><p>Espacio de  direcciones: conjunto de direcciones de un mismo bus de direcciones. La capacidad se expresa en BYTES.</p></li><li><p>El Espacio Memoria Principal y el Espacio Controlador E/S son espacios <strong>diferentes</strong>. Comparten el <strong>mismo bus de direcciones</strong> del bus del sistema pero hay una señal de control que activa la conexión con la memoria principal o con el controlador E/S.</p></li><li><p>"16 bit memory": 16 bits word size . Data bus de 16 bits</p></li><li><p>"8 bit memory": 8 bits word size . Data bus de 16 bits</p></li><li><p>I/O port number: numero de puertos del controlador E/S. Cada puerto para un periférico. Se diferencia el puerto de entrada del puerto de salida. 8 bit I/O port es un puerto con un data buffer de 8 bits y un 16 bit I/O port es un puerto con un data buffer de 16 bits.</p></li></ul></div></li><li><p>Desarrollo:</p><div class="ulist"><ul><li><p>Dibujar el esquema de buses que visualice:</p><div class="ulist"><ul><li><p>las interconexiones entre periféricos, puertos, controlador E/S, memoria principal, CPU, buses indicando el modo de operación con cada uno de los buses.</p><div class="listingblock"><div class="content"><pre>|
.
.
.
.
.
.
.
.
.
.</pre></div></div></li></ul></div></li><li><p>a)2<sup>16</sup>Bytes. 64KB. En el bus de datos se transfieren datos de dos bytes.</p></li><li><p>b)2<sup>16</sup>Bytes. 64KB. En el bus de datos se transfieren datos de un byte.</p></li><li><p>c)En el bus del sistema hace falta una señal de control : señal I/O</p></li><li><p>d) 2<sup>8</sup>= Direccionamiento de 256 puertos de entrada y 256 puertos de salida en el controlador E/S independientemente del tamaño del buffer I/O si es de 8 bits o 16 bits.</p></li></ul></div></li></ul></div></li></ol></div></li><li><p>Consider a 32-bit microprocessor, with a 16-bit external data bus, driven by an  8-MHz input clock. Assume that this microprocessor has a bus cycle whose minimum duration equals four input clock cycles. What is the maximum data transfer rate across the bus that this microprocessor can sustain, in bytes/s? To increase its performance, would it be better to make its external data bus 32 bits or to double the external clock frequency supplied to the microprocessor? State any other assumptions you make, and explain. Hint: Determine the number of bytes that can be transferred per bus cycle.</p><div class="ulist"><ul><li><p>Desarrollo:</p><div class="ulist"><ul><li><p>32-bit CPU : tamaño de los registros internos de la CPU. Bus de datos local (interno) de la CPU</p></li><li><p>16-bit external data bus: bus de datos del sistema</p></li><li><p>CPU input clock: 8MHz</p></li><li><p>bus cycle: ciclo del bus del sistema: duración 4 veces el de la CPU : 2 MHz.</p></li><li><p>a) Data transfer rate: teóricamente número de datos en la secuencia continua de una transferencia cada <em>bus cycle</em> durante 1 segundo: 2MTransferencias/s. Cada transferencia el bus de datos transfiere 16 bits, es decir, 2 bytes = 2M/s*2B = 4MB/s</p></li><li><p>b) Doblar el ancho del bus de datos, dobla el ancho de banda &#8594; 8MB/s</p></li><li><p>c) Doblar la frecuencia de reloj reduce proporcionalmente el ciclo de bus y dobla el ancho de banda &#8594; 8MB/s</p></li></ul></div></li></ul></div></li><li><p>Consider two microprocessors having 8- and 16-bit-wide external data buses, respectively. The two processors are identical otherwise and their bus cycles take just as long.</p><div class="olist loweralpha"><ol class="loweralpha"><li><p>Suppose all instructions and operands are two bytes long. By what factor do the
maximum data transfer rates differ?</p></li><li><p>Repeat assuming that half of the operands and instructions are one byte long.</p><div class="ulist"><ul><li><p>Desarrollo:</p><div class="ulist"><ul><li><p>a) CPU1 de 8 bits tiene un ancho de banda mitad (50%) respecto de CPU2 de 16 bits</p></li><li><p>b1) CPU1: 50% de 2 bytes a 2 ciclos de bus por cada 2 bytes y el otro 50% de 1 byte en 1 ciclo por byte =2ciclos*50%+1ciclo*50%=1.5ciclos</p></li><li><p>b2) CPU2: 50% de 2 bytes a 1 ciclo de bus por cada 2 bytes y el otro 50% de 1 byte a 1 ciclo de bus (unicamente se puede acceder a una instrucción o un dato en cada ciclo de bus)=1ciclo*50%+1ciclos*50%=0.5+0.5=1ciclos</p></li><li><p>b) según b1 y b2 la CPU1 tiene un ancho de banda 150% menor que la CPU2, es decir, el 66.6% del CPU2.</p></li></ul></div></li></ul></div></li></ol></div></li><li><p>A microprocessor has an increment memory direct instruction, which adds 1 to the value in a memory location. The instruction has five stages: fetch opcode (four bus clock cycles), fetch operand address (three cycles), fetch operand (three cycles), add 1 to operand (three cycles), and store operand (three cycles).</p><div class="olist loweralpha"><ol class="loweralpha"><li><p>By what amount (in percent) will the duration of the instruction increase if we
have to insert two bus wait states in each memory read and memory write
operation?</p></li><li><p>Repeat assuming that the increment operation takes 13 cycles instead of 3 cycles.</p><div class="ulist"><ul><li><p>Desarrollo:</p><div class="ulist"><ul><li><p>instruction cycle: 4+3+3+3+3= 16ciclos</p></li><li><p>a) accesos a memoria en las 3 etapas fetch y en la etapa store &#8594; incremento de 2*4 ciclos de espera &#8594; incremento de 8/16 &#8594; un incremento del 50%</p></li><li><p>b) instruction cycle:4+3+3+13+3= 26ciclos &#8594; incremento del ciclo de instruccion en un  8/26 &#8594; incremento en 34%</p></li></ul></div></li></ul></div></li></ol></div></li><li><p>The Intel 8088 microprocessor has a read bus timing similar to that of Figure 3.19, but requires four processor clock cycles. The valid data is on the bus for an amount of time that extends into the fourth processor clock cycle. Assume a processor clock rate of 8 MHz.</p><div class="imageblock" style="text-align: center"><img src="./images/ejercicios/memoria_rw_sync.png" alt="memoria rw sync" /></div><div class="title">Figure 91. Cronograma de una operación Read/Write de la Memoria Principal</div>
<div class="olist loweralpha"><ol class="loweralpha"><li><p>What is the maximum data transfer rate?</p></li><li><p>Repeat but assume the need to insert one wait state per byte transferred.</p><div class="ulist"><ul><li><p>Desarrollo:</p><div class="ulist"><ul><li><p>8088: bus data: 1 byte</p></li><li><p>read time : 4 cpu cycles</p></li><li><p>data valid: 1 processor clock cycle. El cuarto ciclo del read time.</p></li><li><p>cpu clock: 8MHz</p></li><li><p>a) 4 ciclos por transferencia. 8MHz/4ciclos = 2MT/s = 1 byte por transferencia &#8594; 2MB/s</p></li><li><p>b) cada transferencia está un ciclo sin transferir (4,1) &#8594; throughput = 4/5 del máximo &#8594; (4/5)*2MB/s&#8594;1.6MB/s</p></li></ul></div></li></ul></div></li></ol></div></li><li><p>The Intel 8086 is a 16-bit processor similar in many ways to the 8-bit 8088. The 8086 uses a 16-bit bus that can transfer 2 bytes at a time, provided that the lower-order byte has an even address. However, the 8086 allows both even- and odd-aligned word operands. If an odd-aligned word is referenced, two memory cycles, each consisting of four bus cycles, are required to transfer the word. Consider an instruction
on the 8086 that involves two 16-bit operands. How long does it take to fetch the operands? Give the range of possible answers. Assume a clocking rate of 4 MHz and no wait states</p><div class="ulist"><ul><li><p>Desarrollo:</p><div class="ulist"><ul><li><p>8086: bus data: 2 bytes</p></li><li><p>intel : little endian: el LSB byte se guarda en la dirección menor y el MSB byte en la dirección superior.</p></li><li><p>alineación del dato par requiere 1 ciclo de memoria.</p></li><li><p>palabras con alineación impar requieren 2 ciclos de memoria. Cada ciclo de memoria son 4 ciclos de bus.</p></li><li><p>instrucción de 2 operandos de 2 bytes cada uno. CPU clock de 4MHz &#8594; 0.250 microsegundos &#8594; 250 ns</p></li><li><p>a) los dos operandos tienen alineación par</p><div class="ulist"><ul><li><p>1 ciclo de memoria cada operando: 2 ciclos de memoria: 8 ciclos de bus &#8594; 2 microsegundos</p></li></ul></div></li><li><p>b) un operando tiene alineación par y el otro impar</p><div class="ulist"><ul><li><p>1 ciclo de memoria el par y 2 ciclos el impar: 3 ciclos de memoria: 12 ciclos de bus &#8594; 3 microsegundos</p></li></ul></div></li><li><p>c) los dos operandos tienen alineación impar</p><div class="ulist"><ul><li><p>2 ciclos cada operando: 4 ciclos de memoria: 16 ciclos de bus &#8594; 4 microsegundos.</p></li></ul></div></li></ul></div></li></ul></div></li><li><p>Consider a 32-bit microprocessor whose bus cycle is the same duration as that of a 16-bit microprocessor. Assume that, on average, 20% of the operands and instructions are 32 bits long, 40% are 16 bits long, and 40% are only 8 bits long. Calculate the improvement achieved when fetching instructions and operands with the 32-bit microprocessor.</p><div class="ulist"><ul><li><p>Desarrollo</p><div class="ulist"><ul><li><p>En cada flanco positivo del ciclo de bus se realiza una transferencia entre memoria y CPU. La cpu de 16 bits realiza una transferencia de 2 bytes o menos y el de 32 bits una transferencia de 4 bytes o menos.</p></li><li><p>Media ciclos (CPU 16 bits)= 0.2x(2ciclos para las dos transferencias de 2 bytes cada una)+0.4x1+0.4x1=1.2 ciclos de media</p></li><li><p>Media ciclos (CPU 32 bits)= 0.2x1+0.4x1+0.4x1=1ciclo de media</p></li><li><p>Mejora de (1.2-1) sobre 1.2 = (1.2-1)/1.2=17%</p></li></ul></div></li></ul></div></li></ol></div></div></section><section id="_representación_de_datos"><h2>10.3. Representación de Datos</h2><div class="slide-content"><div class="olist arabic"><ol class="arabic"><li><p>Representar el número decimal 1197 en las bases:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Hexadecimal</p><div class="listingblock"><div class="content"><pre>Divisiones sucesivas por 16
0x4AD</pre></div></div></li><li><p>octal:</p><div class="listingblock"><div class="content"><pre>Divisiones sucesivas por 8
0o2255</pre></div></div></li><li><p>binaria:</p><div class="listingblock"><div class="content"><pre>Divisiones sucesivas por 2
0b10010101101</pre></div></div></li><li><p>Representar el número 0x4AD en base binaria y base octal mediante una conversión directa, sin calcular su valor.</p></li></ol></div></li><li><p>Representar el número -1197 en base binaria y hexadecimal y en formato:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Signo-magnitud:  0b110010101101 &#8594; 0xCAD</p></li><li><p>Complemento a 2: 0b101101010011 &#8594; 0xB53</p></li></ol></div></li><li><p>Calcular el rango de los números enteros de 8 bits en complemento a 2. (2<sup>7</sup>-1,-2<sup>7</sup>)</p></li><li><p>Utilizar notación hexadecimal:</p><div class="olist loweralpha"><ol class="loweralpha"><li><p>Representar el valor 23 en el formato BCD..</p><div class="ulist"><ul><li><p>En el formato Binary Code Decimal (BCD) cada  dígito decimal se expande independientemente en su código binario de 4 bits</p></li><li><p>2&#8594;0010 ; 3&#8594;0011 ; 23 &#8594; 0010-0011</p></li></ul></div></li><li><p>The ASCII characters 23</p><div class="ulist"><ul><li><p>0x32-0x33 &#8594; 0011-0010-0011-0011</p></li></ul></div></li></ol></div></li><li><p>Escribir el carácter <strong>a</strong> con acento <strong>á</strong> en el código universal UTF-8 (hexadecimal), en el código Unicode(U+XXXX), en ascii extendido e iso-8859-1 consultando el enlace <a href="https://charset.org/utf-8">UTF-8</a>, los manuales: man ascii, man iso-8859-1,  y el comando <code>showkey -a</code> &#8594; teclear <strong>á</strong></p></li><li><p>For each of the following packed decimal numbers, show the decimal value</p><div class="olist loweralpha"><ol class="loweralpha"><li><p>0111 0011 0000 1001</p><div class="ulist"><ul><li><p>7309</p></li></ul></div></li><li><p>0101 1000 0010</p><div class="ulist"><ul><li><p>582</p></li></ul></div></li><li><p>0100 1010 0110</p><div class="ulist"><ul><li><p>No es posible ya que 1010 corresponde al valor 10 que no tiene un digito decimal sino dos.</p></li></ul></div></li></ol></div></li><li><p>(NO hacer) Another representation of binary integers that is sometimes encountered is ones complement. Positive integers are represented in the same way as sign magnitude.A negative integer is represented by taking the Boolean complement of each bit of the corresponding positive number. Note: Ones complement arithmetic disappeared from hardware in the 1960s, but still survives checksum calculations for the Internet Protocol (IP) and the Transmission Control Protocol (TCP).</p><div class="olist loweralpha"><ol class="loweralpha"><li><p>Provide a definition of ones complement numbers using a weighted sum of bits.</p><div class="ulist"><ul><li><p>Poner ejemplos de conversión con n=3 bits</p><div class="ulist"><ul><li><p>000&#8594;111 (luego el cero tiene dos representaciones), <em>+1</em>: 001&#8594; <em>-1</em>:110, <em>+2</em>:010&#8594;'-2':101, <em>+1</em>:011&#8594;'-3':100</p></li></ul></div></li><li><p>positivos con n bits&#8594; \(\sum_{i=0}^{n-1}b_i 2^i\).</p></li><li><p>negativos con n bits</p><div class="ulist"><ul><li><p>Tenemos en cuenta que complemento a dos = complemento_a_1 <em>+</em> 1</p></li><li><p>el complemento a dos con n bits de X se puede calcular como la resta binaria 2<sup>n</sup> (en binario) - X : por ejemplo con 3 bits el complemento a dos de <em>+1</em> es 1000-1=111</p></li><li><p>el complemento a 1 es el complemento a 2 menos 1 &#8594; 2<sup>n</sup> -X -1. Por ejemplo con 3 bits el complemento a uno de <em>+1</em> 1000-1-1 = 110</p></li></ul></div></li></ul></div></li><li><p>What is the range of numbers that can be represented in ones complement with n bits?</p><div class="ulist"><ul><li><p>El máximo positivo &#8594; <em>011__1</em> :  2<sup>n</sup>-1</p></li><li><p>El máximo negativo &#8594; <em>100__0</em> : -(2<sup>n</sup>-1)</p></li></ul></div></li></ol></div></li><li><p>Representar 0.56789 en binario utilizando multiplicaciones sucesivas</p><div class="listingblock"><div class="content"><pre>0.56789 * 2 = 1.13578 = 1 + 0.13578 -&gt; 1, bit de la posición -1
0.13578 * 2 = 0.27156 -&gt; 0, bit de la posición -2
0.27156 * 2 = 0.54312 -&gt; 0, bit de la posición -3
0.54312 * 2 = 1.08624 = 1 + 0.08624 -&gt; 1, bit de la posición -4</pre></div></div></li><li><p>Representar 0.0625 en binario sin utilizar multiplicaciones sucesivas.</p><div class="ulist"><ul><li><p>0.0625 = M*2<sup>E</sup> tal que E es un entero</p></li><li><p>log_dos(0.0625) =  log_dos(M)+E</p></li><li><p>-4 = log_dos(M)+E &#8594; E=-4 y log_dos(M)=0 &#8594; M=1</p></li></ul></div></li><li><p>Representar el número real 1234.56789 en base binaria:</p><div class="ulist"><ul><li><p>En formato coma fija</p><div class="listingblock"><div class="content"><pre>Parte Entera: 1234 : 10011010010
Parte Fracción: 0.56789: 0.100100010110000101
Número 1234.56789: 10011010010.100100010110000101</pre></div></div></li><li><p>En notación científica: 1.0011010010100100010110000101*2^+10</p></li><li><p>En precisión simple punto flotante:</p><div class="listingblock"><div class="content"><pre>Campo signo: + : 0
Campo Exponente (8 bits): 10+127 = 137 = 10001001
Campo fracción mantisa (23 bits)= 00110100101001000101100</pre></div></div></li><li><p>En precisión doble punto flotante:</p><div class="listingblock"><div class="content"><pre>Campo signo: + : 0
Campo Exponente (11 bits): 10+1023 = 1033 = 10000001001
Campo fracción mantisa (52 bits) = 00110100101001000101100001010__0</pre></div></div></li></ul></div></li><li><p>Codificar el número entero 3 en single precision FP</p><div class="ulist"><ul><li><p>3 = 11 = 1.1 2<sup>1</sup></p><div class="ulist"><ul><li><p>S=0, E=1+127=128, Mn=0.1</p></li><li><p>0-1000-0000-1000-0000-ceros</p></li><li><p>No es necesario redondear</p></li><li><p>Resultado= 0x40400000</p></li></ul></div></li></ul></div></li><li><p>Representar el número natural 123456789 en precisión simple Punto Flotante (IEEE-754)</p><div class="ulist"><ul><li><p>123456789 = 0x075BCD15 = 111-0101-1011-1100-1101-0001-0101 = 1.11010110111100110100010101*2<sup>+26</sup></p></li><li><p>Redondear= 1.11010110111100110100011*2<sup>+26</sup></p><div class="ulist"><ul><li><p>Campo Signo= 0</p></li><li><p>Campo Exp= 26+127=153=10011001</p></li><li><p>Campo fracción Mantisa=0.11010110111100110100011</p></li><li><p>Resultado 0x4CEB79A3</p></li></ul></div></li></ul></div></li><li><p>Float Point:</p><div class="olist loweralpha"><ol class="loweralpha"><li><p>Consider a fixed-point representation using decimal digits, in which the implied radix point can be in any position (e.g., to the right of the least significant digit, to the right of the most significant digit, and so on). How many decimal digits are needed to represent the approximations of both Planck’s (6.63 x 10<sup>-27</sup>) constant and Avogadro’s number (6.02 x 10<sup>23</sup>) The implied radix point must be in the same position for both numbers.</p><div class="ulist"><ul><li><p>para el número de planck hace falta correr la coma 27 posiciones  a la izda más los dos digitos a la derecha (63)  &#8594; fracción de 27 dígitos</p></li><li><p>para el número de avogrado hace falta correr la coma 23 posiciones a la dcha más el dígito de la izda (7) &#8594; parte entera de 24 dígitos</p></li><li><p>para los dos 29+24=53 dígitos</p></li></ul></div></li><li><p>Now consider a decimal floating-point format with the exponent stored in a biased representation with a bias of 50. A normalized representation is assumed. How many decimal digits are needed to represent these constants in this floating point format?</p><div class="ulist"><ul><li><p>planck &#8594; 0.63× 10<sup>-26</sup> &#8594; 0.63x 10<sup>-26+50</sup>&#8594; 0.63x 10<sup>+24</sup></p></li><li><p>avogrado &#8594;  0.602 x 10<sup>24</sup> &#8594; 0.602 x 10<sup>24+50</sup> &#8594; 0.602 x 10<sup>74</sup></p></li><li><p>para los dos hacen falta = 3 dígitos fraccíon y 2 dígitos para el exponente.</p></li></ul></div></li></ol></div></li><li><p>Any floating-point representation used in a computer can represent only certain real numbers exactly; all others must be approximated. If Ap is the stored value approximating the real value A, then the relative error, r, is expressed as r=(A-Ap)/A .Represent the decimal quantity <em>+0.4</em> in the following floating-point format: base=2 exponent: biased, 4 bits; significand, 7 bits.What is the relative error?</p><div class="ulist"><ul><li><p>En binario coma fija</p><div class="ulist"><ul><li><p>0.4x2=0.8 &#8594;0</p></li><li><p>0.8x2=1.6 &#8594;1</p></li><li><p>0.6x2=1.2 &#8594;1</p></li><li><p>0.2x2=0.4 &#8594;0</p></li><li><p>0.4x2 &#8594; otra vez 0110, luego es un número periódico &#8594; 0.0110-0110-0110-período</p></li><li><p>normalizado 1.10-0110-0110-etc x 2<sup>-1</sup> &#8594; se representa la fracción 10-0110-0110-</p></li><li><p>con fracción de 7 bits 1001100</p></li><li><p>Valor del número  aproximado 1.1001100 x 2<sup>-1</sup> = 110011 x 2<sup>-6</sup> = (32+16+2+1)x2<sup>-6</sup>=51/64=.796875</p></li><li><p>Error=(0.8-0.796875)/0.8=.003906250=0.4%</p></li><li><p>En exceso de 4 bits. Con el número excedido el rango es (0,15). El exceso es la mitad de combinaciones -1=16/2-1=7, luego se pueden representar los exponentes (-7,8).</p></li></ul></div></li></ul></div></li><li><p>Representar el número Pi en coma flotante IEEE de simple y doble precisión</p><div class="ulist"><ul><li><p>SOLUCION:</p></li><li><p>Formato decimal:  3.1415926535897932384626433832795028841968</p></li><li><p>Binario Coma fija : 11.001001000011111101101010100010001000010110100011000010001101001100010011000110011000101000101110000000110111</p></li><li><p>Hexadecimal Coma fija:   0011.0010-0100-0011-1111-0110-1010-1000-1000-1000-0101-1010-0011-0000-1000-1101-0011-0001-0011-0001-1001-1000-1010-0010-1110-0000-0011-0111</p><div class="ulist"><ul><li><p>3.243F6A8885A308D313198A2E03E</p><div class="listingblock"><div class="title">IEEE-754 precisión simple (32 bits)</div><div class="content"><pre>  1      8bits              23bits            &lt;-- tamaño en bits
 +-+-------------+-----------------------+
 |S|  Exp + 127  | Fracción Mantisa  Norm|
 +-+-------------+-----------------------+
 31 30         23 22                     0   &lt;-- índice del bit (0 a la derecha)
     +127</pre></div></div></li></ul></div></li><li><p>v = s × 2^e × m</p><div class="ulist"><ul><li><p>Notación científica con la mantisa normalizada y su parte fracción  truncada a 23 bits y redondeada:</p></li><li><p><em>+ (1 + 0.10010010000111111011011) * 2<sup>+1</sup></em></p></li></ul></div></li><li><p>Campos:</p><div class="ulist"><ul><li><p>Signo : positivo --&#8594;  0  --&#8594; 1 bit</p></li><li><p>Exponente:+1</p></li><li><p>Exponente desplazado <em>+ 127 = +1+127 = 128 &#8594; 10000000 &#8594; 8 bits</em></p></li><li><p>Mantisa normalizada:1 <em>+</em> 0.10010010000111111011011</p><div class="ulist"><ul><li><p>Fracción de la mantisa normalizada: 10010010000111111011011 &#8594; 23 bits</p><div class="listingblock"><div class="title">Formato IEEE-754  precisión simple</div><div class="content"><pre> +-+---------+------------------------+
 |0|10000000 | 10010010000111111011011|
 +-+---------+------------------------+
 31 30    23   22                    0</pre></div></div></li></ul></div></li></ul></div></li><li><p>Resultado= 0x40490fdb</p></li></ul></div></li></ol></div></div></section><section id="_operaciones_aritméticas_2"><h2>10.4. Operaciones Aritméticas</h2><div class="slide-content"><div class="olist arabic"><ol class="arabic"><li><p>Sumar en binario puro</p><div class="ulist"><ul><li><p>10011011+00011011  SOLUCION: = 10110110</p></li><li><p>0x3A1F+0xF4E1  SOLUCION: = 0x12f00</p></li><li><p>10011011+10011011  SOLUCION: = 100110110</p></li></ul></div></li><li><p>Sumar en complemento a 2 : 50+23</p><div class="ulist"><ul><li><p>Realizar las operaciones en código binario  SOLUCION: = 0110010+0010111 = 01001001</p></li><li><p>Realizar las operaciones en código hexadecimal  SOLUCION: = 0x32+0x17 = 0x49</p></li></ul></div></li><li><p>Representar el valor -66 en complemento a 2</p><div class="ulist"><ul><li><p>SOLUCION: <em>+66</em> = 01000010 &#8594; -66 = 10111101+1 = 10111110</p></li></ul></div></li><li><p>Resta en complemento a 2 : 33-66</p><div class="ulist"><ul><li><p>Realizar las operaciones en código binario:  SOLUCION: 0100001+10111110=1011111</p></li><li><p>Realizar las operaciones en código hexadecimal:  SOLUCION: 0x21+0xBE=0xDF</p></li></ul></div></li><li><p>Representar en hexadecimal el mayor número en módulo que se puede representar en complemento a 2 con 16 bits</p><div class="ulist"><ul><li><p>SOLUCION: 1000-0000-0000-0000 = 0x8000</p></li></ul></div></li><li><p>Sumar en complemento a 2 con 16 bits 0x8000+0x8000</p><div class="ulist"><ul><li><p>SOLUCION: 0x8000+0x8000=0x0000</p></li></ul></div></li><li><p>Restar en binario puro 0110010 - 0010111</p><div class="ulist"><ul><li><p>SOLUCION:</p><div class="listingblock"><div class="content"><pre>  0110010  &lt;- minuendo
  0010111  &lt;- sustraendo
    1111   &lt;- llevadas
  *******
  0011011</pre></div></div></li></ul></div></li><li><p>Restar en hexadecimal 0x32-0x17</p><div class="listingblock"><div class="content"><pre>   0x32  &lt;- minuendo
   0x17  &lt;- sustraendo
     1   &lt;- llevadas
  *****
   0x1B</pre></div></div></li><li><p>Multiplicación</p><div class="ulist"><ul><li><p>¿A qué equivale en base binaria multiplicar por una potencia de 2 positiva 2<sup>n</sup>? :</p><div class="ulist"><ul><li><p>SOLUCION:</p></li><li><p>en un número real mover la coma n posiciones hacia la dcha</p></li><li><p>en un número entero añadir n ceros a la dcha</p></li><li><p>en un registro es desplazar los bits n posiciones hacia la izda e introducir n ceros por la dcha</p></li></ul></div></li><li><p>¿A qué equivale en base binaria multiplicar por una potencia de 2 negativa 2<sup>-n</sup>? :</p><div class="ulist"><ul><li><p>SOLUCION:</p></li><li><p>en un número real mover la coma n posiciones hacia la izda</p></li><li><p>en un número entero añadir n ceros a la izda</p></li><li><p>en un registro es desplazar los bits n posiciones hacia la dcha e introducir n ceros por la izda</p></li></ul></div></li></ul></div></li><li><p>Realizar la multiplicación de los siguientes números naturales:</p><div class="ulist"><ul><li><p>1010*1010</p></li><li><p>1010*1111</p></li><li><p>SOLUCION:</p><div class="listingblock"><div class="content"><pre>                1010            1010
              x 1010          x 1111
            ********        ********
                0000            1010
               1010            1010
              0000            1010
             1010            1010
            ********        ********
             1100100        10010110</pre></div></div></li></ul></div></li></ol></div></div></section><section id="_operaciones_lógicas"><h2>10.5. Operaciones Lógicas</h2><div class="slide-content"><div class="olist arabic"><ol class="arabic"><li><p>Realizar las operaciones lógicas &#195;, &#195;+1, A+B, A&#183;B, A&#8853;B siendo A=10101010 y B=11110000</p><div class="ulist"><ul><li><p>SOLUCION:</p></li><li><p>A+B &#8594; A|B &#8594; AVB</p></li><li><p>A&#183;B  &#8594;  A&amp;B &#8594; A&#8743;B</p></li><li><p>&#195;        = 01010101</p></li><li><p>&#195;+1      = 01010110</p></li><li><p>A+B           = 11111010</p></li><li><p>A&#183;B      = 10100000</p></li><li><p>A&#8853;B     = 01011010</p></li></ul></div></li><li><p>Dado un operando de 20 bits, indicar la operación lógica a realizar para: (expresar la operación con los operandos en código hexadecimal)</p><div class="ulist"><ul><li><p>Set el bit 7 (posición 7ª)</p><div class="ulist"><ul><li><p>SOLUCION: 20 bits son 5 dígitos hex &#8594; Operando | 0x00080</p></li></ul></div></li><li><p>Clear el bit 15</p><div class="ulist"><ul><li><p>SOLUCION: Operando &amp; 0xF7FFF</p></li></ul></div></li><li><p>Toogle el bit 19</p><div class="ulist"><ul><li><p>SOLUCION:Operando &#8853; 0x8000</p></li></ul></div></li><li><p>Set toda la palabra</p><div class="ulist"><ul><li><p>SOLUCION: Operando | 0xFFFF</p></li></ul></div></li><li><p>Clear toda la palabra</p><div class="ulist"><ul><li><p>SOLUCION:Operando &#8853; Operando ó Operando &amp; 0x00000</p></li></ul></div></li></ul></div></li><li><p>Dadas las operaciones lógicas SAR X,n (shift arithmetic right X, n), SLR X,n (shift logic right X,n) , SAL X,n (shift arithmetic left X, n) y SLL X,n (shift logic left X, n) donde X es el operando, xxR significa derecha, xxL significa izquierda y n es el número de posiciones a desplazar. Realizar las siguientes operaciones con el operando A=10101010: SAR A,4, SLR A,4, SAL A, 4 y SLL A,4 de forma manual,  mediante un programa en lenguaje C y también mediante el depurador GDB.</p><div class="ulist"><ul><li><p>SAR A,4 = 11111010</p></li><li><p>SLR A,4 = 00001010</p></li><li><p>SAL A,4 = 10100000</p></li><li><p>SLL A,4 = 10100000</p></li></ul></div></li><li><p>Realizar manualmente la multiplicación A&#183;2<sup>2</sup> y A&#183;2<sup>-2</sup> donde A=10101010 primero aritméticamente y después mediante operaciones lógicas.</p><div class="ulist"><ul><li><p>A&#183;2<sup>2</sup>  = 1010101000</p></li><li><p>A&#183;2<sup>-2</sup> = 101010.10</p></li><li><p>Con operaciones lógicas la operación A&#183;2<sup>2</sup></p><div class="olist lowerroman"><ol class="lowerroman" type="i"><li><p>Doblar el tamaño de A &#8594; D:A &#8592; 0000000001010101</p></li><li><p>desplazar SLL D:A,2  &#8594; D:A &#8592; 0000000101010100</p></li></ol></div></li></ul></div></li></ol></div></div></section><section id="_representación_de_las_instrucciones_2"><h2>10.6. Representación de las Instrucciones</h2><div class="slide-content"><div class="olist arabic"><ol class="arabic"><li><p>Sea un computador con palabras de 32 bits. La CPU tiene 64 instrucciones diferentes (operaciones) de un operando, 32 registros de propósito general de 32 bits y posibilidad de direccionamiento directo a registro (el campo de operando es directamente el registro) o indirecto con desplazamiento a registro-base. a)Diseñar el formato de instrucción para este computador. Se debe especificar un registro para las direcciones de memoria  y un valor del desplazamiento, además del modo de direccionamiento y código de operación. b)¿Cuál es el máximo valor del desplazamiento (el desplaz. es un número en C2)?</p><div class="ulist"><ul><li><p>SOLUCION</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Formato</p><div class="sidebarblock"><div class="content"><div class="paragraph"><p>Palabra de 32 bits &#8594; Registros de propósito general de 32 bits y Registro de Instrucción IR de 32 bits</p></div>
<div class="paragraph"><p>Formato de instrucciones con una estructura en 4 campos: código de operación, modo de direccionamiento,
campo de operando (registro o registro con desplazamiento)</p></div>
<div class="paragraph"><p>1º Campo: código de operación: 64 instrucciones : 2<sup>6</sup>  &#8594; 6 bits</p></div>
<div class="paragraph"><p>2º Campo: modo de direccionamiento: 2 tipos: 2<sup>1</sup>        &#8594; 1 bit</p></div>
<div class="paragraph"><p>3º Campo: registro: 32 registros: 2<sup>5</sup>                   &#8594; 5 bits</p></div>
<div class="paragraph"><p>4º Campo: Desplazamiento nº entero: (32-(6+1+5))bits	&#8594; 20 bits</p></div></div></div>
<div class="listingblock"><div class="content"><pre>+----------+--------------------+
| Cod. Op. |Operando (Registro) |
+----------+--------------------+


+----------+-------------------------+-----------------------------------+
| Cod. Op. |Operando (Registro Base) |Operando (Registro Desplazamiento) |
+----------+-------------------------+-----------------------------------+</pre></div></div></li><li><p>Desplazamiento de 20 bits</p><div class="ulist"><ul><li><p>En complemento a 2: El valor Positivo máximo 0111-1111-1111-1111-1111 de valor <em>2<sup>19</sup>-1</em> y el valor Negativo mínimo 1000-0000-0000-0000-0000 que cambiado de signo es el 0-1000-0000-0000-0000-0000 de valor <em>+2<sup>19</sup></em>, por lo que el rango es [<em>+2<sup>19</sup>-1</em>,<em>-2<sup>19</sup></em>] &#8594; [+524287,-524288]</p></li></ul></div></li></ol></div></li></ul></div></li><li><p>Una computadora con palabras de 24 bits posee 16 instrucciones diferentes de un operando, 8 registros  de propósito general, y 3 modos de direccionamiento (directo a registro, indirecto con registro e indirecto con desplazamiento a registro-base)</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Diseñar un formato de instrucción para este computador. Debe especificar el código de operación, el modo de direccionamiento, un registro y un desplazamiento.</p><div class="ulist"><ul><li><p>SOLUCION:</p><div class="sidebarblock"><div class="content"><div class="paragraph"><p>Word Size = 24 &#8594; Registros de Propósito general de 24 bits y el registro de instrucción IR también de 24 bits</p></div>
<div class="paragraph"><p>4 campos en el formato de instruccioń:</p></div>
<div class="listingblock"><div class="content"><pre>+----------+-------------------------+----------+---------------+
| Cod. Op. |Modo de direccionamiento | Registro | Desplazamiento|
+----------+-------------------------+----------+---------------+</pre></div></div>
<div class="paragraph"><p>1º Campo: código de operación: 16 instrucciones : 2<sup>4</sup>  &#8594; 4 bits</p></div>
<div class="paragraph"><p>2º Campo: modo de direccionamiento: 3 tipos: 2<sup>2</sup>	&#8594; 2 bit para 3 tipos (Directo Reg, Indirecto Reg e Indirecto RegyDesp)</p></div>
<div class="paragraph"><p>3º Campo: registro: 8 registros: 2<sup>3</sup>			&#8594; 3 bits</p></div>
<div class="paragraph"><p>4º Campo: Desplazamiento nº entero: (24-(4+2+3))bits	&#8594; 15 bits</p></div></div></div></li></ul></div></li><li><p>¿Cuál es el rango de valores del desplazamiento en magnitud?, ¿y en C2?</p><div class="ulist"><ul><li><p>Formato Magnitud: Mínimo el cero y el máximo 111-1111-1111-1111 = 2<sup>15</sup>-1 = 32768</p></li><li><p>Complemento a 2: Positivo máximo 0111-1111-1111-1111-1111 de valor <em>2<sup>14</sup>-1</em> y Negativo mínimo 100-0000-0000-0000  que cambiado de signo es el 0100-0000-0000-0000 de valor <em>+2<sup>14</sup></em>, por lo que el rango es [<em>+2<sup>14</sup>-1</em>,<em>-2<sup>14</sup></em>] &#8594; [+16383,-16384]</p></li></ul></div></li></ol></div></li><li><p>Una computadora tiene un formato de instrucción de 11 bits donde el campo de operando es de 4 bits. ¿Es posible codificar en este formato 5 instrucciones de dos operandos, 45 de un operando y 48 sin operando?. Justificar la respuesta.</p><div class="ulist"><ul><li><p>SOLUCION</p></li><li><p>3 tipos de formatos</p><div class="ulist"><ul><li><p>Tipo 1: campo tipo - Cod. Op. - Op1 - Op2</p><div class="ulist"><ul><li><p>2 bits - x bits - 4 bits - 4 bits &#8594; x=11-(2+4+4)= 1 bit &#8594; Máximo de 2 instrucciones &lt; 5 instrucciones &#8594; No es posible</p></li></ul></div></li><li><p>Tipo 2: campo tipo - Cod. Op. - Op</p><div class="ulist"><ul><li><p>2 bits - y bits - 4 bits  &#8594; y=11-(2+4)= 5 bits &#8594; Máximo de 32 instrucciones &lt; 45 instrucciones &#8594; No es posible</p></li></ul></div></li><li><p>Tipo 3: campo tipo - Cod. Op.</p><div class="ulist"><ul><li><p>2 bits - z bits   &#8594; 48 instrucciones</p></li></ul></div></li></ul></div></li><li><p>Alternativa: 3 Registros IR , uno para cada tipo</p><div class="ulist"><ul><li><p>Sin campo de tipo : 5+45+48=98 instrucciones &#8594; 2<sup>7</sup> &#8594; 7 bits &#8594; la instrucción tipo 1 ocuparía 7+4+4=15 bits &gt; 11 &#8594; No es posible</p></li></ul></div></li></ul></div></li><li><p>Una computadora de 16 bits de ancho de palabra (instrucciones, palabra de memoria, registros) y 8 registros, tiene el siguiente repertorio de instrucciones:</p><div class="ulist"><ul><li><p>14 instrucciones de referencia de un solo operando en memoria, con direccionamiento directo e indirecto de memoria</p></li><li><p>31 instrucciones con dos operandos con los modos de direccionamiento directo e indirecto de registro.</p></li><li><p>32 instrucciones sin operando explícito.</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Especificar la codificación de las instrucciones.</p></li><li><p>Especificar la zona de memoria alcanzable en cada tipo de direccionamiento y rango posible de valores de los operandos (en C’2).</p></li></ol></div></li><li><p>SOLUCION</p><div class="ulist"><ul><li><p>Word Size = 16 &#8594; Registros de Propósito general de 16 bits</p></li><li><p>Repertorio con 3 tipos de formatos</p></li><li><p>1º Tipo: Tipo-Cod.Op.-Modo Direc-Op1 &#8594; 14 instrucciones (2<sup>4</sup>), Bits:2-4-1-x &#8594; x=16-(2+4+1)=9bits</p></li><li><p>2º Tipo: Tipo-Cod.Op.-Modo Direc1-Op1-Modo Direc2-Op2 &#8594; 31 instrucciones (2<sup>5</sup>) Bits:2-5-1-x-1-x &#8594; x=(16-(2+5+2))/2=3bits</p></li><li><p>3º Tipo: Tipo-Cod.Op. &#8594; 32 instrucciones (2<sup>5</sup>) Bits:2-5 &#8594; 7 bits ocupados de los 16.</p></li></ul></div></li></ul></div></li><li><p>Una computadora basada en el  procesador de Motorola M68000 presenta los siguientes contenidos en registro y memoria:</p><table class="tableblock frame-all grid-all" style="width:80%"><colgroup><col style="width:25%" /><col style="width:25%" /><col style="width:25%" /><col style="width:25%" /></colgroup><thead><tr><th class="tableblock halign-center valign-top">REGISTROS</th><th class="tableblock halign-center valign-top"></th><th class="tableblock halign-center valign-top">MEMORIA</th><th class="tableblock halign-center valign-top"></th></tr><tbody><tr><td class="tableblock halign-center valign-top"><p class="tableblock">Registro</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">Contenido</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">Dirección</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">Contenido</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">A1</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">100</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">99</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">104</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">A2</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">100</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">108</p></td></tr><tr><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-center valign-top"><p class="tableblock">101</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">106</p></td></tr><tr><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-center valign-top"><p class="tableblock">102</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">107</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">&#8230;&#8203;</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">&#8230;&#8203;</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">&#8230;&#8203;</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">&#8230;&#8203;</p></td></tr><tr><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-center valign-top"><p class="tableblock">199</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">100</p></td></tr><tr><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-center valign-top"><p class="tableblock">200</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">34</p></td></tr><tr><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-center valign-top"><p class="tableblock">201</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">96</p></td></tr><tr><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-center valign-top"><p class="tableblock">202</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">201</p></td></tr></table>
<div class="ulist"><ul><li><p>Si el contenido del desplazamiento de la instrucción en ejecución es desp=99 ¿Cuál seria el valor del operando (de tamaño byte) con los siguientes modos de direccionamientos?.</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Directo de memoria o absoluto (dirección = desplazamiento).</p></li><li><p>Directo de registro con A1.</p></li><li><p>Indirecto de registro con A1.</p></li><li><p>Indirecto con desplazamiento con registro base A1</p></li><li><p>Indirecto con desplazamiento con registro base A2.</p></li><li><p>Indirecto con desplazamiento con registro base A1 e indexado con A2.</p></li><li><p>Indirecto de registro con predecremento con A1.</p></li></ol></div></li><li><p>SOLUCION:</p><div class="listingblock"><div class="content"><pre>Directo de memoria o absoluto (dirección = desplazamiento) -&gt; M[99]=104
NOTA: El linker resuelve la dirección absoluta del operando especificando un desplazamiento respecto de un registro que apunta al inicio del segmento o sección de instrucciones. De esta forma el campo de operando es más corto que poniendo la dirección absoluta.

Directo de registro con A1. -&gt; R[A1]=100
Indirecto de registro con A1. -&gt; M[A1]=M[100]=108
Indirecto con desplazamiento con registro base A1 -&gt; M[A1+99]=M[199]=100
Indirecto con desplazamiento con registro base A2.-&gt; M[A2+99]=M[101]=106
Indirecto con desplazamiento con registro base A1 e indexado con A2.-&gt; M[A1+99+A2]=M[100+99+2]=M[201]=96
Indirecto de registro con predecremento con A1.-&gt; M[A1-1]=M[100-1]=104</pre></div></div></li></ul></div></li><li><p>Una computadora presenta los siguientes contenidos de los registros y la memoria:</p><table class="tableblock frame-all grid-all" style="width:80%"><colgroup><col style="width:25%" /><col style="width:25%" /><col style="width:25%" /><col style="width:25%" /></colgroup><thead><tr><th class="tableblock halign-center valign-top">REGISTROS</th><th class="tableblock halign-center valign-top"></th><th class="tableblock halign-center valign-top">MEMORIA</th><th class="tableblock halign-center valign-top"></th></tr><tbody><tr><td class="tableblock halign-center valign-top"><p class="tableblock">Registro</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">Contenido</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">Dirección</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">Contenido</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">R1</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">99</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">96</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">100</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">R2</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">6</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">97</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">102</p></td></tr><tr><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-center valign-top"><p class="tableblock">98</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">101</p></td></tr><tr><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-center valign-top"><p class="tableblock">99</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">104</p></td></tr><tr><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-center valign-top"><p class="tableblock">100</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">108</p></td></tr><tr><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-center valign-top"><p class="tableblock">101</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">106</p></td></tr><tr><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-center valign-top"><p class="tableblock">102</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">107</p></td></tr><tr><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-center valign-top"><p class="tableblock">103</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">109</p></td></tr><tr><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-center valign-top"><p class="tableblock">104</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">110</p></td></tr></table>
<div class="ulist"><ul><li><p>Si el contenido del desplazamiento de la instrucción en ejecución es 96 ¿Cuál seria el valor del operando con los siguientes direccionamientos?.</p><div class="literalblock"><div class="content"><pre>a)Directo de memoria (dir = desp).
b)Indirecto de memoria (dir memoria = desp).
c)Directo de registro con R1.
d)Indirecto de registro con R1.
e)Indirecto con desplazamiento con registro base R2</pre></div></div></li></ul></div></li><li><p>Se tiene una  computadora con un ancho de palabra de 32 bits y con un banco de registros de 32 registros de 32 bits. El computador tiene 64 instrucciones diferentes y los siguientes modos de direccionamiento: Un formato de instrucción con direccionamiento directo de memoria e indirecto de memoria y el otro formato con direccionamiento indirecto con desplazamiento a registro-base.</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Diseñar los dos formatos de las instrucciones de dos operandos sabiendo que siempre un operando está en memoria y otro en registro.</p><div class="ulist"><ul><li><p>SOLUCION:</p><div class="ulist"><ul><li><p>CodOp/Modo/Memoria_fuente/Registro_destino</p><div class="ulist"><ul><li><p>CodOp=2<sup>6</sup>=64 instrucciones</p></li><li><p>Modo: directo o indirecto:2<sup>1</sup></p></li><li><p>Memoria=x bits de direcciones</p></li><li><p>Reg=2<sup>5</sup>=32 registros &#8594; 5 bits</p></li><li><p>Total IR =32 bits &#8594; Memoria=32-(6+1+5)=32-12=20 bits</p></li></ul></div></li><li><p>CodOp/Desplazamiento-Registro_fuente/Registro_destino</p><div class="ulist"><ul><li><p>CodOp=2<sup>6</sup>=64 instrucciones</p></li><li><p>Desplazamiento= x bits de direcciones</p></li><li><p>Reg_base=2<sup>5</sup>=32 registros &#8594; 5 bits</p></li><li><p>Registro=2<sup>5</sup>=32 registros &#8594; 5 bits</p></li><li><p>Total=32 bits &#8594; Desplazamiento=32-(6+5+5)=16 bits</p></li></ul></div></li></ul></div></li></ul></div></li><li><p>Si cada dirección de memoria hace referencia a un byte ¿qué zona de memoria se puede acceder con cada uno de los modos de direccionamiento?</p><div class="ulist"><ul><li><p>SOLUCION</p></li></ul></div></li></ol></div></li><li><p>Consideremos cuatro arquitectura de procesador: acumulador, pila, memoria-memoria y registro-registro con 16 registros. Para las cuatro arquitectura se tienen los siguientes datos comunes:</p><div class="ulist"><ul><li><p>El código de operación es siempre 1 byte</p></li><li><p>Todas las direcciones de memoria son 2 bytes</p></li><li><p>Todos los datos son 4 bytes</p></li><li><p>Todas las instrucciones tienen una longitud igual a un numero entero de bytes</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Escribir de forma genérica los programas en lenguaje ensamblador de cada una de las arquitecturas para realizar la siguiente operación; A=B+C. Para cada programa, calcular el tráfico con  memoria  y  el  tamaño  del  código. ¿Cuál es mas eficiente?.</p></li><li><p>Escribir los cuatro programas ensamblador  para  la  siguiente  secuencia de operaciones A=B+C ; B=A+C ; D=A-B Calcular el   trafico con memoria y el tamaño del código. ¿Cuál es más eficiente?.</p></li></ol></div></li></ul></div></li><li><p>Considerando que en un procesador cada  búsqueda de instrucción y cada acceso a un  operando consumen un ciclo y teniendo en  cuenta para 3 programas los siguientes datos en millones de  referencias.</p><table class="tableblock frame-all grid-all" style="width:80%"><colgroup><col style="width:50%" /><col style="width:16.6666%" /><col style="width:16.6666%" /><col style="width:16.6668%" /></colgroup><thead><tr><th class="tableblock halign-center valign-top"></th><th class="tableblock halign-center valign-top">TEX</th><th class="tableblock halign-center valign-top">Spice</th><th class="tableblock halign-center valign-top">C</th></tr><tbody><tr><td class="tableblock halign-center valign-top"><p class="tableblock">Arquitectura R-R</p></td><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-center valign-top"></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">Referencias de datos</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">5.4</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">4.9</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">1.4</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">Palabras de instr.</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">14</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">18.9</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">3.9</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">Arquitectura M-M</p></td><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-center valign-top"></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">Referencias a datos</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">12.4</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">10.5</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">4.1</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">Palabras de instr</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">7.5</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">8.4</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">2.4</p></td></tr></table>
<div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Calcular el porcentajes de accesos a  memoria que se realizan para buscar  instrucciones de los tres programas para  la arquitectura R-R y para la arquitectura  M-M.</p></li><li><p>¿Cuál es la relación de accesos totales  entre ambas arquitecturas?</p></li></ol></div></li><li><p>Para la arquitectura M68000 de Motorola de 32 bits, mostrar el contenido de todos los registros y  posiciones de memoria afectadas (sin incluir  el PC) por la  ejecución de cada una de las  instrucciones, suponiendo que partimos  siempre de las condiciones iniciales  siguientes:</p><table class="tableblock frame-all grid-all" style="width:50%"><colgroup><col style="width:50%" /><col style="width:50%" /></colgroup><thead><tr><th class="tableblock halign-center valign-top">Instrucciones:</th><th class="tableblock halign-center valign-top"></th></tr><tbody><tr><td class="tableblock halign-center valign-top"><p class="tableblock">a. CLR.L</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">-(A1)</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">b.  CLR.W</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">D2</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">c.  MOVE.W</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">$1204,D1</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">d.  MOVE.W</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">#$1204,D1</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">e.  MOVE.B</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">(A2)+,$1200</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">f.  MOVE.L</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">D1,-(A2)</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">g.  MOVE.L</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">(A1)+,D2</p></td></tr></table>
<table class="tableblock frame-all grid-all" style="width:50%"><colgroup><col style="width:50%" /><col style="width:50%" /></colgroup><thead><tr><th class="tableblock halign-center valign-top">Condiciones iniciales:</th><th class="tableblock halign-center valign-top"></th></tr><tbody><tr><td class="tableblock halign-center valign-top"><p class="tableblock">REGISTROS</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">MEMORIA</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">A1:00001202</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">0011FE:7777</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">A2:00001204</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">001200:1111</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">D1:01020304</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">001202:2222</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">D2:F0F1F2F3</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">001204:3388</p></td></tr><tr><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-center valign-top"><p class="tableblock">001206:4444</p></td></tr><tr><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-center valign-top"><p class="tableblock">001208:5555</p></td></tr><tr><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-center valign-top"><p class="tableblock">00120A:6666</p></td></tr></table>
<div class="ulist"><ul><li><p>Sufijos &#8594; Long=4 bytes, Word=2Bytes, Byte=1Byte</p></li><li><p>El incremento o decremento de la dirección efectiva se escala con el tamaño del operando</p></li><li><p>SOLUCION</p><div class="listingblock"><div class="content"><pre>CLR.L -(A1) :
	Clear operando long
	Predecremento del registro A1 seguido de indirección
	A1&lt;-A1-4 ;(A1-4=0x1202-0x4=0x11FE) A1:000011FE
        M[A1]&lt;-0,M[A1+1]&lt;-0,M[A1+2]&lt;-0,M[A1+3]&lt;-0  M[0011FE]:0000 M[001200]:0000
CLR.W D2 :
	Clear operando Word
	D2(15:0)&lt;-0 ; D2:F0F10000
MOVE.W  $1204,D1
	Copiar 2bytes de Op_fuente (Dir. Directo) en Op_destino (Registro)
	D1(15:0)&lt;-M[0x1204] ;(M[0x1204]=3388); D1:01023388
MOVE.W  #$1204,D1
	Copiar 2bytes de Op_fuente (Dir. Inmediato) en Op_destino (Registro)
	D1(15:0)&lt;-0x1204 ; (D1:01021204)
MOVE.B  (A2)+,$1200
	Copiar 1byte Op_fuente (indirecto con postincremento), Op_destino (Directo)
        0x1200&lt;-M[A2][LSB] ;(M[A2][LSB]=M[A2+1]=M[1205]=88) ; M[1200]:1188
        A2&lt;-A2+1 ;(A2+1=0x1204+0x1=0x1205) ; A2:00001205
MOVE.L  D1,-(A2)
        Copiar 4bytes Op_fuente(Registro) a Op_destino(indirecto con predecremento)
	A2&lt;-A2-4 ;(A2-4=0x1204-0x4=0x1200) A2:00001200
        M[A2+3]&lt;-D1(7:0),M[A2+2]&lt;-D1(15:8),M[A2+1]&lt;-D1(23:16),M[A2]&lt;-D1(31:24)  ; M[001200]:01020304
MOVE.L  (A1)+,D2
        Copiar 4bytes Op_fuente(Indirecto con postincremento) a Op_destino(Registro)
        D2(7:0)&lt;-M[A1+3] ; D2(15:8)&lt;-M[A1+2]; D2(23:16)&lt;-M[A1+1]; D2(31:24)&lt;-M[A1] ; D2:11112222
	A1&lt;-A1+4; (A1=0x1202+0x4=0x1206) A1:00001206</pre></div></div></li></ul></div></li><li><p>Mostrar el contenido de todos los registros  y posiciones de memoria afectadas (sin  incluir el PC) por la ejecución de cada una  de las instrucciones, suponiendo que  partimos siempre de las condiciones iniciales  especificadas:</p><table class="tableblock frame-all grid-all" style="width:70%"><colgroup><col style="width:50%" /><col style="width:50%" /></colgroup><thead><tr><th class="tableblock halign-center valign-top">Instrucciones:</th><th class="tableblock halign-center valign-top">a. MOVE.W -(A1),A3</th></tr><tbody><tr><td class="tableblock halign-center valign-top"><p class="tableblock">b. CLR.B  -11(A2)</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">c. MOVE.W  (A4)+,-100(A1,D5.W)</p></td></tr></table>
<table class="tableblock frame-all grid-all" style="width:50%"><colgroup><col style="width:50%" /><col style="width:50%" /></colgroup><thead><tr><th class="tableblock halign-center valign-top">Condiciones iniciales:</th><th class="tableblock halign-center valign-top"></th></tr><tbody><tr><td class="tableblock halign-center valign-top"><p class="tableblock">REGISTROS</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">MEMORIA</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">A1:00001504</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">001500:1234</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">A2:00001510</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">001502:5678</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">A3:11122233</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">001504:9ABC</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">A4:00001506</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">001506:EF11</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">D5:FA000064</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">001508:2233</p></td></tr><tr><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-center valign-top"><p class="tableblock">00150A:4455</p></td></tr></table></li><li><p>Para la arquitectura M68000-32 de Motorola, suponiendo que se dan las siguientes  condiciones iniciales, mostrar el contenido  de todos los registros y posiciones de  memoria afectadas (incluyendo el PC) por la ejecución de cada una de las instrucciones.  Suponer, además, que las instrucciones  están en posiciones consecutivas de  memoria, a partir de la dirección $2000, y que se ejecutan en secuencia.</p><table class="tableblock frame-all grid-all" style="width:50%"><colgroup><col style="width:50%" /><col style="width:50%" /></colgroup><thead><tr><th class="tableblock halign-center valign-top">Condiciones iniciales:</th><th class="tableblock halign-center valign-top"></th></tr><tbody><tr><td class="tableblock halign-center valign-top"><p class="tableblock">REGISTROS</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">MEMORIA</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">A1:00001504</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">001500:1234</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">A2:00001510</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">001502:5678</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">A4:00001506</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">001504:9ABC</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">D3:11122233</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">001506:EF11</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">D5:FA000070</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">001508:2233</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">D6:AB00FF9B</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">00150A:4455</p></td></tr></table>
<table class="tableblock frame-all grid-all" style="width:70%"><colgroup><col style="width:50%" /><col style="width:50%" /></colgroup><thead><tr><th class="tableblock halign-center valign-top">Instrucciones:</th><th class="tableblock halign-center valign-top">CLR.B  -(A4)</th></tr><tbody><tr><td class="tableblock halign-center valign-top"><p class="tableblock">MOVE.L  -124(A2, D5.W), -(A1)</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">MOVE.W  $64(A4,D6.W), D3</p></td></tr></table></li><li><p>Comparar los computadores de 1, 2 y 3 direcciones escribiendo los programas para calcular la expresión X= (A+B*C)/(D-E*F) siendo los repertorios de cada uno de ellos los siguientes:</p><div class="listingblock"><div class="content"><pre>0 Address 	1 Address 	2 Address 		3 Address
PUSH M 	 	LOAD M 		MOVE X,Y ;(X&lt;-Y)	MOVE X,Y ;(X&lt;-Y)
POP M 		STORE M 	ADD X,Y  ;(X &lt;- X+Y)	ADD X,Y ;(X &lt;- Y+Z)
ADD 		ADD M 		SUB X,Y  ;(X &lt;- X-Y)	SUB X,Y ;(X &lt;- Y-Z)
SUB 		SUB M 		MUL X,Y  ;(X &lt;- X*Y)	MUL X,Y ;(X &lt;- Y*Z)
MUL 		MUL M 		DIV X,Y  ;(X &lt;- X/Y)	DIV X,Y ;(X &lt;- X/Y)
DIV 		DIV M</pre></div></div>
<div class="ulist"><ul><li><p>SOLUCION:</p><div class="listingblock"><div class="content"><pre>PUSH A      LOAD   E     MOV R0, E     MUL R0, E, F
PUSH B      MUL    F     MUL RO, F     SUB R0, D, R0
PUSH C      STORE  T     MOV R1, D     MUL R1, B, C
MUL         LOAD   D     SUB R1, R0    ADD R1, A, R1
ADD         SUB    T     MOV R0, B     DIV X, R0, R1
PUSH D      STORE  T     MOV R0, C
PUSH E      LOAD   B     ADD R0, A
PUSH F      MUL    C     DIV R0, R1
MUL         ADD    A     MOV X,  R0
SUB         DIV    T
DIV         STO    X
POP X</pre></div></div></li></ul></div></li><li><p>If the last operation performed on a computer with an 8-bit word was an addition in which the two operands were 00000010 and 00000011, what would be the value of the following flags?</p><div class="ulist"><ul><li><p>Carry</p></li><li><p>Zero</p></li><li><p>Overflow</p></li><li><p>Sign</p></li><li><p>Even Parity</p></li><li><p>Half-Carry</p></li><li><p>SOLUCION:</p><div class="ulist"><ul><li><p>0010+0011=0101 &#8594; No hay llevada en el MSB, el resultado no es cero, no hay overflow ya que no hay llevada, positivo, número de unos par,  no hay llevada en el bit de posición 3. Por lo que todos los flags desactivados excepto el de paridad par . El flag parity estará a 1.</p></li></ul></div></li></ul></div></li><li><p><a></a>The x86 Compare instruction (CMP) <strong>subtracts</strong> the source operand from the destination operand; it updates the status flags (C, P, A, Z, S, O) but does not alter either of the operands. The CMP instruction can be used to determine if the destination operand is greater than, equal to, or less than the source operand.Cuando se ejecuta CMP hay dos flags de overflow en el registro EFLAGS: el flag <strong>CF</strong> no hace la función de Carrier Flag sino la función de overflow flag si se comparan números sin signo. Si se comparan números con signo el flag de overlfow es <strong>OF</strong>. Leer los apuntes referentes a <a href="#prog_condicional">instrucciones condicionales</a></p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Suppose the two operands are treated as unsigned integers. Show which status flags are relevant to determine the relative size of the two integer and what values of the flags correspond to greater than, equal to, or less than.</p></li><li><p>Suppose the two operands are treated as twos complement signed integers. Show which status flags are relevant to determine the relative size of the two integer and what values of the flags correspond to greater than, equal to, or less than.</p></li><li><p>Cómo varían los flags de signo SF y overflow OF para operandos con signo de 1 byte: si el operando destino es 0x80 y el operando fuente es 0x7F; si el operando destino es 0x7F y el operando fuente 0x81.</p><div class="ulist"><ul><li><p>SOLUCION:</p></li><li><p>Ver <a href="#CFR">Programación en Lenguaje Ensamblador (x86)</a>,</p></li><li><p>CMP &#8658; Dest - Source</p></li><li><p>a. Enteros sin signo</p><table class="tableblock frame-all grid-all" style="width:80%"><caption class="title">Table 14. CMP/EFLAFS</caption><colgroup><col style="width:25%" /><col style="width:12.5%" /><col style="width:12.5%" /><col style="width:12.5%" /><col style="width:12.5%" /><col style="width:12.5%" /><col style="width:12.5%" /></colgroup><thead><tr><th class="tableblock halign-left valign-top">Caso</th><th class="tableblock halign-left valign-top">CF</th><th class="tableblock halign-left valign-top">PF</th><th class="tableblock halign-left valign-top">AF</th><th class="tableblock halign-left valign-top">ZF</th><th class="tableblock halign-left valign-top">SF</th><th class="tableblock halign-left valign-top">OF</th></tr><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Dest&gt;Source</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">x</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">x</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">x</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">x</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Dest=Source</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">x</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">x</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">x</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">x</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Dest&lt;Source</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">x</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">x</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">x</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">x</p></td></tr></table>
<div class="ulist"><ul><li><p>CF es el flag de overflow en este caso.</p></li><li><p>Sin signo &#8594; para el caso Destino &gt; Fuente, la resta Destino - Fuente da lugar a   CF=0 y OF según la resta con signo. El flag de signo no vaŕía SF=X.</p></li><li><p>Sin signo &#8594; para el caso Destino &lt; Fuente, la resta Destino - Fuente da lugar a   CF=1 y OF según la resta con signo. El flag de signo no varía SF=X.</p></li></ul></div></li><li><p>b. Enteros con signo</p><table class="tableblock frame-all grid-all" style="width:80%"><caption class="title">Table 15. CMP/EFLAFS</caption><colgroup><col style="width:25%" /><col style="width:12.5%" /><col style="width:12.5%" /><col style="width:12.5%" /><col style="width:12.5%" /><col style="width:12.5%" /><col style="width:12.5%" /></colgroup><thead><tr><th class="tableblock halign-left valign-top">Caso</th><th class="tableblock halign-left valign-top">CF</th><th class="tableblock halign-left valign-top">PF</th><th class="tableblock halign-left valign-top">AF</th><th class="tableblock halign-left valign-top">ZF</th><th class="tableblock halign-left valign-top">SF</th><th class="tableblock halign-left valign-top">OF</th></tr><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Dest&gt;Source</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">x</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">x</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">x</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">0/1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">0/1</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Dest=Source</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">x</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">x</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Dest&lt;Source</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">x</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">x</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">0/1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">1/0</p></td></tr></table>
<div class="ulist"><ul><li><p>Relación entre SF y OF</p></li><li><p>Datos de 1 Byte: Ejemplo A &gt; B</p><div class="listingblock"><div class="content"><pre>1 Byte : valor máximo +127, valor mínimo -128 y operaciones de la computadora en módulo 2^8=256
Si A=+127 y B= -8 -&gt; A &gt; B
instrucción CMP -&gt; A-B=+127-(-8)=+135
+135 &gt; +127  -&gt; OF=1
La computadora computa +135 en módulo 256, es decir, el resultado A-B=+135-módulo=+135-256=-121 -&gt; signo negativo -&gt; SF=1
La relación entre OF y SF es siempre OF=SF para el caso A &gt; B</pre></div></div></li><li><p>Datos de 1 Byte: Ejemplo A &lt; B</p><div class="listingblock"><div class="content"><pre>1 Byte : valor máximo +127, valor mínimo -128 y operaciones de la computadora en módulo 2^8=256
Si A=-128 y B= +8 -&gt; A&lt;B
instrucción CMP -&gt; A-B=-128-(+8)=-136
-136 &lt; -128  -&gt; OF=1
La computadora computa -136 en módulo 256, es decir, el resultado A-B=-136+módulo=-136+256=+120 -&gt; signo positivo -&gt; SF=0
La relación entre OF y SF es siempre OF&lt;&gt;SF para el caso A &lt; B</pre></div></div></li><li><p>interpretación gráfica: describir los dos ejemplos anteriores bien posicionando los vectores A y B en una recta o en un círculo y marcando el valor de los valores máximo, mínimo y módulo.</p></li><li><p>OF es el flag de overflow.</p></li><li><p>Con signo &#8594; para el caso Destino &gt; Fuente, la resta Destino - Fuente da lugar a  CF según la resta sin signo. SF=0 ó 1. OF=SF</p></li><li><p>Con signo &#8594; para el caso Destino &lt; Fuente, la resta Destino - Fuente da lugar a  CF según la resta sin signo. SF=0 ó 1. OF&lt;&gt;SF</p></li><li><p>CONCLUSION</p><div class="listingblock"><div class="content"><pre> CMP realiza los dos casos simultaneamente (con signo y sin signo) por lo que afecta a los dos flags de overflow CF y OF
 para el caso Destino &gt; Fuente,  la resta Destino - Fuente da lugar a  SF=OF y CF=0
 para el caso Destino &lt; Fuente, la resta Destino - Fuente da lugar a  SF&lt;&gt;OF y CF=1</pre></div></div></li></ul></div></li></ul></div></li></ol></div></li><li><p>Interpretación de los flags CF y OF con la instrucción suma  aritmética ADD. Al igual que con SUB el flag CF responde al overflow de la suma aritmética SIN signo y el flag OF responde al overflow de la suma aritmética con signo. Comprobarlo con el programa:</p><div class="listingblock"><div class="content"><pre>#### explicación de la relación de CF y OF con el oveflow
#### las instrucciones ADD y SUB hacen la interpretación de SIMULTANEA de operación CON y SIN signo
#### CF es el resultado del overflow de la operación (add,sub,etc) SIN signo
#### OF es el resultado del overflow de la operación (add,sub,etc) CON signo
#### ¿En qué operaración aritmética CF NO es overflow sin signo y  SÍ es un CARRY puro?


	.section .data
oper1:	.byte 0x80 # con signo -128 y sin signo 256
oper2:  .byte 0x7F # con signo +127 y sin signo 255

oper3: 	.byte 0x00 # con signo 0 y sin signo 0
oper4:	.byte 0xFF # con signo -1 y sin signo 511

	.section .text
	.global main
main:	push %ebp
	mov %esp,%ebp

	mov oper1,%al
	mov oper2,%bl
	mov oper3,%cl
	mov oper4,%dl

	subb $0x01,%al # comprobar que sin signo no hay overflow (CF=0) y con signo sí hay overflow (OF=1)
	addb $0x01,%bl # comprobar que sin signo no hay overflow (CF=0) y con signo sí hay overflow (OF=1)

	subb $0x01,%cl # comprobar que sin signo sí hay overflow (CF=1) y con signo no hay overflow (OF=0)
	addb $0x01,%dl # comprobar que sin signo sí hay overflow (CF=1) y con signo no hay overflow (OF=0)

	mov %esp,%ebp
	pop %ebp
	ret
	.end</pre></div></div></li><li><p>Many microprocessor instruction SETS include an instruction that tests a condition and sets a destination operand if the condition is true. Examples include the <em>SETcc</em> on the x86 processor, the <em>Scc</em> on the Motorola MC68000 processor, and the <em>Scond</em> on the National NS32000 processor. <a href="http://www.felixcloutier.com/x86/">Manual Intel quick</a>: interpretar los nmemónicos y operando de la instrucción SETcc</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>There are a few differences among these instructions:</p><div class="ulist"><ul><li><p>SETcc and Scc operate only on a byte, whereas Scond operates on byte, word, and doubleword operands.</p></li><li><p>SETcc and Scond set the operand to integer <strong>one if true</strong> and to <strong>zero if false</strong>,es decir, lógica positiva. Scc sets the byte to all binary ones if true and all zeros if false. What are the relative advantages and disadvantages of these differences?</p></li></ul></div></li><li><p>None of these instructions set any of the condition code flags, and thus an explicit test of the result of the instruction is required to determine its value. Discuss whether condition codes should be set as a result of this instruction (test). <a href="http://www.felixcloutier.com/x86/">Manual Intel quick</a>: interpretar la instrucción TEST.</p></li><li><p>A simple IF statement such as <em>IF b &gt; a</em> THEN can be implemented using a numerical representation method, that is, making the <em>Boolean value</em> manifest (utilizando una variable booleana en memoria), as opposed to a <em>flow of control</em> method, which represents the value of a Boolean expression by a point reached in the program (con saltos condicionales). (Primero transcribir el lenguaje ASM del enunciado a lenguaje RTL). Leer los apuntes referentes a <a href="#prog_condicional">instrucciones condicionales</a> Interpretar las instrucciones: <a href="http://www.felixcloutier.com/x86/">Manual Intel quick</a>. A compiler might implement <em>IF b &gt; a THEN</em> with the following <strong>x86 code</strong> for implement the <em>flow of control</em> method:</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-nasm" data-lang="nasm">        ; Sintaxis de Intel: Opeación Op_destino, Op_fuente
        SUB CX, CX ;set register CX to 0
        MOV AX, B ;move contents of location B to register AX
        CMP AX, A ;compare contents of register AX and location A

        JLE TEST ;salto si Op_destino &lt; Op_fuente or Op_destino=Op_fuente -&gt; B&lt;A or B=A
        INC CX ;add 1 to contents of register CX
TEST:   JCXZ OUT ;jump if contents of CX equal 0

THEN:   XXXXX  ; B&gt;A

OUT:    XXXXX  ; B&lt;A or B=A</code></pre></div></div>
<div class="ulist"><ul><li><p>Desarrollar el módulo fuente del programa if_ba.s : Editar el nuevo código y comentarios, compilar el módulo fuente y ejecutar  el módulo binario paso a paso con el debugger hasta que el programa funcione correctamente.</p></li><li><p>Escribir este mismo programa utilizando la instrucción SETcc que ahorra memoria y tiempo de ejecución.</p></li></ul></div></li><li><p>Now consider the high-level language statement, (Primero transcribir el lenguaje ASM del enunciado a lenguaje RTL):</p><div class="ulist"><ul><li><p><em>A:=(B &gt; C) OR (D == F)</em> donde := significa asignación</p></li><li><p>A compiler might generate the following code:</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-nasm" data-lang="nasm">	MOV EAX, B ;move contents of location B to register EAX
	CMP EAX, C ;compare contents of register EAX and location C
	MOV BL, 0 ;0 represents false -&gt; la instrucción MOV NO afecta a los registros
	JLE N1 ;jump if B&lt;C or B=C
	MOV BL, 1 ;1 represents true
N1 	MOV EAX, D
	CMP EAX, F
	MOV BH, 0 ;0 represents false
	JNE N2 ;jump if F&lt;&gt;D
	MOV BH, 1 ;1 represents true
N2 	OR BL, BH</code></pre></div></div>
<div class="ulist"><ul><li><p>Desarrollar el módulo fuente del programa if_doble_condicion.s : Editar el nuevo código y comentarios, compilar el módulo fuente y ejecutar  el módulo binario paso a paso con el debugger hasta que el programa funcione correctamente.</p></li><li><p>¿Cuál es el valor de BL para los casos falso y verdadero?</p></li><li><p>Escribir este mismo programa utilizando la instrucción SETcc que ahorra memoria y tiempo de ejecución.</p><div class="ulist"><ul><li><p>SOLUCION:</p></li><li><p>a. <code>JLE Op_destino</code></p></li></ul></div></li></ul></div></li><li><p>Salta si el ultimo resultado activa el banderín ZF=1 ó los banderines SF y OF son diferentes (SF&lt;&gt;OF)</p></li><li><p><code>CMP Op_destino_B,Op_fuente_A</code> &#8594; B-A &#8594; operandos con signo en complemento a dos</p><div class="ulist"><ul><li><p>ZF=1 &#8594; B==A</p></li><li><p>SF &lt;&gt; OF</p></li><li><p>SF=1,OF=0 &#8594; B&lt;A</p></li><li><p>SF=0,OF=1 &#8594; B&gt;A</p></li></ul></div></li><li><p>Sustituir el salto <code>JLE Op_destino</code> por <code>SETcc</code></p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-nasm" data-lang="nasm">        SUB CX, CX ;set register CX to 0
        MOV AX, B  ;move contents of location B to register AX
        CMP AX, A  ;compare contents of register AX and location A

        SETGE CX   ;CX = (b GE a) en lógica positiva
TEST:	JCXZ OUT   ;jump if contents of CX equal 0
THEN:   XXXXXX     ;si verdadero
OUT:    XXXXXX     ;si falso</code></pre></div></div>
<div class="ulist"><ul><li><p>Desarrollar el módulo fuente del programa if_doble_condicion.s : Editar el nuevo código y comentarios, compilar el módulo fuente y ejecutar  el módulo binario paso a paso con el debugger hasta que el programa funcione correctamente.</p><div class="ulist"><ul><li><p>b.</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-nasm" data-lang="nasm">MOV EAX, B ; move from location B to register EAX
CMP EAX, C
SETG BL ; Setcc SETGreater ;BL = 0/1 depending on result B&gt;C
MOV EAX, D
CMP EAX, F
MOV BH, 0
SETE BH ; Setcc SETEqual ;BH= 0 ó 1 dependiendo del resultado D=F
OR BL, BH</code></pre></div></div></li></ul></div></li></ul></div></li><li><p>Si BL ó BH es verdadero la sentencia a evaluar (B &gt; C) OR (D == F) es verdadera</p></li><li><p>BL : variable lógica A con lógica positiva</p></li><li><p>Desarrollar el módulo fuente del programa if_doble_condicion.s : Editar el nuevo código y comentarios, compilar el módulo fuente y ejecutar  el módulo binario paso a paso con el debugger hasta que el programa funcione correctamente.</p></li></ul></div></li></ol></div></li><li><p>En la estructura de datos siguiente, dibujar el layout de memoria little-endian, teniendo en cuenta que el compilador alinea los datos con direcciones múltiplo de 4 rellenando los huecos con ceros, y así minimizar el número de  transferencias entre la memoria y la CPU en la captura de los datos.</p><div class="ulist"><ul><li><p>Declaración:</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">#include &lt;stdio.h&gt;
void main (void)
{
  struct{
    int a;
    int pad; //
    double b;
    int* c;
    char d[7];
    short e;
    int f;
    char q[4];
  } s={.a=0x11121314,.pad=0,.b=0x2122232425262728,.d={'A','B','C','D','E','F','G'},.e=0x5152,.f=0x61626364,.q="abc"};
  s.c=&amp;s.e;
}</code></pre></div></div></li><li><p>SOLUCION Little Endian:</p><div class="listingblock"><div class="content"><pre>00: 14 13 12 11
04: xx xx xx xx
08: rr rr rr rr
0C: rr rr rr rr
10: aa aa aa aa
14: 41 42 43 44
18: 45 46 47 pp
1C: 52 51 pp pp
20: 64 63 62 61
24: 61 62 63 00</pre></div></div></li><li><p>xx: indeterminado</p></li><li><p>rr: código ieee-754 doble precisión</p></li><li><p>aa: dirección de la variable e con la que es inicializado el puntero c.</p></li><li><p>char q[4]="abc" : array de 4 elementos tipo carácter. Equivale a: char q[4]={<em>a</em>,<em>b</em>,<em>c</em>,NULL} donde el caracter NULL vale 00.</p></li></ul></div></li><li><p>Para una arquitectura little endian el mapa de direcciones en memoria es el de la figura de abajo. Asociar la declaración de las estructuras s1 y s2 en lenguaje C y su inicialización con el mapa de direcciones indicando las direcciones en memoria de los elementos de las estructuras.</p><div class="imageblock" style="text-align: center"><img src="./images/ejercicios/little_endian.png" alt="little endian" /></div><div class="title">Figure 92. Little Endian</div>
<div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>declaración de la variable s1:  tipo estructura</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">struct {
double i; //0x1112131415161718 ; 8 bytes
} s1;</code></pre></div></div>
<div class="ulist"><ul><li><p>SOLUCION:</p><div class="ulist"><ul><li><p>MSB(i):0x11 en la dirección 0x03 y LSB(i):18 en la dirección de MSB-7</p></li></ul></div></li></ul></div></li><li><p>declaración de la variable s2:  tipo estructura</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">struct {
int i; //0x11121314 ; 4 bytes
int j; //0x15161718
} s2;</code></pre></div></div>
<div class="ulist"><ul><li><p>SOLUCION:</p></li><li><p>i:</p><div class="ulist"><ul><li><p>MSB(i):0x11 en la dirección 0x03 y LSB(i) en la dirección 0x00</p></li></ul></div></li><li><p>j:</p><div class="ulist"><ul><li><p>j se reservar secuencialmente a continuación de i, por lo que LSB(j) estará en la dirección 0x04 y MSB(j) en la dirección 0x07</p></li><li><p>0x04 : 18 17 16 15</p></li></ul></div></li></ul></div></li></ol></div></li><li><p>Write a small program to determine the endianness of machine and report the results. Run the program on a computer available to you and turn in the output.</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">#include &lt;stdio.h&gt;
main()
{
  int integer; /*4 bytes*/
  char *p;
  integer = 0x30313233; /* ASCII for chars '0', '1', '2', '3' */
  p = (char *)&amp;integer
    if (*p=='0' &amp;&amp; *(p+1)=='1' &amp;&amp; *(p+2)=='2' &amp;&amp; *(p+3)=='3')
      printf("This is a big endian machine.\n");
    else if (*p=='3' &amp;&amp; *(p+1)=='2' &amp;&amp; *(p+2)=='1' &amp;&amp; *(p+3)=='0')
      printf("This is a little endian machine.\n");


    else
      printf("Error in logic to determine machine endian-ness.\n");</code></pre></div></div>
<div class="ulist"><ul><li><p>SOLUCION:</p><div class="ulist"><ul><li><p>p apunta al primer byte de la variable integer, (p+1) al siguiente byte y así sucesivamente</p></li><li><p>si p apunta al caracter <em>0</em> significa que el MSB de integer se almacena en la dirección más baja &#8594; Big endian</p></li><li><p>si p apunta al caracter <em>3</em> significa que el MSB de integer se almacena en la dirección más alta &#8594; Little endian</p></li></ul></div></li></ul></div></li></ol></div></div></section><section id="_programación_asm"><h2>10.7. Programación asm</h2><div class="slide-content"><div class="ulist"><ul><li><p>Explicación breve de las operaciones de los  <a href="#mnemonicos_basicos_explicados">códigos mnemónicos más básicos</a>. Para información más detallada ir al <a href="#repertorio_instruc_oper">Manual del Repertorio de Instrucciones de INTEL</a></p></li></ul></div>
<h level="3">Datos</h><div class="olist arabic"><ol class="arabic"><li><p>Interpretar las instrucciones siguientes de un programa en lenguaje ensamblador x86-64 describiéndolas en lenguaje RTL:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>mov da1,da4</p></li><li><p>mov $0xFF00FF00FF00FF00,%rax</p></li><li><p>mov $0xFF,%rsi</p></li><li><p>mov $da1,%rsp</p></li><li><p>lea da1,%rsp</p></li><li><p>mov da4,%ebx</p></li><li><p>movb da4,%ebx</p></li><li><p>movl da4,%ax</p></li><li><p>movw %ebx,da4</p></li><li><p>movw %ebx,da1</p><div class="ulist"><ul><li><p>teniendo en cuenta que la sección de datos  presenta el código siguiente:</p><div class="listingblock"><div class="content"><pre>	.data

da1:	.byte   0x0A
da2:	.2byte  0x0A0B
da4:	.4byte  0x0A0B0C0D
saludo:	.ascii  "hola"
lista:  .int    1,2,3,4,5</pre></div></div></li><li><p>SOLUCION</p><div class="listingblock"><div class="content"><pre>mov da1,da4
mov $0xFF00FF00FF00FF00,%rax
mov $0xFF,%rsi
mov $da1,%rsp
lea da1,%rsp
mov da4,%ebx
movb da4,%ebx
movl da4,%ax
movw %ebx,da4
movq %ebx,da4</pre></div></div></li></ul></div></li></ol></div></li></ol></div>
<h level="3">Modos de Direccionamiento</h><div class="olist arabic"><ol class="arabic"><li><p>Deducir la dirección efectiva del operando en las expresiones siguientes:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>$0</p></li><li><p>%rax</p></li><li><p>loop_exit</p></li><li><p>data_items(,%rdi,4)</p></li><li><p>(%rbx)</p></li><li><p>(%rbx,%rdi,4)</p><div class="ulist"><ul><li><p>SOLUCIONES</p><div class="ulist"><ul><li><p>$0		: inmediato : el operando está en la propia instrucción, es 0.</p></li><li><p>%rax 	: directo registro  . El operando está en el registro. Operando R[rax]</p></li><li><p>loop_exit   : directo memoria   . La etiqueta es la dirección efectiva del operando en memoria. Operando M[loop_exit]</p></li><li><p>data_items(,%rdi,4)  : indexado y desplazamiento inmediato. Dirección efectiva = data_item+4*RDI. Operando M[data_item+4*RDI]</p></li><li><p>(%rbx)  : Indirecto a registro . Dirección efectiva=RBX . Operando M[RBX]</p></li><li><p>(%rbx,%rdi,4) : indexado y desplazamiento en registro base. Dirección efectiva = RBX+4*RDI .Operando M[RBX+4*RDI]</p></li></ul></div></li></ul></div></li></ol></div></li><li><p>Describir en lenguaje RTL el código:</p><div class="listingblock"><div class="content"><pre>lea buffer,%eax
mov da2,(%eax)
mov da2,%bx
mov %bx, (%eax)
incw da2
lea  da2,%ebx
incw 2(%ebx)
mov $3,%esi
mov da2(,%esi,2),%ebx</pre></div></div>
<div class="ulist"><ul><li><p>SOLUCION:</p><div class="listingblock"><div class="content"><pre>lea buffer,%eax
mov da2,(%eax)
mov da2,%bx
mov %bx, (%eax)
incw da2
lea  da2,%ebx
incw 2(%ebx)
inc 2(%ebx)
mov $3,%esi
mov da2(,%esi,2),%ebx</pre></div></div></li></ul></div></li></ol></div>
<h level="3">Aritmética</h><div class="olist arabic"><ol class="arabic"><li><p>Suponer que los números enteros con signo x e y están almacenados en las posiciones 8 y 12 relativas al registro %ebp , y se desea almacenar en el top de la pila el producto x*y de 8 bytes, siendo el registro %esp (stack pointer) el puntero al top de la pila. a)Desarrollar el código ensamblador gas para la arquitectura i386 y b) dibujar el contenido de la pila sabiendo que la anchura de la pila es una palabra en la arquitectura i386 y suponiendo que el registro <em>ebp</em> y el puntero de pila <em>esp</em> están distanciados 4 palabras.</p><div class="ulist"><ul><li><p>SOLUCION: Módulo asm:</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">x en %ebp+8, y en %ebp+12

1 movl 12(%ebp), %eax
2 imull 8(%ebp) 			; EDX:EAX&lt;-x*y[63-32:31-0] ; imul: multiplicación de enteros con signo
3 movl %eax, (%esp) 			; pila &lt;-x*y[31:0]
4 movl %edx, 4(%esp) 			; pila &lt;-x*y[63:32]</code></pre></div></div></li><li><p>Pila: arquitectura i386 &#8594; x86-32 &#8594; palabra=4bytes. EL crecimiento de la pila es hacia direcciones de la memoria más bajas.</p><div class="listingblock"><div class="content"><pre>DIRECCIONES         CONTENIDO
              &lt;------ 4 bytes -------&gt;
              +----------------------+
   0x00000    |                      |
              +----------------------+
   0x00004    |                      |
              +----------------------+
   0x00008    |                      |
              +----------------------+
   0x0000C    |                      |
              +----------------------+                 ^
              |                      |                 |
              +----------------------+                 |
              |                      |                 | Crecimiento DESCENDENTE
              +----------------------+                 |
              |      x*y[31:0]       | &lt;-  esp  &lt;------PARTE ALTA DE LA PILA: PUNTERO ESP
              +----------------------+                 |
              |      x*y[63:32]      | &lt;-  esp+4       |
              +----------------------+                 |
              |                      |                 |
              +----------------------+                 |
   ebp   -&gt;   |                      | &lt;---------------PARTE BAJA DE LA PILA: PUNTERO EBP
              +----------------------+
   ebp+4 -&gt;   |                      |
              +----------------------+
   ebp+8 -&gt;   |          x           |
              +----------------------+
   ebp+C -&gt;   |          y           |
              +----------------------+
              |                      |
              +----------------------+
   0xfffff    |                      |
              +----------------------+</pre></div></div></li><li><p>EBP: base pointer register: apunta al bottom de la pila</p></li><li><p>ESP: stack pointer register: apunta al top de la pila</p></li><li><p>La pila está ocupada desde la dirección bottom hasta la dirección top, donde la dirección top &lt; dirección bottom.</p></li></ul></div></li><li><p>Suponer que los números enteros con signo x e y están almacenados en las posiciones 8 y 12 relativas al registro %ebp , y se desea almacenear en el top de la pila el producto x/y y también x mod y, siendo el registro %esp (stack pointer) el puntero al top de la pila. Desarrollar el código ensamblador gas para la arquitectura i386.</p><div class="ulist"><ul><li><p>Solución: Módulo asm</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">x en ebp+8, y en ebp+12

1 movl 8(%ebp), %edx	; edx&lt;-x
2 movl %edx, %eax	; copiar x en eax
3 sarl $31, %edx 	; edx lo lleno con el bit de signo de x , ya que forma parte del dividendo.
                        ; edx:eax &lt;- x
4 idivl 12(%ebp)        ; EAX&lt;-Cociente{x/y} , EDX&lt;-Resto{x/y]}
5 movl %eax, 4(%esp)    ; pila &lt;- Cociente{x/y}
6 movl %edx, (%esp)     ; pila &lt;- x%y  ; x%y = Resto{x/y}</code></pre></div></div>
<div class="ulist"><ul><li><p>Mismo enunciado anterior pero utilizando la instrucción  de extensión de signo <code>cltd</code></p></li></ul></div></li><li><p>Módulo asm</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">x en ebp+8, y en ebp+12

1 movl 8(%ebp), %edx	; edx&lt;-x
2 movl %edx, %eax	; copiar x en eax
3 cltd			; extiende el signo del operando en eax a edx
4 idivl 12(%ebp)        ; EAX&lt;-Cociente{x/y} , EDX&lt;-Resto{x/y]}
5 movl %eax, 4(%esp)    ; pila &lt;- Cociente{x/y}
6 movl %edx, (%esp)     ; pila &lt;- x%y  ; x%y = Resto{x/y}</code></pre></div></div></li></ul></div></li><li><p>Del módulo fuente en lenguaje C:</p><div class="ulist"><ul><li><p>Deducir el tipo num_t del argumento del prototipo de la función store_prod</p></li><li><p>Interpretar el módulo ASM en lenguaje RTL</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">void store_prod(num_t *dest, unsigned x, num_t y) {
*dest = x*y;
}</code></pre></div></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">dest en ebp+8, x en ebp+12, y en ebp+16

1 movl 12(%ebp), %eax
2 movl 20(%ebp), %ecx
3 imull %eax, %ecx
4 mull 16(%ebp)
5 leal (%ecx,%edx), %edx
6 movl 8(%ebp), %ecx
7 movl %eax, (%ecx)
8 movl %edx, 4(%ecx)</code></pre></div></div></li><li><p>SOLUCION:</p><div class="ulist"><ul><li><p>El argumento dest está implementado en la dirección ebp+8</p></li><li><p>dest es un puntero a un objeto de tipo num_t</p></li><li><p>línea 6: carga ecx con el valor de dest</p></li><li><p>línea 7: carga eax en la dirección de memoria a la que apunta dest</p></li><li><p>línea 1: carga eax con la variable x que es de tipo sin signo, luego num_t es unsigned.</p></li></ul></div></li></ul></div></li></ol></div>
<h level="3">Saltos</h><div class="ulist"><ul><li><p>Calcular las direcciones de salto en código máquina en el siguiente bloque de código ensamblador:</p><div class="ulist"><ul><li><p>módulo fuente:</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">1 jle .L2 if &lt;=, goto dest2
2 .L5: dest1:
3 movl %edx, %eax
4 sarl %eax
5 subl %eax, %edx
6 leal (%edx,%edx,2), %edx
7 testl %edx, %edx
8 jg .L5 if &gt;, goto dest1
9 .L2: dest2:
10 movl %edx, %eax</code></pre></div></div></li><li><p>Módulo objeto reubicable :las posiciones de memoria son relativas a la dirección de referencia "silly" (dirección cero del módulo reubicable)</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">1 	8: 7e 0d jle 17 &lt;silly+0x17&gt; Target = dest2
2 	a: 89 d0 mov %edx,%eax dest1:
3 	c: d1 f8 sar %eax
4 	e: 29 c2 sub %eax,%edx
5 	10: 8d 14 52 lea (%edx,%edx,2),%edx
6 	13: 85 d2 test %edx,%edx
7 	15: 7f f3 jg a &lt;silly+0xa&gt; Target = dest1
8 	17: 89 d0 mov %edx,%eax dest2:</code></pre></div></div></li><li><p>Módulo objeto ejecutable : El linker ha resuelto las posiciones de memoria relativas del módulo objeto reubicable convirtiendolas en direcciones de memoria absolutas.</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">1 804839c: 7e 0d jle 80483ab &lt;silly+0x17&gt;
2 804839e: 89 d0 mov %edx,%eax
3 80483a0: d1 f8 sar %eax
4 80483a2: 29 c2 sub %eax,%edx
5 80483a4: 8d 14 52 lea (%edx,%edx,2),%edx
6 80483a7: 85 d2 test %edx,%edx
7 80483a9: 7f f3 jg 804839e &lt;silly+0xa&gt;
8 80483ab: 89 d0 mov %edx,%eax</code></pre></div></div></li><li><p>SOLUCION:</p></li><li><p>los saltos están en las líneas 1 y 7 del código.</p></li><li><p>el operando del salto de la línea 1 es la dirección absoluta 80483ab etiquetada como dest2</p><div class="ulist"><ul><li><p>Cuando se ejecuta la línea 1 el PC ó RIP apunta a la línea 2, es decir, 804839e</p></li><li><p>El salto será la resta 80483ab - 804839e = 0D</p></li></ul></div></li><li><p>el operando del salto de la línea 7 es la dirección 804839e etiquetada como dest1</p><div class="ulist"><ul><li><p>El salto será la resta 804839e - 80483ab</p><div class="ulist"><ul><li><p>Como la resta va a dar negativo invierto los operandos y después cambio el signo del resultado</p></li><li><p>80483ab - 804839e = 0D</p></li><li><p>El complemento a 2 de tamaño 1 byte de 0D es F2+1 = F3</p></li></ul></div></li></ul></div></li></ul></div></li></ul></div>
<h level="3">If-Then-Else</h><div class="olist arabic"><ol class="arabic"><li><p>Relacionar un programa en lenguaje  C (Ref.  Randal194) y el programa equivalente  en lenguaje ensamblador mediante comentarios en el módulo fuente de bajo nivel:</p><div class="ulist"><ul><li><p>Módulo C:</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">(a) Original C code
1 int absdiff(int x, int y) {
2 if (x &lt; y)
3 return y - x;
4 else
5 return x - y;
6 }

(b) Equivalent goto version
1 int gotodiff(int x, int y) {
2 int result;
3 if (x &gt;= y)
4 goto x_ge_y;
5 result = y - x;
6 goto done;
7 x_ge_y:
8 result = x - y;
9 done:
10 return result;
11 }</code></pre></div></div></li><li><p>Módulo ASM:</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">(c) Generated assembly code
x at %ebp+8, y at %ebp+12
1 movl 8(%ebp), %edx Get x
2 movl 12(%ebp), %eax Get y
3 cmpl %eax, %edx Compare x:y
4 jge .L2 if &gt;= goto x_ge_y
5 subl %edx, %eax Compute result = y-x
6 jmp .L3 Goto done
7 .L2: x_ge_y:
8 subl %eax, %edx Compute result = x-y
9 movl %edx, %eax Set result as return value
10 .L3: done: Begin completion code</code></pre></div></div></li></ul></div></li></ol></div>
<h level="3">Do-While Loops</h><div class="olist arabic"><ol class="arabic"><li><p>Relacionar un programa en lenguaje  C (Ref.  Randal199) y el programa equivalente  en lenguaje ensamblador mediante comentarios en el módulo fuente de bajo nivel:</p><div class="ulist"><ul><li><p>Módulo C:</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">1 int dw_loop(int x, int y, int n) {
2 do {
3 x += n;
4 y *= n;
5 n--;
6 } while ((n &gt; 0) &amp;&amp; (y &lt; n));
7 return x;
8 }</code></pre></div></div></li><li><p>Módulo ASM:</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">x at %ebp+8, y at %ebp+12, n at %ebp+16

1 movl 8(%ebp), %eax
2 movl 12(%ebp), %ecx
3 movl 16(%ebp), %edx
4 .L2:
5 addl %edx, %eax
6 imull %edx, %ecx
7 subl $1, %edx
8 testl %edx, %edx
9 jle .L5
10 cmpl %edx, %ecx
11 jl .L2
12 .L5:</code></pre></div></div>
<div class="ulist"><ul><li><p>Write a goto version of the function (in C) that mimics how the assembly code program operates.</p></li></ul></div></li></ul></div></li><li><p>Relacionar un programa en lenguaje  C (Ref.  Randal201) y el programa equivalente  en lenguaje ensamblador mediante comentarios en el módulo fuente de bajo nivel:</p><div class="ulist"><ul><li><p>Módulo C:</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">1 int loop_while(int a, int b)
2 {
3 int result = 1;
4 while (a &lt; b) {
5 result *= (a+b);
6 a++;
7 }
8 return result;
9 }</code></pre></div></div></li><li><p>Ensamblaje: In generating the assembly code, gcc makes an interesting transformation that, in effect, introduces a new program variable. Register %edx is initialized on line 6 and updated within the loop on line 11. Describe how it relates to the
variables in the C code. Create a table of register usage for this function.</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">a at %ebp+8, b at %ebp+12

1 movl 8(%ebp), %ecx
2 movl 12(%ebp), %ebx
3 movl $1, %eax
4 cmpl %ebx, %ecx
5 jge .L11
6 leal (%ebx,%ecx), %edx
7 movl $1, %eax
8 .L12:
9 imull %edx, %eax
10 addl $1, %ecx
11 addl $1, %edx
12 cmpl %ecx, %ebx
13 jg .L12
14 .L11:</code></pre></div></div></li></ul></div></li><li><p>Relacionar un programa en lenguaje  C (Ref.  Randal204) y el programa equivalente  en lenguaje ensamblador mediante comentarios en el módulo fuente de bajo nivel:</p><div class="ulist"><ul><li><p>Módulo C:</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">1 int fact_for_goto(int n)
2 {
3 int i = 2;
4 int result = 1;
5 if (!(i &lt;= n))
6 goto done;
7 loop:
8 result *= i;
9 i++;
10 if (i &lt;= n)
11 goto loop;
12 done:
13 return result;
14 }</code></pre></div></div></li><li><p>Módulo asm</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">Argument: n at %ebp+8
Registers: n in %ecx, i in %edx, result in %eax

1 movl 8(%ebp), %ecx Get n
2 movl $2, %edx Set i to 2 (init)
3 movl $1, %eax Set result to 1
4 cmpl $1, %ecx Compare n:1 (!test)
5 jle .L14 If &lt;=, goto done
6 .L17: loop:
7 imull %edx, %eax Compute result *= i (body)
8 addl $1, %edx Increment i (update)
9 cmpl %edx, %ecx Compare n:i (test)
10 jge .L17 If &gt;=, goto loop
11 .L14: done:</code></pre></div></div></li></ul></div></li></ol></div>
<h level="3">Llamada a la subrutina</h><div class="olist arabic"><ol class="arabic"><li><p>Analizar la subrutina sumMtoN.s</p><div class="listingblock"><div class="content"><pre>##Subrutina: sumMtoN
##Descripción: calcula la suma de números enteros en secuencia desde el 1o sumando hasta el 2o sumando
##	Argumentos de entrada: 1o sumando y 2o sumando los argumentos los pasa la rutina principal a través de la pila:
##	1o se apila el último argumento y finalmente se apila el 1o argumento.
##	Argumento de salida: es el resultado de la suma y se pasa a la rutina principal a través del registro EAX.
##	Variables locales: se implementa una variable local en la pila pero no se utiliza

	.type sumMtoN, @function # declara la etiqueta sumMtoN

sumMtoN:
	## Próĺogo: Crea el nuevo frame del stack
	pushl %ebp #salvar el frame pointer antiguo
	movl %esp, %ebp #actualizar el frame pointer nuevo
	## Reserva una palabra en la pila como variable local
	## Variable local en memoria externa: suma
	subl $4, %esp
	## Captura de argumentos
	movl 8( %ebp), %ebx #1o argumento copiado en %ebx
	movl 12( %ebp), %ecx #2o argumento copiado en %ecx

	## suma la secuencia entre el valor del 1oarg y el valor del 2oarg
	## 1o arg &lt; 2oarg
	## utilizo como variable local EDX en lugar de la reserva externa para variable local: optimiza velocidad
	## Inicializo la variable local suma
	movl $0, %edx

	## Número de iteracciones
	mov %ecx, %eax
	sub %ebx, %eax

bucle:
	add %ebx, %edx
	inc %ebx
	sub $1, %eax
	jns bucle

	## Salvo el resultado de la suma como el valor de retorno
	movl %edx, %eax

	## Epílogo: Recupera el frame antiguo
	movl %ebp, %esp #restauro el stack pointer
	popl %ebp #restauro el frame pointer

	## Retorno a la rutina principal
	ret
	.end</pre></div></div></li><li><p>Programar una rutina main con llamada a la subrutina sumMtoN. Salir de main con la llamada a sistema exit. Ejecutar el programa con el depurador GDB y comprobar que el comando "next" <strong>entra</strong> en la subrutina sumMtoN. Estando dentro de la subrutina interpretar el comando "backtrace" <strong>bt</strong> que informa sobre el número y estado de los frames del stack.</p></li><li><p>Programar una rutina main con llamada a la subrutina sumMtoN. Nada más entrar en main editar el prólogo de main (creación de un nuevo frame) y terminar main con el epílogo (fin del frame) y con la instrucción "ret".  Estando dentro de la subrutina interpretar el comando "backtrace" <strong>bt</strong> que informa sobre el número y estado de los frames del stack.</p><div class="listingblock"><div class="content"><pre>	## Próĺogo: Crea el nuevo frame del stack
	pushl %ebp #salvar el frame pointer antiguo
	movl %esp, %ebp #actualizar el frame pointer nuevo



	## Epílogo: Recupera el frame antiguo
	movl %ebp, %esp #restauro el stack pointer
	popl %ebp #restauro el frame pointer</pre></div></div></li></ol></div></div></section><section id="_lenguaje_de_programación_c"><h2>10.8. Lenguaje de Programación C</h2><div class="slide-content"><h level="3">Punteros</h><div class="olist arabic"><ol class="arabic"><li><p>Editar y ejecutar el siguiente programa en lenguaje C interpretando el resultado sabiendo que lista es una "variable puntero" que apunta al elemento lista[0].</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">#include &lt;stdio.h&gt;

void main (void)
{

  int lista[]={1,2,3,4,5};

  printf ("\n **********ARRAY LISTA***********");
  printf ("\n *******lista es una VARIABLE PUNTERO*******");
  printf ("\n **la variable lista contiene la dirección de lista[0]*******\n\n") ;
  printf("\n lista[0] = %d es el 1º elemento de lista \n", lista[0]);
  printf("\n lista = %p es la dirección del 1º elemento \n", lista);
  printf("\n &amp;lista[0] = %p es la dirección del 1º elemento \n", &amp;lista[0]);
  printf("\n *lista = %d equivale a lista[0] \n", *lista);
  printf("\n *&amp;lista = %p equivale a lista \n", *&amp;lista);
  printf("\n **&amp;lista = %d equivale a lista[0] \n", **&amp;lista);

  printf ("\n\n *******ARITMETICA DE PUNTEROS*******");
  printf("\n *(lista+1) = %d equivale a lista[1] \n", *(lista+1));
  printf("\n *(lista+4) = %d equivale a lista[4] \n", *(lista+4));

  printf ("\n\n *******CASTING*******");
  printf("\n (int *)lista = %p  \n", (int *)lista);
  printf("\n *(int *)lista = %d \n", *(int *)lista);
  printf("\n *(int)lista+1 = %d \n", *(int *)lista+1);
  printf("\n *(int)lista+4 = %d \n", *(int *)lista+4);

  printf("\n *((short *)lista+1) = %d . Ahora lista lo declaro con elementos de 2  bytes \n", *((short *)lista+1));
}</code></pre></div></div></li><li><p>Al depurar con el depurador GDB un programa escrito en lenguaje ensamblador donde se ha declarado la directiva <code>lista: .int 1,2,3,4,5</code>, deducir las siguientes sentencias si la etiqueta lista es ensamblada como la dirección 0x55bf0000 y por lo tanto no es una variable puntero, sino que es el mismo puntero, es decir, la dirección del primer elemento del array lista. Indicar la relación entre el mapa de direcciones de memoria y el mapa de posiciones de elementos del array lista.</p><div class="listingblock"><div class="content"><pre>&amp;lista	: dirección de la "variable array" lista para el elemento de la posición 0  : 0x55bf0000
&amp;lista+1         	: 0x55bf0004 -&gt; dirección para el elemento de la posición 1.
(void *)&amp;lista+1  	: 0x55bf0001
(int  *)&amp;lista+1   	: 0x55bf0004
lista                	: 1 -&gt; equivale a lista[0]
(int)lista	       	: 1
(int *)&amp;lista		: 0x55bf0000
(int [5])lista		: {1,2,3,4,5}
*(int *)&amp;lista+1	: 2</pre></div></div></li></ol></div></div></section><section id="_capitulo_4_memoria_cache"><h2>10.9. Capitulo 4: Memoria Cache</h2><div class="slide-content"><div class="olist arabic"><ol class="arabic"><li><p>Libro William Stalling Ejemplo 4.2a Pg125. Calcular para una controladora de Caché con Asociación de Mapeo Directo, qué línea de la memoria caché (tag/línea/word) está asociada a la dirección 0x02ABCD de la memoria principal.</p><div class="ulist"><ul><li><p>Formato de la dirección de memoria principal (Bloque MPrincipal/Word)</p><div class="listingblock"><div class="content"><pre>&lt;-------------24 bits----------&gt;
+--------------------------------+
|     block number     |   Word  |
+--------------------------------+
&lt;--------s:22bits-----&gt;&lt;-w:2bits-&gt;</pre></div></div></li><li><p>Formato de la dirección de memoria principal (Tag/Línea Caché/Word)</p><div class="listingblock"><div class="content"><pre>&lt;-----------------24 bits--------------&gt;
+--------------------------------------+
|   Tag       | Line number  |   Word  |
+--------------------------------------+
&lt;-(s-r):8bits-&gt;&lt;--r:14bits--&gt;&lt;-w:2bits-&gt;</pre></div></div></li><li><p>Memoria Cache</p><div class="listingblock"><div class="content"><pre>                      +----------------------------------+
                      |           DATA                   |
+----------+----------+--------+-------+--------+--------+
|  Linea   |   Tag    | Word3  | Word2 |  Word1 |  Word0 |
+----------+----------+--------+-------+--------+--------+
|    0     |          |        |       |        |        |
+----------+----------+--------+-------+--------+--------+
|    1     |          |        |       |        |        |
+----------+----------+--------+-------+--------+--------+
|    2     |          |        |       |        |        |
+----------+----------+--------+-------+--------+--------+

+----------+----------+--------+-------+--------+--------+
|penúltima |          |        |       |        |        |
+----------+----------+--------+-------+--------+--------+
|última    |          |        |       |        |        |
+----------+----------+--------+-------+--------+--------+
           &lt;--8bits-&gt;&lt;-1byte-&gt;&lt;-1byte-&gt;&lt;-1byte-&gt;&lt;-1byte-&gt;</pre></div></div></li><li><p>0x02ABCD = 0000-0010-1010-1011-1100-1101</p></li><li><p>Block/Word &#8594;  0000001010101011110011/01 &#8594; Block=0000001010101011110011 Word=01 &#8594; block=0x0AAF3 word=01</p></li><li><p>Tag/Line/Word &#8594; 00000010/10101011110011/01 &#8594; Tag=00000010 Line=10101011110011 Word=01 &#8594; tag=02 line=0x2AF3 word=01</p><div class="ulist"><ul><li><p>Tag 0x02 Línea 0x2AF3 Word 1</p></li><li><p>Cuando la CPU lance la dirección 0x02ABCD, la controladora de la Caché irá a la línea 0x2AF3 y si el Tag de esa línea es 0x02 quiere decir que el contenido de datos (4 bytes)  de esa línea es una copia del contenido de datos (4 bytes) del bloque 0x0AAF3 y por lo tanto la palabra 01 de ese bloque de la memoria principal está en esa línea de la caché &#8594; hit. En caso de que en esa línea el tag no sea 02, los datos de esa línea no son una copia del bloque y la controladora de la caché tendrá que pedir a la controladora de la memoria principal una copia del bloque para la caché y otra copia para la CPU.</p></li></ul></div></li></ul></div></li><li><p>Repetir el ejercicio anterior mediante multiplicaciones y divisiones binarias respondiendo a los siguientes apartados:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>completar la tabla asociando líneas de la Memoria Caché con direcciones de la MPrincipal (primera palabra de cada bloque)</p><table class="tableblock frame-all grid-all" style="width:100%"><colgroup><col style="width:20%" /><col style="width:20%" /><col style="width:20%" /><col style="width:20%" /><col style="width:20%" /></colgroup><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Línea</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Dirección MP</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Dirección MP</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Dirección MP</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Dirección MP</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>0x000000</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>0x010000</code></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>0x000004</code></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>2<sup>14</sup> -1</code></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr></table>
<div class="ulist"><ul><li><p>la relación línea - dirección MP ( excepto tag) es una multiplicación x4, ya que cada línea y bloque tienen 4 bytes.</p><div class="ulist"><ul><li><p>para última linea:  2<sup>14</sup> -1 = 0x4000-1=0x3FFF &#8594; 0x3FFF x 4 = 14 unos seguidos de 2_ceros(x4)= 0xFFFC</p></li></ul></div></li><li><p>Dirección 0x010000 &#8594; los 4 digitos de menor peso (16bits), es decir, todos menos el tag, equivalen al bus de direcciones de la Caché, pero no direcciones de línea, sino de bytes, es decir la capacidad de la caché en bytes.</p></li></ul></div></li><li><p>calcular la dirección lineal 0x0000B de la MP con dirección Bloque/Palabra se corresponde:</p><div class="ulist"><ul><li><p>dirección bloque/palabra = dirección MP dividido por 4 &#8594; el cociente es el número de bloque y el resto el número de palabra</p></li><li><p>0x0000B  &#xF7; 4  &#8594; 11=2x4+3  &#8594; bloque Nº 2 y palabra Nº 3</p></li></ul></div></li><li><p>calcular para la dirección MP 0x02ABCD con que dirección Bloque/Palabra se corresponde:</p><div class="ulist"><ul><li><p>0x02ABCD &#xF7; 4 &#8594; muevo la coma dos posiciones a la izda (1/4=2<sup>-2</sup>) &#8594; parte entera Bloque Nº 0xAAF3 y parte fracción Word Nº01</p></li></ul></div></li><li><p>calcular al Bloque Nº 0xAAF3 qué línea le corresponde:</p><div class="ulist"><ul><li><p>i= j mod m , donde m=2<sup>14</sup> &#8594; la línea es el resto de dividir 0xAAF3 entre 2<sup>14</sup> &#8594; parte fracción de mover la coma 14 posiciones a la izda &#8594; 0x2AF3</p></li></ul></div></li><li><p>calcular para la dirección MP 0x02ABCD con que byte y línea de la caché se corresponde:</p><div class="ulist"><ul><li><p>byte &#8594; 0xABCD</p></li><li><p>línea &#8594; 0xABCD &#xF7; 4  &#8594; muevo la coma dos bits a la izda y tomo la parte entera &#8594; 0x2AF3</p></li></ul></div></li><li><p>calcular  para la dirección MP 0x02ABCD con que word de la caché se corresponde</p><div class="ulist"><ul><li><p>word  &#8594; 0xABCD en módulo 4 &#8594; muevo la coma dos bits a la izda y tomo la parte fracción &#8594; 01</p></li></ul></div></li></ol></div></li><li><p>William Stalling Ejemplo 4.2a Pg125 : The system has a Cache memory of 64KB  and Main Memory of 16MB with a byte word size and four word block size. For a cache controller with direct mapping correspondence function search the main memory block addresses correspondences to cache memory <strong>0x0CE7 number line</strong> .</p><div class="ulist"><ul><li><p>Desarrollo:</p><div class="ulist"><ul><li><p>Memoria principal: 16MB, 1word=1byte, 1block=4 byte.</p><div class="ulist"><ul><li><p>16MB &#8594; 2<sup>24</sup> &#8594; 24 bits address bus</p></li></ul></div></li><li><p>Memoria cache: 64KB, 4 byte line, 16K lines.</p><div class="ulist"><ul><li><p>16K &#8594; 2<sup>14</sup>&#8594; 14 bits campo de línea</p></li></ul></div></li><li><p>Direct mapping correspondence function: 0x0CE7 cache line</p></li><li><p>i=j mod m donde i es el número de línea, j el número de bloque y m el número de líneas de la caché.</p></li><li><p>la dirección de 24 bits se descompone en 3 campos : etiqueta-línea-palabra</p><div class="listingblock"><div class="content"><pre>&lt;-------------24 bits----------&gt;
+------------------------------+
|Tag      | Line number| Word  |
+------------------------------+
&lt;--8bits-&gt;&lt;---14bits--&gt;&lt;-2bits-&gt;</pre></div></div></li><li><p>Cada tag agrupa 16K bloques &#8594; (16K bloques/tag)x(4bytes/bloque)x(número de tags N)= CapacidadMemPrincipal=16MB &#8594; 2<sup>14</sup>x2<sup>2</sup>xN=2<sup>24</sup>bytes &#8594; N=2<sup>8</sup> Tags &#8594; Como cada agrupamiento Tag equivale a la capacidad de la Caché &#8594; La MPrincipal equivale a 256 Cachés.</p></li><li><p>dirección línea 0CE7 :  dirección línea de 14 bits: 00-1100-1110-0111. Buscamos las direcciones de memoria asociadas a dicha línea.</p><div class="ulist"><ul><li><p>Dirección MemPrincipal = Tag 0,   Linea 0CE7, Palabra 0 &#8594; 0000-0000-00-1100-1110-0111-00 = 0000-0000-0011-0011-1001-1100 &#8594; 00339C</p></li><li><p>Dirección MemPrincipal = Tag 1,   Línea 0CE7, Palabra 0 &#8594; cambia el primer campo a 01 				       &#8594; 01339C</p></li><li><p>Dirección MemPrincipal = Tag 255, Línea 0CE7, Palabra 0 &#8594; cambia el primer campo a FF				       &#8594; FF339C</p></li><li><p>Las direcciones de memoria de un bloque son la dirección de la primera palabra del bloque en la Memoria Principal.</p></li></ul></div></li></ul></div></li></ul></div></li><li><p>A set-associative cache consists of 64 lines, or slots, divided into four-line sets. Main memory contains 4K blocks of 128 words each. Show the format of main memory addresses. Calculate the 0x7FAFA memory address show in hexadecimal code the cache format. How know the cache controller if the 0x7FAFA is in cache memory.</p><div class="ulist"><ul><li><p>Desarrollo:</p><div class="ulist"><ul><li><p>Caché: 64 líneas de 128 palabras cada una agrupadas en sets de 4 líneas</p><div class="ulist"><ul><li><p>128 palabras &#8594; 7 bits para direccionar la palabra dentro de la línea</p></li><li><p>16 sets &#8594; 2<sup>4</sup> &#8594; 4 bits para direccionar los sets dentro de la caché</p></li></ul></div></li><li><p>Main memory: 4Kblocks de 2<sup>7</sup>palabras</p><div class="ulist"><ul><li><p>12 bits para direccionar un bloque</p></li><li><p>2<sup>19</sup> palabras&#8594;512Kpalabras &#8594; 19 bits para direccionar una palabras &#8594; ancho bus de direcciones</p></li></ul></div></li><li><p>set associative &#8594; i = j mod v donde v es el número de sets, j el bloque e i el set</p><div class="ulist"><ul><li><p>Tag &#8594; código para diferenciar los bloques que van al mismo set.  bits Tag=bits totales - bits Set - bits Word=19-4-7=8 bits.</p></li></ul></div></li><li><p>Tag/Set/Word &#8594; 19 address bits descompuestos en los 3 campos de 8/4/7 bits</p></li></ul></div></li><li><p>Sol:</p><div class="ulist"><ul><li><p>Tag/Set/Word : 8/4/7</p></li><li><p>0x7FAFA &#8594; Tag 0xFF, Set 0x6, Word 0x7A. If Tag 0xFF is on any of the four lines of Set 0x6, then a "hit" has occurred.</p></li></ul></div></li></ul></div></li><li><p>For the hexadecimal main memory addresses 111111, 666666,BBBBBB, show the following information, in hexadecimal format:</p><div class="olist loweralpha"><ol class="loweralpha"><li><p>Tag, Line, and Word values for a direct-mapped cache, using the format of Figure 4.10</p></li><li><p>Tag and Word values for an associative cache, using the format of Figure 4.12</p></li><li><p>Tag, Set, and Word values for a two-way set-associative cache, using the format of Figure 4.15</p><div class="ulist"><ul><li><p>Desarrollo:</p><div class="ulist"><ul><li><p>a) Direct mapped Tag/Line/Word 		&#8594; 24 address bits descompuestos en los 3 campos de 8/14/2 bits</p><div class="ulist"><ul><li><p>111111 = 0001-0001-0001-0001-0001-0001 = 00010001-00010001000100-01=0001-0001-00-0100-0100-0100-01=11-0444-1 &#8594; El 0 no se escribe en hex por la izda</p></li></ul></div></li><li><p>b) Full associative cache Tag/Word 		&#8594; 24 address bits descompuestos en los 2 campos de 22/2 bits</p><div class="ulist"><ul><li><p>111111 = 0001-0001-0001-0001-0001-0001 = 0001000100010001000100-01=00-0100-0100-0100-0100-0100-01=044444-1 &#8594; El 0 no se escribe en hex por la izda</p></li></ul></div></li><li><p>c) Set associative cache Tag/Set/Word 	&#8594; 24 address bits descompuestos en los 3 campos de 9/13/2</p><div class="ulist"><ul><li><p>111111 = 0001-0001-0001-0001-0001-0001 = 000100010-0010001000100-01=0-0010-0010-0-0100-0100-0100-01=022/0444/1-1 &#8594; El 0 no se escribe en hex por la izda</p></li></ul></div></li></ul></div></li><li><p>Sol:</p><table class="tableblock frame-topbot grid-all" style="width:80%"><caption class="title">Table 16. Direcciones</caption><colgroup><col style="width:25%" /><col style="width:25%" /><col style="width:25%" /><col style="width:25%" /></colgroup><thead><tr><th class="tableblock halign-left valign-top">Address</th><th class="tableblock halign-left valign-top">111111</th><th class="tableblock halign-left valign-top">666666</th><th class="tableblock halign-left valign-top">BBBBBB</th></tr><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>a. Tag/Line/Word</strong></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>11/444/1</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>66/1999/2</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>BB/2EEE/3</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>b. Tag/Word</strong></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>44444/1</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>199999/2</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>2EEEEE/3</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>c. Tag/Set/Word</strong></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>22/444/1</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>CC/1999/2</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>177/EEE/3</code></p></td></tr></table></li></ul></div></li></ol></div></li><li><p>Consider a 32-bit microprocessor that has an on-chip 16-KByte four-way set-associative cache. Assume that the cache has a line size of four 32-bit words.</p><div class="olist loweralpha"><ol class="loweralpha"><li><p>Draw a block diagram of this cache showing its organization and how the different address fields are used to determine a cache hit/miss.</p></li><li><p>Where in the cache is the word from memory location ABCDE8F8 mapped</p><div class="ulist"><ul><li><p>Desarrollo:</p><div class="ulist"><ul><li><p>Memoria principal</p><div class="ulist"><ul><li><p>no dice nada del bus externo, supongo el máximo de 32 bits &#8594; 2<sup>32</sup>Bytes &#8594; 4GB</p></li></ul></div></li><li><p>Cache on-chip: bus local: 32 bits data bus y address bus: Set associative de 4 líneas por set.</p><div class="ulist"><ul><li><p>4 palabras de 4 bytes cada una por línea hacen un total de 16 bytes por línea (4 bits en el campo word). El código de 4 bits direcciona el primer byte de cada palabra (0x0 la palabra 0, 0x4 la palabra 1, 0x8 la palabra 2, 0xC la palabra 3)</p></li><li><p>El número de sets es capacidad total/bytes por set = 16KB / (4líneas/set)<strong>(4palabras/línea)</strong>(4bytes/palabra) = 16KB/64B = 2<sup>8</sup>=256 sets &#8594; 8bits</p></li><li><p>el número de bloques en cache es capacidad/bytes_por_línea= 16KB/(4palabras/línea)*(4bytes/palabra)=1Kbloques</p></li><li><p>los 1kbloques se asocian en sets de 4 líneas.</p></li><li><p>address bus=tag bits+set bits+word bits &#8594; 32=tag bits+8+4 &#8594; tag_bits=32-8-4=20 bits. El campo Tag distingue bloques dentro del mismo set.</p></li><li><p>¿que bloques van al mismo set? i = j mod v, donde i es el número de set al que va el bloque j, v es el número de sets. Es decir, 2^20 bloques están asocidos al mismo set por lo que han de compartir 4 líneas &#8594; 4 para 20.</p></li><li><p>Tag/Set/Word &#8594; 32 address bits descompuestos en los 3 campos de 20/8/4 bits</p></li></ul></div></li><li><p>a) Después de la descomposición tag/set/word se selecciona el set direccionado y se comparan los tags de las 4 líneas con el tag de la dirección absoluta. Son 4 comparadores, uno por vía. Al Comparador_1 irán la primera línea de cada set en que dividimos la memoria principal. 2<sup>32</sup> bytes los agrupo en sets de 16 palabras por set &#8594; la memoria principal queda dividida en 2<sup>8</sup> sets</p></li><li><p>b) Descomposición 20/8/4 de la dirección ABCD8F8&#8594; ABCD/8F/8 &#8594; 8F es el set 143 y el byte 8 es la palabra número 2.</p></li></ul></div></li><li><p>Sol:
a&#8230;&#8203;   Descomposición: Tag/Set/Offset . 4 comparadores: 1 por cada vía del Set.
b&#8230;&#8203;   Set 143, cualquier línea, la doblepalabra número 2.</p></li></ul></div></li></ol></div></li><li><p>The Intel 80486 has an on-chip, unified cache. It contains 8 KBytes and has a four-way set-associative organization and a block length of four 32-bit words. The cache is organized into 128 sets. There is a single “line valid bit” and three bits, B0, B1, and B2
(the “LRU” bits), per line. On a cache miss, the 80486 reads a 16-byte line from main memory in a bus memory read burst.</p><div class="olist loweralpha"><ol class="loweralpha"><li><p>Draw a simplified diagram of the cache</p></li><li><p>show how the different fields of the address are interpreted.</p><div class="ulist"><ul><li><p>Desarrollo:</p><div class="ulist"><ul><li><p>Intel 80486 ( Pag 38,47,130) tiene un bus de memoria de 32 bits &#8594; address bus de 32 bits que direccionan 1 byte.</p></li><li><p>Caché: 8KB, set-associative de 4 vías, cada línea 4 palabras de 4 bytes (16 bytes con 4 bits), y 128 sets (7 bits)</p><div class="ulist"><ul><li><p>4 palabras de 4 bytes cada una por línea hacen un total de 16 bytes por línea (4 bits en el campo word). El código de 4 bits direcciona el primer byte de cada palabra (0x0 la palabra 0, 0x4 la palabra 1, 0x8 la palabra 2, 0xC la palabra 3)</p></li></ul></div></li><li><p>Descomposición de los 32 bits : Tag/Set/Offset &#8594; 21/7/4</p></li><li><p>Además de los 32 bits es necesario añadir:</p><div class="ulist"><ul><li><p>3 bits USO para indicar de las cuatro líneas quien es la MENOS recientemente utilizada, la de menor valor de los 8 posibles: 000-001-010-011-100-101-110-111</p></li><li><p>1 bit de validación que indica con el valor 1 que hace falta su actualización en MP antes de sobreescribir la línea &#8594; técnica de postescritura.</p></li></ul></div></li><li><p>Línea: Valid/LRU/Tag/Set/Offset &#8594; 1/3/21/7/4</p></li></ul></div></li><li><p>Solución:
a.. Esquema Set associative
b.. Valid/LRU/Tag/Set/Offset &#8594; 1/3/21/7/4</p></li></ul></div></li></ol></div></li><li><p>Consider the following code:</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">for (i=0; i=20; i++)
   for ( j=0; j=10; j++)
         a[i] = a[i] * j ;</code></pre></div></div>
<div class="olist loweralpha"><ol class="loweralpha"><li><p>Give one example of the spatial locality in the code.</p></li><li><p>Give one example of the temporal locality in the code.</p><div class="ulist"><ul><li><p>Desarrollo</p><div class="ulist"><ul><li><p>en el bucle interno siempre se repite la misma instrucción, siempre accedes a la misma dirección donde esta la instrucción &#8594; localidad espacial</p></li><li><p>en el bucle interno siempre se repite la misma instrucción, el futuro es el presente &#8594; localidad temporal</p></li><li><p>en el bucle interno con j=0 accedes al operando a[0] y en la siguiente iteracción se repite el mismo operando a[0] &#8594; localidad espacial y temporal.</p></li></ul></div></li></ul></div></li></ol></div></li><li><p>Consider a cache of 4 lines of 16 bytes each. Main memory is divided into blocks of
16 bytes each. That is, block 0 has bytes with addresses 0 through 15, and so on. Now
consider a program that accesses memory in the following sequence of addresses:</p><div class="literalblock"><div class="content"><pre>Once: 63 through 70
Loop ten times: 15 through 32; 80 through 95</pre></div></div>
<div class="olist loweralpha"><ol class="loweralpha"><li><p>Suppose the cache is organized as direct mapped. Memory blocks 0, 4, and so on are
assigned to line 1; blocks 1, 5, and so on to line 2; and so on. Compute the hit ratio.</p></li><li><p>Suppose the cache is organized as two-way set associative, with two sets of two
lines each. Even-numbered blocks are assigned to set 0 and odd-numbered blocks
are assigned to set 1. Compute the hit ratio for the two-way set-associative cache
using the least recently used replacement scheme.</p></li></ol></div></li><li><p>Consider a single-level cache with an access time of 2.5 ns, a line size of 64 bytes, and a
hit ratio of H = 0.95. Main memory uses a block transfer capability that has a firstword
(4 bytes) access time of 50 ns and an access time of 5 ns for each word thereafter.</p><div class="olist loweralpha"><ol class="loweralpha"><li><p>What is the access time when there is a cache miss? Assume that the cache waits
until the line has been fetched from main memory and then re-executes for a hit.</p></li><li><p>Suppose that increasing the line size to 128 bytes increases the H to 0.97. Does this
reduce the average memory access time?</p></li></ol></div></li><li><p>On the Motorola 68020 microprocessor, a cache access takes two clock cycles. Data
access from main memory over the bus to the processor takes three clock cycles in the
case of no wait state insertion; the data are delivered to the processor in parallel with
delivery to the cache.</p><div class="olist loweralpha"><ol class="loweralpha"><li><p>Calculate the effective length of a memory cycle given a hit ratio of 0.9 and a
clocking rate of 16.67 MHz.</p></li><li><p>Repeat the calculations assuming insertion of two wait states of one cycle each
per memory cycle.What conclusion can you draw from the results?</p></li></ol></div></li><li><p>For a system with two levels of cache, define Tc1 first-level cache access time; Tc2
second-level cache access time; Tm memory access time;H1 first-level cache hit
ratio;H2 combined first/second level cache hit ratio. Provide an equation for Ta for
a read operation.</p></li></ol></div></div></section><section id="_capitulo_5_memoria_sincrona_dinamica_ram_sdram"><h2>10.10. Capitulo 5: Memoria Sincrona Dinamica RAM (SDRAM)</h2><div class="slide-content"><div class="olist arabic"><ol class="arabic"><li><p>La arquitectura de un computador Intel tiene un bus del sistema con una frecuencia de reloj de 100MHz, el ancho del bus de datos son 64 bits y el ancho del bus de direcciones de la placa base es de 48 bits.</p><div class="olist loweralpha"><ol class="loweralpha"><li><p>Calcular el ancho de banda del bus en transferencias/s y en bytes/s</p></li><li><p>Calcular la capacidad de memoria</p></li><li><p>Calcular el ciclo de memoria teniendo en cuenta que la latencia de la memoria DRAM son 10ns.</p><div class="ulist"><ul><li><p>Desarrollo</p><div class="olist lowerroman"><ol class="lowerroman" type="i"><li><p>100 x 10<sup>6</sup> ciclos/seg x 1Transferencia/ciclo = 100MT/s</p></li><li><p>bus de direcciones &#8594; 2<sup>48</sup> Words =  2<sup>8</sup> x 2<sup>40</sup> = 256 TWords = 2<sup>48</sup> x 2<sup>3</sup> Bytes = 2 x 2<sup>50</sup> = 2 petabytes</p></li><li><p>ciclo de memoria ideal (sin bus multiplexado, sin precarga, etc)= 1 Transferencia= latencia_memoria + latencia_bus_transferencia = 10ns + 1/(10<sup>8</sup>) = 10ns + 10ns = 20 ns</p></li></ol></div></li></ul></div></li></ol></div></li><li><p>Consider a dynamic RAM that must be given a refresh cycle 64 times per ms. Each refresh operation requires 150 ns; a memory cycle requires 250 ns.What percentage of the memory’s total operating time must be given to refreshes?</p><div class="ulist"><ul><li><p>Desarrollo</p><div class="ulist"><ul><li><p>en 1 ms 64 refrescos de 150ns &#8594; 9600 ns refrescando</p></li><li><p>9600ns/1ms = 0.0096 = 1%</p></li></ul></div></li><li><p>Sol:</p><div class="olist loweralpha"><ol class="loweralpha"><li><p>1%</p></li></ol></div></li></ul></div></li><li><p>Figure 5.16 shows a simplified timing diagram for a DRAM read operation over a bus. The access time is considered to last from t1 to t2. Then there is a recharge time, lasting from t2 to t3, during which the DRAM chips will have to recharge before the processor can access them again.</p><div class="olist loweralpha"><ol class="loweralpha"><li><p>Assume that the access time is 60 ns and the recharge time is 40 ns.What is the memory cycle time? What is the maximum data rate this DRAM can sustain, assuming a 1-bit output?</p></li><li><p>Constructing a 32-bit wide memory system using these chips yields what data transfer rate?</p><div class="ulist"><ul><li><p>Desarrollo:</p></li><li><p>t1&#8594;t2 : direccionamiento</p></li><li><p>t2&#8594;t3</p><div class="ulist"><ul><li><p>acceso al dato</p></li><li><p>recarga del bus de direcciones a medio camino entre el 0 y el 1</p></li><li><p>60ns de latencia y 40 de precarga = 100 ns de ciclo de memoria entre 2 lecturas consecutivas</p><div class="ulist"><ul><li><p>durante la precarga se realizaría el burst que puede ser mayor, menor o igual a la precarga</p></li></ul></div></li><li><p>El ciclo de bus de 100 ns son 1/100ns= 10MHz. Si transferimos un bit por ciclo de bus= 10Mbps</p></li><li><p>Si utilizamos 32 líneas en paralelo = 32 bits/transferencia x 10MT/s = 320Mbps = 40 MB/s</p></li></ul></div></li><li><p>Sol:</p><div class="olist lowerroman"><ol class="lowerroman" type="i"><li><p>tcycle = 100ns. BW=10Mbps</p></li><li><p>40MB/s</p></li></ol></div></li></ul></div></li></ol></div></li><li><p>Figure 5.6 indicates how to construct a module of chips that can store 1 MByte based on a group of four 256-Kbyte chips. Let’s say this module of chips is packaged as a single 1-Mbyte chip, where the word size is 1 byte. Give a high-level chip diagram of how to construct an 8-Mbyte computer memory using eight 1-Mbyte chips. Be sure to show the address lines in your diagram and what the address lines are used for.</p><div class="ulist"><ul><li><p>Desarrollo:</p><div class="ulist"><ul><li><p>Con 4 chips de 256Kbit creo un módulo-chip de 1Mb</p></li><li><p>Con 8 chips de 1Mb creo un módulo de 8Mb llevando distintos chip select a cada chip de 1Mb. Para seleccionar 1 chip de 8 necesito 3 bits de direcciones, por ejemplo los 3 bits de mayor posición. Para direccionar un bit de un chip 1Mb necesito un bus de direcciones de 20 bits. En total necesito un bus de 20+3=23 bits.</p></li></ul></div></li><li><p>Sol:</p><div class="olist lowerroman"><ol class="lowerroman" type="i"><li><p>8 chips x1 de capacidad 1M donde cada entrada chip-select es la salida de un decodificador de 3 líneas de dirección</p></li></ol></div></li></ul></div></li><li><p>On a typical Intel 8086-based system, connected via system bus to DRAM memory, for a read operation, RAS is activated by the trailing edge of the Address Enable signal (Figure 3.19). However, due to propagation and other delays, RAS does not go active until 50 ns after Address Enable returns to a low. Assume the latter occurs in the middle of the second half of state T1 (somewhat earlier than in Figure 3.19). Data are read by the processor at the end of T3. For timely presentation to the processor, however, data must be provided 60 ns earlier by memory. This interval accounts for propagation delays along the data paths (from memory to processor) and processor data hold time requirements. Assume a clocking rate of 10 MHz.</p><div class="olist lowerroman"><ol class="lowerroman" type="i"><li><p>How fast (access time) should the DRAMs be if no wait states are to be inserted?</p></li><li><p>How many wait states do we have to insert per memory read operation if the access time of the DRAMs is 150 ns?</p><div class="ulist"><ul><li><p>Desarrollo:</p><div class="ulist"><ul><li><p>Ciclo de lectura</p><div class="ulist"><ul><li><p>Load address - Address Enable (EA)- Address Command - Access Data</p></li><li><p>Trailing edge = fall edge = negative edge</p></li><li><p>AE fall = en la segunda mitad del ciclo T1. Instante 75ns</p></li><li><p>RAS = Read Command : Retardo de 50ns respecto de AE fall. Instante 75+50=125ns</p></li><li><p>La presentación del dato en el bus debe ser realizada con 60 ns de antelación a la carga del dato en la CPU la final del ciclo T3(300ns), es decir, 300ns-60ns=240ns</p></li><li><p>Reloj del bus del sistema = 10 MHz = 100 ns.</p><div class="olist upperalpha"><ol class="upperalpha" type="A"><li><p>Tiempo de acceso (desde la orden de lectura hasta volcar el dato la memoria) sin estados de espera = Tiempo de acceso mínimo impuesto por los retardos de la ruta de datos (CPU y bus): 240ns - 125ns = 115ns</p><div class="listingblock"><div class="content"><pre>                       0                                    300ns
                       &lt;-----T1----&gt;&lt;-----T2----&gt;&lt;-----T3----&gt;
                       -----        -----        -----        -----        -----
Clock           ------/     \------/     \------/     \------/     \------/     \------
                          75ns
                      &lt;--------&gt;
                            ----
Address Enable  -----------/    \-----------------------------------------
                                     50ns
                                 &lt;--------&gt;
                                     ------
Read            --------------------/      \--------------------------------
                                           Acces Time Hold Time
                                           &lt;--------&gt;&lt;--------&gt;
Data            -------------------------------------XXXXXXXXXX----------
                                           &lt;--------&gt;&lt;--------&gt;
                                              115ns     60ns
                                  &lt;----------------------------&gt;
                                           Read cycle</pre></div></div></li><li><p>Si la memoria DRAM tiene un tiempo de acceso 150ns, superior a un ciclo de bus, desde la orden de lectura la cpu debe de esperar dos ciclos de reloj, uno el propio ciclo de la orden de lectura y otro ciclo extra o ciclo de ESPERA. Por lo que 200ns son suficientes para superar los 150ns del tiempo de acceso. Si el ciclo de espera comienza después de los 115ns, tenemos 215ns que superan a los 150ns.</p></li></ol></div></li></ul></div></li></ul></div></li><li><p>Sol:</p></li></ul></div></li><li><p>115ns</p></li><li><p>1</p></li></ol></div></li></ol></div></div></section><section id="_capitulo_7_sistemas_entradasalida"><h2>10.11. Capitulo 7: Sistemas Entrada/Salida</h2><div class="slide-content"><div class="ulist"><ul><li><p>7.1 On a typical microprocessor, a distinct I/O address is used to refer to the I/O data registers and a distinct address for the control and status registers in an I/O controller for a given device. Such registers are referred to as ports. In the Intel 8088, two I/O instruction
formats are used. In one format, the 8-bit opcode specifies an I/O operation; this is followed by an 8-bit port address. Other I/O opcodes imply that the port address is in the 16-bit DX register. How many ports can the 8088 address in each I/O addressing mode? .</p><div class="ulist"><ul><li><p>Desarrollo:</p><div class="ulist"><ul><li><p>memory mapped i/o : se reservan direcciones RAM para i/o</p></li><li><p>controlador i/o: registros datos, estado y control : puerto</p></li><li><p>2 formatos</p><div class="ulist"><ul><li><p>CodOP/Address(Dir Directo)  : 8bits/8bits</p></li><li><p>CodOP/DX Register(Dir Indirecto)  : 8bits/8bits &#8594; DX:16bits</p></li><li><p>Número de puertos : Directo &#8594; 2<sup>8</sup> e Indirecto &#8594; 2<sup>16</sup> &#8658; total= 256+65536=65792 ports</p></li></ul></div></li></ul></div></li><li><p>Sol:</p><div class="ulist"><ul><li><p>65792 puertos</p></li></ul></div></li></ul></div></li><li><p>7.2 A similar instruction format is used in the Zilog Z8000 microprocessor family. In this case, there is a direct port addressing capability, in which a 16-bit port address is part of the instruction, and an indirect port addressing capability, in which the instruction references one of the 16-bit general purpose registers, which contains the port address. How many ports can the Z8000 address in each I/O addressing mode?</p><div class="ulist"><ul><li><p>Desarrollo</p><div class="ulist"><ul><li><p>Modo directo: 2<sup>16</sup> = 64K = 65536 ports</p></li><li><p>Modo indirecto: 2<sup>16</sup> = 64 K = 65536 ports</p></li></ul></div></li><li><p>Sol</p><div class="ulist"><ul><li><p>128K=131072 puertos</p></li></ul></div></li></ul></div></li><li><p>7.5 A system is based on an 8-bit microprocessor and has two I/O devices. The I/O controllers for this system use separate control and status registers. Both devices handle data on a 1-byte-at-a-time basis.The first device has two status lines and three control lines.The second device has three status lines and four control lines.</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>How many 8-bit I/O control module registers do we need for status reading and control of each device?</p></li><li><p>What is the total number of needed control module registers given that the first device is an output-only device?</p></li><li><p>How many distinct addresses are needed to control the two devices?</p><div class="ulist"><ul><li><p>modelo: El controlador i/o de los perifericos tiene implementados los puertos que son la interfaz con el periférico. Los puertos son direccionables y estan formados por un banco de registros: registro de datos, registro de control, registro de estado.</p></li></ul></div></li></ol></div></li><li><p>Desarrollo:</p><div class="ulist"><ul><li><p>buffer data de 8 bits: 2 puertos de datos (in,out) por cada periférico.</p></li><li><p>1 buffer status de lectura (registro de estado) y 1 buffer control de escritura (registro de control) por cada periférico</p></li><li><p>las líneas de estado y control no son líneas de direccionamiento,sino que serán líneas conectadas a sus respectivos puertos. Las líneas de estado a 1 registro de estado y las líneas de control a 1 registro de control.</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>: 1 registro de control y 1 registro de estado por cada periférico</p></li><li><p>: periférico A (1Data+1Status+1Control) y  periférico B (2Data+1Status+1Control) = 7 registros</p></li><li><p>: tantas direcciones como registros = 7 direcciones</p></li></ol></div></li></ul></div></li><li><p>Sol:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>1 reg control y 1 reg estado</p></li><li><p>7 registros</p></li><li><p>7 direcciones</p></li></ol></div></li><li><p>7.6 For programmed I/O, Figure 7.5 indicates that the processor is stuck in a wait loop doing status checking of an I/O device. To increase efficiency, the I/O software could be written so that the processor periodically checks the status of the device. If the device is not ready, the processor can jump to other tasks. After some timed interval, the processor comes back to check status again.</p><div class="imageblock"><img src="./images/ejercicios/7-5.png" alt="7 5" /></div>
<div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Consider the above scheme for outputting data one character at a time to a printer that operates at 10 characters per second (cps).What will happen if its status is scanned every 200 ms?</p></li><li><p>Next consider a keyboard with a single character buffer. On average, characters are entered at a rate of 10 cps. However, the time interval between two consecutive key depressions can be as short as 60 ms. At what frequency should the keyboard be scanned by the I/O program?</p></li></ol></div></li><li><p>Desarrollo:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>10cps &#8594; El periférico necesita transmitir 1 caracter cada 100ms y escribe en el puerto dicho dato. Si la CPU no salva el dato escrito por el periférico antes de cada escritura, los datos se pierden. Si la CPU consulta cada 200ms y el periférico escribe cada 100ms, cada dos datos uno se pierde. La solución sería aumentar el buffer de datos a dos carácteres o aumentar la frecuencia de consulta a períodos de 100ms.</p></li><li><p>La velocidad media es de 10cps pero la frecuencia máxima es de 60ms. La frecuencia de escaneo de la CPU tiene que ser como mínimo de 1/60ms &#8594; 16.66Hz</p></li></ol></div></li><li><p>7.10 Consider a system employing interrupt-driven I/O for a particular device that transfers data at an average of 8 KB/s on a continuous basis.</p><div class="olist loweralpha"><ol class="loweralpha"><li><p>Assume that interrupt processing takes about 100 us (i.e., the time to jump to the interrupt service routine (ISR), execute it, and return to the main program). Determine what fraction of processor time is consumed by this I/O device if it interrupts for every byte.</p></li><li><p>Now assume that the device has two 16-byte buffers and interrupts the processor when one of the buffers is full. Naturally, interrupt processing takes longer, because the ISR must transfer 16 bytes.While executing the ISR, the processor takes about 8 us for the transfer of each byte. Determine what fraction of processor time is consumed by this I/O device in this case.</p></li><li><p>Now assume that the processor is equipped with a block transfer I/O instruction such as that found on the Z8000.This permits the associated ISR to transfer each byte of a block in only 2 us. Determine what fraction of processor time is consumed by this I/O device in this case.</p></li></ol></div></li><li><p>Desarrollo:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>8kB/s &#8594; T_int_rq=1/8KB/s=125us &#8594; fracción=100us/125us=80%</p></li><li><p>T_interrupt_service=100us(ISR+1byte)+15bytesx8us=220us &#8594; T_16=16x125us=2ms &#8594; fracción=220us/2000us=0.11=11%</p></li><li><p>T_int_serv=100us(ISR+1byte)+15bytesx2us=130us &#8594; fracción=130us/2000us=6.5%</p></li></ol></div></li><li><p>7.11 In virtually all systems that include DMA modules, DMA access to main memory is given higher priority than CPU access to main memory. Why?</p><div class="ulist"><ul><li><p>Si el buffer de datos del DMAC se llena y no es leído, se perderían los datos.</p></li></ul></div></li><li><p>7.12 A DMA module is transferring characters to memory using cycle stealing, from a device transmitting at 9600 bps. The processor is fetching instructions at the rate of 1 million instructions per second (1 MIPS). Suponer que la CPU está continuamente capturando instrucciones (no captura datos). By how much will the processor be slowed down due to the DMA activity?</p><div class="ulist"><ul><li><p>1MIPS &#8594; 1 instrucción cada microsegundo. Como la CPU está continuamente capturando instrucciones tendrá ocupado el bus durante 1 microsegundo para captar cada instrucción y completar el ciclo de instrucción, por lo que el ciclo del bus del sistema es 1us.</p></li><li><p>1 character = 8 bits</p></li><li><p>9600 bps &#8594; 1200 bytes/s &#8594; 1/1200 seg/byte =833us/byte &#8594; cada byte se transfiere por robo de ciclo. Se roba el bus del sistema cada 833us, es decir, cada 833 ciclos del bus del sistema.</p></li><li><p>El bus del sistema lo tiene el DMAC durante un ciclo, es decir, 1 us.</p></li><li><p>Cada 833 ciclos el DMAC roba 1 &#8594; 1/833 &#8594; 0.12%</p></li><li><p>1MIPSx(1-0.0012)=998800 instrucciones por segundo.</p></li></ul></div></li><li><p>7.13 Consider a system in which bus cycles takes 500 ns. Transfer of bus control in either direction, from processor to I/O device or viceversa, takes 250 ns. One of the I/O devices has a data transfer rate of 50 KB/s and employs DMA. Data are transferred one byte at a time.</p><div class="olist loweralpha"><ol class="loweralpha"><li><p>Suppose we employ DMA in a burst mode. That is, the DMA interface gains bus mastership prior to the start of a block transfer and maintains control of the bus until the whole block is transferred. For how long would the device tie up the bus when transferring a block of 128 bytes?</p></li><li><p>Repeat the calculation for cycle-stealing mode.</p></li></ol></div></li><li><p>Desarrollo:</p><div class="ulist"><ul><li><p>500ns dura el ciclo del bus del sistema</p></li><li><p>T<sub>tx</sub>=1/50KB=20us/B. El DMA  según recibe el dato del periférico lo transfiere a la memoria principal, transfiriendo datos a través del bus del sistema a la misma velocidad del periférico. Sólo tiene sentido en periféricos de alta velocidad.</p><div class="olist loweralpha"><ol class="loweralpha"><li><p>Modo ráfaga: T=t<sub>acceso_bus</sub>+t<sub>bus_io_transferencia_bloque</sub>+t<sub>liberar_bus</sub>=250ns+128x20us+250ns=2560us</p></li><li><p>Robo de ciclo T=128x(t<sub>acceso_bus</sub>+t<sub>bus_io_transferencia_byte</sub>+t<sub>liberar_bus</sub>)=128x(250ns+20us+250ns)=128x20.5us=2624us</p></li></ol></div></li></ul></div></li><li><p>7.16 A DMA controller serves four receive-only telecommunication links (one per DMA channel) having a speed of 64 Kbps each.</p><div class="olist loweralpha"><ol class="loweralpha"><li><p>Would you operate the controller in burst mode or in cycle-stealing mode?</p></li><li><p>What priority scheme would you employ for service of the DMA channels?</p></li></ol></div></li><li><p>Desarrollo:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Ahora el DMAC tendrá cuatro bufferes de datos y podría acceder al bus de la misma forma que con uno. Debido a que los enlaces de telecomunicaciones ocupan el canal de forma continua (voz o datos), todo el tiempo que dura la comunicaión, el modo ráfaga ocuparía el bus el 100% del tiempo. Por lo que seleccionamos el robo de ciclo.</p></li><li><p>Prioridad entre 4 clientes: misma prioridad ya que tienen la misma velocidad. Si tuviesen diferentes velocidades, tendría mayor velocidad el más rápido, el de mayor tráfico.</p></li></ol></div></li><li><p>7.17 A 32-bit computer has two selector channels and one multiplexor channel. Each selector channel supports two magnetic disk and two magnetic tape units. The multiplexor channel has two line printers, two card readers, and 10 VDT terminals connected to it. Assume the following transfer rates:</p><div class="ulist"><ul><li><p>Disk drive 800 KBytes/s</p></li><li><p>Magnetic tape drive 200 KBytes/s</p></li><li><p>Line printer 6.6 KBytes/s</p></li><li><p>Card reader 1.2 KBytes/s</p></li><li><p>VDT 1 KBytes/s</p></li><li><p>Estimate the maximum aggregate I/O transfer rate in this system.</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Los dos canales selector tienen los mismos periféricos. Un canal selector está permanentemente asignado a sus periféricos y sólo puede dar servicio a uno de los periféricos asignados. El multiplexor en cambio da servicio a todos &#8594; Rate=800+800+2x6.6+2x1.2+10x1=1625.6KB/s</p></li></ol></div></li></ul></div></li><li><p>7.18 A computer consists of a processor and an <em>I/O device D</em> connected to <em>main memory M</em> via a shared bus with a data bus width of one word. The processor can execute a maximum of 10<sup>6</sup> instructions per second. An average instruction requires five machine cycles, three of which use the memory bus. A memory read or write operation uses one machine cycle. Suppose that the processor is continuously executing “background” programs that require 95% of its instruction execution rate but not any I/O instructions, es decir, el 5% son instrucciones I/O si utiliza mecanismo e/s por programa. Assume that one processor cycle equals one bus cycle. Now suppose the I/O device is to be used to transfer very large blocks of data between M and D.</p><div class="olist loweralpha"><ol class="loweralpha"><li><p>If programmed I/O is used and each one-word I/O transfer requires the processor to execute two instructions, estimate the maximum I/O data-transfer rate, in words per second, possible through D.</p></li><li><p>Estimate the same rate if DMA is used.</p></li></ol></div></li><li><p>Desarrollo:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Mecanismo E/S por programa</p><div class="olist lowerroman"><ol class="lowerroman" type="i"><li><p>La transferencia se realiza por programa y lo realiza la CPU. La transferencia de 1 palabra requiere la ejecución de dos instrucciones.</p></li><li><p>1 instrucción=3 ciclos máquina con el memory bus</p></li><li><p>Como el ciclo de bus equivale a un ciclo máquina &#8594; 3 ciclos de bus con el memory bus &#8594; La transferencia de una palabra requiere 3 ciclos de bus&#8594; En cada ciclo de bus se transfiere un tercio de la palabra.</p></li><li><p>Los programas en background requieren el 95% de instrucciones a la CPU, dejando el 5% de instrucciones para I/O</p></li><li><p>Del 5% de instrucciones i/o el 2.5% son transferencias ya que hacen falta dos instrucciones i/o por transferencia.</p></li><li><p>T_transfer(1word)= 0.025x10<sup>6</sup> instrucciones<sub>io</sub>/seg= 25000words/seg</p></li></ol></div></li><li><p>DMA:</p><div class="olist lowerroman"><ol class="lowerroman" type="i"><li><p>Observamos el tiempo que la CPU no utiliza el bus del sistema= 5% de instrucciones (5 ciclos por instrucción) MÁS  el 95% de instrucciones (2ciclos por instrucción).</p></li><li><p>El 5% de ejecución de CPU, la CPU esta libre :10<sup>6</sup>(inst/seg)x0.05x5(ciclos/instr)= 250000 ciclos/seg de procesador que utiliza el DMA= 250000 ciclos/seg de i/o que utiliza el DMA</p></li><li><p>El 95% de ejecución de CPU, el DMA comparte bus del sistema=10<sup>6</sup>x0.95x2 ciclos libres de los 5 ciclos= 1900000 ciclos/seg de cpu= 1900000 ciclos/seg i/o</p></li><li><p>Total=1900000+250000=2.150.000 ciclos/seg bus i/o</p></li><li><p>Si en cada ciclo se puede realizar una transferencia, esa sería la velocidad máxima. La CPU no realiza la operación de acceso a memoria, la realiza el controlador de memoria.</p></li></ol></div></li></ol></div></li></ul></div></div></section><section id="_capitulo_8_operating_system"><h2>10.12. Capitulo 8: Operating System</h2><div class="slide-content"><div class="ulist"><ul><li><p>8.3 A program computes the row sums Ci=Sum[aij] para j=1,n of an array A that is 100 by 100. Assume that the computer uses demand paging with a page size of 1000 words, and that the amount of main memory allotted for data is five page frames. Is there any difference in the page fault rate if A were stored in virtual memory by rows or columns? Explain.</p><div class="ulist"><ul><li><p>Matriz A = 100x100 palabras = 10000 palabras</p></li><li><p>Memoria: 5 marcos de páginas : 5000 palabras</p></li><li><p>Proceso: 10000 palabras se dividirá en 10000/1000=10 páginas</p></li><li><p>Almacenamiento por <em>filas</em></p></li><li><p>1ª  página: a1_1,a1_2,..,a1_100,a2_1,..,a2_100,..,..,a10_1,..,a10_100 &#8594; diez filas</p></li><li><p>5ª  página: a41_1,..,..,a50_100</p></li><li><p>10ª página: a91_1 ,..,..,a100_100</p></li><li><p>xª  página: desde a10*(x-1)+1_1 hasta a10*x_1 &#8594; diez filas</p></li><li><p>Ejecución primera fila: C1=SUM[a1j] j=1,100</p><div class="ulist"><ul><li><p>Demand Paging:</p><div class="ulist"><ul><li><p>La MP está vacía, ningún marco de página inicializado, todas las páginas en disco, sin copia en los marcos de la MPrincipal.</p></li><li><p>captura de a11 &#8594; FAULT (no está en MP, está en disco)&#8594; copia 1ª página &#8594; obtiene C1</p></li></ul></div></li></ul></div></li><li><p>Ejecución C2 &#8594; a21 sí está en la primera página &#8594; obtiene C2</p></li><li><p>Ejecución C3,..,C10 &#8594; ningún fault ya que están en la primera página</p></li><li><p>Ejecución C11 &#8594; FAULT &#8594; copio la 2ª página</p></li><li><p>Ejecución C21 &#8594; FAULT &#8594; copio la 3ª página</p></li><li><p>FAULTS: C1,C11,C21,..,C91</p></li><li><p>Cada vez que se ejecutan las 100 filas Ci se producen 10 Fallos</p></li><li><p>El resultado hubiese sido el mismo si en lugar de 5 páginas hubiese tenido una página si la política de reemplazo es la FIFO</p></li><li><p>se podrían utilizar 4 marcos de página con los mismos datos y realizar los reemplazos en el mismo marco.</p></li></ul></div></li><li><p>Almacenamiento por <em>columnas</em> :</p><div class="ulist"><ul><li><p>1ª  página: a1_1,a2_1,..,a100_1,a1_2,..,a100_2,..,..,a1_10,..,a100_10 &#8594; diez columnas</p></li><li><p>xª  página: desde a1_10*(x-1)+1 hasta a100_10*x &#8594; diez columnas</p><div class="ulist"><ul><li><p>Ejecución 1ª fila: C1=SUM[a1j] j=1,100</p><div class="ulist"><ul><li><p>necesito cargar las 100 columnas de la fila 1 &#8594; necesito 10 páginas con diez columnas por página &#8594; 10 FAULTS</p></li></ul></div></li><li><p>Ejecución nª fila: se necesitan 100 columnas que están distribuidas por páginas de 10 en 10 columnas. &#8594; hacen falta 10 páginas &#8594; 10 FAULTS</p></li></ul></div></li><li><p>Cada vez que se ejecutan las 100 filas Ci : 10 Faults por fila &#8594; 1000 FAULTS</p></li></ul></div></li><li><p>8.4 Consider a fixed partitioning scheme with equal-size partitions of 2<sup>16</sup> bytes and a total main memory size of 2<sup>24</sup> bytes. A process table is maintained that includes a pointer to a partition for each resident process. How many bits are required for the pointer?</p><div class="ulist"><ul><li><p>Las tablas de descriptores están formadas por el índice y el contenido que en este caso es un puntero.</p></li><li><p>2<sup>24</sup>/2<sup>16</sup>=2<sup>8</sup> particiones de la memoria</p></li><li><p>Tamaño de 2<sup>16</sup> &#8594; direcciones que terminan en hexadecimal en 0000 &#8594; direcciones k*2<sup>16</sup>&#8594;0xnn0000</p></li><li><p>puntero: solo es necesario guardar los dos dígitos nn de mayor peso &#8594; 8 bits</p><div class="ulist"><ul><li><p>luego se desplazan 16 bits a a la izda para tener la dirección base</p></li></ul></div></li></ul></div></li><li><p>8.6 Suppose the page table for the process currently executing on the processor looks like the following. All numbers are decimal, everything is numbered starting from zero, and all addresses are memory byte addresses. The page size is 1024 bytes.</p></li></ul></div>
<div class="imageblock" style="text-align: center"><img src="./images/ejercicios/8_6.png" alt="VM" /></div><div class="title">Figure 93. VM</div>
<div class="ulist"><ul><li><p>.</p><div class="olist loweralpha"><ol class="loweralpha"><li><p>Describe exactly how, in general, a virtual address generated by the CPU is translated into a physical main memory address.</p><div class="ulist"><ul><li><p>La dirección virtual esta formada por los campos (VPN,VPO) &#8594; (base,offset). Mediante la tabla de paginas virtuales traducimos VPN en PPN. La dirección física es el par (PPN,PPO) donde el offset PPO=VPO</p></li><li><p>Para qué este cacheada la página virtual en la tabla de páginas virtuales el bit de validación tiene que valer 1.</p></li></ul></div></li><li><p>What physical address, if any, would each of the following virtual addresses correspond to? (Do not try to handle any page faults, if any.)</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>1052</p><div class="ulist"><ul><li><p>VPN=Mod{1052/1024}=1 &#8594; Valid Bit=1 &#8594; PPN=7</p></li><li><p>VPO=Rest{1052/1024}=28</p></li><li><p>Dirección física = 7*1024+28=7196</p></li></ul></div></li><li><p>2221</p><div class="ulist"><ul><li><p>VPN=Mod{2221/1024}=2 &#8594; Valid Bit=0</p></li><li><p>No hay copia de esa página por lo que no se puede realizar la traducción</p></li></ul></div></li><li><p>5499</p><div class="ulist"><ul><li><p>VPN=Mod{5499/1024}=5 &#8594; Valid Bit=1 &#8594; PPN=0</p></li><li><p>VPO=Rest{1052/1024}=379</p></li><li><p>Dirección física = 0+379=379</p></li></ul></div></li></ol></div></li></ol></div></li><li><p>8.8 A process references five pages, A, B, C, D, and E, in the following order: A; B; C; D; A; B; E; A; B; C; D; E .Assume that the replacement algorithm is first-in-first-out and find the number of page transfers during this sequence of references starting with an empty main memory with three page frames. Repeat for four page frames.</p><div class="olist loweralpha"><ol class="loweralpha"><li><p>MP &#8594; 3 marcos de página ; política FIFO</p><div class="ulist"><ul><li><p>v/v/v; A&#8594; A/v/v ; B&#8594; A/B/v ; C&#8594; A/B/C; D&#8594; D/B/C; A&#8594; D/A/C; B&#8594; D/A/B; E&#8594; E/A/B ; A&#8594; E/A/B; B&#8594; E/A/B; C&#8594; E/C/B; D&#8594; E/C/D; E&#8594; E/C/D</p></li><li><p>10 Fallos</p></li></ul></div></li><li><p>MP &#8594; 4 marcos de página ; política FIFO</p><div class="ulist"><ul><li><p>v/v/v/v; A&#8594; A/v/v/v ; B&#8594; A/B/v/v ; C&#8594; A/B/C/v; D&#8594;A/B/C/D; A&#8594;A/B/C/D; B&#8594;A/B/C/D; E&#8594;E/B/C/D; A&#8594;E/A/C/D; B&#8594;E/A/B/D; C&#8594;E/A/B/C; D&#8594;D/A/B/C; E&#8594;D/E/B/C</p></li></ul></div></li></ol></div></li><li><p>8.9 The following sequence of virtual page numbers is encountered in the course of execution on a computer with virtual memory: 3 4 2 6 4 7 1 3 2 6 3 5 1 2 3 Assume that a least recently used page replacement policy is adopted. Plot a graph of page hit ratio (fraction of page references in which the page is in main memory) as a function of main-memory page capacity n for 1&#8656; n&#8656;8. Assume that main memory is initially empty.</p><div class="listingblock"><div class="content"><pre>Nº marcos | Fracción Aciertos| 3 4 2 6 4 7 1 3 2 6 3 5 1 2 3
     1    |         0        |
     2    |         0        |
     3    |      2/15        |   4     4     3     3
     4    |      3/15        |   4     4     3     3       3
     5    |      4/15        |   4     4     3 2   3     2 3
     6    |      7/15        |   4 2 6 4   1 3 2 6 3   1 2 3
     7    |      8/15        | 3 4 2 6 4   1 3 2 6 3   1 2 3
     8    |      8/15        | 3 4 2 6 4   1 3 2 6 3   1 2 3</pre></div></div></li><li><p>8.11 Suppose the program statement</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">for (i = 1; i &lt;= n; i++)
  a[i] = b[i] + c[i];</code></pre></div></div></li><li><p>is executed in a memory with page size of 1000 words. Let n = 1000. Using a machine that has a full range of register-to-register instructions and employs index registers, write a hypothetical program to implement the foregoing statement. Then show the sequence of page references during execution.</p><div class="ulist"><ul><li><p>En la memoria virtual estará tanto el código como los datos</p></li><li><p>Marcos de 1000 palabras.</p></li><li><p>Programa arquitectura load/store (espacio de direcciones virtual)</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">            SECCION CODIGO
            Ri &lt;- 1
            Ra &lt;- n
loop_start: R1 &lt;- b[Ri]
            R2 &lt;- c[Ri]
            R3 &lt;- R1+R2
            a[Ri] &lt;- R3
            Flags &lt;- Ri&lt;Ra
            Flags:PC &lt;- loop_start
            CPU &lt;- halt
            SECCION DATOS INICIALIZADOS
uno:        1
n:          1000
a:          array a[1000]
b:          array b[1000]
c:          array c[1000]</code></pre></div></div></li><li><p>Asignación del espacio virtual</p><div class="ulist"><ul><li><p>Código en la página PV1</p></li><li><p>array A ocupa una página &#8594; PV2</p></li><li><p>array B ocupa una página &#8594; PV3</p></li><li><p>array C ocupa una página &#8594; PV4</p></li><li><p>uno y n en una página de tipo datos &#8594; PV5</p></li></ul></div></li><li><p>Ejecución</p><div class="ulist"><ul><li><p>1515(131411211)<sup>1000</sup>11</p></li></ul></div></li></ul></div></li><li><p>8.13 Consider a computer system with both segmentation and paging. When a segment is in memory, some words are wasted on the last page. In addition, for a segment size s and a page size p, there are s/p page table entries. The smaller the page size, the less waste in the last page of the segment, but the larger the page table. What page size minimizes the total overhead?</p><div class="ulist"><ul><li><p>Desarrollo:</p><div class="olist loweralpha"><ol class="loweralpha"><li><p>Número de páginas por segmento: tamaño del segmento/ tamaño de página = s/p</p></li><li><p>Cada segmento tiene su propia tabla de páginas</p></li><li><p>Si reducimos el tamaño de página se reduce la fragmentación interna pero se incrementa el número de entradas de la tabla de páginas.</p></li><li><p>El Total de palabras desperdiciadas (w) es el desperdicio debido a las últimas páginas de cada segmento más el tamaño de la tabla de págincas. El valor medio de la fragmentación interna de todos los segmentos es p/2 y el tamaño de la tabla de páginas es proporcional al número de entradas de la tabla s/p &#8594; w=p/2+s/p &#8594; dw/dp=1/2-s/p<sup>2</sup>=0 &#8594; p<sup>2</sup>=2s</p></li></ol></div></li></ul></div></li><li><p>8.14 A computer has a cache, main memory, and a disk used for virtual memory. If a referenced word is in the cache, 20 ns are required to access it. If it is in main memory but not in the cache, 60 ns are needed to load it into the cache, and then the reference is started again. If the word is not in main memory, 12 ms are required to fetch the word from disk, followed by 60 ns to copy it to the cache, and then the reference is started again. The cache hit ratio is 0.9 and the main-memory hit ratio is 0.6. What is the average time in ns required to access a referenced word on this system?</p><div class="ulist"><ul><li><p>T=hit_cache*t_acc_ca+(1-hit_cache)<strong>hit_main</strong>(t_main_cache+t_acc_ca)+(1-hit_cache)<strong>(1-hit_main)</strong>(t_acc_disk_main+t_main_cache+t_acc_ca)=
= 0.9*20+0.1*0.6*(60+20)+0.1*0.4*(12000000+60+20)=480us</p></li></ul></div></li><li><p>8.15 Assume a task is divided into four equal-sized segments and that the system builds an eight-entry page descriptor table for each segment. Thus, the system has a combination of segmentation and paging. Assume also that the page size is 2 Kbytes.</p><div class="olist loweralpha"><ol class="loweralpha"><li><p>What is the maximum size of each segment?</p></li><li><p>What is the maximum logical address space for the task?</p></li><li><p>Assume that an element in physical location 00021ABC is accessed by this task. What is the format of the logical address that the task generates for it? What is the maximum physical address space for the system?</p><div class="ulist"><ul><li><p>Desarrollo:</p><div class="olist upperalpha"><ol class="upperalpha"><li><p>Tabla de PAGINAS: 8 entradas : 8 paginas virtuales de 2KB &#8594; Segmento:8*2KB=16KB.</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>No dice nada pero &#8230;&#8203; La tabla de SEGMENTOS tendrá una entrada por segmento. Cada entrada de segmento apuntará a una tabla de página diferente. Una tabla de página por segmento.</p></li></ol></div></li><li><p>Proceso: 4 segmentos &#8594; 4*16KB=64KB</p></li><li><p>Dirección lógica &#8594; Formato (Segmento,Pagina,VPO) &#8594; (4seg,8pag,2KB)&#8594; (2bits,3bits,11bits)&#8594; Dirección lógica de 16 bits</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Dirección física &#8594; 00021ABC &#8594; 8 digitos hex &#8594; 32 bits &#8594; 4GB</p></li><li><p>Marcos de página &#8594; 4GB/2KB &#8594; 2*2<sup>20</sup> marcos</p></li><li><p>00021ABC &#8594; 0000-0000-0000-0010-0001-1010-1011-1100 &#8594; marco/offset &#8594; 21/11 &#8594; 000000000000001000011 / 01010111100 &#8594; marco 67/ offset 700</p></li></ol></div></li><li><p>Traducción: El offset virtual y físico idénticos (11bits) &#8594; El segmento lógico (2bits) apunta a una tabla de páginas. La página virtual (3bits) es el offset de la tabla de páginas. Cada entrada de la tabla de páginas es un puntero a un marco de la memoria principal ( una dirección base de 21 bits). Se añadir la pregunta de inventarse la tabla de descripción de segmentos y las cuatro tablas de páginas de cada segmento. En este ejercicio la dirección lógica tendrá el offset  01010111100 y los 5 bits del par seg/página no se pueden saber ya que haría falta saber en que tabla y posición está el puntero al marco 67.</p></li></ol></div></li></ul></div></li></ol></div></li><li><p>8.16 Assume a microprocessor capable of accessing up to 2<sup>32</sup> bytes of physical main memory. It implements one segmented logical address space of maximum size 2<sup>31</sup> bytes. Each instruction contains the whole two-part address. External memory management units (MMUs) are used, whose management scheme assigns contiguous blocks of physical memory of fixed size 2<sup>22</sup> bytes to segments. The starting physical address of a segment is always divisible by 1024. Show the detailed interconnection of the external mapping mechanism that converts logical addresses to physical addresses using the appropriate number of MMUs, and show the detailed internal structure of an MMU (assuming that each MMU contains a 128-entry directly mapped segment descriptor cache) and how each MMU is selected.</p><div class="ulist"><ul><li><p>un espacio virtual segmentado de 2<sup>31</sup> bytes: no es el espacio virtual de cada segmento sino el de todos los segmentos.</p></li><li><p>dirección lógica con dos partes &#8594; (segmento,offset)</p></li><li><p>MP: Espacio de 2<sup>32</sup> bytes con Bloques de 2<sup>22</sup> bytes contiguos para cada segmento</p><div class="ulist"><ul><li><p>offset de 22 bits</p></li><li><p>2<sup>31</sup>/2<sup>22</sup> = 2<sup>9</sup> segmentos en espacio virtual &#8594; 9 bits para el segmento en la dirección virtual y una tabla de segmentos con 512 entradas</p></li><li><p>Dirección lógica de 31 bits (9,22) &#8594; (seg,offset)</p></li></ul></div></li><li><p>MP: segmentos alineados en multiplos de 1K</p><div class="ulist"><ul><li><p>segmento físico:los 10 bits de menor peso son cero y los 22 de mayor peso están en la <em>tabla de segmentos</em>.</p></li><li><p>Dirección física: segmento+offset</p></li></ul></div></li><li><p>MMU: <em>tabla de segmentos</em> de 128 entradas (2<sup>7</sup>)</p><div class="olist loweralpha"><ol class="loweralpha"><li><p>no tenemos una tabla con 512 entradas sino cuatro tablas de 128 cada una.</p></li><li><p>cantidad de MMUs: Si tenemos 2<sup>9</sup> segmentos en el espacio virtual y la MMU tiene una tabla de 2<sup>7</sup> necesitaremos 4 MMUs.</p></li><li><p>Traducción: espacio lógico (9,22)(seg,offset) en una dirección segmento+offset de 32 bits.</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>De los 9 bits de segmento virtual, dos bits seleccionaran la MMU y otros siete bits la entrada de la tabla de segmentos. (2,7,22)</p></li><li><p>los 9 bits de segmento lógico son el índice de la tabla de segmentos que contiene los 22 bits altos de un segmento físico.</p></li><li><p>El offset físico también tiene un tamaño de 22 bits</p></li><li><p>dirección física: dirección base múltiplo de 1K más offset de 22bits.</p></li></ol></div></li></ol></div></li></ul></div></li><li><p>8.17 Consider a paged logical address space (composed of 32 pages of 2 Kbytes each) mapped into a 1-Mbyte physical memory space.</p><div class="olist loweralpha"><ol class="loweralpha"><li><p>What is the format of the processor’s logical address?</p></li><li><p>What is the length and width of the page table (disregarding the “access rights” bits)?</p></li><li><p>What is the effect on the page table if the physical memory space is reduced by half?</p><div class="ulist"><ul><li><p>Desarrollo:</p></li><li><p>MP : 1MB con páginas de 2KB &#8594; 2<sup>20</sup>/2<sup>11</sup> = 2<sup>9</sup> marcos de página</p><div class="olist upperalpha"><ol class="upperalpha"><li><p>VPN/OFFSET &#8594; VPN:32 páginas supone 2<sup>5</sup>, 5 bits ; OFFSET:2KB supone 2<sup>11</sup>, 11bits</p></li><li><p>Tabla de páginas: longitud igual al número de paginas virtuales= 32 y anchura igual al puntero a uno de los 2<sup>9</sup> marcos, es decir, 9 bits.</p></li><li><p>Si se reduce la MP a la mitad, se reduce el número de marcos a la mitad también &#8594; 2<sup>8</sup> marcos de página &#8594; anchura de 8 bits.</p></li></ol></div></li></ul></div></li></ol></div></li><li><p>Randal Capítulo 9: Figure 9.19 shows the formats of the virtual and physical addresses. Since each page is 26 =64 bytes, the low-order 6 bits of the virtual and physical addresses serve as the VPO and PPO respectively.The high-order 8 bits of the virtual address serve as the VPN. The high-order 6 bits of the physical address serve as the PPN. Figure 9.20 shows a snapshot of our little memory system, including the TLB (Figure 9.20(a)), a portion of the page table (Figure 9.20(b)), and the L1 cache (Figure 9.20(c)). Above the figures of the TLB and cache, we have also shown how the bits of the virtual and physical addresses are partitioned by the hardware as it accesses these devices.</p><div class="imageblock"><img src="./images/ejercicios/randal_9-19.png" alt="randal 9 19" /></div>
<div class="imageblock"><img src="./images/ejercicios/randal_9-20.png" alt="randal 9 20" /></div>
<div class="ulist"><ul><li><p>Given this initial setup, let’s see what happens when the CPU executes a load instruction that reads the byte at address 0x03d4</p></li><li><p>Solución</p><div class="ulist"><ul><li><p>TLBI:0x03</p></li><li><p>TLBT:0x3</p></li><li><p>VPN:0x0f</p></li><li><p>VPO:0x14</p></li><li><p>PPN=0x0D</p></li><li><p>physical address=0x354</p></li><li><p>CO=0x0</p></li><li><p>CI=0x5</p></li><li><p>CT=0x0D</p></li><li><p>Data=0x36</p></li></ul></div></li></ul></div></li></ul></div></div></section><section id="_capitulo_12_processor_structure_and_function_capitulo_14_en_9ªed"><h2>10.13. Capitulo 12: Processor Structure and Function (Capitulo 14 en 9ªEd)</h2><div class="slide-content"><div class="ulist"><ul><li><p>12.1 a. If the last operation performed on a computer with an 8-bit word was an addition in which the two operands were 00000010 and 00000011, what would be the value of the following flags?</p><div class="ulist"><ul><li><p>Carry</p></li><li><p>Zero</p></li><li><p>Overflow &#8594; Número con signo</p></li><li><p>Sign</p></li><li><p>Even Parity &#8594; Paridad PAR</p></li><li><p>Half-Carry</p></li><li><p>Desarrollo</p><div class="ulist"><ul><li><p>0010+0011=0101 &#8594; No hay llevada en el MSB, el resultado no es cero, no hay overflow, positivo, número de unos PAR,  no hay llevada en el bit de posición 3. Por lo que todos los flags desactivados excepto el de paridad par . El flag parity estará a 1.</p></li></ul></div></li></ul></div></li><li><p>12.3 A microprocessor is clocked at a rate of 5 GHz.</p><div class="olist loweralpha"><ol class="loweralpha"><li><p>How long is a clock cycle?</p></li><li><p>What is the duration of a particular type of machine instruction consisting of three clock cycles?</p><div class="ulist"><ul><li><p>Desarrollo</p><div class="ulist"><ul><li><p>a. T= 1/f = 1/(5*10<sup>9</sup>)=0.2ns</p></li><li><p>b.  3T= 3*0.2=0.6ns</p></li></ul></div></li></ul></div></li></ol></div></li><li><p>12.4 A microprocessor provides an instruction capable of moving a string of bytes from one area of memory to another. The fetching and initial decoding of the instruction takes 10 clock cycles. Thereafter, it takes 15 clock cycles to transfer each byte. The microprocessor is clocked at a rate of 10 GHz.</p><div class="olist loweralpha"><ol class="loweralpha"><li><p>Determine the length of the instruction cycle for the case of a string of 64 bytes.</p></li><li><p>What is the worst-case delay for acknowledging an interrupt if the instruction is noninterruptible?</p></li><li><p>Repeat part (b) assuming the instruction can be interrupted at the beginning of each byte transfer</p><div class="ulist"><ul><li><p>Desarrollo</p><div class="ulist"><ul><li><p>a) IC=Instruction Cycle= FI+DI+CO+FO+EI+WO; FI+DI=10T ; CO+FO= 0 ; EI= 15T/byte ; WO=0 ; T=1/(10*10<sup>9</sup>))=0.1 ns; IC=(10+15*64)*T=970*0.1= 97ns</p></li><li><p>b) Justo nada más empezar la instrucción quedaría todo el ciclo para poder atender a la interrupción: 97 ns.</p></li><li><p>c) Si se interrumpe antes de la primera transfer tardaría 10T como mucho, y si se interrumpe durante las transferencias sería 15T. Por lo que es caso peor sería 15T=15*0.1=1.5ns</p></li></ul></div></li></ul></div></li></ol></div></li><li><p>12.5 The Intel 8088 consists of a bus interface unit (BIU) and an execution unit (EU), which form a 2-stage pipeline. The BIU fetches instructions into a 4-byte instruction queue. The BIU also participates in address calculations, fetches operands, and writes results in memory as requested by the EU. If no such requests are outstanding and the bus is free, the BIU fills any vacancies in the instruction queue. When the EU completes execution of an instruction, it passes any results to the BIU (destined for memory or I/O) and proceeds to the next instruction. <a href="http://en.wikipedia.org/wiki/Intel_8088">wikipedia</a>:  the 8088 had an <strong>8-bit</strong> external data bus</p><div class="olist loweralpha"><ol class="loweralpha"><li><p>Suppose the tasks performed by the BIU and EU take about equal time. By what factor does pipelining improve the performance of the 8088? Ignore the effect of branch instructions.</p></li><li><p>Repeat the calculation assuming that the EU takes twice as long as the BIU.</p><div class="ulist"><ul><li><p>Desarrollo</p><div class="ulist"><ul><li><p>0. El micro 8088 tiene un bus de datos de 8bits. La unidad de ejecución comprende la ALU y los Registros. La BIU junto a la EU forman conjuntamente una CPU segmentada con dos unidades. La <em>prefetch instruction queue</em> es el buffer que almacena la siguiente instrucción a ejecutar.</p></li><li><p>a. Una etapa tarda x y la siguiente también x. La primera instrucción tarda en ejecutarse 2x y cada intervalo x sale una nueva por lo que la mejoría a partir de la segunda instrucción es de x/2x &#8658; En un ciclo de instrucción (duración 2x) salen instrucciones cada intervalo x, es decir, el doble.</p></li><li><p>b. x+2x=3x. A partir de la segunda instrucción tardan 2x. En un ciclo de instrucción 3x salen instrucciones cada 2x &#8658; (3x time  ciclo)/ (2x time/instrucción) = 1.5 veces más instrucciones por ciclo.</p></li></ul></div></li></ul></div></li></ol></div></li><li><p>12.6 Assume an 8088 is executing a program in which the probability of a program jump is 0.1. For simplicity, assume that all instructions are 2 bytes long. If the prefetch instruction queue is empty, the EU waits for the next instruction byte to be fetched and shifted to top of the queue.
When the EU executes a branch or jump instruction, it transfers control to a location corresponding to another set of sequential instructions.
Whenever this happens, the BIU automatically resets the queue and then begins to fetch instructions from this new location to refill the queue.</p><div class="olist loweralpha"><ol class="loweralpha"><li><p>What fraction of instruction fetch bus cycles is wasted?</p></li><li><p>Repeat if the instruction queue is 8 bytes long.</p><div class="ulist"><ul><li><p>Buffer (de 4 bytes para dos instrucciones) &#8594; BIU &#8594; EU : Para leer una instrucción son necesarios <strong>DOS ciclos de bus</strong>, un bus de datos (1 byte) por ciclo de bus.</p></li><li><p>Desarrollo</p><div class="ulist"><ul><li><p>0. Si no hay salto durante la ejecución de la instrucción N se captura la instrucción N+1.</p><div class="listingblock"><div class="content"><pre>          BUFFER                    BIU             EU
------------+------------    ---------------    ------------
|N+2(2bytes)|N+1(2bytes)| -&gt; | Captura N+2 | -&gt; | Ejecuta N|
------------+------------    ---------------    ------------

                                |
                                | Dos Ciclos de Bus para capturar una instrucción
                                |
                                v

          BUFFER                    BIU             EU
------------+------------    ---------------    --------------
|N+3(2bytes)|N+2(2bytes)| -&gt; | Captura N+3 | -&gt; | Ejecuta N+1|
------------+------------    ---------------    --------------</pre></div></div></li><li><p>1. Si la ejecución de la instrucción N supone un salto de M instrucciones no se ejecutará la instrucción N+1 que espera en el buffer, sino que se debe ejecutar la instrucción N+M. Durante la ejecución de N NO se captura nada sino que se actualiza el Contador de Programa a N+M y en el siguiente ciclo de instruccióń se capturará N+M. Por lo que si hay salto, el ciclo de captura estará infrautilizado y será necesario vaciar el buffer de instrucciones.</p></li><li><p>Interpretación</p><div class="listingblock"><div class="content"><pre>Pasar de una fase a otra de este esquema supone la captura de una instrucción (2 ciclos de bus)


          BUFFER                    BIU                    EU
------------+------------    ---------------    -------------------------
|N+1(2bytes)|  N(2bytes)| -&gt; | Captura N+1 | -&gt; | Ejecuta N -1          |  -&gt; Ejecuta la instrucción anterior a la del salto
------------+------------    ---------------    -------------------------


          BUFFER                    BIU                    EU
------------+------------    ---------------    -------------------------
|N+2        |N+1        | -&gt; | Captura N+2 | -&gt; | Ejecuta N: salto a N+M|  -&gt; Ejecuta la instrucción de salto: actualiza el PC
------------+------------    ---------------    -------------------------

          BUFFER                    BIU                EU
------------+------------    ---------------    --------------
|N+M        |  Vacia    | -&gt; | Captura  N+M| -&gt; | No Ejecuta |              -&gt; La BIU vacía el Buffer y captura la inst N+M a la cola
------------+------------    ---------------    --------------

          BUFFER                    BIU                  EU
------------+------------    ---------------    --------------
|N+M+1      | N+M       | -&gt; |Captura N+M+1| -&gt; | No Ejecuta |            -&gt; Rellena el buffer poniendo N+M en la cabeza de la cola
------------+------------    ---------------    --------------

          BUFFER                    BIU                    EU
------------+--------------    ---------------    --------------
|N+M+2      | N+M+1       | -&gt; |Captura N+M+2| -&gt; |Ejecuta N+M |          -&gt; La unidad de Control captura,interpreta y ejecuta N+M
------------+--------------    ---------------    --------------</pre></div></div></li><li><p>a. Cuando la BIU capta de la memoria principal N+1 y lo pone en cola detrás de N, se están desaprovechando los dos ciclos de bus que se necesitan para la captura de la instrucción M+1 que no se va a ejecutar. Lo mismo ocurre con la captura de N+2 de la memoria princiapl. Por lo tanto se malgastan los ciclos del bus del sistema de N+1 y N+2, es decir, 4 ciclos de bus.</p></li><li><p>El buffer de instrucción es de 4 bytes según el ejercicio anterior, por lo que es necesario "empujar" los 4 bytes de N+1 y N+2  para dejar pasar a la nueva instrucción N+M desde que es capturada de la memoria principal.</p></li><li><p>La captura de una instrucción no_jump supone 2 ciclos de bus bien utilizados, la instrucción estará en la cabeza del buffer cuando la vaya a ejecutar la CPU. La de una instrucción jump supone 2 ciclos bien utilizados en capturarla desde la memoria principal pero 4 ciclos mal utilizados en vaciar el buffer y desplazar la instrucción N+M desde la cola hasta la cabecera del buffer, mientras la cpu espera. De cada 100 instrucciones tendremos 100 instruccionesx2ciclos/instr bien utilizados y 10 instruccionesx4ciclos/instrucción mal utilizados&#8594; en total 240 ciclos &#8594; fracción de infrautilización= 40/240= 0.166= 17% del tiempo el bus no está siendo utilizado en operaciones fetch, la BIU está ocupado en vaciar el buffer.</p></li><li><p>b. Con una cola de 8 bytes &#8594; Total=100x2+10*8=280&#8594; ineficiencia=80/280=0.285=28.5%</p></li></ul></div></li></ul></div></li></ol></div></li><li><p>12.7 Consider the timing diagram of Figures 12.10. Assume that there is only a two-stage pipeline (fetch, execute). Redraw the diagram to show how many time units are now needed for four instructions.</p><div class="ulist"><ul><li><p>Desarrollo</p><div class="listingblock"><div class="content"><pre>    --------------------------
    | 1  | 2  | 3  | 4  | 5  |
    --------------------------
I1    FI   EI
I2         FI   EI
I3              FI   EI
I4                   FI   EI</pre></div></div>
<div class="ulist"><ul><li><p>Son necesarias 5 unidades de Tiempo</p></li></ul></div></li></ul></div></li><li><p>12.9 A pipelined processor has a clock rate of 2.5 GHz and executes a program with 1.5 million instructions. The pipeline has five stages, and instructions are issued at a rate of one per clock cycle. Ignore penalties due to branch instructions and outof-sequence executions.</p><div class="olist loweralpha"><ol class="loweralpha"><li><p>What is the speedup of this processor for this program compared to a nonpipelined processor, making the same assumptions used in Section 12.4?</p></li><li><p>What is throughput (in MIPS) of the pipelined processor?</p><div class="ulist"><ul><li><p>Desarrollo</p><div class="ulist"><ul><li><p>a. Duración Programa con N instrucciones, segmentación de k etapas de duración t cada una= 1ª instrucción más el resto = <em>k*t +(N-1)<strong>t = t</strong>(N+k-1) = para N&gt;&gt;k = t*(N-1)</em> . La relación sin_seg/con_seg = N*k*t / t(N+k-1) = Nk/(N+k-1) . Si N tiende a infinito &#8594; Nk/N=k=5</p></li><li><p>b. Throughput = instrucciones del programa/duración del programa= N/{t*(N+k-1)}=1/t</p></li></ul></div></li></ul></div></li></ol></div></li><li><p>12.11 Consider an instruction sequence of length n that is streaming through the instruction pipeline. Let p be the probability of encountering a conditional or unconditional branch instruction, and let q be the probability that execution of a branch instruction I causes a jump to a nonconsecutive address. Assume that each such jump requires the pipeline to be cleared, destroying all ongoing instruction processing, when I emerges from the last stage. Revise Equations (12.1) and (12.2) to take these probabilities into account.</p><div class="ulist"><ul><li><p>Desarrollo</p><div class="ulist"><ul><li><p>Instrucciones cuya ejecución es un salto no consecutivo : pqn</p></li><li><p>Instrucciones cuya ejecución supone un no salto : (1-pq)n</p></li><li><p>T_programa=T_inst_salto+T_inst_nosalto = {pq*nkt}+{(1-pq)*(k+n-1)t}</p></li></ul></div></li></ul></div></li><li><p>12.13 Consider the state diagrams of Figure 12.28.</p><div class="olist loweralpha"><ol class="loweralpha"><li><p>Describe the behavior of each.</p></li><li><p>Compare these with the branch prediction state diagram in Section 12.4. Discuss the relative merits of each of the three approaches to branch prediction.</p></li></ol></div></li></ul></div>
<div class="paragraph"><p><span class="image"><img src="./images/ejercicios/cpu_12-13.png" alt="cpu 12 13" title="Predicción de Salto" /></span></p></div>
<div class="ulist"><ul><li><p>Predict taken: predicción de SI salto.</p></li><li><p>Diagrama A:</p><div class="ulist"><ul><li><p>Cambio de predicción afirmativa a negativa:</p><div class="ulist"><ul><li><p>Partiendo de predicción de salto SI &#8594; Dos "NO" consecutivos para cambiar la predicción a NO</p></li></ul></div></li><li><p>Cambio de predicción negativa a afirmativa:</p><div class="ulist"><ul><li><p>Partiendo de predicción de salto NO &#8594; Un "SI"  para cambiar la predicción a SÍ</p></li></ul></div></li></ul></div></li><li><p>Diagrama B:</p><div class="ulist"><ul><li><p>Cambio de predicción afirmativa a negativa:</p><div class="ulist"><ul><li><p>Partiendo de predicción de salto SI &#8594; Dos "NO" consecutivos para cambiar la predicción a NO</p></li></ul></div></li><li><p>Cambio de predicción negativa a afirmativa:</p><div class="ulist"><ul><li><p>Partiendo de predicción de salto NO &#8594; Un "SI"  para cambiar la predicción a SÍ si previamente ha habido dos "NO SALTO" consecutivos</p></li><li><p>Partiendo de predicción de salto NO &#8594; Dos "SI"  para cambiar la predicción a SÍ si ha habido más de dos "NO SALTO" consecutivos</p></li></ul></div></li></ul></div></li><li><p>12.14 The Motorola 680x0 machines include the instruction <em>Decrement and Branch According to Condition</em>, which has the following form:</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">     DBcc Dn, displacement

where cc is one of the testable conditions, Dn is a general-purpose register, and displacement
specifies the target address relative to the current address.

The instruction can be defined as follows:
   if (cc = False)
     then begin
     Dn := (Dn) - 1;
     if Dn != -1 then PC := (PC) + displacement end
   else PC := (PC) + 2;</code></pre></div></div>
<div class="ulist"><ul><li><p>When the instruction is executed, the condition is first tested to determine whether the termination condition for the loop is satisfied. If so, no operation is performed and execution continues at the next instruction in sequence. If the condition is false, the specified data register is decremented and checked to see if it is less than zero. If it is less than zero, the loop is terminated and execution continues at the next instruction in sequence. Otherwise, the program branches to the specified location. Now consider the following assembly-language program fragment:</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">AGAIN CMPM.L (A0)+, (A1)+
      DBNE D1, AGAIN
      NOP</code></pre></div></div></li><li><p>Two strings addressed by A0 and A1 are compared for equality; the string pointers are incremented with each reference. D1 initially contains the number of longwords (4 bytes) to be compared.</p><div class="olist loweralpha"><ol class="loweralpha"><li><p>The initial contents of the registers are A0 = $00004000, A1 = $00005000 and D1 = $000000FF (the $ indicates hexadecimal notation). Memory between $4000 and $6000 is loaded with words $AAAA. If the foregoing program is run, specify the number of times the DBNE loop is executed and the contents of the three registers when the NOP instruction is reached.</p></li><li><p>Repeat (a), but now assume that memory between $4000 and $4FEE is loaded with $0000 and between $5000 and $6000 is loaded with $AAA.</p></li></ol></div></li><li><p>Desarrollo:</p><div class="ulist"><ul><li><p>La instrucción DBcc se emplea como control de los bucles una vez finalizada cada iteracción. La condicción cc hace referencia a la última operación antes de la instrucción DBcc, en este caso CMPM.L. Si la condición es verdadera &#8594; Fin de bucle y sigue la secuencia del programa. Si la condición es falsa decrementa el contador de iteraciones y salta al comienzo del bucle. Palabras tipo .L (Large) de 4 bytes. D1=0xFF. D1-1=0xFFFFFFFF. A0 puntero a string &#8594; (A0) indirección &#8594; (A0)+ incrementa el puntero en una palabra en cada ejecución.</p><div class="olist loweralpha"><ol class="loweralpha"><li><p>Los dos punteros apuntan a memoria cuyo contenido es $AAAA por lo tanto la comparación da como resultado EQUAL. La condición de la instrucción DBcc es NE, not equal, por lo tanto es FALSE  y sí se ejecuta el bucle.  Se ejecuta 0xFF+1 veces hasta llegar el contador D1=-1. Ultima dirección del puntero A0 &#8594; 0x4000+0xFFpalabras+1palabra=0x4000+4x(0xFF)bytes+4bytes &#8594;2<sup>2</sup>x(0xFF) equivale a desplazar 0xFF dos bits a la izda = 0x3FC &#8594; 0x4000+0x3FC+4=0x4400. Puntero A1 &#8594;  0x5000+0x3FC+4=0x5400.</p></li><li><p>Todas las comparaciones dan como resultado distinto de cero &#8594; NE &#8594; por lo tanto TRUE &#8594; Unicamente se ejecuta una iteracción. D1=0xFF-1=0xFE; A0=A0+1palabra=0x4004 y A1=0x5004</p></li></ol></div></li></ul></div></li></ul></div></li><li><p>12.15 Redraw Figures 12.19c (14.21c), assuming that the conditional branch is not taken</p><div class="paragraph"><p><span class="image"><img src="./images/ejercicios/14-21.png" alt="14 21" /></span></p></div>
<div class="ulist"><ul><li><p>Desarrollo:</p><div class="ulist"><ul><li><p>80486: 32 bits</p></li><li><p>Etapas del cauce (pipeline) de instrucciones: FE-D1-D2-Ex-WB.</p></li><li><p>Fetch: Captura de la instrucción</p></li><li><p>D1: Decodifico Cod.Op y Modo Direccionamiento</p></li><li><p>D2: Operaciones para el cálculo de la Dirección Efectiva del Operando</p></li><li><p>EX: Operaciones ALU y acceso a operandos</p></li><li><p>WB: EFLAGS, Resultados en Reg y Mem(Caché y MP)</p></li><li><p>Figura 12.19 b) La 1ª ins. en EX lee el operando de la memoria y la 2ª en D2 accede a memoria para leer del puntero la dirección del operando.</p></li><li><p>Figura 12.19 c) La instrucción CMP actualiza reg flags. La instrucción Jcc en D2 ya tiene la dirección de salto aunque actualiza el Contador de Programa en EX. La inst 3ª después de D2 de Jcc ya pueded ser capturada.</p></li><li><p>Sí salto:</p><div class="ulist"><ul><li><p>La cpu realiza la captura de la 3ª instrucción (Fetch) inmediatamente despúes de la captura de la segunda pero dicha captura es errónea ya que ha capturado la siguiente en secuencia a la 2ª y no la instrucción target. La captura de la instrucción destino se ha de realizar cuando se conozca la dirección dónde se encuentra  dicha instrucción.</p><div class="listingblock"><div class="content"><pre>+------+------+------+------+------+
|      |      |      |      | WB   | WB:Actualizar Flags -&gt; Sí salto
+------+------+------+------+------+
       |      |      |  D2  |      | D2:Dirección destino
       +------+------+------+------+------+------+------+------+
                            |Fetch |      |      |  EX  |      | Fetch: instrucción destino del salto
                            +------+------+------+------+------+</pre></div></div></li></ul></div></li><li><p>No salto:</p><div class="ulist"><ul><li><p>La CPU captura las 3 instrucciones en secuencia y no se equivoca en la 3ª ya que no hay salto.</p><div class="listingblock"><div class="content"><pre>+------+------+------+------+------+
|      |      |      |      | WB   | WB:Actualizar Flags -&gt; No salto
+------+------+------+------+------+
       |      |      |  D2  |      | D2:Dirección destino -&gt; No salto
       +------+------+------+------+------+------+
              |Fetch |      |      |  EX  |      |Fetch: instrucción en secuencia
              +------+------+------+------+------+</pre></div></div></li></ul></div></li></ul></div></li></ul></div></li><li><p>12.16 Table 14.5 summarizes statistics from [MACD84] concerning branch behavior for various classes of applications. With the exception of type 1 branch behavior, there is no noticeable difference among the application classes. Determine the fraction of all branches that go to the branch target address for the scientific environment. Repeat for commercial and systems environments.</p><div class="paragraph"><p><span class="image"><img src="./images/ejercicios/14-5.png" alt="14 5" /></span></p></div>
<div class="ulist"><ul><li><p>Desarrollo:</p><div class="ulist"><ul><li><p>tipo1=72.5 ; tipo2=9.8 ; tipo3=17.7</p><div class="ulist"><ul><li><p>tipo1: hay 3 casos dentro del tipo1 (1/3 salta incondicional,1/3 salta condicional,1/3 no salta)</p></li><li><p>tipo2: 91%salta, el 9% no salta</p></li><li><p>tipo3: saltan todas</p></li></ul></div></li><li><p>Salto a destino= tipo1x[(0.2+0.4+0.35)x100/100+(43.2+24.3+32.5)x1/3]+
 tipo2x0.91+
 tipo3x100/100
=</p></li><li><p>Saltos to taget por aplicaciones</p><div class="ulist"><ul><li><p>científica=tipo1x[(0.2 )x100/100+(43.2)x1/3]+ tipo2x0.91+tipo3x100/100=0.724&#8594; El 72% de los saltos de una aplicación científica son a destino.</p></li><li><p>comercial =tipo1x[(0.4 )x100/100+(24.3)x1/3]+ tipo2x0.91+tipo3x100/100=0.732</p></li><li><p>sistema   =tipo1x[(0.35)x100/100+(32.5)x1/3]+ tipo2x0.91+tipo3x100/100=0.756</p></li></ul></div></li></ul></div></li></ul></div></li></ul></div></div></section><section id="_capitulo_13_reduces_instruction_set_computer_capítulo_15_en_9ªed"><h2>10.14. Capitulo 13: Reduces Instruction Set Computer (Capítulo 15 en 9ªEd)</h2><div class="slide-content"><div class="ulist"><ul><li><p>13.3 We wish to determine the execution time for a given program using the various pipelining schemes discussed in Section 13.5. Let
N = number of executed instructions, J = number of jump instructions, D = number of memory accesses. For the simple sequential scheme (Figure 13.6a) for a RISC architecture, the execution time is 2N+D stages. Derive formulas for two-stage, three-stage, and four-stage pipelining.</p><div class="paragraph"><p><span class="image"><img src="./images/ejercicios/15-6.png" alt="15 6" /></span></p></div>
<div class="ulist"><ul><li><p>Desarrollo:</p><div class="ulist"><ul><li><p>CAUCE SEGMENTADO: I &#8594; captación de la instrucción. E&#8594; operaciones ALU con Reg. u obtención de la dirección efectiva. D&#8594; Transferencia Mem &lt;&#8594; Reg.</p></li><li><p>Cada instrucción tiene por lo menos dos etapas: E e I. En cambio la etapa D no la tienen todas las instrucciones (sólo load y store entre reg y mem)</p><div class="olist loweralpha"><ol class="loweralpha"><li><p>Figura apartado a &#8594;T=Nx(t<sub>e</sub>+t<sub>i</sub>)+t<sub>d</sub>xD; si t<sub>i</sub>=t<sub>e</sub>=t<sub>d</sub>=t &#8594; T=[2N+D]t</p></li><li><p>Figura apartado b &#8594; Cauce segmentado &#8594; k=2 &#8594; Sin instrucciones de salto &#8594; T<sub>k,n</sub>=[k+(n-1)]t &#8594;  T<sub>2,n</sub>=[2+(N-1)]t .</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Sólo es posible un acceso a memoria en cada etapa.</p></li><li><p>I es una etapa, E y D forman una única etapa.</p></li><li><p>E e I se solapan &#8594; N etapas E|I</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">     +-----+
     |  E  |
     +-----+
     |  I  |
     +-----+</code></pre></div></div></li><li><p>D no se solapa &#8594; D etapas</p></li><li><p>En la fase E de la instrucción Branch se calcula la dirección de salto por lo que la fase I de la instrucción destino no puede coincidir con dicha fase E. Se soluciona con un instrucción de no operación NOOP.</p></li><li><p>Los saltos originan un NOOP &#8594; una etapa de retardo más que añadir</p></li><li><p>T=(N+D+J)t</p></li></ol></div></li><li><p>Figura apartado c &#8594; k=3 etapas</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>En una etapa son posibles dos accesos a memoria.</p></li><li><p>La 2ª instrucción load carga el dato en el registro en la etapa D por lo que no puede coincidir con la ejecución de la instrucción suma.</p></li><li><p>D,E e I se solapan si no hay dependencia de datos</p></li><li><p>Si hay dependencias D no se solapa por lo que hay una fracción de las D instrucciones que hay que sumar.</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">     +-----+
     |  E  |
     +-----+
     |  I  |
     +-----+
                    -&gt; N+alfaxD
     +-----+
     |  E  |
     +-----+
     |  I  |
     +-----+
     |  D  |
     +-----+</code></pre></div></div></li><li><p>T=(N+alfa*D+J)t &#8594; J noops</p></li></ol></div></li><li><p>Figura apartado d &#8594; k=4 etapas</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Dividimos E en E1 (lectura RPG) y E2 (ALU y escritura RPG)</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">     +-----+
     |  D  |
     +-----+
     | E2  |
     +-----+
     | E1  |
     +-----+
     |  I  |
     +-----+</code></pre></div></div></li><li><p>El solape de D con dependencia de datos introduce un retardo y J otros dos según la figura.</p></li><li><p>T=(N+alfa*D+2J)t</p></li></ol></div></li></ol></div></li></ul></div></li></ul></div></li><li><p>13.4 Reorganize the code sequence in Figure 13.6d to reduce the number of NOOPs. Figura del ejercicio 13.3 d).</p><div class="paragraph"><p><span class="image"><img src="./images/ejercicios/risc_pipelining_13-6.png" alt="risc pipelining 13 6" title="Diagrama de Tiempos.Segmentación de 4 Etapas" /></span></p></div>
<div class="ulist"><ul><li><p>La instrucción Branch la ejecutamos en la posición del 2º NOOP</p></li><li><p>Las dos instrucciones anteriores al salto (Add y Store) en lugar de los 2 NOOP después del salto Branch.</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">Load ra&lt;-M
Load rb&lt;-M
Noop
Branch X
Add  rc&lt;-ra+rb
Store M&lt;-rc
Next</code></pre></div></div>
<div class="ulist"><ul><li><p>Mientras se ejecutan Add y Store se calcula la dirección X</p><div class="listingblock"><div class="content"><pre>       +------+------+------+------+
       |  I   |  E1  |  E2  |  D   |  Load ra&lt;-M
       +------+------+------+------+------+
              |  I   |  E1  |  E2  | "D"  |  Load rb&lt;-M
              +------+------+------+------+
                     |  I   |  E1  |  E2  |  Noop
                     +------+------+------+------+
                            |  I   |  E1  | &amp;E2&amp; | Branch X
                            +------+------+------+------+
                                   |  I   | "E1" |  E2  |  Add rc&lt;-ra+rb
                                   +------+------+------+------+------+
                                          |  I   |  E1  |  E2  |  D   | Store M&lt;-rc
                                          +------+------+------+------+
                                                 | &amp;I&amp;  |      |      | Next
                                                 +------+------+------+</pre></div></div></li><li><p>Dependencias: Una vez que se carga rb en la fase "D" ya se puede leer rb en "E1"</p></li><li><p>Dependencias: Una vez que se calcula X en &amp;E2&amp; ya se puede capturar la instrucción Next durante &amp;I&amp;</p></li></ul></div></li></ul></div></li><li><p>13.5 Consider the following code fragment in a high-level language:</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">for I in 1...100 loop
    S ← S + Q(I).VAL
end loop;</code></pre></div></div></li><li><p>Assume that Q is an array of 32-byte records and the VAL field is in the first 4 bytes of each record. Using x86 code, we can compile this program fragment as follows:</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">    MOV ECX,1 ;use register ECX to hold I
LP: IMUL EAX, ECX, 32 ;get offset in EAX
    MOV EBX, Q[EAX] ;load VAL field
    ADD S, EBX ;add to S
    INC ECX ;increment I
    CMP ECX, 101 :compare to 101
    JNE LP ;loop until I = 100</code></pre></div></div></li><li><p>This program makes use of the IMUL instruction, which multiplies the second operand by the immediate value in the third operand and places the result in the first operand (see Problem 10.13). A RISC advocate would like to demonstrate that a clever compiler can eliminate unnecessarily complex instructions such as IMUL. Provide the demonstration by rewriting the above x86 program without using the IMUL instruction.</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Array Q: 100 registros (estructuras) de 32 bytes cada uno.</p></li><li><p>VAL field: primeros 4 bytes del registro.</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">typedef struct {int VAL;....) Data;
Data Q[100];</code></pre></div></div></li><li><p>Q(i).VAL : El campo VAL de cada registro Q(i)</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">    ## El bucle suma los campos VAL de los 100 registros
    MOV ECX,1 ;use register ECX to hold I #Indice de registro del array Q
LP: IMUL EAX, ECX, 32 ;get offset in EAX  #EAX: dirección relativa del campo VAL del registro al que apunta el índice ECX del array Q
                                          #Cada 32 bytes un registro
    MOV EBX, Q[EAX] ;load VAL field       #Q en ensamblador se estructrua en bytes. 100registrosx32bytes/registro=3200registros
    ADD S, EBX      ;add to S             #Suma de los 4 bytes del campo VAL
    INC ECX         ;increment I          #siguiente registro
    CMP ECX, 101    ;compare to 101       #ultimo+1 registro?
    JNE LP          ;loop until I = 100   #Siguiente interacción si no ultimo</code></pre></div></div></li><li><p>Multiplicar por 2<sup>x</sup> equivale a un desplazamiento de x bits a la izda</p><div class="ulist"><ul><li><p>Multiplicar por 32 &#8594; x2<sup>5</sup> &#8594; desplazar 5 bits a la izda : shl $5,%ecx</p></li></ul></div></li></ol></div></li><li><p>13.6 Consider the following loop:</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">S := 0;
   for K := 1 to 100 do
S := S - K;</code></pre></div></div></li><li><p>A straightforward translation of this into a <em>generic</em> assembly language would look something like this:</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">   LD R1, 0          ;keep value of S in R1
   LD R2,1           ;keep value of K in R2
LP SUB R1, R1, R2    ;S := S - K
   BEQ R2, 100, EXIT ;done if K = 100          #Branch EQual
   ADD R2, R2, 1     ;else increment K
   JMP LP            ;back to start of loop</code></pre></div></div></li><li><p>A compiler for a <em>RISC</em> machine will <em>introduce</em> delay slots into this code so that the processor can employ the <em>delayed branch mechanism</em>.The JMP instruction is easy to deal with, because this instruction is always followed by the SUB instruction; therefore, we can simply place a copy of the SUB instruction in the delay slot after the JMP. The BEQ presents a difficulty. We can’t leave the code as is, because the ADD instruction would then be executed one too many times. Therefore, a NOP instruction is needed. Show the resulting code.</p></li><li><p>Desarrollo:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Delayed Branch</p><div class="paragraph"><p><span class="image"><img src="./images/ejercicios/15-7.png" alt="15 7" /></span></p></div>
<div class="ulist"><ul><li><p>La primera gráfica es un salto normal y las otras dos retardado. La última gráfica  supone una instrucción menos</p></li></ul></div></li><li><p>El programa presenta dos instrucciones de salto con retardo: BEQ y JMP</p></li><li><p>JMP LP</p><div class="ulist"><ul><li><p>Salto incondicional. En el programa original se ejecutará el salto después de <code>SUB R1, R1, R2</code>. Solución:</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">   JMP LP            ;back to start of loop
   ADD R2, R2, 1     ;else increment K</code></pre></div></div></li><li><p>De esta manera el salto se ejecuta después del <code>ADD R2, R2, 1</code></p></li></ul></div></li><li><p>BEQ R2, 100, EXIT</p><div class="ulist"><ul><li><p>Salto condicional</p></li><li><p>Si lo dejamos como está el salto será después del ADD R2, R2, 1. Solución:</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">   BEQ R2, 100, EXIT ;done if K = 100          #Branch EQual
LP SUB R1, R1, R2    ;S := S - K</code></pre></div></div></li><li><p>Ahora el salto condicional se realizará después de la resta SUB</p></li></ul></div></li><li><p>Solución 1ª:</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">   LD R1, 0          ;keep value of S in R1
   LD R2,1           ;keep value of K in R2
LP BEQ R2, 100, EXIT ;done if K = 100          #Branch EQual
   SUB R1, R1, R2    ;S := S - K
   JMP LP            ;back to start of loop
   ADD R2, R2, 1     ;else increment K</code></pre></div></div>
<div class="ulist"><ul><li><p>Tiene el defecto de que si R2=100 se ejecuta también SUB modificando el valor final de R1 y R2</p></li></ul></div></li><li><p>Solución Definitiva:</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">   LD R1, 0          ;keep value of S in R1
   LD R2,1           ;keep value of K in R2
LP BEQ R2, 100, EXIT ;done if K = 100          #Branch EQual
   NOP
   ADD R2, R2, 1     ;else increment K
   JMP LP            ;back to start of loop
   SUB R1, R1, R2    ;S := S - K</code></pre></div></div></li></ol></div></li><li><p>13.7 A RISC machine may do both a mapping of symbolic registers to actual registers and a <em>rearrangement</em> of instructions for pipeline efficiency. An interesting question arises as to the order in which these two operations should be done. Consider the following program fragment:</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c"> LD SR1,A          ;load A into symbolic register 1
 LD SR2, B         ;load B into symbolic register 2
 ADD SR3, SR1, SR2 ;add contents of SR1 and SR2 and store in SR3
 LD SR4, C
 LD SR5,D
 ADD SR6, SR4, SR5</code></pre></div></div>
<div class="olist loweralpha"><ol class="loweralpha"><li><p>First do the register mapping and then any possible instruction reordering. How many machine registers are used? Has there been any pipeline improvement?</p></li><li><p>Starting with the original program, now do instruction reordering and then any possible mapping. How many machine registers are used? Has there been any pipeline improvement?</p></li></ol></div></li><li><p>Desarrollo:
.</p></li><li><p>13.9 In many cases, common machine instructions that are not listed as part of the MIPS instruction set can be synthesized with a single MIPS instruction. Show this for the following:</p><div class="olist loweralpha"><ol class="loweralpha"><li><p>Register-to-register move</p></li><li><p>Increment, decrement</p></li><li><p>Complement</p></li><li><p>Negate</p></li><li><p>Clear</p></li></ol></div></li><li><p>13.11 SPARC is lacking a number of instructions commonly found on CISC machines.
Some of these are easily simulated using either register R0, which is always set to 0, or a constant operand. These simulated instructions are called pseudoinstructions and are recognized by the SPARC compiler. Show how to simulate the following pseudoinstructions, each with a single SPARC instruction. In all of these, src and dst refer to registers. (Hint: A store to R0 has no effect.)</p><div class="olist loweralpha"><ol class="loweralpha"><li><p>MOV src, dst</p></li><li><p>COMPARE src1, src2</p></li><li><p>TEST src1</p></li><li><p>NOT dst</p></li><li><p>NEG dst</p></li><li><p>INC dst</p></li><li><p>DEC dst</p></li><li><p>CLR dst</p></li><li><p>NOP</p></li></ol></div></li><li><p>13.12 Consider the following code fragment:</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c"> if K &gt; 10
   L := K + 1
 else
   L := K - 1;</code></pre></div></div></li><li><p>A straightforward translation of this statement into SPARC assembler could take the following form:</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">    sethi %hi(K), %r8        ;load high-order 22 bits of address of location
                         ;K into register r8
    ld [%r8 + %lo(K)], %r8   ;load contents of location K into r8
    cmp %r8, 10              ;compare contents of r8 with 10
    ble L1                   ;branch if (r8) &lt;= 10
    nop
    sethi %hi(K), %r9
    ld [%r9 + %lo(K)], %r9   ;load contents of location K into r9
    inc %r9                  ;add 1 to (r9)
    sethi %hi(L), %r10
    st %r9, [%r10 + %lo(L)]  ;store (r9) into location L
    b L2
    nop
L1: sethi %hi(K), %r11
    ld [%r11 + %lo(K)], %r12 ;load contents of location K into r12
    dec %r12                 ;subtract 1 from (r12)
    sethi %hi(L), %r13
    st %r12, [%r13 + %lo(L)] ;store (r12) into location L
L2:</code></pre></div></div></li><li><p>The code contains a nop after each branch instruction to permit delayed branch operation.</p><div class="olist loweralpha"><ol class="loweralpha"><li><p>Standard compiler optimizations that have nothing to do with RISC machines aregenerally effective in being able to perform two transformations on the foregoing code. Notice that two of the loads are unnecessary and that the two stores can be merged if the store is moved to a different place in the code. Show the programafter making these two changes.</p></li><li><p>It is now possible to perform some optimizations peculiar to SPARC. The nop after the ble can be replaced by moving another instruction into that delay slot and setting the annul bit on the ble instruction (expressed as ble,a L1). Show the program after this change.</p></li><li><p>There are now two unnecessary instructions. Remove these and show the resulting program</p></li></ol></div></li></ul></div></div></section></section></div></section>
<section id="_iv_autoevaluación_teoría"><h2>IV Autoevaluación Teoría</h2><div class="slide-content"><section><section id="_teoría_cuestionario"><h2>11. Teoría: Cuestionario</h2></section><section id="_arquitectura_von_neumann_4"><h2>11.1. Arquitectura von Neumann</h2><div class="slide-content"><div class="olist arabic"><ol class="arabic"><li><p>Qué función tiene el programa ensamblador</p></li><li><p>Qué tipo de lenguaje es el lenguaje máquina</p></li><li><p>En qué año se desarrollo la máquina IAS</p></li><li><p>Cuál es el formato de instrucción de la máquina IAS</p></li><li><p>Indica dos instrucciones de la máquina IAS en dos lenguajes diferentes.</p></li><li><p>Cuál es el programa de demostración en lenguaje ensamblador del emulador, de la máquina IAS, IASSim.</p></li><li><p>Cuales son las dos primeras instrucciones en lenguaje máquina del programa demo del emulador IASSim.</p></li><li><p>En que consiste la arquitecura ISA</p></li><li><p>Emplea la palabra abstracción en algún concepto de la asignatura</p></li><li><p>Indica dos microórdenes</p></li><li><p>Que unidad genera las microórdenes</p></li><li><p>Hacia que elementos van dirigidas las microórdenes</p></li><li><p>Qué significa 1MB</p></li><li><p>Cuáles son los registros que utiliza la UC de la IAS</p></li><li><p>Cuáles son los registros que utiliza la ALU de la IAS</p></li><li><p>Cuáles son las fases del ciclo de instrucción</p></li><li><p>Qué unidad o unidades implementan el ciclo de instrucción.</p></li><li><p>De qué categoría de memoria lee los programas la CPU</p></li><li><p>Qué es un proceso</p></li><li><p>Define la arquitectura de la CPU utilizando por lo menos los términos siguientes:</p><div class="ulist"><ul><li><p>ciclo de instrucción</p></li><li><p>instrucción máquina</p></li><li><p>almacenamiento</p></li><li><p>interpretación</p></li><li><p>ruta de datos</p></li><li><p>registro</p></li><li><p>microórdenes</p></li></ul></div></li></ol></div></div></section></section></div></section>
<section id="_v_guiones_de_prácticas_programación_ensamblador_x86"><h2>V Guiones de Prácticas: Programación Ensamblador x86</h2><div class="slide-content"><section><section id="_introducción_a_la_programación_en_lenguaje_ensamblador_att_x86_32"><h2>12. Introducción a la Programación en Lenguaje Ensamblador AT&amp;T x86-32</h2></section><section id="_introducción_16"><h2>12.1. Introducción</h2><div class="slide-content"><h level="3">Objetivos</h><div class="ulist"><ul><li><p>Introducción a la <strong>programación de bajo nivel</strong> mediante los lenguajes <em>C</em> y <em>ensamblador AT&amp;T</em> para la arquitectura <strong>x86 de 32 bits</strong> de Intel.</p></li><li><p>Utilización de herramientas de desarrollo de sw de bajo nivel como el toolchain (compilador, ensamblador, linker) y el depurador GDB, libres de la fundación GNU.</p></li><li><p>Desarrollo de una workstation mediante la instalación de herramientas de desarrollo en un entorno GNU/linux/x86 en una computadora personal.</p></li><li><p>Comprender el funcionamiento de la computadora desde el punto de vista de un programador de bajo nivel.</p></li><li><p>Relacionar las propiedades de un lenguaje de alto nivel con un lenguaje de bajo nivel.</p></li><li><p>El lenguaje ensamblador puede ser utilizado como una herramienta para analizar la arquitectura y el funcionamiento de la computadora. No es el objetivo central de esta asignatura ser un experto en lenguajes de programación de bajo nivel ni en el desarrollo de algoritmos, aunque sí un nivel muy básico.</p></li></ul></div>
<h level="3">Requisitos</h><h level="4">Teóricos</h><div class="ulist"><ul><li><p>Conocimientos muy básicos de una arquitectura ISA: Arquitectura modelo Von Neumann( Microarquitectura CPU, arquitectura Memoria Principal, ciclo de instrucción), representación de datos y operaciones aritméticas, formato de  instrucciones y programación básica en lenguaje ensamblador y lenguaje máquina con la máquina IAS de John von Neumann, la sintaxis del lenguaje ensamblador AT&amp;T x86 y la arquitectura básicA del procesador x86-64 y x86-32 de intel.</p></li></ul></div>
<h level="4">Prácticos</h><div class="ulist"><ul><li><p>Tener configurada la "Plataforma de Desarrollo" GNU/linux(AMD64)/x86_64(Intel ó AMD) con las herramientas apropiadas.</p></li><li><p>Conocimientos de programación imperativa en lenguaje C y del "Lenguaje de Transferencia entre Registros" RTL, manejo básico del entorno GNU/linux y una herramienta de edición.</p></li><li><p>Estar dado de alta en el sitio de la asignatura en servidor miaulario.</p></li><li><p>Haber realizado la simulación de ejecución de un programa en lenguaje ensamblador y lenguaje máquina.  Por ejemplo en la máquina IAS de John von Neumann mediante el emulador Web IASSim</p></li></ul></div>
<div class="admonitionblock important"><table><tr><td class="icon"><i class="fa fa-exclamation-circle" title="Important"></i></td><td class="content">Haber analizado la sintaxis y estructura de un programa sencillo en lenguaje ensamblador AT&amp;T x86, compilado, ejecutado  y analizada la ejecución del programa paso a paso mediante el depurador GDB mediante la información de <a href="#prac_apu">Apéndice:Practicando la Programación desde el principio</a> y el pequeño tutorial <a href="#empezando_asm">Apéndice: empezando ASM</a> y <a href="#empezando_c">Apéndice: Empezando C</a></td></tr></table></div></div></section><section id="_leeme"><h2>12.2. LEEME</h2><div class="slide-content"><div class="ulist"><ul><li><p>Lectura del guión de prácticas  y de los capítulos 1 y 2 del Libro Programming from the Ground-Up.</p></li><li><p><a href="#prac_apu">Apuntes y Libro de Texto</a></p></li></ul></div>
<div class="admonitionblock important"><table><tr><td class="icon"><i class="fa fa-exclamation-circle" title="Important"></i></td><td class="content">La memoria se realiza en tiempo real durante la realización de la práctica y es la única documentación impresa que se utilizará el día del examen, por lo que debe de estar bien documentada. La memoria se entrega unos días después de la realización de la memoria a través de MiAulario/TAREAS siguiendo las indicaciones especificadas en <a href="#prac_doc_mem">Apéndice: Contenido y Formato de la Memoria</a> y en la fecha indicada en MiAulario/TAREAS.</td></tr></table></div>
<div class="ulist"><ul><li><p><strong>Abrir en el Escritorio de la computadora un documento texto que será la MEMORIA donde se irá añadiendo toda la información obtenida durante toda la sesión de prácticas</strong></p></li><li><p><a href="#prac_eval">Evaluación</a>: sistema de evaluación</p></li><li><p><a href="#prac_prog">Programación</a> : metodología</p></li></ul></div></div></section><section id="_cuestiones_2"><h2>12.3. Cuestiones</h2><div class="slide-content"><div class="ulist"><ul><li><p><a href="#prac_eval">"Autoevaluación de Prácticas"</a> opcional: <a href="#prac_cues">Prácticas: Cuestionario</a></p></li></ul></div></div></section><section id="_estación_de_trabajo"><h2>12.4. Estación de Trabajo</h2><div class="slide-content"><div class="ulist"><ul><li><p>Anotar las características de la <a href="#prac_plat_des">Plataforma de Desarrollo</a>  en el Documento Memoria.</p></li></ul></div></div></section><section id="_programación_sum1ton_c"><h2>12.5. Programación sum1toN.c</h2><div class="slide-content"><h level="3">Algoritmo</h><div class="ulist"><ul><li><p>Desarrollar un programa en lenguaje C que realice la suma \(\sum_{i=1}^{N}i\) cuyo resultado es \(N(N+1)/2\) con la arquitectura <em>i386</em> utilizando el <a href="#prac_prog">método de programación</a> de descripción inicial en lenguaje pseudocódigo y organigrama.</p></li></ul></div>
<h level="3">Edición del Módulo fuente: sum1toN.c</h><div class="ulist"><ul><li><p>Editar el programa descargando el módulo fuente "sum1toN.c" de miaulario y añadiendo los comentarios apropiados.</p></li><li><p>Cabecera con información complementaria:</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-C" data-lang="C">/*
 Programa: sum1toN.c
 Descripción: realiza la suma de la serie 1,2,3,...N
 Es el programa en lenguaje C equivalente a sum1toN.ias de la máquina IAS de von Neumann
 y equivalente al programa sum1toN.s en lenguaje ensamblador AT&amp;T
Lenguaje:       C99
Descripción:    Suma de los primeros 5 números naturales
Entrada:        Definida en una variable
Salida:         Sin salida periférica&lt;&lt;&lt;&lt;s
Compilación:    gcc -m32 -g -o sum1toN sum1toN.c
S.O:            GNU/linux 5.4.0-128-generic ubuntu 20.04 x86-64
Librería:       /usr/lib/x86_64-linux-gnu/libc.so
PC:		ThinkPad L560 product: 20F1S0H400 serial: MP15YSW7
CPU:            Intel(R) Core(TM) i5-6300U CPU @ 2.40GHz width:64 bits
Compilador:     gcc version 9.4.0
Ensamblador:    GNU assembler version 2.34
Linker/Loader:  GNU ld (GNU Binutils for Ubuntu) 2.34
Asignatura:     Estructura de Computadores
Fecha:          25/09/2022
Autor:          Cándido Aramburu
*/</code></pre></div></div></li><li><p>Programa:</p><div class="listingblock"><div class="content"><pre>// Módulo Principal
void  main (void) {
  //Declaración de variables locales e inicialización de los parámetros del bucle
  int sum=0,n=5;
  //Bucle que genera los sumandos y realiza la suma
  while(n&gt;0){ 	//Condición de salida del bucle cuando el sumando es negativo
    sum+=n;
    n--;     	//Actualización del sumando
  }
}	   	//Si las instrucciones se han ejecutado sin interrupción ni fallo main() devuelve el valor cero al sistema operativo.</pre></div></div></li></ul></div>
<h level="3">Compilación</h><div class="ulist"><ul><li><p>Seguir los pasos del proceso de <a href="#compilacion">compilación</a> común a todas las sesiones.</p><div class="ulist"><ul><li><p><code>gcc -m32 -g -o sum1toN sum1toN.c</code></p><div class="ulist"><ul><li><p>listar los ficheros: <code>ls -l sum1toN*</code>. ¿Qué representa cada uno de ellos?</p></li></ul></div></li><li><p><code>gcc --save-temps -m32 -g -o sum1toN sum1toN.c</code></p><div class="ulist"><ul><li><p>listar los ficheros: <code>ls -l sum1toN*</code>. ¿Qué representan los nuevos ficheros?</p></li></ul></div></li></ul></div></li></ul></div>
<h level="3">Análisis de los módulos</h><div class="ulist"><ul><li><p>Análisis para comprobar los distintos módulos:</p><div class="ulist"><ul><li><p><code>file sum1toN.c</code></p></li><li><p><code>file sum1toN.i</code></p></li><li><p><code>file sum1toN.s</code></p></li><li><p><code>file sum1toN.o</code></p></li><li><p><code>file sum1toN</code></p></li></ul></div></li></ul></div>
<h level="3">Ejecución</h><div class="ulist"><ul><li><p><code>./sum1toN</code> : llamada al módulo binario ejecutable</p></li><li><p><code>echo $?</code>   : visualización del valor devuelto por el programa <em>sum1toN</em> al sistema operativo linux.</p><div class="ulist"><ul><li><p>El valor cero se utiliza como indicador de que el programa se ha ejecutado sin ningún tipo de contratiempo.</p></li></ul></div></li></ul></div>
<h level="3">Depuración</h><h level="4">introducción</h><div class="ulist"><ul><li><p>La ejecución del programa paso a paso, instrucción a instrucción, permite un análisis minucioso de bajo nivel de la ejecución del programa pudiendo detener el programa y volcar el valor de las variables en la memoria principal, estado de los registros de la cpu, etc.</p></li><li><p>El Depurador GDB (GNU DeBugger) permite la ejecución a paso a paso y análisis de la memoria mediante un repertorio de comandos propios del depurador.</p></li></ul></div>
<h level="4">Generación de la tabla de símbolos</h><div class="ulist"><ul><li><p><code>gcc -m32 -g -o sum1toN sum1toN.c</code></p><div class="ulist"><ul><li><p>opción <strong>-g</strong>: Inserta la "Tabla de Símbolos" en el módulo binario ejecutable.</p></li></ul></div></li><li><p>En la línea de comandos emplear el TABULADOR TAB para Completar los nombres: <code>gcc -m32 -g -o sum1TAB suTAB</code></p></li></ul></div>
<h level="4">gdb</h><div class="ulist"><ul><li><p>Abrir el depurador: <code>gdb</code> para comenzar la sesión de depuración.</p><div class="ulist"><ul><li><p>Ventana con el prompt <strong>(gdb)</strong>: línea de comandos propios del debugger que serán interpretados por el GDB.</p></li></ul></div></li></ul></div>
<h level="4">abrir una nueva ventana</h><div class="ulist"><ul><li><p>(gdb) <code>layout src</code> ó <code>Control-x Control-a</code></p></li><li><p>navegar entre las dos ventanas: <code>Control-x o</code> y sino también <code>focus src</code> y <code>focus cmd</code></p></li><li><p><code>help focus</code></p></li></ul></div>
<h level="4">Logging</h><div class="admonitionblock caution"><table><tr><td class="icon"><i class="fa fa-fire" title="Caution"></i></td><td class="content">El logging hay que configurarlo con las dos ventanas abiertas: la ventana de comandos y la ventana del código source. Si se hace teniendo solamente la ventana de comandos, luego al abrir más ventanas deja de loggear.</td></tr></table></div>
<div class="ulist"><ul><li><p>Salvar toda la sesión de depuración en el fichero <em>sum1toN_gdb_c.txt</em></p><div class="ulist"><ul><li><p>Entradas &#8594;  (gdb) <code>set trace-commands on</code>,</p></li><li><p>Salidas &#8594;   (gdb) <code>set logging file sum1toN_gdb_c.txt</code></p></li><li><p>Activación &#8594;  <code>set logging on</code></p><div class="listingblock"><div class="content"><pre>Copying output to sum1toN_gdb_c.txt.
Copying debug output to sum1toN_gdb_c.txt.</pre></div></div></li></ul></div></li><li><p>Cada vez que salga y entre en el debugger en la misma sesión de prácticas y utilice el mismo fichero histórico <em>sum1toN_gdb_c.txt</em> hay que realizar la configuración anterior con las dos ventanas abiertas.</p></li></ul></div>
<h level="4">Comandos linux desde la línea de comandos gdb</h><div class="ulist"><ul><li><p><code>shell ls -l sum1toN_gdb_c.txt</code></p><div class="ulist"><ul><li><p><code>shell date</code></p></li><li><p><code>shell pwd</code></p></li><li><p><code>shell ls</code></p></li><li><p><code>shTAB</code> : Emplear el TABULADOR TAB para Completar los nombres.</p></li><li><p><code>shell daTAB</code></p></li></ul></div></li></ul></div>
<h level="4">COMPROBAR el histórico de la sesión de depuración</h><div class="ulist"><ul><li><p>Abrir una consola y en la carpeta de trabajo comprobar que existe el fichero <em>sum1toN_gdb_c.txt</em> y que contiene los comandos gdb ejecutados anteriormente.</p></li></ul></div>
<div class="admonitionblock caution"><table><tr><td class="icon"><i class="fa fa-fire" title="Caution"></i></td><td class="content">Es muy frustante darse cuenta después de dos horas de trabajo que no se ha guardado todo el trabajo</td></tr></table></div>
<h level="4">Ventanas</h><div class="ulist"><ul><li><p>Layout: <code>C-x a</code> &#8594; por defecto dos ventanas: módulo fuente y línea de comandos.</p></li><li><p>Navegador ventanas: <code>C-x o</code></p></li><li><p>Navegar por el histórico de comandos</p><div class="ulist"><ul><li><p>Logging histórico de comandos: Activar la ventana de comandos del GDB. Navegar con las teclas flecha arriba/abajo.</p></li></ul></div></li></ul></div>
<h level="4">Ayuda</h><div class="ulist"><ul><li><p><code>help shell</code> ó <code>h shell</code></p></li></ul></div>
<h level="4">Cargar módulo objeto ejecutable</h><div class="ulist"><ul><li><p>Cargar el módulo objeto binario que contiene la Tabla de Símbolos: <code>file sum1toN</code></p></li><li><p>módulo fuente con los símbolos asociados a la Tabla de Símbolos: <code>info sources</code></p></li></ul></div>
<div class="admonitionblock caution"><table><tr><td class="icon"><i class="fa fa-fire" title="Caution"></i></td><td class="content">Observar que el depurador confirma la existencia de la tabla de símbolos, imprescindible para la depuración.</td></tr></table></div>
<h level="4">Ejecución paso a paso</h><div class="ulist"><ul><li><p>punto ruptura en la entrada al programa: <code>break main</code></p></li><li><p>Ejecución: <code>run</code> hasta el punto de ruptura cuya línea NO se ejecuta &#8594; Aparece el código fuente.</p></li><li><p>Next source line: <code>next</code>, <code>n</code></p></li><li><p>Next 5 source lines: <code>n 5</code>, <code>print sum</code>, <code>p sum</code></p></li><li><p>Comenzar desde el principio nuevamente: <code>run</code> ó <code>start</code></p></li><li><p>Continuar hasta el próximo punto de ruptura: <code>continue</code>, <code>c</code></p></li><li><p><code>run</code>, <code>n</code>, RETURN, RET, RET, <code>p sum</code></p></li></ul></div>
<h level="4">Bucle</h><div class="ulist"><ul><li><p>¿cómo salir de un bucle de cientos o miles de iteracciones hasta la siguiente instrucción fuera del bucle?</p></li><li><p><code>run</code>, <code>until</code>, RET,RET,RET..hasta salir del bucle.., <code>p sum</code>, <code>c</code></p></li></ul></div>
<h level="4">Análisis de la memoria principal DRAM</h><div class="ulist"><ul><li><p>imprimir el contenido de variables y sus direcciones en la memoria principal</p></li><li><p><code>print n</code>, <code>p n</code>, <code>p /t n</code>, <code>p /x n</code>, <code>ptype n</code>, <code>whatis n</code>,<code>p &amp;n</code></p></li><li><p><code>print symbol</code> : symbol es el nombre de la variable, no su dirección.</p></li><li><p><code>p $eax</code></p></li><li><p><code>p $ebx</code></p></li><li><p><code>p $ecx</code></p></li><li><p><code>info registers</code></p></li></ul></div>
<h level="4">Desensamblar</h><div class="ulist"><ul><li><p>Desensamblar: ingeniería inversa . Convierte el código binario en código ensamblador</p><div class="ulist"><ul><li><p><code>layout split</code></p></li><li><p>Next machine instruction: <code>ni</code>, RET, RET, RET, RET, <code>until</code>, RET,..hasta salir del bucle</p><div class="ulist"><ul><li><p>Ejecuta instrucciones máquina (observar ventana con el código ensamblador)</p></li></ul></div></li></ul></div></li></ul></div>
<h level="4">Salir</h><div class="ulist"><ul><li><p><code>exit</code></p></li></ul></div>
<div class="admonitionblock caution"><table><tr><td class="icon"><i class="fa fa-fire" title="Caution"></i></td><td class="content">Comprobar que el contenido del fichero <em>sum1toN_gdb_C.txt</em> es correcto.</td></tr></table></div>
<h level="3">Recordatorio: Documento Memoria</h><div class="ulist"><ul><li><p>Ir salvando el trabajo y comentándolo según se va realizando.</p></li><li><p>En la consola abrimos el fichero <code>sum1toN_gdb_C.txt</code> que contiene todos los comandos utilizados con sus volcados.</p></li><li><p>Guardar el contenido de <em>sum1toN_gdb_C.txt</em> en el Documento Memoria añadiendo los comentarios necesarios.</p></li></ul></div>
<h level="3">Continuamos con más ejercicios</h><h level="4">Jugar con el módulo fuente</h><div class="ulist"><ul><li><p>Cambios en el Módulo fuente en lenguaje C.</p><div class="ulist"><ul><li><p>Cambiar el tamaño de los datos con alguno de los siguientes tipos:</p><div class="ulist"><ul><li><p>char,short,int,long</p></li></ul></div></li><li><p>Cambiar el formato de los números con alguno de los siguientes bases:</p><div class="ulist"><ul><li><p>decimal, hexadecimal, octal, binario &#8594; prefijos 0x, 0, 0b &#8594; 0x5, 05, 0b5</p></li></ul></div></li><li><p>Compilar y ejecutarlos. Indicar en la memoria si da o no algún error</p></li></ul></div></li></ul></div>
<h level="4">Jugar con el depurador</h><div class="ulist"><ul><li><p>GDB</p><div class="ulist"><ul><li><p>Cambiar en el módulo fuente el tamaño de las variables a <em>char</em> y la sentencia sum+=n por la sentencia sum-=n .</p></li><li><p>Compilar el módulo fuente con la opción de inserción de la tabla de símbolos</p></li><li><p>Abrir el depurador y cargar el módulo binario</p></li><li><p>Ejecutar en modo paso a paso observando las sumas parciales con lo siguientes comandos:</p><div class="ulist"><ul><li><p><code>x /1db &amp;sum</code>, <code>x /1tb &amp;sum</code>, <code>x /1ob &amp;sum</code>, <code>x /1xb &amp;sum</code></p></li><li><p>indicar para comando el resultado</p></li><li><p>Con la ayuda de <code>help x</code> explica el significado de <code>1db</code>, <code>1tb</code>, <code>1ob</code>, <code>1xb</code>.</p></li></ul></div></li></ul></div></li></ul></div></div></section><section id="_programación_sum1ton_s"><h2>12.6. Programación sum1toN.s</h2><div class="slide-content"><h level="3">Algoritmo</h><div class="ulist"><ul><li><p>Desarrollar un programa en lenguaje ensamblador AT&amp;T con la arquitectura <em>i386</em> que realice la suma \(\sum_{i=1}^{N}i\) cuyo resultado es \(N(N+1)/2\) utilizando el <a href="#prac_prog">método de programación</a> de descripción inicial en lenguaje pseudocódigo y organigrama.</p></li></ul></div>
<h level="3">Edición del Módulo fuente: sum1toN.s</h><div class="ulist"><ul><li><p>Descargar el módulo fuente "sum1toN.s" de miaulario y añadir los comentarios apropiados.</p></li><li><p>x86 es la arquitectura de Intel de 32 bits</p></li><li><p>i386 significa en linux: arquitectura x86-32</p></li><li><p>Lenguaje ensamblador AT&amp;T de GNU para la arquitectura i386 &#8594; lenguaje GNU as &#8594; lenguaje gas</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-nasm" data-lang="nasm">### Programa: sum1toN.s
### Descripción: realiza la suma de la serie 1,2,3,...N. La entrada se define en el propio programa y la salida se pasa al S.O.
### Lenguaje: Lenguaje ensamblador de GNU para la arquitectura i386 -&gt; GNU as -&gt; gas -&gt; AT&amp;T
### Es el programa en lenguaje AT&amp;T i386 equivalente a sum.ias de la máquina IAS de von Neumann
### gcc -m32 -g -nostartfiles -o sum1toN  sum1toN.s
### Ensamblaje as --32 --gstabs sum1toN.s -o sum1toN.o
### linker -&gt; ld -melf_i386   -o sum1toN sum1toN.o

        ##  Declaración de variables
	##  SECCION DE DATOS
        .section .data

n:      .int 5

        .global _start

        ##  Comienzo del código
	##  SECCION DE INSTRUCCIONES
        .section .text
_start:
        mov $0,%ecx # ECX implementa la variable suma
        mov n,%edx
bucle:
        add %edx,%ecx
        sub $1,%edx
        jnz bucle

        mov %ecx, %ebx # el argumento de salida al S.O. a través de EBX según convenio ABI i386

        ## salida
        mov $1, %eax  # código de la llamada al sistema operativo: subrutina exit
        int $0x80     # llamada al sistema operativo para que ejecute la subrutina según el valor de EAX


        .end</code></pre></div></div></li></ul></div>
<h level="3">Compilación</h><div class="ulist"><ul><li><p>Seguir los pasos de la <a href="#compilacion_asm">compilación </a> de un módulo en lenguaje ensamblador.</p><div class="ulist"><ul><li><p><code>gcc -m32 -g -o sum1toN sum1toN.s</code></p></li></ul></div></li></ul></div>
<h level="3">Ejecución</h><div class="ulist"><ul><li><p><code>./sum1toN</code></p></li><li><p><code>echo $?</code></p></li></ul></div>
<h level="3">Análisis del módulo Fuente</h><div class="ulist"><ul><li><p>Leer en las hojas de referencia rápida el <a href="#programa_minimalista">Programa Ejemplo Minimalista</a></p></li></ul></div>
<h level="3">Depuración</h><h level="4">Inicio</h><div class="ulist"><ul><li><p>Depurador GDB: GNU DeBugger.</p></li><li><p><code>gcc -m32 -g -o sum1toN sum1toN.s</code></p></li><li><p><code>gdb</code></p></li><li><p><code>C-x a</code></p></li><li><p><code>C-x o</code></p></li><li><p><code>set trace-commands on</code></p></li><li><p><code>set logging file sum1toN_gdb_asm.txt</code></p></li><li><p><code>set logging on</code></p></li><li><p><code>shell ls -l sum1toN_gdb_asm.txt</code></p></li></ul></div>
<h level="4">Arrancar el programa</h><div class="ulist"><ul><li><p><code>file sum1toN</code></p></li><li><p><code>info sources</code></p></li><li><p><code>b _start</code></p></li><li><p><code>run</code></p></li></ul></div>
<h level="4">Analizar símbolos en memoria</h><div class="ulist"><ul><li><p><code>ptype n</code></p></li><li><p><code>p n</code></p><div class="ulist"><ul><li><p><code>x address</code> : examine main memory address . Devuelve el contenido de la dirección de memoria address &#8594; <em>&amp;symbol</em> donde symbol es el nombre de la variable.</p></li></ul></div></li><li><p><code>x &amp;n</code>, <code>x n</code>, <code>x /1bw &amp;n</code>, <code>x /1xw &amp;n</code>, <code>x /4xw &amp;n</code></p></li><li><p><code>b bucle</code></p></li><li><p><code>c</code></p></li><li><p><code>start</code></p></li><li><p><code>c</code></p></li><li><p><code>n</code></p></li></ul></div>
<h level="4">Registros</h><div class="ulist"><ul><li><p><code>p $ecx</code></p></li><li><p><code>p $edx</code></p></li><li><p><code>until</code></p></li><li><p><code>p $ecx</code></p></li><li><p><code>p $edx</code></p></li><li><p><code>info registers</code></p></li></ul></div>
<h level="4">Instrucciones máquina</h><div class="ulist"><ul><li><p><code>layout split</code></p></li><li><p><code>start</code></p></li><li><p><code>c</code></p></li></ul></div>
<h level="4">Fin</h><div class="ulist"><ul><li><p><code>exit</code></p></li><li><p>En la consola abrimos el fichero <code>gedit  sum1toN_gdb_asm.txt</code> que contiene todos los comandos utilizados con sus volcados.</p></li><li><p>Guardar el contenido de <em>sum1toN_gdb_asm.txt</em> en el Documento Memoria añadiendo los comentarios necesarios.</p></li></ul></div></div></section><section id="_arquitectura_amd64_4"><h2>12.7. Arquitectura amd64</h2><div class="slide-content"><div class="ulist"><ul><li><p>Ejemplo en el apéndice : <a href="#sum1toN_att_64">sum1toN.s</a></p><div class="ulist"><ul><li><p>Analizar el código, compilarlo, ejecutarlo y comprobar mediante el debugger que efectivamente los registros son de 64 bits.</p></li></ul></div></li></ul></div></div></section></section>
<section><section id="_representación_de_los_datos_2"><h2>13. Representación de los Datos</h2></section><section id="_introducción_18"><h2>13.1. Introducción</h2><div class="slide-content"><h level="3">Objetivos</h><div class="ulist"><ul><li><p>Programación:</p><div class="ulist"><ul><li><p>Desarrollar programas que almacenen y procesen distintos tipos de datos como enteros con signo, caracteres, arrays, strings de distintos tamaños como 1 byte, 2 bytes, 4 bytes, etc..</p></li><li><p>Empleo de los sufijos de los mnemónicos: analizar el tamaño de los operandos según el sufijo del mnemónico empleado, el tamaño del operando registro y el tipo de operando en memoria.</p></li><li><p>Emplear distintos tipos de modos de direccionamiento (inmediato, directo, indirecto, indexado) de acceso a los operandos</p></li><li><p>Empleo de Macros mediante directivas.</p></li><li><p>Concepto de llamada al sistema operativo.</p></li></ul></div></li><li><p>Análisis:</p><div class="ulist"><ul><li><p>Comprobación del tipo de alineamiento <em>little endian</em> de los datos almacenados en memoria</p></li><li><p>Analizar el contenido de la memoria como números con signo, caracteres, arrays y strings: tipos y tamaños de los operandos numéricos y de los operandos alfanuméricos</p></li><li><p>Realizar la operación de desensamblaje para comprobar el lenguaje máquina del módulo ejecutable cargado en la memoria principal</p></li></ul></div></li></ul></div>
<h level="3">Módulos fuente: características</h><div class="ulist"><ul><li><p><strong>datos_size.s</strong></p><div class="ulist"><ul><li><p>Declaración del tamaño de los operandos:</p><div class="ulist"><ul><li><p>Mediante las directivas  (.byte, .2byte, .short, etc ..)</p></li></ul></div></li><li><p>Declaración de <strong>arrays</strong> de datos numéricos mediante directivas (.short,.int, etc ..)</p></li><li><p>Declaración de datos <strong>alfanuméricos</strong> mediante:</p><div class="ulist"><ul><li><p>Directivas del ensamblador (.ascii, .asciiz, .string, etc)</p></li></ul></div></li><li><p>Empleo de Macros</p></li></ul></div></li><li><p><strong>datos_sufijos.s</strong></p><div class="ulist"><ul><li><p>Acceso a los operandos mediante instrucciones con los <strong>sufijos</strong>  (b,w,l,q)</p></li></ul></div></li><li><p><strong>datos_direccionamiento.s</strong></p><div class="ulist"><ul><li><p>Diferentes Modos de direccionamiento de los operandos: inmediato, directo, indirecto, indexado</p></li></ul></div></li></ul></div>
<h level="3">Requisitos</h><div class="ulist"><ul><li><p>Teoría: representación de datos, formato de instrucciones y repertorio  ISA de la arquitectura X86.</p><div class="ulist"><ul><li><p>Almacenamiento con <strong>alineamiento interno</strong> de bytes "little endian"</p></li></ul></div></li><li><p>Práctica previa: Introducción a la programación en lenguaje ensamblador AT&amp;T x86-32</p></li><li><p>Conceptos del lenguaje de <strong>programación C</strong>:</p><div class="ulist"><ul><li><p>Punteros, array, string y operación de casting.</p></li></ul></div></li></ul></div></div></section><section id="_leeme_2"><h2>13.2. LEEME</h2><div class="slide-content"><div class="ulist"><ul><li><p>Lectura del guión de prácticas  y del capítulo 3 del Libro <strong>Programming from the Ground-Up</strong>.</p></li><li><p><a href="#prac_apu">Apuntes y Libro de Texto</a></p></li><li><p><a href="#prac_doc_mem">Documentación Memoria</a>: Contenido y Formato de la Memoria</p></li><li><p><a href="#prac_eval">Evaluación</a>: sistema de evaluación</p></li><li><p><a href="#prac_plat_des">Plataforma de Desarrollo</a> : configuración de la computadora personal</p></li><li><p><a href="#prac_prog">Programación</a> : metodología</p></li></ul></div></div></section><section id="_cuestiones_opcionales"><h2>13.3. Cuestiones Opcionales</h2><div class="slide-content"><div class="ulist"><ul><li><p><a href="#prac_eval">"Autoevaluación de Prácticas"</a> opcional: <a href="#prac_cues">Prácticas: Cuestionario</a></p><div class="ulist"><ul><li><p>Los ejercicios opcionales suman 4 puntos en la calificación de las memorias.</p></li></ul></div></li></ul></div></div></section><section id="_registros_internos_de_la_cpu"><h2>13.4. Registros internos de la CPU</h2><div class="slide-content"><div class="ulist"><ul><li><p>La arquitecura amd64 dispone de:</p><div class="ulist"><ul><li><p>16 registros de propósito general (RPG) de 64 bits cada uno: rax,rbx,rcx,rdx,rsi,rdi,rsp, etc</p></li><li><p>1 registros de estado de 64 bits: rflags</p></li></ul></div></li><li><p>El acceso a los registros de propósito general puede ser <em>parcial</em>:</p><div class="ulist"><ul><li><p>Registro RAX: es un registro de 64 bits</p></li><li><p>Registro EAX: son los 32 bits de menor peso de RAX</p></li><li><p>Registro AX:  son los 16 bits de menor peso de RAX</p></li><li><p>Registro AL:  son los  8 bits de menor peso de RAX</p></li><li><p>Registro AH:  es el byte con los bits de las posiciones 8:15 de RAX</p></li></ul></div></li><li><p>En las <a href="#registros_32">"Hojas de Referencia Rápida"</a> están representados todos los nombres de los difererentes grupos de bits de cada registro de propósito general.</p></li></ul></div></div></section><section id="_tamaño_de_los_datos_y_variables"><h2>13.5. Tamaño de los datos y variables</h2><div class="slide-content"><h level="3">Algoritmo</h><div class="ulist"><ul><li><p>La sección de instrucciones comprende un algoritmo que inicializa dos punteros.</p></li></ul></div>
<h level="3">Edición del Módulo fuente: datos_size.s</h><div class="ulist"><ul><li><p>Descargar el módulo fuente "datos_size.s" de miaulario y añadir los comentarios apropiados.</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-nasm" data-lang="nasm">### Programa: datos_size.s
### Descripción: declarar y acceder a distintos tamaños de operandos
### Compilación: gcc -m32 -g -o datos_size datos_size.s

	## MACROS
	.equ SYS_EXIT,	1
	.equ SUCCESS,	0

	## VARIABLES LOCALES
	.data

da1:	.byte   0x0A
da2:	.2byte  0x0A0B
da4:	.4byte  0x0A0B0C0D
men1:	.ascii  "hola"
lista:  .int    1,2,3,4,5

	## INSTRUCCIONES
	.global _start
	.text
_start:
	mov $da4,%eax
	lea da4,%ebx
	mov (%eax),%ecx
	mov (%ebx),%edx
salida:
	mov $SYS_EXIT, %eax
	mov $SUCCESS,  %ebx
	int $0x80

	.end</code></pre></div></div></li></ul></div>
<h level="3">Compilación</h><div class="ulist"><ul><li><p>Seguir los pasos del proceso de <a href="#compilacion">compilación</a> común a todas las sesiones.</p><div class="ulist"><ul><li><p><code>gcc -nostartfiles -m32 -g -o datos_size datos_size.s</code></p></li></ul></div></li></ul></div>
<h level="3">Ejecución</h><div class="ulist"><ul><li><p><code>./datos_size</code></p></li><li><p><code>echo $?</code></p></li></ul></div>
<h level="3">Análisis del módulo fuente</h><div class="ulist"><ul><li><p>Leer en las hojas de referencia rápida el <a href="#programa_minimalista">Programa Ejemplo Minimalista</a></p></li></ul></div>
<h level="4">Estructura en secciones: ensamblaje</h><div class="ulist"><ul><li><p>La estructura del programa esta formada por los siguientes elementos:</p><div class="ulist"><ul><li><p>Cabecera</p></li><li><p>Definición de Macros</p></li><li><p>Sección de Datos</p></li><li><p>Sección de Instrucciones</p></li></ul></div></li></ul></div>
<h level="4">Definición de Macros</h><div class="ulist"><ul><li><p>Macro:</p><div class="ulist"><ul><li><p>La construcción macro se utiliza en el programa fuente para sustituir datos utilizados en el programa fuente por símbolos de texto que faciliten la lectura del código fuente.</p></li><li><p>Para ello empleamos la directiva "EQU" cuya sintaxis es: <code>.EQU  SÍMBOLO, dato</code></p></li><li><p>El preprocesador en la primera fase de la compilación sustituirá el texto SIMBOLO que aparece a lo largo de la sección de datos e instrucciones por el dato asociado.</p></li></ul></div></li><li><p>Macros empleadas</p><div class="ulist"><ul><li><p>SYS_EXIT : código de la llamada al sistema para finalizar el programa y devolver el control al Sistema Operativo. En la arquitectura i386 su valor es 1.</p></li><li><p>SUCCESS  : código empleado por los programas para indicar que su ejecución se ha realizado con normalidad. Su valor es 0.</p></li></ul></div></li></ul></div>
<h level="4">Sección de Datos</h><div class="ulist"><ul><li><p>Interpretar las etiquetas y directivas de reserva de memoria e inicialización para los datos utilizando la <a href="#directivas_as">tabla de directivas</a>: identificar las variables ordinarias, strings y arrays.</p></li></ul></div>
<div class="admonitionblock caution"><table><tr><td class="icon"><i class="fa fa-fire" title="Caution"></i></td><td class="content">Si un objeto de memoria es inicializado con un número entero que es representado con menos dígitos que el tamaño del objeto, los digitos de mayor peso tendrán de valor cero. Por ejemplo:  <code>.4byte 0xFF</code> equivale a <code>.4byte 0x000000FF</code></td></tr></table></div>
<h level="4">Sección de Instrucciones</h><div class="ulist"><ul><li><p>Determinar la instrucción de entrada al programa.</p></li><li><p>Determinar el bloque de salida del programa.</p></li></ul></div>
<h level="3">GDB: Observaciones</h><div class="ulist"><ul><li><p>El depurador al visualizar el contenido de los registros:</p><div class="ulist"><ul><li><p>únicamente visualiza el número de bytes del tamaño de los operandos..aunque los registros "r-x" son de 64 bits (rax,rbx,etc..)</p></li><li><p>con números enteros con signo, no visualiza los ceros de mayor peso, es decir, ni el signo ni la extensión de signo de los números positivos.</p></li></ul></div></li></ul></div>
<h level="3">GDB:Ejecución paso a paso</h><h level="4">Inicialización</h><div class="ulist"><ul><li><p>Compilar el programa con la opción de generación de la tabla de símbolos requerida por el depurador y generar el módulo binario ejecutable:</p><div class="ulist"><ul><li><p><code>gcc -nostartfiles -m32 -g  -o datos_size datos_size.s</code></p></li></ul></div></li><li><p>Abrir el depurador GDB, cargar el módulo binario ejecutable y comprobar que se carga la tabla de símbolos junto al módulo binario ejecutable.</p><div class="ulist"><ul><li><p><code>gdb</code></p></li><li><p><code>file datos_size</code></p></li><li><p><code>info sources</code></p></li></ul></div></li><li><p>Abrir la ventana para el módulo fuente</p><div class="ulist"><ul><li><p><code>layout src</code> ó <code>Control-x Control-a</code></p></li></ul></div></li><li><p>Configurar el fichero para el logging histórico de los comandos.</p><div class="ulist"><ul><li><p><code>set trace-commands on</code></p></li><li><p><code>set logging file datos_size_gdb_asm.txt</code></p></li><li><p><code>set logging on</code></p></li><li><p><code>shell ls -l datos_size_gdb_asm.txt</code></p></li></ul></div></li><li><p>Activar un punto de ruptura en la instrucción de entrada al programa.</p><div class="ulist"><ul><li><p><code>b _start</code></p></li></ul></div></li><li><p>Ejecutar el programa deteniéndolo en la primera instrucción del programa.</p><div class="ulist"><ul><li><p><code>run</code></p></li></ul></div></li></ul></div>
<h level="4">Comandos y operadores: x, p, disas, casting, &amp;, <code>*</code>, @</h><div class="ulist"><ul><li><p>comando eXaminar <strong>x</strong>: vuelca el contenido de una <strong>dirección</strong> de memoria</p><div class="ulist"><ul><li><p><code>x /nvt address</code></p></li><li><p>formato /nvt : "t" es el <em>tamaño</em> de la variable en memoria , "v" la codificación del <em>valor</em> del contenido de memoria a visualizar y "n" el <em>número</em> de veces que hay que volcar secuencialmente grupos de bytes en memoria de tamaño "t" comenzando en  la dirección <em>address</em></p></li><li><p><code>help x</code> : formatos d (decimal) ,x (hexadecimal),t (binario) ,o (octal) ,c (character) ,a (address),i (instruction),etc</p></li><li><p>ejemplos:</p><div class="ulist"><ul><li><p>x /1d4 address (ejecutar 1 vez el comando examinar en código decimal volcando un objeto de 4bytes ubicado en la dirección address)</p></li><li><p>x /2t4 address (ejecutar 2 veces el comando examinar en código binario: volcando la primera vez un objeto de 4 bytes ubicado en la dirección address y volcando la segunda vez un objeto de 4 bytes ubicado en la dirección address+4)</p></li><li><p>x /100x1 address: vuelca 100 datos de 1 byte en código hexadecimal a partir de la dirección address.</p></li></ul></div></li><li><p>La sintaxis del argumento del comando examinar es la misma que en lenguaje de <strong>programación de C</strong>.</p><div class="ulist"><ul><li><p>work language: <code>show language</code> &#8594; indica que el lenguaje de las expresiones GDB son ASM (pej $eax) pero en cambio también admite el lenguaje C (&amp;variable)</p></li><li><p>work languages supported: <code>set language</code></p></li></ul></div></li></ul></div></li><li><p>operador <strong>&amp;</strong> : se utiliza como prefijo de una etiqueta para evaluar la dirección de memoria a la que hace referencia una etiqueta</p></li><li><p>operador <strong>*</strong> : se utiliza para evaluar el contenido de una posición de memoria mediante la indirección de un puntero</p></li><li><p>operación de <strong>casting</strong>:</p><div class="ulist"><ul><li><p><a href="#prog_C">Apéndice Programación Lenguaje C</a></p></li><li><p>El casting consiste en definir o redifinir el tipo de variable. Se utiliza como prefijo de la variable a redefinir y va entre paréntesis.</p></li><li><p>la etiqueta "lista" está definida en la sección de datos mediante la directiva ".int". Esta directiva reserva memoria para inicializar los datos a partir de la dirección &amp;lista pero NO es una declaración de tipo por lo que el depurador NO tiene información sobre el tipo de elementos del array lista y por ello es necesario realizar declaraciones en modo casting.</p></li><li><p>Ej. (char *): el tipo <code>char *</code> es un puntero a un entero de 1 byte.</p></li></ul></div></li><li><p>comando Print <strong>p</strong>: Evalua el argumento del comando y el valor resultante lo imprime en pantalla</p><div class="ulist"><ul><li><p>La sintaxis del argumento del comando examinar es la misma que en lenguaje de programación de C.</p></li><li><p>Ej. p /a &amp;lista : evalua &amp;lista cuyo valor resulante se imprime con formato tipo "a" (address)</p></li><li><p>formatos de impresión: los mismos que eXaminar: <code>help x</code></p></li><li><p>operador @: <strong>direccion</strong>@<strong>n</strong>: array artificial: evalua la expresión "direccion" (a la izda de @) y debe ser una dirección de memoria. Crea una array artificial de longitud "n" (el valor del parámetro a la derecha del operador @) bytes.</p></li></ul></div></li><li><p>comando <strong>disas</strong> : desensambla el código binario traduciéndolo a código ensamblador.</p></li></ul></div>
<h level="4">Análisis</h><div class="ulist"><ul><li><p>Análisis del contenido de la memoria principal mediante el depurador GDB:</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-shell" data-lang="shell">//Alineamiento interno de los bytes de un dato
x /tb &amp;da1
x /xh &amp;da2
x /xw &amp;da4
x /5xb &amp;da4	-&gt; Alineamiento little endian

//Alineamiento de los bytes de un string
x /5cb &amp;men1	-&gt; Alineamiento en secuencia
x /5xb &amp;men1

//Volcado de un string
p /s (char *)&amp;men1	-&gt; imprime una cadena de caracteres desde la primera dirección hasta encontrar el caracter NULL (0x00).

//Volcado de un array
x /5xw &amp;lista	        -&gt; contenido de 5 elementos de lista
p /a &amp;lista	        -&gt; dirección del array lista
p /a &amp;lista+1  -&gt; el depurador informa que es necesario realizar algún tipo de casting (declaración dinámica)
p /a (void *)&amp;lista+1  	-&gt; se incrementa en 1 byte
p /a (int  *)&amp;lista+1   -&gt; escalado: se incrementa en  1*4 bytes apuntando al segundo elemento del array
p lista                	-&gt; el depurador informa que es necesario realizar un casting
p (int)lista            -&gt; primer elemento del array
p (int *)&amp;lista	        -&gt; dirección del array lista
p *((int *)&amp;lista+1)    -&gt; segundo elemento de lista
x /dw (int *)&amp;lista+1   -&gt; segundo elemento de lista
p (int [5])lista        -&gt; contenido de cinco elementos de lista
p *(int *)&amp;lista@5      -&gt; array artificial de 5 elementos de tipo int a partir de la dirección  &amp;lista.

//volcado de una instrucción
p &amp;_start
x /i &amp;_start		-&gt; desensambla: convierte el código máquina en código ensamblador.

//Desensamblar: Conversión del código máquina en ensamblador
disas /r _start
layout split

//Análisis de los punteros
b salida
c
p /a &amp;da4
x /x4 &amp;da4
p /x (int)da4
p /x $eax
p /x *(int *)$eax</code></pre></div></div></li></ul></div></div></section><section id="_tamaño_de_los_operandos"><h2>13.6. Tamaño de los Operandos</h2><div class="slide-content"><h level="3">Edición del Módulo fuente: datos_sufijos.s</h><div class="ulist"><ul><li><p>Descargar el módulo fuente "datos_sufijos.s" de miaulario y añadir los comentarios apropiados.</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-nasm" data-lang="nasm">### Programa: datos_sufijos.s
### Descripción: utilizar distintos sufijos para los mnemónicos indicado distintos tamaños de operandos
### Compilación: gcc -nostartfiles -m32 -g -o datos_sufijos datos_sufijos.s

	## MACROS
	.equ SYS_EXIT,	1
	.equ SUCCESS,	0

	## VARIABLES LOCALES
	.data

da1:	.byte   0x0A
da2:	.2byte  0x0A0B
da4:	.4byte  0x0A0B0C0D
saludo:	.ascii  "hola"
lista:  .int    1,2,3,4,5

	## INSTRUCCIONES
	.global _start
	.text
_start:

	## Reset de Registros
	xor  %eax,%eax
	xor  %ebx,%ebx
	xor  %ecx,%ecx
	xor  %edx,%edx

	## Carga de datos
	## mov da1,da4		ERROR: por referenciar las dos direcciones efectivas de los dos operandos a la memoria principal
	mov  da4,%eax
	movl da4,%ebx
	movw da4,%cx
	movb da4,%dl

	## Reset de Registros
	xor  %eax,%eax
	xor  %ebx,%ebx
	xor  %ecx,%ecx
	xor  %edx,%edx

	## Carga de datos
	mov  da4,%al		#aplica el tamaño de AL
	## movw  da4,%al	ERROR: incoherencia entre -w y AL
	movb da4,%ebx  	        #AVISO, NO error: incoherencia entre el regisro BL y el sufijo



	mov  da1,%ecx
	mov  da4,%dx

	## Reset de Registros
	xor  %eax,%eax
	xor  %ebx,%ebx
	xor  %ecx,%ecx
	xor  %edx,%edx

	## Carga de datos

        mov  da1,%al

	## inc da1     	ERROR: por ser la dirección efectiva del operando una referencia a la memoria principal no restringe el tamaño del operando. Al no especificar tampoco sufijo el ensamblador no reconoce el tamaño del operando.
	incb da1
	incw da2
	incl da4

## salida
	mov $SYS_EXIT, %eax
	mov $SUCCESS,  %ebx
	int $0x80

	.end</code></pre></div></div></li></ul></div>
<h level="3">Compilación</h><div class="ulist"><ul><li><p>Seguir los pasos de la <a href="#compilacion_asm">compilación </a> de un módulo en lenguaje ensamblador.</p><div class="ulist"><ul><li><p><code>gcc -nostartfiles -m32 -g -o datos_sufijos datos_sufijos.s</code></p></li><li><p>WARNING: <strong>Aviso:</strong> empleando <em>%bl</em> en lugar de <em>%ebx</em> debido a la utilización de <em>b</em> como sufijo</p><div class="ulist"><ul><li><p>Es un aviso de la sintaxis de la instrucción <code>movb da4,%ebx</code>, NO es un error.</p></li></ul></div></li></ul></div></li></ul></div>
<h level="3">Ejecución</h><div class="ulist"><ul><li><p><code>./datos_sufijos</code></p></li><li><p><code>echo $?</code></p></li></ul></div>
<h level="3">Análisis del módulo fuente asm</h><div class="ulist"><ul><li><p>Sufijos de los mnemónicos indicando distintos tamaños de los operandos: b,w,l</p><div class="ulist"><ul><li><p><code>movw da4,%cx</code>  : el sufijo "w" de 2 bytes y el registro destino CX de dos bytes.</p></li><li><p><code>movw da4,%al</code>  : el sufijo "w" impone una transferencia de 2 bytes a un registro destino AL de 1 byte &#8594; error en el ensamblaje.</p></li><li><p><code>movb da4,%ebx</code> : el sufijo "b" no es coherente con el registro destino EBX de 4 bytes y el ensamblaje se produce con BL.</p></li></ul></div></li><li><p>Sin sufijo:</p><div class="ulist"><ul><li><p><code>xor  %eax,%eax</code> : operandos fuente y destino EAX de 4 bytes</p></li><li><p><code>mov  da4,%al</code>  : el registro destino AL limita la transferencia a 1 byte y no hay contradicción con el sufijo ya que éste no existe.</p></li><li><p><code>mov  da1,%ecx</code> : de los dos operandos, registro y memoria, es el registro quien prioriza el tamaño de la transferencia.</p></li><li><p><code>inc da1</code>       : Al ser la dirección efectiva del operando una referencia a la memoria principal no restringe el tamaño del operando. Al no especificar tampoco un sufijo el ensamblador no reconoce el tamaño del operando &#8594; error en el ensamblaje</p></li></ul></div></li></ul></div>
<h level="3">Deducción del tamaño del operando en una instrucción asm</h><div class="olist arabic"><ol class="arabic"><li><p>Diferencia entre la referencia a un operando en memoria o registro</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Un operando referenciado mediante una dirección de memoria no tiene un tamaño específico para el assembler.</p></li><li><p>En cambio el nombre de un registro si es asociado a un tamaño de operando por el assembler.</p></li></ol></div></li><li><p>En una instrucción con un único operando en memoria el tamaño es deducido por el assembler gracias al sufijo del mnemónico, por lo tanto en este caso si el mnemónico no tiene sufijo el assembler no traducirá la instrucción.</p></li><li><p>En una instrucción con dos operandos, uno en memoria y otro en un registro, es el operando en el registro o el sufijo quienes especifican el tamaño de los dos operandos fuente y destino:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Si el mnemónico tiene sufijo, es dicho sufijo quien especifica el tamaño de los operandos fuente y destino.</p></li><li><p>Si el mnemónico no tiene sufijo, es el tamaño del registro quien especifica el tamaño de los operandos fuente y destino.</p></li></ol></div></li><li><p>Casos de error</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>En el caso de que el mnemónico tenga un sufijo mayor que el tamaño del registro destino.</p></li><li><p>En el caso de que el mnemónico no tenga sufijo y el tamaño del registro fuente sea mayor que el registro destino.</p></li></ol></div></li></ol></div>
<h level="3">GDB:Ejecución paso a paso</h><h level="4">Inicialización</h><div class="ulist"><ul><li><p>Compilar el programa con la opción de generación de la tabla de símbolos requerida por el depurador y generar el módulo binario ejecutable:</p><div class="ulist"><ul><li><p><code>gcc -nostartfiles -m32 -g  -o datos_sufijo datos_sufijo.s</code> donde modulo_fuente se sustituye por el nombre del archivo que se desea compilar.</p></li></ul></div></li><li><p>Abrir el depurador GDB, cargar el módulo binario ejecutable y comprobar que se carga la tabla de símbolos junto al módulo binario ejecutable.</p><div class="ulist"><ul><li><p><code>gdb</code></p></li><li><p><code>file modulo_ejecutable</code></p></li><li><p><code>info sources</code></p></li></ul></div></li><li><p>Abrir la ventana para el módulo fuente</p><div class="ulist"><ul><li><p><code>layout src</code> ó <code>Control-x Control-a</code></p></li></ul></div></li><li><p>Configurar el fichero para el logging histórico de los comandos.</p><div class="ulist"><ul><li><p><code>set trace-commands on</code></p></li><li><p><code>set logging file datos_sufijo_gdb_asm.txt</code></p></li><li><p><code>set logging on</code></p></li><li><p><code>shell ls -l datos_sufijo_gdb_asm.txt</code></p></li></ul></div></li><li><p>Activar un punto de ruptura en la instrucción de entrada al programa.</p><div class="ulist"><ul><li><p><code>b _start</code></p></li></ul></div></li><li><p>Ejecutar el programa deteniéndolo en la primera instrucción del programa.</p><div class="ulist"><ul><li><p><code>run</code></p></li></ul></div></li><li><p>abrir la ventana de visualización de los registros</p><div class="ulist"><ul><li><p><code>layout regs</code></p></li></ul></div></li><li><p>Análisis del contenido de la memoria principal mediante el depurador GDB.</p><div class="ulist"><ul><li><p>Ejecutar el programa paso a paso analizando el resultado de la ejecución de cada instrucción</p></li><li><p><code>n</code></p></li><li><p>RET, RET, RET, &#8230;&#8203;.</p></li></ul></div></li></ul></div></div></section><section id="_modos_de_direccionamiento_3"><h2>13.7. Modos de Direccionamiento</h2><div class="slide-content"><h level="3">Edición del Módulo fuente: datos_direccionamiento.s</h><div class="ulist"><ul><li><p>Descargar el módulo fuente "datos_direccionamiento.s" de miaulario y añadir los comentarios apropiados.</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-nasm" data-lang="nasm">### Program:     datos_direccionamiento.s
### Descripción: Emplear estructuras de datos con diferentes direccionamientos
### Compilación: gcc -m32 -g -o datos_direccionamiento datos_direccionamiento.s
###		 sin la opción startfiles al utilizar el punto de entrada referenciado con la etiqueta "main"

	## MACROS
	.equ SYS_EXIT,	1
	.equ SUCCESS,	0

	## VARIABLES LOCALES
	.data

	.align 4				     # Alineamiento con direcciones de MP múltiplos de 4
da2:	.2byte  0x0A0B,0b0000111101011100,-21,0xFFFF # Array da2 de elementos de 2 bytes
	.align 4
lista:  .word    1,2,3,4,5	# Array lista de elementos de 2 bytes
	.align 8
buffer:	.space  100		# Array buffer de 100 bytes
	.align 2
saludo:
	.string "Hola"		# Array saludo de elementos de 1 byte por ser caracteres

	## INSTRUCCIONES
	.global main
	.text
main:

	## RESET

	xor  %eax,%eax
	xor  %ebx,%ebx
	xor  %ecx,%ecx
	xor  %edx,%edx
	xor  %esi,%esi
        xor  %edi,%edi

	## ALGORITMO sum1toN

	## Direccionamiento inmediato
	mov $4,%si
	## Direccionamiento indexado
bucle:	add lista(,%esi,2),%di
	## Direccionamiento a registro
	dec %si
	## Direccionamiento relativo al PC
	jns bucle


	## EJERCICIOS SOBRE DIRECCIONAMIENTO

	## Direccionamiento indirecto
	lea buffer,%eax		#inicializo el puntero EAX
	## mov da2,(%eax) ERROR: la dirección efectiva de los dos operandos hacen referencia a la memoria principal
	mov da2,%bx
	mov %bx, (%eax)
	## Direccionamiento directo
	incw da2
	## Direccionamiento indexado
	lea  da2,%ebx
	## inc 2(%ebx) ERROR: dirección efectiva a memoria y no hay sufijo
	incw 2(%ebx)

	mov $3,%esi
	mov da2(,%esi,2),%ebx

	## SALIDA

	mov $SYS_EXIT, %eax
	mov $SUCCESS,  %ebx
	int $0x80

	.end</code></pre></div></div></li></ul></div>
<h level="3">Compilación</h><div class="ulist"><ul><li><p>Seguir los pasos de la <a href="#compilacion_asm">compilación </a> de un módulo en lenguaje ensamblador.</p><div class="ulist"><ul><li><p>El punto de entrada no es "_start".</p></li><li><p><code>gcc -m32 -g -o datos_direccionamiento datos_direccionamiento.s</code></p></li></ul></div></li></ul></div>
<h level="3">Ejecución</h><div class="ulist"><ul><li><p><code>./datos_direccionamiento</code></p></li><li><p><code>echo $?</code></p></li></ul></div>
<h level="3">Análisis del módulo fuente asm</h><div class="ulist"><ul><li><p>Alineación de datos mediante la directiva <code>.align n</code> asigna una dirección de memoria múltiplo de <em>n</em> al siguiente dato declarado.</p></li></ul></div>
<div class="admonitionblock caution"><table><tr><td class="icon"><i class="fa fa-fire" title="Caution"></i></td><td class="content">NO está permitido que en el caso de una instrucción con dos operandos, ambos estén en la memoria principal. Uno o los dos operandos han de estar en los registros de propósito general.</td></tr></table></div>
<h level="3">GDB: Ejecución paso a paso</h><h level="4">inicialización</h><div class="ulist"><ul><li><p>Compilar el programa con la opción de generación de la tabla de símbolos requerida por el depurador y generar el módulo binario ejecutable:</p><div class="ulist"><ul><li><p><code>gcc  -m32 -g  -o datos_direccionamiento datos_direccionamiento.s</code> donde modulo_fuente se sustituye por el nombre del archivo que se desea compilar.</p></li></ul></div></li><li><p>Abrir el depurador GDB, cargar el módulo binario ejecutable y comprobar que se carga la tabla de símbolos junto al módulo binario ejecutable.</p><div class="ulist"><ul><li><p><code>gdb</code></p></li><li><p><code>file datos_direccionamiento</code></p></li><li><p><code>info sources</code></p></li></ul></div></li><li><p>Abrir la ventana para el módulo fuente</p><div class="ulist"><ul><li><p><code>layout src</code> ó <code>Control-x Control-a</code></p></li></ul></div></li><li><p>Configurar el fichero para el logging histórico de los comandos.</p><div class="ulist"><ul><li><p><code>set trace-commands on</code></p></li><li><p><code>set logging file datos_direccionamiento_gdb_asm.txt</code></p></li><li><p><code>set logging on</code></p></li><li><p><code>shell ls -l datos_direccionamiento_gdb_asm.txt</code></p></li></ul></div></li><li><p>Activar un punto de ruptura en la instrucción de entrada al programa.</p><div class="ulist"><ul><li><p><code>b _start</code></p></li></ul></div></li><li><p>Ejecutar el programa deteniéndolo en la primera instrucción del programa.</p><div class="ulist"><ul><li><p><code>run</code></p></li></ul></div></li></ul></div>
<h level="4">Análisis</h><div class="ulist"><ul><li><p>Array <em>da2</em></p><div class="ulist"><ul><li><p>Imprimir la dirección de memoria del array <em>da2</em> y el contenido del primer elemento: <code>x /xh &amp;da2</code></p></li><li><p>4 elementos de 2bytes del array da2: <code>x /4xh &amp;da2</code></p></li><li><p><code>p /x (short[4])da2</code></p></li></ul></div></li><li><p>Array <em>lista</em></p><div class="ulist"><ul><li><p><code>ptype lista</code></p></li><li><p><code>p (short[5])lista</code></p></li></ul></div></li><li><p>Array <em>buffer</em></p><div class="ulist"><ul><li><p><code>ptype buffer</code></p></li><li><p>Imprimir la dirección de memoria del array <em>buffer</em> y comprobar su alineamiento: <code>p &amp;buffer</code></p></li></ul></div></li><li><p>String</p><div class="ulist"><ul><li><p><code>ptype saludo</code> : no debug info &#8594; no admite referencia elemento array expresión <em>saludo[n]</em></p></li><li><p><code>p /c (char[5])saludo</code>   :casting array</p></li><li><p><code>x /5c (char *)&amp;saludo</code>  :casting puntero</p></li><li><p><code>p /c *(char *)&amp;saludo</code>  :casting puntero e indirección</p></li><li><p><code>p /s (char *)&amp;saludo</code>   :casting puntero y formato string</p></li></ul></div></li></ul></div></div></section></section>
<section><section id="_operaciones_aritméticas_y_lógicas"><h2>14. Operaciones Aritméticas y Lógicas</h2></section><section id="_introducción_19"><h2>14.1. Introducción</h2><div class="slide-content"><h level="3">Objetivos</h><div class="ulist"><ul><li><p>Programación:</p><div class="ulist"><ul><li><p>Realizar operaciones aritméticas (suma,resta,multiplicación y división) con números enteros.</p></li></ul></div></li><li><p>Análisis:</p><div class="ulist"><ul><li><p>Comprobar cómo afectan las operaciones lógicas y aritméticas a los flags del registro de estado EFLAGS</p></li><li><p>Analizar el contenido de la memoria como números con signo, caracteres, arrays y strings: tipos y tamaños de los operandos numéricos y de los operandos alfanuméricos</p></li><li><p>Realizar la operación de desensamblaje para comprobar el lenguaje máquina del módulo ejecutable cargado en la memoria principal</p></li></ul></div></li></ul></div>
<h level="3">Conceptos de Arquitectura</h><div class="ulist"><ul><li><p>La Unidad Aritmético-Lógica ALU sólo opera con números enteros almacenados en los registros de propósito general. Para operar con números reales es necesaria la unidad Float Process Unit FPU con los operandos almacenados en los registros específicos para números en coma flotante.</p></li></ul></div>
<h level="3">Módulos fuente</h><div class="ulist"><ul><li><p><strong>op_arit_log.s</strong></p></li></ul></div>
<h level="3">Requisitos</h><div class="ulist"><ul><li><p>Teoría: representación de datos, operaciones aritméticas y lógicas, formato de instrucciones y repertorio  ISA de la arquitectura X86.</p></li><li><p>Prácticas previas:</p><div class="ulist"><ul><li><p>Introducción a la programación en lenguaje ensamblador AT&amp;T x86-32</p></li><li><p>Representación de los Datos</p></li></ul></div></li></ul></div></div></section><section id="_leeme_3"><h2>14.2. LEEME</h2><div class="slide-content"><div class="ulist"><ul><li><p>Lectura del guión de prácticas  y del capítulo 3 del Libro Programming from the Ground-Up.</p></li><li><p><a href="#prac_apu">Apuntes y Libro de Texto</a></p></li><li><p><a href="#prac_doc_mem">Documentación Memoria</a>: Contenido y Formato de la Memoria</p></li><li><p><a href="#prac_eval">Evaluación</a>: sistema de evaluación</p></li><li><p><a href="#prac_plat_des">Plataforma de Desarrollo</a> : configuración de la computadora personal</p></li><li><p><a href="#prac_prog">Programación</a> : metodología</p></li></ul></div></div></section><section id="_cuestiones_3"><h2>14.3. Cuestiones</h2><div class="slide-content"><div class="ulist"><ul><li><p><a href="#prac_eval">"Autoevaluación de Prácticas"</a> opcional: <a href="#prac_cues">Prácticas: Cuestionario</a></p></li></ul></div></div></section><section id="_registros_internos_de_la_cpu_2"><h2>14.4. Registros internos de la CPU</h2><div class="slide-content"><div class="ulist"><ul><li><p>La arquitecura amd64 dispone de:</p><div class="ulist"><ul><li><p>16 registros de propósito general (RPG) de 64 bits cada uno: rax,rbx,rcx,rdx,rsi,rdi,rsp, etc</p></li><li><p>1 registros de estado de 64 bits: rflags</p></li></ul></div></li><li><p>El acceso a los registros de propósito general puede ser <em>parcial</em>:</p><div class="ulist"><ul><li><p>Registro RAX: es un registro de 64 bits</p></li><li><p>Registro EAX: son los 32 bits de menor peso de RAX</p></li><li><p>Registro AX:  son los 16 bits de menor peso de RAX</p></li><li><p>Registro AL:  son los  8 bits de menor peso de RAX</p></li><li><p>Registro AH:  es el byte con los bits de las posiciones 8:15 de RAX</p></li></ul></div></li><li><p>En las <a href="#registros_32">"Hojas de Referencia Rápida"</a> están representados todos los nombres de los difererentes grupos de bits de cada registro de propósito general.</p></li></ul></div></div></section><section id="_operaciones_aritméticas_y_lógicas_con_números_enteros_con_signo"><h2>14.5. Operaciones Aritméticas y Lógicas con Números Enteros con Signo</h2><div class="slide-content"><h level="3">Edición del Módulo fuente: op_arit_log.s</h><div class="ulist"><ul><li><p>Descargar el módulo fuente "op_arit_log.s" de miaulario y añadir los comentarios apropiados.</p></li></ul></div>
<div class="listingblock"><div class="content"><pre>### Programa:     op_arit_log.s
### Descripción: Emplear estructuras de datos con diferentes operaciones lógicas y aritméticas.
### Compilación: gcc -m32 -g -o op_arit_log op_arit_log.s

	## MACROS
	.equ SYS_EXIT,	1
	.equ SUCCESS,	0
	.equ N,		5

	## VARIABLES LOCALES


	## INSTRUCCIONES
	.global main
	.text
main:

	## RESET

	xor  %eax,%eax
	xor  %ebx,%ebx
	xor  %ecx,%ecx
	xor  %edx,%edx
	xor  %esi,%esi
        xor  %edi,%edi


	## OPERACIONES ARITMETICAS con NUMEROS ENTEROS

	## add: suma
	mov $5,%eax
	mov $10,%ebx
	add %ebx,%eax

	##  sub: resta   <i class="conum" data-value="1"></i><b>(1)</b>
	mov $5,%eax
	mov $10,%ebx
	sub %ebx,%eax


	##  imul: multiplicación entera "con signo": AX&lt;- BL*AL  <i class="conum" data-value="2"></i><b>(2)</b>
        movb $-3,%bl
	movb $5,%al
	imulb %bl

        ##  idiv: división "con signo" .   (AL=Cociente, AH=Resto) &lt;- AX/(byte en registro o memoria)	  <i class="conum" data-value="3"></i><b>(3)</b>
	movw $5,%ax		#dividendo
	movb $3,%bl		#divisor
	idivb %bl	    # 5/3 = 1*3 + 2

        ## complemento a 2: equivalente a cambiar de signo negación
	negb %bl


	## Expresión N*(N+1)/2
	movw $N,%bx
	movw $(N+1),%ax
	imulw %bx		#imulw Op ; Op=word ; DX:AX&lt;- AX*Op
	movw $2,%bx
	##  El resultado queda en AX y el resto DX=0 <i class="conum" data-value="4"></i><b>(4)</b>
	idivw %bx		#idivw Op ; Op=word ; AX&lt;-(DX:AX)/Op ; DX:=Resto


	## OPERACIONES LOGICAS

	mov $0xFFFF1F, %eax
        mov $0x0000F1, %ebx
	not %eax	# inversión
	and %ebx,%eax	# producto lógico
	or  %ebx,%eax	# suma lógica

        ## Complemento a 2 mediante operación lógica not()+1
	mov %ebx,%eax
	not %eax
	inc %eax

	## Desplazamiento de bits <i class="conum" data-value="5"></i><b>(5)</b>
        shr $4,%eax		#desplazamiento lógico: bits a introduccir -&gt; 0..
	sar $4,%eax		#desplazamiento aritmético: bits a introducir -&gt; extensión del signo

	## SALIDA

	mov $SYS_EXIT, %eax
	mov $SUCCESS,  %ebx
	int $0x80

	.end</pre></div></div>
<div class="colist arabic"><table><tr><td><i class="conum" data-value="1"></i><b>1</b></td><td>Instrucciones referenciadas en las cuestiones de autoevaluación</td></tr><tr><td><i class="conum" data-value="2"></i><b>2</b></td><td>"               "                  "               "</td></tr><tr><td><i class="conum" data-value="3"></i><b>3</b></td><td>"               "                  "               "</td></tr><tr><td><i class="conum" data-value="4"></i><b>4</b></td><td>"               "                  "               "</td></tr><tr><td><i class="conum" data-value="5"></i><b>5</b></td><td>"               "                  "               "</td></tr></table></div>
<h level="3">Compilación</h><div class="ulist"><ul><li><p>Seguir los pasos de la <a href="#compilacion_asm">compilación </a> de un módulo en lenguaje ensamblador.</p><div class="ulist"><ul><li><p>El punto de entrada no es "_start".</p></li><li><p><code>gcc -m32 -g -o op_arit_log op_arit_log.s</code></p></li></ul></div></li></ul></div>
<h level="3">Ejecución</h><div class="ulist"><ul><li><p><code>./op_arit_log</code></p></li><li><p><code>echo $?</code></p></li></ul></div>
<h level="3">Análisis del módulo fuente</h><div class="ulist"><ul><li><p>Para la interpretación de las instrucciones add, sub, imul (integer multiplication), idiv (integer division) , neg, not, and, or, xor, shr, sar, consultar la tabla de operaciones de las <a href="#rie">hojas de referencia rápida </a></p></li><li><p>Las operaciones únicamente procesan el número de bits que indica el sufijo del mnemónico&#8230;&#8203;aunque los registros "r-x" son de 64 bits.</p></li></ul></div>
<h level="3">Ejecución paso a paso</h><h level="4">Observaciones</h><div class="admonitionblock caution"><table><tr><td class="icon"><i class="fa fa-fire" title="Caution"></i></td><td class="content">El depurador al visualizar el contenido de los registros: Unicamente visualiza el número de bytes del tamaño de los operandos..aunque los registros "r-x" son de 64 bits. Con números enteros con signo no visualiza los ceros de mayor peso, es decir, ni el signo ni la extensión de signo de los números positivos.</td></tr></table></div>
<h level="4">Operaciones</h><div class="ulist"><ul><li><p>Compilar el programa con la opción de generación de la tabla de símbolos requerida por el depurador y generar el módulo binario ejecutable:</p><div class="ulist"><ul><li><p><code>gcc  -m32 -g  -o op_arit_log op_arit_log.s</code> donde modulo_fuente se sustituye por el nombre del archivo que se desea compilar.</p></li></ul></div></li><li><p>Abrir el depurador GDB, cargar el módulo binario ejecutable y comprobar que se carga la tabla de símbolos junto al módulo binario ejecutable.</p><div class="ulist"><ul><li><p><code>gdb</code></p></li><li><p><code>file op_arit_log</code></p></li><li><p><code>info sources</code></p></li></ul></div></li><li><p>Configurar el fichero para el logging histórico de los comandos.</p><div class="ulist"><ul><li><p><code>set trace-commands on</code></p></li><li><p><code>set logging file op_arit_log_gdb_asm.txt</code></p></li><li><p><code>set logging on</code></p></li><li><p><code>shell ls -l op_arit_log_gdb_asm.txt</code></p></li></ul></div></li><li><p>Activar un punto de ruptura en la instrucción de entrada al programa.</p><div class="ulist"><ul><li><p><code>b _start</code></p></li></ul></div></li><li><p>Ejecutar el programa deteniéndolo en la primera instrucción del programa.</p><div class="ulist"><ul><li><p><code>run</code></p></li></ul></div></li></ul></div>
<h level="4">Operaciones aritméticas</h><div class="ulist"><ul><li><p>Comprobar los resultados de las operaciones aritméticas de suma, resta, multiplicación, división y negación de números enteros con signo</p></li></ul></div>
<h level="4">Operaciones lógicas</h><div class="ulist"><ul><li><p>Comprobar los resultados de las operaciones lógicas bitwise de negación, multiplicación, suma, or-exclusiva y desplazamiento.</p></li></ul></div></div></section></section>
<section><section id="_instrucciones_de_saltos_condicionales"><h2>15. Instrucciones de Saltos Condicionales</h2></section><section id="_introducción_20"><h2>15.1. Introducción</h2><div class="slide-content"><h level="3">Objetivos</h><div class="ulist"><ul><li><p>Manejo del registro de flags, instrucciones de comparación y saltos condicionales  para su aplicación en sentencias de lenguajes de alto nivel tipo if, for, while, switch-case.</p></li><li><p>Depurador GDB</p><div class="ulist"><ul><li><p>Uso del comando <code>watch</code></p></li></ul></div></li></ul></div>
<h level="3">Requisitos</h><div class="ulist"><ul><li><p>Teoría: representación de datos, operaciones aritméticas y lógicas, formato de instrucciones y repertorio  ISA de la arquitectura X86.</p></li><li><p>Práctica anterior: Introducción a la programación en lenguaje ensamblador AT&amp;T x86-32</p></li><li><p>Conceptos del lenguaje de programación C: if, for, while, switch-case</p></li></ul></div></div></section><section id="_leeme_4"><h2>15.2. LEEME</h2><div class="slide-content"><div class="ulist"><ul><li><p>Lectura del guión de prácticas  y del capítulo 3 del Libro Programming from the Ground-Up.</p></li><li><p><a href="#prac_apu">Apuntes y Libro de Texto</a></p></li><li><p><a href="#prac_doc_mem">Documentación Memoria</a>: Contenido y Formato de la Memoria</p></li><li><p><a href="#prac_eval">Evaluación</a>: sistema de evaluación</p></li><li><p><a href="#prac_plat_des">Plataforma de Desarrollo</a> : configuración de la computadora personal</p></li><li><p><a href="#prac_prog">Programación</a> : metodología</p></li></ul></div></div></section><section id="_cuestiones_4"><h2>15.3. Cuestiones</h2><div class="slide-content"><div class="ulist"><ul><li><p><a href="#prac_eval">"Autoevaluación de Prácticas"</a> opcional: <a href="#prac_cues">Prácticas: Cuestionario</a></p></li></ul></div></div></section><section id="_saltos_condicionales"><h2>15.4. Saltos Condicionales</h2><div class="slide-content"><h level="3">Algoritmo</h><div class="ulist"><ul><li><p>No se desarrolla ningún algoritmo. Son instrucciones para la práctica de los saltos condicionales.</p></li></ul></div>
<h level="3">Edición del Módulo fuente: saltos.s</h><div class="ulist"><ul><li><p>Descargar el módulo fuente "saltos.s" de miaulario y añadir los comentarios apropiados.</p><div class="listingblock"><div class="content"><pre>/*
Programa:     datos_saltos.s
Descripción: Emplear estructuras de datos con diferentes direccionamientos
### Compilación: gcc -m32 -g -o datos_saltos datos_saltos.s

*/

	## MACROS
	.equ SYS_EXIT,	1
	.equ SUCCESS,	0

	## VARIABLES LOCALES
	.data


	## INSTRUCCIONES
	.global main
	.text
main:

	## RESET

	xor  %eax,%eax
	xor  %ebx,%ebx
	xor  %ecx,%ecx
	xor  %edx,%edx
	xor  %esi,%esi
        xor  %edi,%edi

	## SALTOS INCONDICIONALES

	## Direccionamiento relativo
	jmp salto1		#salto relativo al contador de programa pc -&gt; eip
	xor %esi,%esi

	## FLAGS DEL REGISTRO DE BANDERINES EFLAGS
	/*
	los flags se activan al realizar operaciones aritméticas, lógicas, etc dependiendo del resultado de dicha operación
CF: El resultado de la operación tiene llevada del bit MSB del destino
OF: El resultado de la operación con signo se  desborda, su tamaño supera el permitido.
ZF: el resultado de la operación  tiene  valor  cero
SF: el resultado de la oeración tiene valor  negativo
PF: el resultado de la operación tiene el byte LSB con un  número par de bits
	*/
salto1:
	xor %eax,%eax	       # resultado cero -&gt; activa ZF y PF pero desactiva CF,OF,SF
	inc %eax	       # desactiva ZF y PF
	neg %eax	       # activa SF,PF y CF : realiza la resta de la definición de complemento a 2 :(0-N)
	shr $1,%eax	       # SHift Right : desplazamiento lógico: desplaza n bits el operando destino.
/* Salen bits por la dcha y entran ceros por la izda.
 El último bit salido queda en CF.
 SF=0 ya que ha entrado un cero en el MSB
 MANUAL INTEL: http://www.cs.nyu.edu/~mwalfish/classes/ut/s13-cs439/ref/i386/SAL.htm
 For SHR, OF is set to the high-order bit of the original operand.
	OF=MSB=1
 The OF flag is affected only on 1-bit shifts.
 Equivale a dividir 2^n si desplazo a la dcha y a multiplicar 2^n hacia la izda (posible overflow).
*/
	shl $1,%eax
	clc		       # clear CF -&gt; CF=0
	xor %eax,%eax	       # resultado cero -&gt; activa ZF y PF pero desactiva CF,OF,SF
	movw $0xFFFF,%ax       # MOV NO afecta a ningún flag
	addw $0xFFFF,%ax	# activa SF y CF pero no OF
	clc
	movw $0x7FFF,%ax
	addw $1,%ax		#activa OF pero no CF, OF avisa del error en la suma y se puede ver que SF se ha activado


	## INSTRUCCIONES COMPARATIVAS: TEST,CMP

	## Comprobar si el bit de la posicion 5  es cero con la mascara 0x0010 que aisla dicha posicion
	## test realiza la operación AND afectando a los flags de EFLAGS pero no guarda el resultado en el operando destino
	movw $0xABFF, %ax
	movw $0x0BCF, %bx
	test $0x0010, %ax	# AX^0x0010=0x0010=positivo -&gt; SF=0, low byte=0x10 impar -&gt; PF=0,
				# El manual dice -&gt; The OF and CF flags are cleared
        test $0xFFFF, %ax	# SF=1 porque AX^0xFFFF=AX= negativo, low byte=AL= par -&gt;  PF=1
	test $0b0000000000010000, %bx	# SF=0 porque AX^0x0010=positivo ,ZF=1 porque BX[5] es cero, PF=0

	## Comprobar si el valor de una variable es mayor, menor o igual al valor 0x00FF
	## cmp realiza la operacion SUB afectando a los flags de EFLAGS pero no guarda el resultado en el operando destino
	## SUB: It evaluates the result for both signed and unsigned integer operands and sets the OF and CF flags
	## to indicate an overflow in the signed or unsigned result, respectively
	movw $0x01FF, %ax
	movw $0x0001, %bx
	movw $0x00FF, %cx
	cmp  $0x00FF, %ax	#  AX-0x00FF=0x0100 &gt; 0 -&gt;  ZF=0 y SF=0, low byte=00 -&gt; PF=1
	cmp  $0x00FF, %bx	#  BX-0x00FF=0x0001+0xFF01=0xFF02 &lt; 0 -&gt; SF=1, 0x02 impar -&gt; PF=0,
				#  unsigned overflow -&gt; CF=1, signed not overflow OF=0
	cmp  $0x00FF, %cx	#  CX-0x00FF=0 -&gt; ZF=1, SF=0, 0xFF par PF=1, CF=0, OF=0

	## SALTOS CONDICIONALES

	movw $0x01FF, %ax
	movw $0x0001, %bx
	movw $0x00FF, %cx
	cmp  $0x00FF, %ax	#  AX-0x00FF=0x0100 &gt; 0, luego ZF=0 y SF=0, 0x00 para -&gt; PF=1
	jg   salto4		# great jump -&gt; resta de numeros con signo -&gt; SF=0 y salta
	nop
salto4:	cmp  $0x00FF, %bx	# BX-0x00FF=0x0001+0xFF01=0xFF02 &lt; 0, luego ZF=0 , SF=1,
				# unsigned over CF=1 y not signed over OF=0
	jl   salto5		# less jump -&gt; resta de numeros con signo -&gt; SF=1 y salta
	nop
salto5:	movw $0x8000, %ax	# 0x8000 vale -32768 con signo y 32768 sin signo
	cmp  $0x0001, %ax	# Con signo -&gt;0x8000 - 0x1 = 0x8000+0xFFFF=0x7FFFF &gt;0 -&gt; SF=0,
				# OF=1 ya que la suma de dos negativos ha dado positivo
                                # CF=0 ya que en binario puro 0x01FF-0x00001=0x01FE, no overflow
				# 0xFF es par -&gt; PF=1

	ja   salto6		# above jump -&gt; resta de números sin signo -&gt; 32768-1&gt;0
	nop
salto6:	cmp  $0x00FF, %cx	# CX-0x00FF = 0, luego ZF=1 y SF=0
	je   salto7		# equal jump
	nop


	## SALIDA

salto7:	mov $SYS_EXIT, %eax
	mov $SUCCESS,  %ebx
	int $0x80

	.end</pre></div></div></li></ul></div>
<h level="3">Compilación</h><div class="ulist"><ul><li><p>Seguir los pasos del proceso de <a href="#compilacion">compilación</a> común a todas las sesiones.</p><div class="ulist"><ul><li><p><code>gcc  -m32 -g -o saltos saltos.s</code></p></li></ul></div></li></ul></div>
<h level="3">Ejecución</h><div class="ulist"><ul><li><p><code>./saltos</code></p></li><li><p><code>echo $?</code></p></li></ul></div>
<h level="3">Análisis del módulo fuente</h><div class="ulist"><ul><li><p>Leer en las hojas de referencia rápida el <a href="#programa_minimalista">Programa Ejemplo Minimalista</a></p></li></ul></div>
<h level="4">Estructura</h><div class="ulist"><ul><li><p>La estructura del programa esta formada por los siguientes elementos:</p><div class="ulist"><ul><li><p>Cabecera</p></li><li><p>Definición de Macros</p></li><li><p>Sección de Datos</p></li><li><p>Sección de Instrucciones</p></li></ul></div></li></ul></div>
<h level="3">Ejecución paso a paso</h><h level="4">Operaciones Iniciales</h><div class="ulist"><ul><li><p>Compilar el programa con la opción de generación de la tabla de símbolos requerida por el depurador y generar el módulo binario ejecutable:</p><div class="ulist"><ul><li><p><code>gcc -m32 -g  -o saltos saltos.s</code></p></li></ul></div></li><li><p>Abrir el depurador GDB, cargar el módulo binario ejecutable y comprobar que se carga la tabla de símbolos junto al módulo binario ejecutable.</p><div class="ulist"><ul><li><p><code>gdb</code></p></li><li><p><code>file saltos</code></p></li><li><p><code>info sources</code></p></li></ul></div></li><li><p>Configurar el fichero para el logging histórico de los comandos.</p><div class="ulist"><ul><li><p><code>set trace-commands on</code></p></li><li><p><code>set logging file saltos_gdb_asm.txt</code></p></li><li><p><code>set logging on</code></p></li><li><p><code>shell ls -l saltos_gdb_asm.txt</code></p></li></ul></div></li><li><p>Activar un punto de ruptura en la instrucción de entrada al programa.</p><div class="ulist"><ul><li><p><code>b _start</code></p></li></ul></div></li><li><p>Ejecutar el programa deteniéndolo en la primera instrucción del programa.</p><div class="ulist"><ul><li><p><code>run</code></p></li></ul></div></li></ul></div>
<h level="4">Registro EFLAGS</h><div class="ulist"><ul><li><p><code>p $eflags</code> &#8594; imprime los nombres de los flags activos</p></li><li><p>comprobar el estado de los banderines con las operaciones lógicas, aritméticas y las instrucciones TEST y CMP.</p></li><li><p>Para el análisis de los banderines en modo paso a paso utilizar el comando <code>watch</code> del depurador GDB</p><div class="listingblock"><div class="content"><pre>(gdb) watch $eflags : interrumpe la ejecución y visualiza el contenido del registro EFLAGS cada vez que cambia su valor.
(gdb) info watch    : visualiza los watchs definidos
(gdb) delete breakpoints : elimina los breaks, watchs, etc</pre></div></div></li></ul></div>
<h level="4">Saltos</h><div class="ulist"><ul><li><p>Comprobar la ejecución o no del salto con el estado e interpretación de los banderines del registro EFLAGS. Es un ejercicio de
interpretación de FLAGS &#8594; Cuando se ejecuta la instrucción de salto,  la CPU  tiene que tomar la decisión de saltar o  no interpretando los FLAGS. ¿ Sabríamos RELACIONAR la condición de <strong>ja</strong> (salto si ABOVE) leyendo los FLAGS y sin leer los valores de los operandos que se comparan en la condición ABOVE?</p></li></ul></div></div></section><section id="_mnemónicos_utilizados"><h2>15.5. Mnemónicos Utilizados</h2><div class="slide-content"><div class="ulist"><ul><li><p>Ver capítulo  <a href="#mnemonicos_basicos_explicados">"Programación ensamblador : Mnemónicos Básicos (Explicados)"</a></p></li></ul></div></div></section></section>
<section><section id="_llamadas_al_sistema_operativo_kernel"><h2>16. LLamadas al Sistema Operativo (Kernel)</h2></section><section id="_introducción_21"><h2>16.1. Introducción</h2><div class="slide-content"><h level="3">Qué son las llamadas al sistema</h><div class="ulist"><ul><li><p>El HW está protegido por el Kernel del SO y por lo tanto el programador de ensamblador accede al HW indirectamente a través de las "LLamadas al Sistema" solicitando operaciones de entrada/salida al Sistema Operativo. Por lo tanto si queremos acceder al teclado y al monitor será necesario realizar llamadas al kernel.</p></li><li><p>Definición de  la interfaz entre el programador y el kernel del SO: <em>System V Application Binary Interface: SysV-ABI</em></p><div class="ulist"><ul><li><p>El lenguaje ensamblador sigue la norma ABI para el lenguaje C.</p></li></ul></div></li><li><p>En este guión se trabajan las llamadas al sistema de la arquitectura i386.</p></li><li><p>LLamadas al sistema desde el código ensamblador:</p><div class="ulist"><ul><li><p>directamente con la instrucción <code>int $0x80</code></p></li><li><p>indirectamente a través de las funciones de la librería standard <em>libc</em> con la instrucción <code>call</code></p></li><li><p>En código ensamblador es necesario pasar los argumentos previamente a la ejecución de la llamada <code>call</code></p></li></ul></div></li></ul></div>
<h level="3">Manuales de las llamadas al sistema</h><div class="ulist"><ul><li><p>Listado con los nombres de las llamadas a al sistema:  <code>man syscalls</code></p><div class="ulist"><ul><li><p>LLamada al sistema <em>exit</em>: <code>man 3 exit</code></p><div class="ulist"><ul><li><p>describe la función de llamada al sistema</p></li><li><p>especifíca el nombre de la cabecera de la librería necesaria para compilar en lenguaje C.</p></li><li><p>especifíca los parámetros que necesita la función y el orden en que son transferidos.</p></li></ul></div></li><li><p>LLamada al sistema <em>write</em>: <code>man 2 write</code></p></li></ul></div></li></ul></div>
<h level="3">Códigos de las llamadas</h><div class="ulist"><ul><li><p>Códigos de las llamadas al sistema en la arquitectura x86-32:</p><div class="ulist"><ul><li><p><em>/usr/include/asm/unistd_32.h</em></p></li><li><p><em>/usr/include/x86-64-linux-gnu/asm/unistd_32.h</em></p></li><li><p>llamada exit &#8594; Código 1</p></li><li><p>read &#8594; 3</p></li><li><p>write &#8594; 4</p></li></ul></div></li><li><p>El código de la llamada se pasa a tavés del registro <em>EAX</em>.</p></li></ul></div>
<h level="3">Cómo pasar los argumentos directamente al Kernel</h><div class="ulist"><ul><li><p>A diferencia de los argumentos de las llamadas a subrutinas de usuario que se pasan a través de la pila, los argumentos  de las llamadas a subrutinas del sistema operativo utilizan los registros como memoria para pasar los argumentos.</p></li><li><p>Los parámetros del primero al sexto se corresponden con los registros : <em>EBX,ECX,EDX,ESI,EDI,EBP</em></p></li><li><p>Valor de retorno: <em>EAX</em></p></li></ul></div>
<h level="3">Como pasar los argumentos indirectamente a través de funciones libc</h><div class="ulist"><ul><li><p>Desde un módulo fuente en ASM</p></li><li><p>Los parámetros se pasan a las funciones libc través de la <em>pila</em>  y por lo tanto también a los <em>wrappers</em> de la librería de C.</p></li><li><p>Valor de retorno: <em>EAX</em></p></li></ul></div></div></section><section id="_leeme_5"><h2>16.2. LEEME</h2><div class="slide-content"><div class="ulist"><ul><li><p>Lectura del guión de prácticas  y del capítulo 3 del Libro Programming from the Ground-Up.</p></li><li><p><a href="#prac_apu">Apuntes y Libro de Texto</a></p></li><li><p><a href="#prac_doc_mem">Documentación Memoria</a>: Contenido y Formato de la Memoria</p></li><li><p><a href="#prac_eval">Evaluación</a>: sistema de evaluación</p></li><li><p><a href="#prac_plat_des">Plataforma de Desarrollo</a> : configuración de la computadora personal</p></li><li><p><a href="#prac_prog">Programación</a> : metodología</p></li></ul></div></div></section><section id="_cuestiones_5"><h2>16.3. Cuestiones</h2><div class="slide-content"><div class="ulist"><ul><li><p><a href="#prac_eval">"Autoevaluación de Prácticas"</a> opcional: <a href="#prac_cues">Prácticas: Cuestionario</a></p></li></ul></div></div></section><section id="_llamada_exit"><h2>16.4. Llamada Exit</h2><div class="slide-content"><h level="3">Edición del Módulo fuente:salida.c / salida.s</h><div class="ulist"><ul><li><p><code>gcc -m32 -g -o salida salida.c</code></p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">#include &lt;stdlib.h&gt;
void main (void)
{
  exit (0xFF);
    }</code></pre></div></div></li><li><p><code>gcc -m32 -o salida salida.c</code></p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">/* Llamada al sistema desde C
   Prototipo:    int syscall(int number, ...);
   man syscall
*/

#define _GNU_SOURCE
#include &lt;unistd.h&gt;
#include &lt;sys/syscall.h&gt;

void main (void)
{
  syscall (__NR_exit,0xFF);
    }</code></pre></div></div></li><li><p><code>gcc -m32 -g -nostartfiles -o salida salida.s</code></p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">        .global _start
        .section .text
_start:
        push    $0xFF   	#return code
        call 	exit		#libc library
        .end</code></pre></div></div></li><li><p><code>gcc -m32 -g -nostartfiles -o salida salida.s</code></p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">        .global _start
        .section .text
_start:
        push    $0xFF   	#return code
        push    $1		# exit syscall code
        call 	syscall		#libc library
        .end</code></pre></div></div></li><li><p><code>gcc -m32 -g -nostartfiles -o salida salida.s</code></p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">        .global _start
        .section .text
_start:
         mov 	 $1,%eax	#exit
         mov     $0xFF,%ebx   	#argument
         int     $0x80          #system call
         .end</code></pre></div></div></li></ul></div></div></section><section id="_llamar_a_la_librería_de_c_desde_código_ensamblador"><h2>16.5. LLamar a la librería de C desde código ensamblador</h2><div class="slide-content"><h level="3">imprimir.s: printf</h><div class="ulist"><ul><li><p>imprimir.s</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">        .section .data
planet:
	.long 9                        # variable planet

        .section .rodata
mensaje:
        .asciz "El número de planetas es %d \n"        #string con formato de la función printf

	.global _start
        .section .text
_start:
        ## imprimir en la pantalla
        push planet               # 2º argumento de la función printf
        push $mensaje     # 1º argumento de la función printf: dirección del string
        call printf
        ## salir al sistema
	push $0
        call exit</code></pre></div></div>
<div class="ulist"><ul><li><p>Compilación con <em>gcc</em> : no es necesario indicar al linker el módulo objeto libc ya que lo enlaza por defecto.</p><div class="ulist"><ul><li><p><code>gcc -m32 -g -nostartfiles -o imprimir imprimir.s</code></p></li></ul></div></li><li><p>Compilación con <em>as</em> y <em>ld</em></p><div class="ulist"><ul><li><p><code>as --32 -gstabs -o imprimir.o imprimir.s</code></p></li><li><p><code>ld -melf_i386 -dynamic-linker /lib32/ld-linux.so.2  -o imprimir imprimir.o -lc</code> : enlazar con el módulo objeto libc</p></li></ul></div></li></ul></div></li></ul></div></div></section><section id="_llamadas_al_sistema_en_la_arquitectura_amd64"><h2>16.6. Llamadas al Sistema en la Arquitectura AMD64</h2><div class="slide-content"><div class="ulist"><ul><li><p>LLamadas a las funciones de la librería standard <em>libc</em>.</p><div class="ulist"><ul><li><p>El manual de los prototipos de las funciones libc son accesibles en GNU con el comando <em>man</em>. Ej <code>man write</code></p></li><li><p>Es necesario pasar los argumentos previamente a la ejecución de la llamada mediante la instrucción <em>call</em>.</p></li><li><p>Los parámetros se pasan a través de los registros <em>%rdi, %rsi, %rdx, %rcx, %r8 and %r9</em> que se asocia con los argumentos de la función de libc en sentido izda&#8594;dcha.</p></li></ul></div></li><li><p>Preservar los registros : %rbp, %rbx and %r12 through %r15</p></li><li><p>Valor de retorno: Uno de los dos registros libres de la secuencia %rax, %rdx.</p></li><li><p>Ejemplo:</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">#include &lt;stdlib.h&gt;

exit (0xFF)</code></pre></div></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">xor	%rax            #resetear RAX
mov     $0xFF, %rdi   	#return code
call 	exit		#libc library</code></pre></div></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">mov 	$60,%rax	#exit
mov     $0xFF, %rdi   	#return code
syscall</code></pre></div></div></li></ul></div></div></section></section>
<section><section id="_subrutinas_2"><h2>17. Subrutinas</h2></section><section id="_introducción_22"><h2>17.1. Introducción</h2><div class="slide-content"><h level="3">Objetivos</h><h level="4">Programación</h><div class="ulist"><ul><li><p>Concepto de Subrutina en el  Lenguaje Ensamblador AT&amp;T x86-32</p></li><li><p>Instrucciones  de llamada y retorno: call y ret</p></li><li><p>Argumentos: Utilización de la pila</p></li><li><p>Instrucciones de pila:  push y pop</p></li><li><p>Estructura de la pila: punteros al bottom y top de la pila: registros EBP y ESP.</p></li><li><p>Anidamiento de llamadas: segmentación de la pila en segmentos "Frame".</p></li><li><p>Convenio de llamada: Pase de los parámetros, Valor de retorno, Dirección de retorno, Pila, Frame de la pila, Punteros al stack Frame, Epílogo, Prólogo</p></li><li><p>Directivas : .type sumMtoN, @function</p></li></ul></div>
<h level="4">Análisis</h><div class="ulist"><ul><li><p>Análisis de la pila mediante el depurador GDB</p><div class="ulist"><ul><li><p>observar la generación de un nuevo frame</p></li><li><p>identificar los límites del frame a través de los registros puntero.</p></li><li><p>volcar los argumentos, dirección de retorno y valor de retorno de la subrutina en la pila.</p></li></ul></div></li></ul></div></div></section><section id="_módulo_fuente_2"><h2>17.2. Módulo Fuente</h2><div class="slide-content"><div class="ulist"><ul><li><p>El módulo fuente <em>sumMtoN.s</em> realiza una llamada desde la rutina principal <em>_start</em> a la subrutina <em>sumMtoN</em> pasándole dos argumentos y recibiendo el resultado de la suma.</p></li><li><p>La subrutina sumMtoN realiza la suma desde el número entero M hasta el número entero N donde N&gt;M.</p></li></ul></div></div></section><section id="_requisitos_7"><h2>17.3. Requisitos</h2><div class="slide-content"><div class="ulist"><ul><li><p>Conceptos básicos de estructura de computadores.</p></li><li><p>Arquitectura básica intel x86-32.</p></li><li><p>Programación en lenguaje ensamblador AT&amp;T: práctica con datos, modos de direccionamiento e instrucciones básicas de transferencia, aritméticas y de saltos.</p></li></ul></div></div></section><section id="_leeme_6"><h2>17.4. LEEME</h2><div class="slide-content"><div class="ulist"><ul><li><p>Lectura del guión de prácticas  y del capítulo 3 del Libro Programming from the Ground-Up.</p></li><li><p><a href="#prac_apu">Apuntes y Libro de Texto</a></p></li><li><p><a href="#prac_doc_mem">Documentación Memoria</a>: Contenido y Formato de la Memoria</p></li><li><p><a href="#prac_eval">Evaluación</a>: sistema de evaluación</p></li><li><p><a href="#prac_plat_des">Plataforma de Desarrollo</a> : configuración de la computadora personal</p></li><li><p><a href="#prac_prog">Programación</a> : metodología</p></li></ul></div></div></section><section id="_cuestiones_6"><h2>17.5. Cuestiones</h2><div class="slide-content"><div class="ulist"><ul><li><p><a href="#prac_eval">"Autoevaluación de Prácticas"</a> opcional: <a href="#prac_cues">Prácticas: Cuestionario</a></p></li></ul></div></div></section><section id="_tamaño_de_los_datos_y_variables_2"><h2>17.6. Tamaño de los datos y variables</h2><div class="slide-content"><h level="3">Algoritmo</h><div class="ulist"><ul><li><p>Desarrollar un programa en lenguaje ensamblador de la arquitectura <em>i386</em> que realice la suma \(\sum_{i=1}^{N}i\) cuyo resultado es \(N(N+1)/2\)  utilizando el <a href="#prac_prog">método de programación</a> de descripción inicial en lenguaje pseudocódigo y organigrama. El programa debe de contener dos módulos: uno principal referenciado con el nombre <em>_start</em> y una subrutina denominada <em>sumMtoN</em> que realiza la suma. El programa principal pasa los paramétros M y N a la subrutina para una vez realizada la suma se devuelva el resultado de la suma como valor de retorno de la subrutina.</p></li></ul></div>
<h level="3">Edición del Módulo fuente: sumMtoN.s</h><div class="ulist"><ul><li><p>Descargar el módulo fuente "sumMtoN.s" de miaulario y añadir los comentarios apropiados.</p><div class="listingblock"><div class="content"><pre>	/*
Programa: sumMtoN.s
Descripción: realiza la suma de números enteros de la serie M,M+1,M+2,M+3,...N
	función : sumMtoN(1º arg=M, 2º arg=N) donde M &lt; N
Ejecución:    Editar los valores M y N y compilar el programa.
	Ejecutar $./sumMtoN
	El resultado de la suma se captura del  sistema operativo con el comando linux: echo $?

	gcc -nostartfiles -m32 -g  -o sumMtoN sumMtoN.s
	Ensamblaje as --32 --gstabs sumMtoN.s -o sumMtoN.o
	linker -&gt; ld -melf_i386    -o sumMtoN  sumMtoN.o
	*/

	## MACROS
	.equ	SYS_EXIT,	1
	## DATOS
	.section .data

	## INSTRUCCIONES
	.section .text
	.globl _start
_start:
	## Paso los dos argumentos M y N a la subrutina a través de la pila
	pushl $10	#push    second argument -&gt; N
	pushl $5	#push    first argument  -&gt; M

	## Llamada a la subrutina sum1toN
	call  sumMtoN

	## Paso la salida de sum11toN al argumento a la llamada al sistema exit()
	mov  %eax, %ebx	  # (%ebx is returned)
	## Código de la llamada al sistema operativo
	movl  $SYS_EXIT, %eax	    # llamada exit
	## Interrumpo al S.O.
	int   $0x80

/*
Subrutina: sumMtoN
Descripción: calcula la suma de números enteros en secuencia desde el 1º sumando hasta el 2º sumando
	Argumentos de entrada: 1º sumando y 2º sumando
	los argumentos los pasa la rutina principal a través de la pila:
	1º se apila el último argumento y finalmente se apila el 1º argumento.
	Argumento de salida: es el resultado de la suma y se pasa a la rutina principal a través del registro EAX.
	Variables locales: se implementa una variable local en la pila pero no se utiliza
*/
	.type sumMtoN, @function # declara la etiqueta sumMtoN
sumMtoN:
	## Próĺogo: Crea el nuevo frame del stack
	pushl %ebp           #salvar el frame pointer antiguo
	movl  %esp, %ebp     #actualizar el frame pointer nuevo
	## Reserva una palabra en la pila como variable local
	## Variable local en memoria externa: suma
	subl  $4, %esp
	## Captura de argumentos
	movl  8(%ebp), %ebx  #1º argumento copiado en %ebx
	movl  12(%ebp), %ecx #2º argumento copiado en %ecx


	## suma la secuencia entre el valor del 1ºarg y el valor del 2ºarg
	## 1º arg &lt; 2ºarg
	## utilizo como variable local EDX en lugar de la reserva externa para variable local: optimiza velocidad
	## Inicializo  la variable local suma
	movl  $0,%edx

	## Número de iteracciones
	mov %ecx,%eax
	sub %ebx,%eax

bucle:
	add %ebx,%edx
	inc %ebx
	sub $1,%eax
	jns bucle

	## Salvo el resultado de la suma como el valor de retorno
	movl  %edx, %eax

	## Epílogo: Recupera el frame antiguo
	movl  %ebp, %esp      #restauro el stack pointer
	popl  %ebp            #restauro el frame pointer

	## Retorno a la rutina principal
	ret
	.end</pre></div></div></li></ul></div>
<h level="3">Compilación</h><div class="ulist"><ul><li><p>Seguir los pasos del proceso de <a href="#compilacion">compilación</a> común a todas las sesiones.</p><div class="ulist"><ul><li><p><code>gcc -nostartfiles -m32 -g -o sumMtoN sumMtoN.s</code></p></li></ul></div></li></ul></div>
<h level="3">Ejecución</h><div class="ulist"><ul><li><p><code>./sumMtoN</code></p></li><li><p><code>echo $?</code></p></li><li><p>Comprobar que funciona correctamente cambiando los valores de los parámetros: 1º valor de la suma y 2º valor de la suma.</p></li></ul></div>
<h level="3">Análisis del módulo fuente</h><div class="ulist"><ul><li><p>Leer en las hojas de referencia rápida el <a href="#programa_minimalista">Programa Ejemplo Minimalista</a></p></li></ul></div>
<h level="4">Estructura</h><div class="ulist"><ul><li><p>La estructura del programa esta formada por los siguientes elementos:</p><div class="ulist"><ul><li><p>Cabecera</p></li><li><p>Definición de Macros</p></li><li><p>Sección de Datos</p></li><li><p>Sección de Instrucciones</p></li></ul></div></li></ul></div>
<h level="4">Ejecución modo paso a paso mediante el depurador GDB</h><div class="ulist"><ul><li><p>Compilar el programa con la opción de generación de la tabla de símbolos requerida por el depurador y generar el módulo binario ejecutable:</p><div class="ulist"><ul><li><p><code>gcc -nostartfiles -m32 -g  -o sumMtoN sumMtoN.s</code></p></li></ul></div></li><li><p>Abrir el depurador GDB, cargar el módulo binario ejecutable y comprobar que se carga la tabla de símbolos junto al módulo binario ejecutable.</p><div class="ulist"><ul><li><p><code>gdb</code></p></li><li><p><code>file modulo_ejecutable</code></p></li><li><p><code>info sources</code></p></li></ul></div></li><li><p>Configurar el fichero para el logging histórico de los comandos.</p><div class="ulist"><ul><li><p><code>set trace-commands on</code></p></li><li><p><code>set logging file sumMtoN_gdb_asm.txt</code></p></li><li><p><code>set logging on</code></p></li><li><p><code>shell ls -l sumMtoN_gdb_asm.txt</code></p></li></ul></div></li><li><p>Activar un punto de ruptura en la instrucción de entrada al programa.</p><div class="ulist"><ul><li><p><code>b _start</code></p></li></ul></div></li><li><p>Ejecutar el programa deteniéndolo en la primera instrucción del programa.</p><div class="ulist"><ul><li><p><code>run</code></p></li></ul></div></li><li><p>Sin ejecutar ninguna instrucción del programa</p><div class="ulist"><ul><li><p>Estado de la pila</p><div class="ulist"><ul><li><p>Top del stack: <code>x $esp</code> ó <code>x $sp</code> : stack pointer</p></li><li><p>Bottom del frame: <code>x $ebp</code> ó <code>x $fp</code> : frame pointer</p></li><li><p>Contenido del top de la pila (dirección sp): argc: número de argumentos string de la línea de comandos en ejecución</p><div class="ulist"><ul><li><p><code>x /xw $sp</code></p></li></ul></div></li><li><p>Contenido una posición anterior al top de la pila (dirección sp+4): argv[0]: dirección del 1º string de la línea de comandos en ejecución</p><div class="ulist"><ul><li><p><code>p /s *(char **)($sp+4)</code></p></li></ul></div></li></ul></div></li></ul></div></li><li><p>Ejecutar las líneas necesarias hasta entrar en la subrutina:</p><div class="ulist"><ul><li><p>Comando step: <code>s</code> ya que el comando <code>n</code> no entra en la subrutina sino que la ejecuta completamente.</p></li><li><p>¿A dónde apunta el stack pointer sp?¿Qué información contiene a donde apunta el sp?</p><div class="ulist"><ul><li><p><code>x /i *(int *)$sp</code> : ¿qué instrucción es?</p></li></ul></div></li></ul></div></li><li><p>Ejecutar el prólogo de la subrutina</p><div class="ulist"><ul><li><p>Nuevo frame</p><div class="ulist"><ul><li><p>Nuevo valor del frame pointer: <code>p $fp</code></p></li><li><p>Valor del stack pointer: <code>p $sp</code></p></li><li><p>Acceso a la dirección de retorno tomando como refefencia el nuevo frame pointer: <code>x /i *(int *)($fp+4)</code></p></li></ul></div></li></ul></div></li><li><p>Ejecutar la subrutina hasta obtener el valor de retorno</p><div class="ulist"><ul><li><p>Imprimir el valor de retorno: <code>p $eax</code></p></li></ul></div></li><li><p>Ejecutar el epílogo de la subrutina</p><div class="ulist"><ul><li><p>Valor del frame pointer: <code>p $fp</code></p></li><li><p>Valor del stack pointer: <code>p $sp</code></p></li><li><p>Dirección de retorno: <code>x *(int *)$sp</code></p></li></ul></div></li><li><p>Ejecutar la instrucción de retorno</p><div class="ulist"><ul><li><p>Dirección del stack pointer: <code>p $sp</code></p><div class="ulist"><ul><li><p>¿Por qué ha cambiado la dirección del stack pointer?</p></li></ul></div></li></ul></div></li></ul></div></div></section></section>
<section><section id="_imágenes_bit_map_portable"><h2>18. Imágenes: Bit Map Portable</h2></section><section id="_introducción_23"><h2>18.1. Introducción</h2><div class="slide-content"><div class="admonitionblock important"><table><tr><td class="icon"><i class="fa fa-exclamation-circle" title="Important"></i></td><td class="content">Práctica introductoria al examen final por lo que se aconseja realizarla de forma <strong>individual</strong> para obtener el mayor rendimiento.</td></tr></table></div>
<div class="ulist"><ul><li><p>El objetivo de la práctica es desarrollar una subrutina en lenguaje ensamblador equivalente a una función de C dentro de una aplicación de generación de imágenes con formato BMP.</p></li><li><p>Los cuatro primeros ejercicios en lenguaje C se realizarán de forma guiada con el profesor y el resto de forma <strong>individual</strong>.</p></li></ul></div></div></section><section id="_aplicación_2"><h2>18.2. Aplicación</h2><div class="slide-content"><h level="3">Ficheros incluidos</h><div class="ulist"><ul><li><p>Descargar el archivo <em>bmp_practica6.zip</em> y extraer los ficheros.</p></li><li><p>Scripts:</p><div class="ulist"><ul><li><p><code>comp_ejec_vis.sh</code> : script que automatiza las tareas de compilar, ejecutar y visualizar llamando al script Makefile.</p></li><li><p><code>Makefile_C</code> : script que automatiza la tarea de compilación del programa fuente C.</p></li><li><p><code>Makefile_pixels_as</code>: script que automatiza la tarea de ensamblaje, compilación y enlazado de los módulos fuentes C y asm.</p></li><li><p><code>LEEME.txt</code> : instrucciones de como proceder para editar los distintos programas fuente en lenguaje C y ensamblador y copiar dichos programas con los nombres apropiados antes de ejecutar el script <code>comp_ejec_vis.sh</code></p></li></ul></div></li><li><p>Módulos fuente:</p><div class="ulist"><ul><li><p><em>bitmap_gen_test.c</em>: Genera una imagen bitmap 512x512 en formato BMP y la guarda en el fichero <em>test.bmp</em>.</p></li><li><p><em>cuadrado_128x128.c</em>: Genera una imagen bitmap DIMENSIONxDIMENSION en formato BMP y la guarda en el fichero <em>test.bmp</em>.</p></li><li><p><em>cuadrados_4.c</em>: Genera cuatro rectángulos anidados bitmap en formato BMP y guarda la imagen en el fichero <em>test.bmp</em>.</p></li><li><p><em>bmp_funcion.c</em>: Partiendo de <em>bitmap_gen_test.c</em> el bucle generador de pixels se define mediante la función <em>pixels_generator(xcoor,ycoor,top,buffer)</em></p></li><li><p><em>bmp_as.c</em>: Módulo no incluido a desarrollar.</p></li><li><p><em>pixels.s</em>: Módulo no incluido a desarrollar.</p></li></ul></div></li><li><p>Fichero</p><div class="ulist"><ul><li><p><em>test.bmp</em></p></li></ul></div></li></ul></div>
<h level="3">Ejemplo de compilación automática</h><div class="ulist"><ul><li><p>Copiar <code>cp Makefile_C Makefile</code></p></li><li><p>Copiar <code>cp cuadrados_4.c bmp_imagen.c</code> y ejecutar <code>comp_ejec_vis.sh</code></p></li><li><p>Copiar <code>cp bitmap_gen_test.c bmp_imagen.c</code> y ejecutar <code>comp_ejec_vis.sh</code></p></li><li><p>Interpretar los scripts <code>comp_ejec_vis.sh</code> y <code>Makefile</code></p></li></ul></div></div></section><section id="_formato_bmp"><h2>18.3. Formato BMP</h2><div class="slide-content"><h level="3">Pantalla: pixel</h><div class="ulist"><ul><li><p>La pantalla de la computadora está formada por una matriz bidimensional de pixeles, donde cada pixel está ubicado en un punto discreto de la pantalla programable. Físicamente el monitor de la computadora puede ser de diferentes tipos: CRT, LCD, LED, OLED, Plasma, etc. Desde el punto de vista funcional supongamos un monitor tipo LED donde cada pixel esta formado por 3 diodos Leds: un led azul, otro led verde y el tercer led rojo. La combinación de los 3 colores básicos da lugar a todos los colores posibles. Las dimensiones de un pixel, es decir 3 leds, es de unas pocas centenas de micrómetros. Un portátil con una pantalla de 15.6" tiene 15" de anchura por 12" de altura. El comando <code>xdpyinfo | grep <em>dimensions:</em></code> informa de : 1366x768 pixels (361x203 millimeters=73283 mm<sup>2</sup>) &#8594;73283mm<sup>2</sup>/(1366x768 pixels)=0,07mm<sup>2</sup>/pixel=70000&#181;m<sup>2</sup>/pixel,es decir, un cuadrado de 265&#181;m de lado.</p></li></ul></div>
<h level="3">Codificación</h><div class="ulist"><ul><li><p>El formato BitMapPortable (BPM) es un formato de imagen escalar, es decir, contiene los datos de <strong>cada pixel</strong> codificando la intensidad de los componentes RGB de color tal como  se visualizarán en la pantalla.</p></li><li><p>En el formato BPM, la matriz de pixeles de la pantalla está vinculada a una estructura de datos tipo array bidimensional 2D de filas (eje horizontal) y columnas (eje vertical) almacenada en la memoria de la tarjeta de video. El origen de coordenadas del array es la esquina inferior izquierda. A cada par (x,y) del array 2D le corresponde el color de un pixel.</p></li><li><p>True Color: cada elemento del array contiene un dato formada por 3 campos, donde cada campo representa un color (Blue-Green-Red) y ocupa un byte .Cada componente de color R-G-B está codificado con un byte que indica la intensidad del color. Ejemplos:</p><div class="ulist"><ul><li><p>R-G-B:0xFF-0x00-0x00 &#8594; pixel 100% rojo e intensidad máxima.</p></li><li><p>R-G-B:0xFF-0x00-0xFF &#8594; pixel 50% rojo y 50% azul &#8594; color morado.</p></li><li><p>R-G-B:0x00-0x00-0x00 &#8594; ausencia de color &#8594; color negro</p></li><li><p>R-G-B:0xFF-0xFF-0xFF &#8594; misma proporción de colores primarios &#8594; color blanco</p></li><li><p>R-G-B:0x7F-0x7F-0x7F &#8594; misma proporción de colores primarios &#8594; escala de grises entre el negro (00-00-00) y el blanco (FF-FF-FF)</p></li></ul></div></li><li><p>Una imagen de tamaño en pixeles 512x512 dara lugar a un array de 512 pixeles x 512 pixeles x 3 bytes/pixel = 786432Bytes = 768KB</p></li></ul></div>
<h level="3">Mapa de memoria: Monitor &#8594; Buffer</h><div class="ulist"><ul><li><p>Al escribir los colores del array2D MxN en la memoria lineal donde cada dirección de memoria es <strong>un byte</strong>, la estructura de datos o buffer tiene sus componentes distribuidos de la siguiente forma:</p><div class="ulist"><ul><li><p>F0C0BGR-F0C1BGR-&#8230;&#8203;-F0C_(N-1)BGR-F1C0BGR-&#8230;&#8203;-F1C_(N-1)BGR-&#8230;&#8203;.-F_(M-1)C0BGR-F_(M-1)C1BGR-&#8230;&#8203;-F_(M-1)C_(N-1)BGR que se corresponden con las posiciones relativas 0-1-2-3-4-5-&#8230;&#8203;..-(MxNx3-1). Donde F0 es la fila 0, C0 la columna 0 y BGR la secuencia de 3 bytes Blue-Green-Red.</p></li><li><p>longitud total del buffer de memoria: MxNx3 bytes</p></li><li><p>Interpretación de F0C0BGR:</p><div class="listingblock"><div class="content"><pre>*** pixel BGR de la Fila cero Columna cero
*** BGR: 3 bytes en el orden azul-verde-rojo.
*** El byte azul ocupará dentro del buffer la posición relativa 0, el byte verde la posición 1 y el byte rojo la posición 2. Posiciones relativas a la dirección del primer byte del buffer.</pre></div></div></li><li><p>F0C1BGR:</p><div class="listingblock"><div class="content"><pre>el byte blue está en la posición 3 dentro del buffer
el byte green está en la posición 4 dentro del buffer
el byte red está en la posición 5 dentro del buffer</pre></div></div></li><li><p>Fila cero del monitor: F0C_(N-1)BGR:  En el buffer, el byte azul está en la posición 3*(N-1), el verde en 3*(N-1)+1 y el rojo en 3*(N-1)+2.</p></li><li><p>Fila uno del monitor: F1C0BGR:  byte azul &#8594; posición 3*N</p></li><li><p>Fila uno del monitor: F1C_(N-1)BGR:  byte azul &#8594; posición 3*N+3*(N-1)</p></li><li><p>F_iC_jBGR:</p><div class="listingblock"><div class="content"><pre>byte azul  -&gt; posición 3*N*i+3*j     donde 0&lt;i&lt;M y 0&lt;j&lt;N
byte verde -&gt; posición (3*N*i+3*j)+1 donde 0&lt;i&lt;M y 0&lt;j&lt;N
byte rojo  -&gt; posición (3*N*i+3*j)+2 donde 0&lt;i&lt;M y 0&lt;j&lt;N</pre></div></div></li></ul></div></li></ul></div>
<h level="3">Fichero BMP</h><div class="ulist"><ul><li><p>Las imágenes con formato BMP se guardan en ficheros con extensión "*.bmp" como "test.bmp"</p></li><li><p>El fichero BMP además del buffer de datos contiene una cabecera con metainformación que no procede explicar en este contexto.</p></li></ul></div></div></section><section id="_módulo_fuente_bitmap_gen_test_c"><h2>18.4. Módulo Fuente bitmap_gen_test.c</h2><div class="slide-content"><h level="3">Descripción</h><div class="ulist"><ul><li><p>El programa <em>bitmap_gen_test</em> genera un array 2D de pixeles y lo salva en el fichero <em>test.bmp</em></p><div class="ulist"><ul><li><p>Las dimensiones del array se definen en el programa fuente <em>bitmap_gen_test.c</em></p></li></ul></div></li></ul></div>
<h level="3">Funciones del programa</h><h level="4">main()</h><div class="ulist"><ul><li><p>Función principal</p></li><li><p>Descripción de bloques:</p><div class="listingblock"><div class="content"><pre>RGB_data buffer[512][512]  : variable local done se declara y almacena el array 2D "buffer" de pixeles donde cada pixel es del tipo RGB_data

Tipo de variable RGB_data:  3 bytes consecutivos donde el primero es la intensidad de azul, el segundo verde y el tercero rojo. Las intensidades son números enteros sin signo. Por ejemplo: 0x7F-0xFF-0x00  representa una intensidad 50% de azul, una intensidad 100% de verde y una intensidad 0% de rojo</pre></div></div></li></ul></div>
<h level="4">memset(buffer, 0, sizeof(buffer))</h><div class="ulist"><ul><li><p>Es una función de la librería standard libc &#8594; <code>man memset</code> &#8594; está declarada en la cabecera <em>string.h</em></p></li><li><p>Inicializa a 0 el array 2D de pixeles "buffer".</p></li><li><p>Ver como ejemplo la llamada a la función memset() en el módulo <em>bitmap_gen_test.c</em></p></li></ul></div>
<h level="4">bmp_generator("./test.bmp", 512, 512, (BYTE*)buffer)</h><div class="ulist"><ul><li><p>Genera el fichero <em>test.bmp</em> y escribe en dicho fichero el contenido del array 2D de pixeles con nombre buffer.</p></li><li><p>Para pasar el argumento buffer es necesario realizar el casting (BYTE*). Ver la declaración del tipo BYTE en el módulo <em>bitmap_gen_test.c</em></p></li></ul></div>
<h level="4">estructura RGB_data</h><div class="ulist"><ul><li><p>Ver la declaración del tipo <em>RGB_data</em> en el módulo <em>bitmap_gen_test.c</em>.</p></li></ul></div>
<h level="4">bucle doble</h><div class="ulist"><ul><li><p>bucle <strong>for</strong> :</p><div class="ulist"><ul><li><p>la variable i es el índice de filas y la variable j el índice de columnas.</p></li><li><p>buffer[i][j].b : byte blue del pixel de la posición (i,j)</p></li><li><p>buffer[i][j].g : byte green del pixel de la posición (i,j)</p></li><li><p>buffer[i][j].r : byte red del pixel de la posición (i,j)</p></li><li><p>cada elemento de la matriz buffer[i][j] es una estructura de datos <em>RGB_data</em> declarada por el programador con los elementos b,g y r.</p></li></ul></div></li></ul></div>
<div style="page-break-after: always;"></div></div></section><section id="_ejercicios_4"><h2>18.5. Ejercicios</h2><div class="slide-content"><div class="admonitionblock important"><table><tr><td class="icon"><i class="fa fa-exclamation-circle" title="Important"></i></td><td class="content">El último ejercicio consistente en una subrutina en lenguaje ensamblador suele ser la base del examen de prácticas.</td></tr></table></div>
<h level="3">Programación en C</h><div class="ulist"><ul><li><p>Leer el procedimiento de programación en el fichero <strong>LEEME.txt</strong></p></li><li><p>El objetivo es modificar la función principal <strong>main()</strong> del programa original <strong>bitmap_gen_test.c</strong> dando lugar a distintos programas independientes entre sí.</p><div class="olist arabic"><ol class="arabic"><li><p>- Compilar y ejecutar el program <em>bitmap_gen_test.c</em></p></li><li><p>-  visualizar la imagen del fichero test.bmp: <strong>$display test.bmp</strong></p></li><li><p>- Módulo <strong>cuadrado_128x128.c</strong> :Cambiar las dimensiones de la imagen a 128 pixeles x 128 pixeles editando la macro DIMENSION=128 un gris con una intensidad del 50% de su valor máximo.</p></li><li><p>- Módulo <strong>cuadrados_4.c</strong>: Generar 4 cuadrados, uno dentro de otro simétricamente, donde el cuadrado mayor negro es 512x512 y el resto se reduce 1/8 cada uno. No utilizar ctes en las sentencias de C, utilizar las macros x_coor, y_coor, top para indicar el valor inicial del <strong>for</strong> y la posición máxima (top) de las filas y columnas. Colores de los cuadrados: background (00-00-00)/(FF-00-FF)/(00-FF-FF)/(FF-FF-00)/</p></li><li><p>- Módulo <strong>bmp_funcion.c</strong>: Dentro de la función main(), sustituir el bloque de código que realiza el bucle para inicializar los pixeles del cuadrado convertirlo por una función con las siguientes características:</p><div class="ulist"><ul><li><p>prototipo: <em>void pixels_generator(unsigned int x, unsigned int y, unsigned int maximo, RGB_data reg_mem[][top])</em></p><div class="ulist"><ul><li><p>x e y son el origen de coordenadas del cuadrado (esquina inferior izquierda)</p></li><li><p>maximo es la coordenada mayor del cuadrado.</p></li><li><p>llamada a la función: pixels_generator(xcoor,ycoor,top,buffer);</p><div class="ulist"><ul><li><p>los argumentos xcoor=top/8, ycoor=top/8 y top=512 definirlos mediante macros</p></li></ul></div></li></ul></div></li></ul></div></li></ol></div></li></ul></div>
<h level="3">Programación en ASM</h><div class="olist arabic"><ol class="arabic"><li><p>- Módulo <strong>bmp_as.c</strong>: Implementar la función <em>void pixels_generator(unsigned int maximo, RGB_data reg_mem[][top])</em> desarrollando en lenguaje ensamblador la subrutina  <em>pixels_generator</em> en el nuevo fichero <strong>array_pixel.s</strong>. El fichero en lenguaje ensamblador únicamente contendrá la subrutina.</p><div class="ulist"><ul><li><p>La subrutina implementa el doble bucle.</p></li><li><p>De forma implícita, en la propia subrutina, consideraremos los argumentos x=y=0 que definen el origen de coordenadas del cuadrado.</p></li><li><p>Todos los pixeles del cuadrado tienen el mismo color cuya intensidad se define con las variables azul, verde y rojo.</p></li></ul></div></li></ol></div>
<h level="3">GDB</h><div class="olist arabic"><ol class="arabic"><li><p>Para el módulo <strong>bmp_funcion.c</strong> indicar la posición de la pila donde se salva la dirección de retorno de la subrutina <strong>pixels_generator</strong>, así como el contenido del frame pointer y del stack pointer.</p></li><li><p>Lo mismo que en el apartado anterior con el módulo <strong>bmp_as.c</strong> para la subrutina <em>pixels_generator</em></p></li><li><p>Interpretar los comandos gdb en el caso siguiente:</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">+file bmp_imagen
Leyendo símbolos desde bmp_imagen...hecho.
+b main
Punto de interrupción 1 at 0x851: file bmp_imagen.c, line 128.
+run
Starting program: /home/candido/Dropbox/apuntes/apuntes_Estr_Computadores/upna/practicas/x86/BMP/bmp_imagen

Breakpoint 1, main (argc=1, argv=0xffffcb54) at bmp_imagen.c:128
+n
+n
+s
pixels_generator (x=64, y=64, maximo=512, reg_mem=0xfff3ca9c) at bmp_imagen.c:112
+n
+n
+n
+n
+n
+ptype buffer
El símbolo «buffer» no está en el contexto actual.
+ptype reg_mem
type = struct {
    BYTE b;
    BYTE g;
    BYTE r;
} (*)[512]
+finish
Correr hasta la salida desde #0  pixels_generator (x=64, y=64, maximo=512, reg_mem=0xfff3ca9c) at bmp_imagen.c:114
0x5655588a in main (argc=1, argv=0xffffcb54) at bmp_imagen.c:139
+n
+ptype buffer
type = struct {
    BYTE b;
    BYTE g;
    BYTE r;
} [512][512]
+x /xb &amp;buffer
0xfff3ca9c:	0x00
+p /a &amp;buffer
$1 = 0xfff3ca9c
+x /x &amp;buffer
0xfff3ca9c:	0x00
+x /x (* RGB_data)&amp;buffer
Un syntax error en la expresión, cerca de «)&amp;buffer».
+x /x (RGB_data *)&amp;buffer
0xfff3ca9c:	0x00
+x /3xb (RGB_data *)&amp;buffer
0xfff3ca9c:	0x00	0x00	0x00
+x /3xb &amp;buffer
0xfff3ca9c:	0x00	0x00	0x00
+x /3xb &amp;buffer[0][0]
0xfff3ca9c:	0x00	0x00	0x00
+p /x buffer
value requires 786432 bytes, which is more than max-value-size
+p /x buffer[0][0]
$2 = {b = 0x0, g = 0x0, r = 0x0}
+p /x buffer[0][0].r
$3 = 0x0
+p /x *(char *)buffer[0][0]
No se puede acceder a la memoria en la dirección 0x0
+p /x *(char *)&amp;buffer[0][0]
$4 = 0x0
+p /a (char *)&amp;buffer[0][0]
$5 = 0xfff3ca9c
+p /a (char *)&amp;buffer[0][1]
$6 = 0xfff3ca9f
+p /a &amp;buffer[0][1]
$7 = 0xfff3ca9f
+p /a &amp;buffer[0][1].b
$8 = 0xfff3ca9f
+p /a &amp;buffer[0][1].g
$9 = 0xfff3caa0
+p /a &amp;buffer[0][1].r
$10 = 0xfff3caa1
+p /a &amp;buffer[64][64].b
$11 = 0xfff54b5c
+p /a buffer[64][64].b
$12 = 0xff
+p  buffer[64][64].b
$13 = 255 '\377'
+p /x  buffer[64][64].b
$14 = 0xff
+p /x  *((char *)&amp;buffer+64*512+64)
$15 = 0x0
+p /x  buffer[512][512].b
$16 = 0x3d
+p /x  buffer[511][511].b
$17 = 0x0
+p /x  buffer[511][511]
$18 = {b = 0x0, g = 0x0, r = 0x0}
+p /a buffer[64][64]
$19 = {b = 0xff, g = 0x0, r = 0xff}
+p /x  *((char *)&amp;buffer+64*512+64)
$20 = 0x0
+p /x  *((char *)&amp;buffer+64*512+63)
$21 = 0x0
+p /x  *((char *)&amp;buffer+64*512+65)
$22 = 0x0
+x /3xb  ((char *)&amp;buffer+64*512+64)
0xfff44adc:	0x00	0x00	0x00
+p /a &amp;buffer[64][64]
$23 = 0xfff54b5c
+p 0xfff54b5c - 0xfff44adc
$24 = 65664
+x /3xb  ((char *)&amp;buffer+3*(64*512+64))
0xfff54b5c:	0xff	0x00	0xff
+(gdb) x /3xb  ((char *)&amp;buffer+3*(64*512+64))
orden indefinida: «». Intente con «help»
++x /3xb  ((char *)&amp;buffer+3*(64*512+64))
orden indefinida: «+x». Intente con «help»
+0xfff54b5c:     0xff    0x00    0xff
orden indefinida: «0xfff54b5c». Intente con «help»
+(gdb) x /3xb  ((char *)&amp;buffer+3*(64*512+64))
orden indefinida: «». Intente con «help»
++x /3xb  ((char *)&amp;buffer+3*(64*512+64))
orden indefinida: «+x». Intente con «help»
+0xfff54b5c:     0xff    0x00    0xff
orden indefinida: «0xfff54b5c». Intente con «help»
+p /a (char *)&amp;buffer[0][1]
$25 = 0xfff3ca9f
+x /3xb (RGB_data *)&amp;buffer+1
0xfff3ca9f:	0x00	0x00	0x00
+quit

DENTRO DE LA SUBRUTINA puedo utilizar los tipos declarados en main

(gdb) ptype RGB_data
type = struct {
    BYTE b;
    BYTE g;
    BYTE r;
}
(gdb) p  *(RGB_data *)RGB_ptr
$29 = {b = 0 '\000', g = 0 '\000', r = 255 '\377'}
(gdb) p  (*(RGB_data *)RGB_ptr).r
$28 = 255 '\377'</code></pre></div></div></li></ol></div></div></section></section></div></section>
<section id="_vi_hojas_de_referencia_rápida"><h2>VI Hojas de Referencia Rápida</h2><div class="slide-content"><section><section id="_programación_ensamblador_att_x86"><h2>19. Programación Ensamblador AT&amp;T x86</h2></section><section id="_programas_x86_32"><h2>19.1. Programas  x86-32</h2><div class="slide-content"><h level="3">Programa Minimalista</h><div class="ulist"><ul><li><p>minimalista.s</p><div class="listingblock"><div class="content"><pre>### Programa: minimalista.s
### gcc -m32 -g  -o minimalista minimalista.s

        .global main
        .section .text
main:
        mov $1, %eax  # código de la llamada al sistema operativo: subrutina exit
        int $0x80     # llamada al sistema operativo
        .end</pre></div></div></li></ul></div>
<h level="4">Estructura del programa</h><div class="ulist"><ul><li><p>Una Cabecera y dos Secciones:</p><div class="ulist"><ul><li><p>Cabecera con comentarios.</p></li><li><p>Sección de Datos: Se realiza la reserva de para implementar las variables inicializadas</p><div class="ulist"><ul><li><p>Directiva <code>.section .data</code> ó únicamente <code>.data</code></p></li></ul></div></li><li><p>Sección de Instrucciones: Secuencia de instrucciones en lenguaje ensamblador</p><div class="ulist"><ul><li><p>Directiva <code>.section .text</code> ó únicamente <code>.text</code></p></li></ul></div></li></ul></div></li></ul></div>
<h level="4">Cabecera</h><div class="ulist"><ul><li><p>Cabecera con comentarios sobre:</p><div class="ulist"><ul><li><p>Nombre del programa, lenguaje de programación.</p></li><li><p>Descripción del programa: entradas al programa, salidas, función del programa.</p></li><li><p>Entorno de programación: sistema operativo, assembler utilizado, comandos de compilación, ensamblaje, linker.</p></li><li><p>Comentarios sobre el autor, fecha, etc</p></li></ul></div></li></ul></div>
<h level="4">Sección de Datos</h><div class="ulist"><ul><li><p>Directiva <code>.section .data</code> : indica el comienzo de la sección de datos</p></li><li><p>Etiqueta <code>n:</code>  :reserva de memoria en la dirección simbólica <em>n</em></p></li><li><p>Directiva <code>.int</code> :reserva de 4 bytes a partir de la dirección <em>n</em>: direcciones n,n+1,n+2,n+3</p></li><li><p>Literal <code>5</code> :valor de inicialización de la reserva de memoria</p></li></ul></div>
<h level="4">Sección de Instrucciones : punto de entrada y bloque de salida: llamada del sistema y llamada al sistema</h><div class="ulist"><ul><li><p>Directiva <code>.section .text</code> : indica el inicio de la sección de instrucciones.</p></li><li><p>Sintaxis de las instrucciones en lenguaje AT&amp;T :</p><div class="ulist"><ul><li><p><code>etiqueta:  operación operando_fuente,operando_destino  #comentario</code></p></li></ul></div></li><li><p>Punto de entrada al programa desde el sistema operativo:</p><div class="ulist"><ul><li><p>El SISTEMA Operativo llama al programa o aplicación.</p></li><li><p>Etiqueta <em>_start:</em>  . Apunta a la primera instrucción del programa.</p></li><li><p>Directiva <code>.global</code> : La etiqueta <em>_start</em> tiene que ser "visible" fuera del programa sum1toN para que el linker la enlace con el sistema operativo linux como punto de entrada, es decir, tiene que ser un símbolo <em>global</em> al resto de programas y no  <em>local</em> al programa <em>sum1toN</em>. El linker <em>ld</em> por defecto presupone que el símbolo utilizado como etiqueta del punto de entrada es <em>_start</em>.</p></li></ul></div></li><li><p>Punto de salida del programa al sistema operativo:</p><div class="ulist"><ul><li><p>Es necesario acabar con el proceso del programa <em>sum1toN</em> y liberar todos los recursos que este utilizando dicho proceso. Esta tarea de fin de proceso la tiene que realizar el sistema operativo o kernel linux.</p></li><li><p>El programa o aplicación llama al  El SISTEMA Operativo.</p></li><li><p>El programa <em>sum1toN</em> llama al sistema operativo para realizar la operación de fin de proceso mediante la ejecución de la función <strong>exit(argumento)</strong> . El sistema operativo tiene un listado de posibles funciones que ejecuta si es llamado. Una de dichas funciones es exit(argumento).</p></li><li><p>LLamada al Sistema Operativo en lenguaje ensamblador:</p><div class="ulist"><ul><li><p>Registro EAX: almacena el código de la función a ejecutar por el Sistema Operativo. El código de la función <em>exit</em> es 1.</p></li><li><p>Registro EBX: almacena el código del argumento de la función <em>exit(argumento)</em>. El valor 0 se interpreta como ejecución del programa correcta.</p></li><li><p>Instrucción <code>int $0x80</code> : esta instrucción llama al sistema operativo, INTerrumpe al sistema operativo para que ejecute la función asociada al código almacenado en el registro EAX.</p></li></ul></div></li><li><p><a href="http://programminggroundup.blogspot.com/2007/01/appendix-c-important-system-calls.html">Programming from the Ground Up</a></p></li></ul></div></li></ul></div>
<h level="4">Fin del ensamblaje</h><div class="ulist"><ul><li><p>Directiva <code>.end</code></p></li></ul></div>
<h level="3">Ejemplo Básico</h><div class="ulist"><ul><li><p>Módulo fuente: <em>sum1toN.s</em></p><div class="listingblock"><div class="content"><pre>### Programa: sum1toN.s
### Descripción: realiza la suma de la serie 1,2,3,...N
### Es el programa en lenguaje AT&amp;T i386 equivalente a sum.ias de la máquina IAS de von Neumann
### gcc -m32 -g -nostartfiles -o sum1toN sum1toN.s
### Ensamblaje as --32 --gstabs sum1toN.s -o sum1toN.o
### linker -&gt; ld -melf_i386  -o sum1toN sum1toN.o
        ##  Declaración de variables
        .section .data
n:	.int 5
        .global _start
        ##  Comienzo del código
        .section .text
_start:
        mov $0,%ecx # ECX implementa la variable suma
        mov n,%edx
bucle:
        add %edx,%ecx
        sub $1,%edx
        jnz bucle
        mov %ecx, %ebx # el argumento de salida al S.O. a través de EBX según convenio
        ## salida
        mov $1, %eax  # código de la llamada al sistema operativo: subrutina exit
        int $0x80     # llamada al sistema operativo
        .end</pre></div></div></li><li><p>Compilación: <code>gcc -nostartfiles -m32 -g -o sum1toN sum1toN.s</code></p></li><li><p>Ensamblaje: <code>as --32 --gstabs sum1toN.s -o sum1toN.o</code></p></li><li><p>linker: <code>ld -melf_i386  -o sum1toN sum1toN.o</code></p></li><li><p>Directivas del traductor ensamblador: .section, .data, .text, .byte, .end, etc&#8230;&#8203; empiezan con un punto como prefijo</p></li></ul></div>
<table class="tableblock frame-all grid-all" style="width:100%"><colgroup><col style="width:9.5238%" /><col style="width:19.0476%" /><col style="width:23.8095%" /><col style="width:4.7619%" /><col style="width:28.5714%" /><col style="width:14.2858%" /></colgroup><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>label:</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>op_mnemonic</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>operand_source</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>,</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>operand_destination</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>;comment</code></p></td></tr></table>
<div class="ulist"><ul><li><p>Las etiquetas llevan el sufijo <strong>:</strong></p></li><li><p>La etiqueta <strong>_start</strong>: es el punto de entrada al programa. Obligatoria. La utiliza el linker.</p></li><li><p>Sufijos de los mnemónicos</p><div class="ulist"><ul><li><p><strong>b</strong> &#8594; byte &#8594; 1Byte  &#8594;Ej: movb</p></li><li><p><strong>w</strong> &#8594; word &#8594; 2Bytes &#8594;Ej: movw  . En este contexto word son 2 bytes por razones históricas.</p></li><li><p><strong>l</strong> &#8594; long &#8594; 4Bytes &#8594;Ej: movl  . Valor por defecto.</p></li><li><p><strong>q</strong> &#8594; quad &#8594; 8Bytes &#8594;Ej: movq</p></li></ul></div></li><li><p>Direccionamientos de los operandos:</p><div class="ulist"><ul><li><p>En la misma instrucción los operandos fuente y destino no pueden hacer ambos referencia a la memoria Principal.</p></li><li><p>inmediato: prefijo del operando <strong>$</strong></p></li><li><p>registro:  prefijo del registro <strong>%</strong></p></li><li><p>directo:   el operando es una etiqueta que apunta a la memoria principal</p></li><li><p>indirecto: el operando es una etiqueta o un registro: utiliza paréntesis. (etiqueta) ó (%registro). Ver indexado.</p><div class="ulist"><ul><li><p>La etiqueta referencia una posición de memoria que contiene a su vez una dirección de la memoria principal que apunta al operando.</p></li><li><p>El registro contiene la dirección de la memoria principal que apunta al operando.</p></li></ul></div></li><li><p>indexado</p><div class="ulist"><ul><li><p>dirección efectiva: <em>base + index*scale + disp</em> &#8594; la sintaxis es:  disp(base,índice,escala)</p></li><li><p>foo(%ebp,%esi,4)    &#8594; dirección efectiva= <em>EBP + 4*ESI + foo</em></p></li><li><p>(%edi)              &#8594; dirección efectiva= <em>EDI</em> &#8594; direccionamiento indirecto</p></li><li><p>-4(%ebp)    	&#8594; dirección efectiva= <em>EBP - 4</em></p></li><li><p>foo(,%eax,4)	&#8594; dirección efectiva= <em>4*EAX + foo</em></p></li><li><p>foo(,1)     	&#8594; dirección efectiva= foo</p></li></ul></div></li><li><p>Cualquier instrucción que tiene una referencia a un operando en la memoria principal y no tiene una referencia a registro, debe especificar el tamaño del operando  (byte, word, long, or quadruple) con una instrucción que lleve el sufijo (&#8216;b&#8217;, &#8216;w&#8217;, &#8216;l&#8217; or &#8216;q&#8217;, respectivamente).</p></li></ul></div></li></ul></div></div></section><section id="directivas_as"><h2>19.2. Directivas Assembler AS</h2><div class="slide-content"><div class="ulist"><ul><li><p>Manual</p><div class="ulist"><ul><li><p><a href="https://sourceware.org/binutils/docs/as/" class="bare">https://sourceware.org/binutils/docs/as/</a></p></li></ul></div></li></ul></div>
<table class="tableblock frame-all grid-all" style="width:100%"><caption class="title">Table 17. Directivas básicas</caption><colgroup><col style="width:50%" /><col style="width:50%" /></colgroup><thead><tr><th class="tableblock halign-left valign-top">.global o .globl</th><th class="tableblock halign-left valign-top">variables globales</th></tr><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.section .data</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">sección de las variables locales estáticas inicializadas</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.section .text</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">sección de las instrucciones</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.section .bss</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">sección de las variables sin inicializar</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.section .rodata</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">sección de las variables de sólo lectura</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.type	  name , type description</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">tipo de variable, p.ej @function</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.common   100</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">reserva 100 bytes sin inicializar y puede ser referenciado globalmente</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.lcomm   bucle, 100</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">reserva 100bytes referenciados con el símbolo local bucle. Sin inicializar.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.space    100</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">reserva 100 bytes inicializados a cero</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.space    100, 3</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">reserva 100 bytes inicializados a 3</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.string  "Hola"</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">añade el byte 0 al final de la cadena</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.asciz   "Hola"</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">añade el byte 0 al final de la cadena</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.ascii   "Hola"</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">no añade le caracter NULL de final de cadena</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.byte    3,7,-10,0b1010,0xFF,0777</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">tamaño 1Byte y formatos decimal,decimal,decimal,binario,hexadecimal,octal</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.2byte    3,7,-10,0b1010,0xFF,0777</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">tamaño 2Bytes</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.word    3,7,-10,0b1010,0xFF,0777</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">tamaño 2Bytes</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.short   3,7,-10,0b1010,0xFF,0777</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">tamaño 2B</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.4byte    3,7,-10,0b1010,0xFF,0777</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">tamaño 4B</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.long    3,7,-10,0b1010,0xFF,0777</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">tamaño 4B</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.int     3,7,-10,0b1010,0xFF,0777</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">tamaño 4B</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.8byte    3,7,-10,0b1010,0xFF,0777</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">tamaño 8B</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.quad    3,7,-10,0b1010,0xFF,0777</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">tamaño 8B</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.octa    3,7,-10,0b1010,0xFF,0777</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">formato octal</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.double  3.14159, 2 E-6</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">precisión doble</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.float   2E-6, 3.14159</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">precisión simple</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.single  2E-6</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">precisión simple</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.include "file"</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">incluye el fichero . Obligatorias las comillas.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.equ     SUCCESS, 0</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">macro que asocia el símbolo SUCCESS al número 0</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.macro macname macargs</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">define el comienzo de una macro de nombre macname y argumentos macargs</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.endmacro</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">define el final de una macro</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.align   n</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">las instrucciones o datos posteriores empezarán en una dirección multiplo de n bytes.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">.end</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">fin del ensamblaje</p></td></tr></table>
<div class="ulist"><ul><li><p>Alineamiento <strong>Little Endian</strong>: El byte de menor peso, LSB, se almacena en la posición de memoria más baja.</p><div class="ulist"><ul><li><p>.int OxAABBCCDD &#8594; 0xDD se almacena primero en la dirección más baja, el resto de bytes se almacenan en sentido ascendente en el orden 0xCC,0xBB,0xAA</p></li></ul></div></li></ul></div></div></section><section id="rie"><h2>19.3. Repertorio de Instrucciones Ensamblador</h2><div class="slide-content"><div class="ulist"><ul><li><p><a href="#repertorio_instruc_oper">Manuales del Repertorio de Instrucciones</a></p></li><li><p>Lenguaje Ensamblador AT&amp;T</p></li></ul></div>
<h level="3">TRANSFERENCIA</h><table class="tableblock frame-all grid-all" style="width:100%"><colgroup><col style="width:9.0909%" /><col style="width:18.1818%" /><col style="width:18.1818%" /><col style="width:36.3636%" /><col style="width:18.1819%" /></colgroup><thead><tr><th class="tableblock halign-left valign-top">Nombre</th><th class="tableblock halign-left valign-top">Comentario</th><th class="tableblock halign-left valign-top">Código</th><th class="tableblock halign-left valign-top">Operación</th><th class="tableblock halign-left valign-top">O D I T S Z A P C</th></tr><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock">MOV</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Mover (copiar)</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">MOV Fuente,Dest</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Dest:=Fuente</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">XCHG</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Intercambiar</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">XCHG Op1,Op2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Op1:=Op2 , Op2:=Op1</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">STC</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Set the carry (Carry = 1)</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">STC</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">CF:=1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">CLC</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Clear Carry (Carry = 0)</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">CLC</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">CF:=0</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">CMC</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Complementar Carry</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">CMC</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">CF:=Ø</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">±</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">STD</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Setear dirección</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">STD</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">DF:=1(interpreta strings de arriba hacia abajo)</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">CLD</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Limpiar dirección</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">CLD</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">DF:=0(interpreta strings de abajo hacia arriba)</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">STI</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Flag de Interrupción en 1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">STI</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">IF:=1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">CLI</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Flag de Interrupción en 0</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">CLI</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">IF:=0</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">PUSH</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Apilar en la pila</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">PUSH Fuente</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">DEC SP, [SP]:=Fuente</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">PUSHF</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Apila los flags</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">PUSHF</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">O, D, I, T, S, Z, A, P, C 286+: También NT,IOPL</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">PUSHA</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Apila los registros generales</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">PUSHA</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">AX, CX, DX, BX, SP, BP, SI, DI</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">POP</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Desapila de la pila</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">POP Dest</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Destino:=[SP], INC SP</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">POPF</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Desapila a los flags</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">POPF</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">O,D,I,T,S,Z,A,P,C 286+: También NT,IOPL</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">± ± ± ± ± ± ± ± ±</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">POPA</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Desapila a los reg. general.</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">POPA</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">DI, SI, BP, SP, BX, DX, CX, AX</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">CBW</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Convertir Byte a Word</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">CBW</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">AX:=AL (con signo)</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">CWD</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Convertir Word a Doble</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">CWD</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">DX:AX:=AX (con signo)</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">CWDE</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Conv. Word a Doble Exten.</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">CWDE 386</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">EAX:=AX (con signo)</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">IN</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Entrada</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">IN Dest,Puerto</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">AL/AX/EAX := byte/word/double del puerto esp.</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">OUT</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Salida</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">OUT Puer,Fuente</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Byte/word/double del puerto := AL/AX/EAX</p></td><td class="tableblock halign-left valign-top"></td></tr></table>
<div class="ulist"><ul><li><p>Flags: <strong>±</strong> =Afectado por esta instrucción, <strong>?</strong> =Indefinido luego de esta instrucción</p></li></ul></div>
<h level="3">ARITMÉTICOS</h><table class="tableblock frame-all grid-all" style="width:100%"><colgroup><col style="width:9.0909%" /><col style="width:18.1818%" /><col style="width:18.1818%" /><col style="width:36.3636%" /><col style="width:18.1819%" /></colgroup><thead><tr><th class="tableblock halign-left valign-top">Nombre</th><th class="tableblock halign-left valign-top">Comentario</th><th class="tableblock halign-left valign-top">Código</th><th class="tableblock halign-left valign-top">Operación</th><th class="tableblock halign-left valign-top">O D I T S Z A P C</th></tr><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock">ADD</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Suma</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">ADD Fuente,Dest</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Dest:=Dest+ Fuente</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">±       ± ± ± ± ±</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">ADC</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Suma con acarreo</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">ADC Fuente,Dest</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Dest:=Dest+ Fuente +CF</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">±       ± ± ± ± ±</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">SUB</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Resta</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">SUB Fuente,Dest</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Dest:=Dest- Fuente</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">±       ± ± ± ± ±</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">SBB</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Resta con acarreo</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">SBB Fuente,Dest</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Dest:=Dest-(Fuente +CF)</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">±       ± ± ± ± ±</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">DIV</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">División (sin signo)</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">DIV Op</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Op=byte: AL:=AX / Op AH:=Resto</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">?       ? ? ? ? ?</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">DIV</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">División (sin signo)</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">DIV Op</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Op=word:         AX:=DX:AX / Op DX:=Resto</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">?       ? ? ? ? ?</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">DIV</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">386 División (sin signo)</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">DIV Op</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Op=doublew.:     EAX:=EDX:EAX / Op EDX:=Resto</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">?	 ? ? ? ? ?</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">IDIV</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">División entera con signo</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">IDIV Op</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Op=byte:        AL:=AX / Op AH:=Resto</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">?	 ? ? ? ? ?</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">IDIV</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">División entera con signo</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">IDIV Op</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Op=word: AX:=DX:AX / Op DX:=Resto</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">?	 ? ? ? ? ?</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">IDIV</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">386 División entera con signo</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">IDIV Op</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Op=doublew.: EAX:=EDX:EAX / Op EDX:=Resto</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">?	 ? ? ? ? ?</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">MUL</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Multiplicación (sin signo)</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">MUL Op</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Op=byte: AX:=AL*Op si AH=0 #</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">±	 ? ? ? ? ±</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">MUL</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Multiplicación (sin signo)</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">MUL Op</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Op=word: DX:AX:=AX*Op si DX=0 #</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">±	 ? ? ? ? ±</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">MUL</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">386 Multiplicación (sin signo)</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">MUL Op</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Op=double: EDX:EAX:=EAX*Op si EDX=0 #</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">±	 ? ? ? ? ±</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">IMUL</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">i Multiplic. entera con signo</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">IMUL Op</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Op=byte: AX:=AL*Op si AL es suficiente #</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">±	 ? ? ? ? ±</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">IMUL</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Multiplic. entera con signo</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">IMUL Op</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Op=word: DX:AX:=AX*Op si AX es suficiente #</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">±	 ? ? ? ? ±</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">IMUL</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">386 Multiplic. entera con signo</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">IMUL Op</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Op=double: EDX:EAX:=EAX*Op si EAX es sufi. #</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">±	 ? ? ? ? ±</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">INC</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Incrementar</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">INC Op</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Op:=Op+1 (El Carry no resulta afectado !)</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">±	 ± ± ± ±</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">DEC</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Decrementar</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">DEC Op</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Op:=Op-1 (El Carry no resulta afectado !)</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">±       ± ± ± ±</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">CMP</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Comparar</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">CMP Fuente,Destino</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Destino-Fuente</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">±       ± ± ± ± ±</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">SAL</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Desplazam. aritm. a la izq.</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">SAL</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Op,Cantidad</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">i       ± ± ? ± ±</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">SAR</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Desplazam. aritm. a la der.</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">SAR</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Op,Cantidad</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">i       ± ± ? ± ±</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">RCL</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Rotar a la izq. c/acarreo</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">RCL Op,Cantidad</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock">i               ±</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">RCR</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Rotar a la derecha c/acarreo</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">RCR Op,Cantidad</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock">i               ±</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">ROL</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Rotar a la izquierda</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">ROL Op,Cantidad</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock">i               ±</p></td></tr></table>
<div class="ulist"><ul><li><p><strong>i</strong>:para más información ver especificaciones de la intrucción,</p></li><li><p><strong>#</strong>:entonces CF:=0, OF:=0 sino CF:=1, OF:=1</p></li></ul></div>
<h level="3">LÓGICOS</h><table class="tableblock frame-all grid-all" style="width:100%"><colgroup><col style="width:9.0909%" /><col style="width:18.1818%" /><col style="width:18.1818%" /><col style="width:36.3636%" /><col style="width:18.1819%" /></colgroup><thead><tr><th class="tableblock halign-left valign-top">Nombre</th><th class="tableblock halign-left valign-top">Comentario</th><th class="tableblock halign-left valign-top">Código</th><th class="tableblock halign-left valign-top">Operación</th><th class="tableblock halign-left valign-top">O D I T S Z A P C</th></tr><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock">NEG</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Negación (complemento a 2)</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">NEG Op</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Op:=0-Op si Op=0 entonces CF:=0 sino CF:=1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">±       ± ± ± ± ±</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">NOT</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Invertir cada bit</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">NOT Op</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Op:=Ø~Op (invierte cada bit)</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">AND</p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><em>Y</em> (And) lógico</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">AND Fuente,Dest</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Dest:=Dest ^ Fuente</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">0       ± ± ? ± 0</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">OR</p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><em>O</em> (Or) lógico</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">OR  Fuente,Dest</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Dest:=Dest v Fuente</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">0       ± ± ? ± 0</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">XOR</p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><em>O</em> (Or) exclusivo</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">XOR Fuente,Dest</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Dest:=Dest (xor) Fuente</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">0       ± ± ? ± 0</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">SHL</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Desplazam. lógico a la izq.</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">SHL Op,Cantidad</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock">i       ± ± ? ± ±</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">SHR</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Desplazam. lógico a la der.</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">SHR Op,Cantidad</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock">i       ± ± ? ± ±</p></td></tr></table>
<h level="3">MISCELÁNEOS</h><table class="tableblock frame-all grid-all" style="width:100%"><colgroup><col style="width:9.0909%" /><col style="width:18.1818%" /><col style="width:18.1818%" /><col style="width:36.3636%" /><col style="width:18.1819%" /></colgroup><thead><tr><th class="tableblock halign-left valign-top">Nombre</th><th class="tableblock halign-left valign-top">Comentario</th><th class="tableblock halign-left valign-top">Código</th><th class="tableblock halign-left valign-top">Operación</th><th class="tableblock halign-left valign-top">O D I T S Z A P C</th></tr><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock">NOP</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Hacer nada</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">NOP</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">No hace operación alguna</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">LEA</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Cargar direciión Efectiva</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">LEA Fuente,Dest</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Dest := dirección fuente</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">INT</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Interrupción</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">INT Num</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Interrumpe el proceso actual y salta al vector Num</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">0 0</p></td></tr></table>
<h level="3">SALTOS  (generales)</h><div class="ulist"><ul><li><p><a href="https://en.wikibooks.org/wiki/X86_Assembly/Control_Flow#Jump_if_Lesser">wiki x86 assembly</a></p></li></ul></div>
<div class="listingblock"><div class="content"><pre>Nombre  Comentario                      Código          Operación
CALL    Llamado a subrutina             CALL Proc
JMP     Saltar                          JMP Dest
JE      Saltar si es igual              JE Dest         (= JZ)
JZ      Saltar si es cero               JZ Dest         (= JE)
JCXZ    Saltar si CX es cero            JCXZ Dest
JP      Saltar si hay paridad           JP Dest         (= JPE)
JPE     Saltar si hay paridad par       JPE Dest        (= JP)
JPO     Saltar si hay paridad impar     JPO Dest        (= JNP)
JNE     Saltar si no es igual           JNE Dest        (= JNZ)
JNZ     Saltar si no es cero            JNZ Dest        (= JNE)
JECXZ   Saltar si ECX es cero           JECXZ Dest 386
JNP     Saltar si no hay paridad        JNP Dest        (= JPO)
RET     Retorno de subrutina            RET</pre></div></div>
<h level="3">SALTOS  Sin Signo (Cardinal) SALTOS Con Signo (Integer)</h><div class="listingblock"><div class="content"><pre>Nombre  Comentario                      Código          Operación
JA      Saltar si es superior           JA Dest         (= JNBE)
JAE     Saltar si es superior o igual   JAE Dest        (= JNB = JNC)
JB      Saltar si es inferior           JB Dest         (= JNAE = JC)
JBE     Saltar si es inferior o igual   JBE Dest        (= JNA)
JNA     Saltar si no es superior        JNA Dest        (= JBE)
JNAE    Saltar si no es super. o igual  JNAE Dest       (= JB = JC)
JNB     Saltar si no es inferior        JNB Dest        (= JAE = JNC)
JNBE    Saltar si no es infer. o igual  JNBE Dest       (= JA)
JC      Saltar si hay carry JC Dest     JO  Dest        Saltar si hay Overflow
JNC     Saltar si no hay carry          JNC Dest
JNO     Saltar si no hay Overflow       JNO Dest
JS      Saltar si hay signo (=negativo) JS Dest
JG      Saltar si es mayor              JG Dest         (= JNLE)
JGE     Saltar si es mayor o igual      JGE Dest        (= JNL)
JL      Saltar si es menor              JL Dest         (= JNGE)
JLE     Saltar si es menor o igual      JLE Dest        (= JNG)
JNG     Saltar si no es mayor           JNG Dest        (= JLE)
JNGE    Saltar si no es mayor o igual   JNGE Dest       (= JL)
JNL     Saltar si no es inferior        JNL Dest        (= JGE)
JNLE    Saltar si no es menor o igual   JNLE Dest       (= JG)</pre></div></div>
<h level="3">FLAGS (ODITSZAPC)</h><div class="listingblock"><div class="content"><pre>O: Overflow resultado de operac. sin signo es muy grande o pequeño.
D: Dirección
I: Interrupción Indica si pueden ocurrir interrupciones o no.
T: Trampa Paso, por paso para debugging
S: Signo Signo del resultado. Razonable sólo para enteros. 1=neg. 0=pos.
Z: Cero Resultado de la operación es cero. 1=Cero
A: Carru Aux. Similar al Carry, pero restringido para el nibble bajo únicamente
P: Paridad 1=el resultado tiene cantidad par de bits en uno
C: Carry resultado de operac. sin signo es muy grande o inferior a cero</pre></div></div>
<div class="ulist"><ul><li><p>Sufijos de los mnemónicos del código de operación:</p><div class="ulist"><ul><li><p><em>q</em> : quad: operando de 8 bytes: cuádruple palabra</p></li><li><p><em>l</em> : long: operando de 4 bytes: doble palabra</p></li><li><p><em>w</em> : word: operando de 2 bytes: palabra</p></li><li><p><em>b</em> : byte: operando de 1 byte</p></li></ul></div></li><li><p>Si el mnemónico de operación no lleva sufijo el tamaño por defecto del operando es <em>long</em></p></li></ul></div>
<div style="page-break-after: always;"></div>
<h level="3">Listado de mnemónicos</h><div class="listingblock"><div class="content"><pre>Quick x86 assembly mnemonics NUP-UPNA

                                        NEG  ;Negación (compl a 2)
ADD     ;Suma                           NOT  ;Invertir cada bit
ADC     ;Suma con acarreo               AND  ;'Y' (And) lógico
SUB     ;Resta                          OR   ;'O' (Or) lógico
SBB     ;Resta con acarreo              XOR  ;'O' (Or) exclusivo
DIV     ;División (sin signo)           SHL  ;Desplazam.lógico a la izq.
DIV     ;División (sin signo)           SHR  ;Desplazam.lógico a la der.
DIV     ;386 División (sin signo)       MOV  ;Mover (copiar)
IDIV    ;División entera con signo      XCHG ;Intercambiar
IDIV    ;División entera con signo      STC  ;Set the carry (Carry=1)
IDIV    ;386 División entera con signo  CLC  ;Clear Carry (Carry=0)
MUL     ;Multiplicación (sin signo)     CMC  ;Complementar Carry
MUL     ;Multiplicación (sin signo)     STD  ;Setear dirección
MUL     ;386 Multiplicación (sin signo) CLD  ;Limpiar dirección
IMUL    ;i Multiplic. entera con signo  STI  ;Flag de Interrupción en 1
IMUL    ;Multiplic. entera con signo    CLI  ;Flag de Interrupción en 0
IMUL    ;386 Multiplic. entera con signoPUSH ;Apilar en la pila
INC     ;Incrementar                    PUSHF;Apila los flags
DEC     ;Decrementar                    PUSHA;Apila los regs generales
CMP     ;Comparar                       POP  ;Desapila de la pila
SAL     ;Desplazam. aritm. a la izq.    POPF ;Desapila a los flags
SAR     ;Desplazam. aritm. a la der.    POPA ;Desapila a los reg. general.
RCL     ;Rotar a la izq. c/acarreo      CBW  ;Conv. Byte a Word
RCR     ;Rotar a la derecha c/acarreo   CWD  ;Conv. Word a Doble
ROL     ;Rotar a la izquierda           CWDE ;Conv. Word a Doble Exten.
ROR     ;Rotar a la derecha             IN   ;Entrada
NOP     ;Hacer nada                     OUT  ;Salida
LEA     ;Cargar dirección Efectiva      Directivas
INT     ;Interrupción			.global ó .globl label
CALL    Llamada a subrutina        	.section .data
JMP     Saltar                     	.section .text
JE      Saltar si es igual         	.section .bss
JZ      Saltar si es cero          	.section .rodata
JCXZ    Saltar si CX es cero       	.type name,description
JP      Saltar si hay paridad      	.common   size
JPE     Saltar si hay paridad par  	.lcomm    label,size
JPO     Saltar si hay paridad impar	.space    size
JNE     Saltar si no es igual           .end
JNZ     Saltar si no es cero       	.string
JECXZ   Saltar si ECX es cero      	.asciz
JNP     Saltar si no hay paridad   	.ascii
RET     Retorno de subrutina		.byte
JA      Saltar si es superior          	.2byte
JAE     Saltar si es superior o igual  	.word
JB      Saltar si es inferior          	.short
JBE     Saltar si es inferior o igual  	.4byte
JNA     Saltar si no es superior       	.long
JNAE    Saltar si no es super. o igual 	.int
JNB     Saltar si no es inferior       	.8byte
JNBE    Saltar si no es infer. o igual 	.quad
JC      Saltar si hay carry JC Dest    	.octa
JNC     Saltar si no hay carry         	.double
JNO     Saltar si no hay Overflow      	.float
JS      Saltar si hay signo (=negativo)	.single
JG      Saltar si es mayor             	.include "file"
JGE     Saltar si es mayor o igual     	.equ     NAME, value
JL      Saltar si es menor             	.macro macname m
JLE     Saltar si es menor o igual     	.endmacro
JNG     Saltar si no es mayor          	.align number
JNGE    Saltar si no es mayor o igual
JNL     Saltar si no es inferior
JNLE    Saltar si no es menor o igual
|63-0| 31-0 | 15-0| 15-8| 7-0
|rax | eax | ax  | ah  | al
|rbx | ebx | bx  | bh  | bl
|rcx | ecx | cx  | ch  | cl
|rdx | edx | dx  | dh  | dl
|rsi | esi | si  |     | sil
|rdi | edi | di  |     | dil
|rbp | ebp | bp  |     | bpl
|rsp | esp | sp  |     | spl
|r8  | r8d | r8w |     | r8b
|r9  | r9d | r9w |     | r9b
|r10 | r10d | r10w|     | r10b
|r11 | r11d | r11w|     | r11b
|r12 | r12d | r12w|     | r12b
|r13 | r13d | r13w|     | r13b
|r14 | r14d | r14w|     | r14b
|r15 | r15d | r15w|     | r15b</pre></div></div>
<div style="page-break-after: always;"></div></div></section><section id="registros_32"><h2>19.4. Registros</h2><div class="slide-content"><h level="3">Visión completa</h><div class="imageblock" style="text-align: center"><img src="./images/hojas_ref_rap/reg_amd64.png" alt="Registros amd64" width="300" /></div>
<div class="ulist"><ul><li><p>Los registros de propósito general RPG de 32 bits son:</p><div class="ulist"><ul><li><p>&#8216;%eax&#8217; (el acumulador), &#8216;%ebx&#8217;, &#8216;%ecx&#8217;, &#8216;%edx&#8217;, &#8216;%edi&#8217;, &#8216;%esi&#8217;, &#8216;%ebp&#8217; (puntero frame), and &#8216;%esp&#8217; (puntero stack).</p></li></ul></div></li></ul></div>
<table class="tableblock frame-all grid-all" style="width:100%"><colgroup><col style="width:100%" /></colgroup><tbody><tr><td class="tableblock halign-left valign-top"><div><div class="imageblock" style="text-align: center"><img src="./images/hojas_ref_rap/reg_amd.png" alt="Registros RPG" height="300" /></div></div></td></tr></table>
<h level="3">Registros visibles al programador</h><table class="tableblock frame-all grid-all" style="width:50%"><colgroup><col style="width:20%" /><col style="width:20%" /><col style="width:20%" /><col style="width:20%" /><col style="width:20%" /></colgroup><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>63-0</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>31-0</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>15-0</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>15-8</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>7-0</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>rax</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>eax</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>ax</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>ah</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>al</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>rbx</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>ebx</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>bx</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>bh</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>bl</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>rcx</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>ecx</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>cx</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>ch</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>cl</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>rdx</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>edx</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>dx</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>dh</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>dl</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>rsi</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>esi</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>si</code></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>sil</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>rdi</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>edi</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>di</code></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>dil</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>rbp</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>ebp</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>bp</code></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>bpl</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>rsp</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>esp</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>sp</code></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>spl</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r8</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r8d</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r8w</code></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r8b</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r9</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r9d</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r9w</code></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r9b</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r10</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r10d</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r10w</code></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r10b</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r11</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r11d</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r11w</code></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r11b</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r12</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r12d</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r12w</code></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r12b</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r13</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r13d</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r13w</code></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r13b</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r14</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r14d</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r14w</code></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r14b</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r15</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r15d</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r15w</code></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>r15b</code></p></td></tr></table>
<h level="3">Compatibilidad 32-64</h><div class="ulist"><ul><li><p>En la nominación de los registros de la arquitectura de 64 bits sustituir R  por E y obtenemos la nominación de la arquitectura de 32 bits.</p></li></ul></div>
<table class="tableblock frame-all grid-all" style="width:50%"><colgroup><col style="width:50%" /><col style="width:50%" /></colgroup><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock">64 bits</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">32 bits</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">RIP</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">EIP</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">RAX</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">EAX</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">RFLAG</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">EFLAG</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">&#8230;&#8203;&#8230;&#8203;.</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">&#8230;&#8203;&#8230;&#8203;&#8230;&#8203;&#8230;&#8203;.</p></td></tr></table>
<div class="ulist"><ul><li><p>Hay excepciones</p></li></ul></div>
<h level="3">Control Flag Register</h><div class="imageblock" style="text-align: center"><img src="./images/hojas_ref_rap/rflags.png" alt="Registros Flags" width="300" /></div>
<div class="ulist"><ul><li><p>Registro de STATUS: La ejecución de una instrucción, activa unos bits denominados banderines que indican consecuencias de la operación realizada. Ejemplo: banderín de overflow : indica que la operación aritmética realizada ha resultado en un desbordamiento del resultado de dicha operación.</p></li><li><p><a href="http://en.wikipedia.org/wiki/FLAGS_register_(computing)">wikipedia</a></p></li><li><p>Unicamente nos fijamos en los flags OSZAPC.</p><table class="tableblock frame-all grid-all" style="width:50%"><caption class="title">Table 18. RFLAG Register</caption><colgroup><col style="width:33.3333%" /><col style="width:33.3333%" /><col style="width:33.3334%" /></colgroup><thead><tr><th class="tableblock halign-left valign-top">Flag</th><th class="tableblock halign-center valign-top">Bit</th><th class="tableblock halign-left valign-top">Name</th></tr><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock">CF</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Carry flag</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">PF</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Parity flag</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">AF</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Adjust flag</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">ZF</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">6</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Zero flag</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">SF</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Sign flag</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">OF</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">11</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Overflow flag</p></td></tr></table></li><li><p>Carry flag:</p><div class="ulist"><ul><li><p>se activa si la llevada se sale del ancho de palabra de la ALU en una operación aritmética de números enteros sin signo o con signo</p></li></ul></div></li><li><p>Overflow flag:</p><div class="ulist"><ul><li><p>se activa si teniendo en cuenta el bit de mayor peso MSB (aunque este fuera del tamaño) indica error en la operación aritmética con números enteros con signo.</p></li></ul></div></li><li><p>Parity Even flag:</p><div class="ulist"><ul><li><p>indica si el número de bits del byte LSB del resultado de la última operación ha sido par.</p></li></ul></div></li><li><p>Sign flag:</p><div class="ulist"><ul><li><p>se activa si el resultado de la última operación ha sido negativo.</p></li></ul></div></li><li><p>Adjust flag:</p><div class="ulist"><ul><li><p>se activa si hay llevada en el nibble LSB del resultado de la última operación</p></li></ul></div></li></ul></div>
<table class="tableblock frame-all grid-all" style="width:100%"><colgroup><col style="width:100%" /></colgroup><tbody><tr><td class="tableblock halign-left valign-top"><div><div class="imageblock" style="text-align: center"><img src="./images/hojas_ref_rap/gdb_posterior.png" alt="gdb 1" width="700" /></div></div></td></tr></table>
<table class="tableblock frame-all grid-all" style="width:100%"><colgroup><col style="width:100%" /></colgroup><tbody><tr><td class="tableblock halign-left valign-top"><div><div class="imageblock" style="text-align: center"><img src="./images/hojas_ref_rap/gdb_anterior.png" alt="gdb 2" width="700" /></div></div></td></tr></table></div></section><section id="_gdb_3"><h2>19.5. GDB</h2><div class="slide-content"><div class="ulist"><ul><li><p>Comandos básicos: ejecutar el comando <code>gdb</code></p><div class="listingblock"><div class="content"><pre>shell date
shell pwd
shell ls
shTAB
shell daTAB
C-x a
C-x o
histórico comandos: navegar con las flechas
set trace-commands on
set logging file gdb_salida.txt
set logging on
shell ls -l gdb_salida.txt
file modulo_bin
info sources
info source
break main
b _start
info breakpoints
info reTAB
run
next , n , n 5
step , s
RETURN
continue, c
start
until, RETURN, RETURN ...
next instruction, ni, RET, RET, RET, RET, until, RET,..hasta salir del bucle
step ,s
si
ptype varible
whatis variable
print variable, p variable, p /t variable, p /x n
p &amp;n
p $rax
p $eax
p $ax
p $ah
p $rflags
p $eflags
p /t $eflags
p $rip
x dirección
x &amp;variable, x /1bw &amp;variable, +x /1xw &amp;variable, x /4xw &amp;variable
pending? n
layout split
h layout
layout src
focus src : navegar
focus cmd : navegar
info registers
info reTAB
disas /r _start
disas /m _start
q</pre></div></div></li></ul></div></div></section></section></div></section>
<section id="_vii_autoevaluación_prácticas"><h2>VII Autoevaluación Prácticas</h2><div class="slide-content"><section><section id="_prácticas_cuestionario"><h2>20. Prácticas: Cuestionario</h2></section><section id="prac_cues"><h2>20.1. Práctica 1ª: Introducción a la Programación en Lenguaje Ensamblador AT&amp;T x86-32</h2><div class="slide-content"><h level="3">Cuestiones teóricas</h><div class="olist arabic"><ol class="arabic"><li><p>Cuál es la principal diferencia entre el lenguaje ensamblador AT&amp;T y el propio de Intel.</p></li><li><p>Qué fases comprende el toolchain</p></li><li><p>Lista las herramientas de desarrollo a utilizar durante la realización de las prácticas mediante los dos procesadores utilizados.</p></li><li><p>Libro: Programming from the Ground-Up</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Qué es GNU/Linux</p></li><li><p>Qué es GNU</p></li><li><p>Qué es gcc</p></li><li><p>Qué gestiona el kernel</p></li><li><p>¿Se puede acceder simultáneamente a  instruccines y datos?¿Por qué?</p></li><li><p>Cuál es la función del registro PC</p></li><li><p>Cuáles son los dos tipos de registros de la CPU</p></li><li><p>Qué significa Word Size</p></li><li><p>Qué es una varible puntero.</p></li><li><p>Lista cuatro modos diferentes de direccionar un operando.</p></li></ol></div></li></ol></div>
<h level="3">Cuestiones prácticas</h><div class="olist arabic"><ol class="arabic"><li><p>Comando de compilación del programa fuente ensamblador mediante el front-end <em>gcc</em> qué incluya la tabla de símbolos para el depurador</p></li><li><p>Comando de enlace (linker) del módulo objeto reubicable.</p></li><li><p>Declaración en lenguaje C de la variable <em>n</em> tipo entero con signo de un byte.</p></li><li><p>Instrucción en lenguaje ensamblador del programa sum1toN.s que realiza una suma.</p></li><li><p>Comandos del depurador gdb para la impresión del contenido de la variable <em>n</em></p></li><li><p>Ejecutar <em>sum1toN</em>, compilado de <em>sum1toN.s</em>, paso a paso mediante el depurador GDB ejecutando los comandos necesarios para:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>imprimir el contenido de la variable n y su dirección en memoria principal</p></li><li><p>imprimir la dirección de la etiqueta bucle</p></li><li><p>imprimir el contenido del <em>registro ECX</em> al salir del bucle</p></li></ol></div></li><li><p>Cambiar el tamaño de los operandos de la suma a 2 bytes</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Cambiar el tamaño del operando n &#8594; <code>n: .word 5</code></p></li></ol></div></li><li><p>Cambiar la instrucción <code>add %edx,%ecx</code> por la instrucción <code>addw %dx,%ec</code></p></li><li><p>En GDB qué comando hay que utilizar para ejecutar todas las iteracciones del bucle del programa de forma continuada.</p></li><li><p>Comparando las versiones en lenguajes C y ASM de los módulos fuente, por qué la instrucción <em>until</em> del depurador GDB en el caso del módulo fuente en lenguaje C se ejecuta durante la sentencia <em>while</em>.</p></li><li><p>Editando el módulo fuente provocar un error de ensamblaje  al no haber coherencia entre  la declaración del tamaño del operando referenciado por la etiqueta <em>n</em> y la declaración de tamaño de operandos de la instrucción <em>add</em>.</p></li></ol></div></div></section><section id="_práctica_2ª_representación_de_los_datos"><h2>20.2. Práctica 2ª: Representación de los Datos</h2><div class="slide-content"><h level="3">Módulo datos_size.s</h><div class="ulist"><ul><li><p>¿En qué orden se guardan los caracteres del string "hola"?</p></li><li><p>¿Cuál es el código ASCII del carácter <em>o</em>?</p></li><li><p>¿Cuál es la dirección de memoria principal donde se almacena el string "hola"?</p></li><li><p>¿Cuál es la dirección memoria principal donde se almacena el array lista?</p><div class="ulist"><ul><li><p>¿Cuál es el contenido de los primeros 4 bytes a partir de la dirección anterior en sentido ascendente?</p></li></ul></div></li></ul></div>
<h level="3">Módulo datos_sufijos.s</h><div class="ulist"><ul><li><p>¿En qué orden se guardan los bytes del dato da4?</p></li><li><p>¿Cuál es el resultado de ejecutar <code>mov  da1,%ecx</code>?</p></li></ul></div>
<h level="3">Módulo datos_direccionamiento.s</h><div class="ulist"><ul><li><p>Con el depurador ejecutar el programa en modo paso a paso realizando las siguientes operaciones.</p></li><li><p>Array <em>da2</em></p><div class="ulist"><ul><li><p>Imprimir la dirección de memoria del array <em>da2</em> y el contenido del primer elemento: <code>x /xh &amp;da2</code></p></li><li><p>4 elementos de 2bytes del array da2: <code>x /4xh &amp;da2</code></p></li><li><p><code>ptype da2</code>: no debug info: al no tener información el debuger del tamaño de los elementos es necesario indicarlos explicitamente en los comandos posteriores.</p><div class="ulist"><ul><li><p>Es necesario realizar un <strong>casting</strong> : Array de 4 elementos de tamaño 2bytes:  <code>p /x (short[4])da2</code></p></li><li><p>Fijarse con el comando <em>eXaminar</em> el resultado es independiente de sí hacemos un <strong>casting</strong> (short *): <code>x /4xh (short *)&amp;da2</code></p><div class="ulist"><ul><li><p>El tamaño y tipo de dato lo fija el argumento del comando: <em>/4xh</em></p></li></ul></div></li></ul></div></li><li><p>Comprobar la norma de almacenamiento <em>little endian</em> identificando cada dirección de memoria a un byte con su contenido.</p></li><li><p>Acceder a la dirección de memoria del elemento de valor -21 del array <em>da2</em>:</p><div class="ulist"><ul><li><p>el argumento elemento de array en <code>p da2[2]</code> no es válido ya que el debugger carece de información</p></li></ul></div></li></ul></div></li><li><p>Desensamblar</p><div class="ulist"><ul><li><p><code>disas salto1</code></p></li><li><p><code>disas /r salto1</code></p></li></ul></div></li></ul></div></div></section><section id="_práctica_3º_operaciones_aritmetico_lógicas_e_instrucciones_de_salto_condicionales"><h2>20.3. Práctica 3º: Operaciones Aritmetico-Lógicas e Instrucciones de Salto Condicionales</h2><div class="slide-content"><h level="3">Módulo op_arit_log.s</h><div class="ulist"><ul><li><p><a href="#practica3:op_arit_log">Módulo fuente op_arit_log</a></p></li><li><p>Indicar cómo asociar el valor de los sumandos a las macros OPE1 y OPE2.</p></li><li><p>Sin cambiar el valor de los operandos:</p><div class="ulist"><ul><li><p>indicar el valor de la resta en la instrucción <strong>1</strong></p></li><li><p>indicar el valor de la multiplicación en la instrucción <strong>2</strong></p></li><li><p>indicar el valor de la división en la instrucción <strong>3</strong></p></li><li><p>indicar el valor de la división en la instrucción <strong>4</strong></p></li><li><p>indicar el valor de las operaciones lógicas en la instrucción <strong>5</strong></p></li></ul></div></li></ul></div>
<h level="3">Módulo saltos.s</h><div class="ulist"><ul><li><p>Registro de Flags</p><div class="ulist"><ul><li><p>Editar, compilar y ejecutar el siguiente bloque de instrucciones para indicar el contenido del registro EAX y el estado de los flags CF,ZF,SF,PF,OF  después de la ejecución de cada instrucción :</p><div class="listingblock"><div class="content"><pre>	mov  $0xFFFFFFFF,%eax
	shr  $1,%eax
	add  %eax,%eax
	testb $0xFF,%eax
        cmpl $0xFFFFFFFF,%eax</pre></div></div></li></ul></div></li><li><p>Saltos</p><div class="ulist"><ul><li><p>Editar, compilar y ejecutar el siguiente bloque de instrucciones para indicar  el estado de los flags CF,ZF,SF,PF,OF antes de la ejecución de la instrucción de salto e indicar si se produce o no el salto.</p><div class="listingblock"><div class="content"><pre>	mov $0x00AA, %ax
	mov $0xFF00, %bx
	cmp %bx,%ax
	ja  salto1
	jg  salto2
salto1: mov $0xFF,%ebx
salto2: mov $1,%eax
	int $0x80</pre></div></div></li></ul></div></li></ul></div></div></section><section id="_práctica_4_llamadas_al_sistema_operativo"><h2>20.4. Práctica 4: LLamadas al Sistema Operativo</h2><div class="slide-content"><h level="3">Módulo syscall_write_puts.c</h><div class="ulist"><ul><li><p>Desarrollar un programa en lenguaje C que  imprima en la pantalla el mensaje de bienvenida "Hola" . Utilizar las funciones puts(), write() y syscall() de la librería standard de C.</p><div class="ulist"><ul><li><p><code>man 2 puts</code></p></li><li><p><code>man 2 write</code> : prototipo de la función</p><div class="listingblock"><div class="content"><pre>WRITE(2)  Linux Programmer's Manual

NAME
       write - write to a file descriptor

SYNOPSIS
       #include &lt;unistd.h&gt;

       ssize_t write(int fd, const void *buf, size_t count);</pre></div></div>
<div class="ulist"><ul><li><p><em>fd</em> : file descriptor: el monitor es un fichero virtual con descriptor número 1.</p></li><li><p><em>void *buf</em>: buffer es un puntero que apunta a la cadena de caracteres a imprimir.</p></li><li><p><em>count</em>: tamaño máximo de la cadena de caracteres a imprimir</p></li><li><p>Esta función llama indirectamente al sistema operativo a través de la llamada syscall().</p><div class="listingblock"><div class="content"><pre>/*
   Programa syscall_write_puts.c
   Descripción: Realiza la llamada al sistema operativo para imprimir en la pantalla
		Realiza la llamada de tres formas diferentes: puts,write,syscall.
   Compilación: gcc -m32 -g -o puts_gets puts_gets.c
*/


// Cabeceras de librerías
#include &lt;stdio.h&gt;  // prototipo de la función puts()
#include &lt;unistd.h&gt; //declaración de las macros STDOUT_FILENO, STDIN_FILENO
#include &lt;syscall.h&gt; //declaración de la función syscall
#include &lt;sys/syscall.h&gt;	// declaración de la macro __NR_write y __NR_exit
#include &lt;stdlib.h&gt;  //declaración de exit()

// Macros
#define LON_BUF  5  // Tamaño del string


void main (void)
{

  char buffer[LON_BUF]="Hola\n";



  puts("\n***************** Práctica : LLAMADAS AL SISTEMA *******************\n"); // función puts() de la librería libc
  puts("\n***************** Imprimo el mensaje de bienvenida mediante la función write(): ");

  write(STDOUT_FILENO, buffer,LON_BUF); // wrapper de la llamada al sistema write.
                                        // ya que write() incluye un syscall(), llama indirectamente al sistema

  puts("\n***************** Imprimo el mensaje de bienvenida mediante la llamada al sistema  syscall(): ");
  syscall(__NR_write,STDOUT_FILENO,buffer,LON_BUF); // función syscall de llamada directa al sistema.
  exit(0xAA); //Salir al sistema envíando el código 0xAA. No es lo mismo que retornar.


}</pre></div></div></li></ul></div></li></ul></div></li></ul></div>
<h level="3">Módulo syscall_write_puts.s</h><div class="ulist"><ul><li><p>Desarrollar un programa en lenguaje ensamblador x86-32 <em>syscall_write_puts.s</em> equivalente al programa <em>syscall_write_puts.c</em> llamando a las funciones puts()  y write() . En lugar de utilizar la función syscall() realizar la llamada al sistema directamente con la instrucción <code>int 0x80</code>. Los argumentos de la llamada al sistema operativo se pasan a través de los registros:</p><div class="ulist"><ul><li><p>1º argumento: a través de EAX: tipo int:  valor <em>__NR_write</em> : valor 4</p></li><li><p>2º argumento: EBX: tipo <em>int fd</em>: valor STDOUT_FILENO: valor 1</p></li><li><p>3º argumento: ECX: tipo <em>const void *buf</em> : puntero al string a imprimir , buffer</p></li><li><p>4º argumento: EDX: tipo <em>size_t count</em>: valor LON_BUF: valor 5</p></li><li><p>Descripción RTL</p><div class="listingblock"><div class="content"><pre># llamada a la función puts de la librería libc. Es necesrio linkar con libc.
pila &lt;-argumento
call puts
# llamada a la función write de la librería libc. Es necesario linkar con libc.
pila &lt;- 3º argumento
pila &lt;- 2º argumento
pila &lt;- 1º argumento
call write
# LLamada al sistema operativo para ejecutar la operación write
EAX&lt;-4
EBX&lt;-1
ECX&lt;-etiqueta que apunta al string a imprimir
EDX&lt;-5
call sistema_operativo
# Llamada al sistema operativo para ejecutar la operación exit
EAX&lt;-1
EBX&lt;-0
call sistema_operativo</pre></div></div></li></ul></div></li></ul></div></div></section><section id="_práctica_5_llamadas_a_una_subrutina"><h2>20.5. Práctica 5: LLamadas a una Subrutina</h2><div class="slide-content"><h level="3">Módulo sumMtoN_aviso.c</h><div class="ulist"><ul><li><p>Desarrollar el programa <em>sumMtoN_aviso.c</em> equivalente al módulo en lenguaje asm <em>sumMtoN.s</em> y añadiendo un mensaje de aviso en caso de error indicando la relación correcta entre los parámetros 1º sumando y 2º sumando.</p></li></ul></div>
<h level="3">Módulo sumMtoN_aviso.s</h><div class="ulist"><ul><li><p>Añadir al programa fuente <em>sumMtoN.s</em> un mensaje de aviso en caso de error indicando la relación correcta entre los parámetros 1º sumando y 2º sumando.</p></li></ul></div></div></section><section id="_práctica_6_imagen_bit_map_portable"><h2>20.6. Práctica 6: Imagen Bit Map Portable</h2><div class="slide-content"><h level="3">Programación en C</h><div class="ulist"><ul><li><p>Leer el procedimiento de programación en el fichero <strong>LEEME.txt</strong></p></li><li><p>El objetivo es modificar la función principal <strong>main()</strong> del programa original <strong>bitmap_gen_test.c</strong> dando lugar a distintos programas independientes entre sí.</p><div class="olist arabic"><ol class="arabic"><li><p>- Compilar y ejecutar el program <em>bitmap_gen_test.c</em></p></li><li><p>-  visualizar la imagen del fichero test.bmp: <strong>$display test.bmp</strong></p></li><li><p>- Módulo <strong>cuadrado_128x128.c</strong> :Cambiar las dimensiones de la imagen a 128 pixeles x 128 pixeles definiendo la macro DIMENSION=128 y definiendo para cada pixel un color gris con una intensidad del 50% de su valor máximo.</p></li><li><p>- Módulo <strong>cuadrados_4.c</strong>: Generar 4 cuadrados, uno dentro de otro simétricamente, donde el cuadrado mayor negro es 512x512 y el resto se reduce 1/8 cada uno. No utilizar ctes en las sentencias de C, utilizar las macros x_coor, y_coor, top para indicar el valor inicial del <strong>for</strong> y la posición máxima (top) de las filas y columnas. Colores de los cuadrados: background (00-00-00)/(FF-00-FF)/(00-FF-FF)/(FF-FF-00)/</p></li><li><p>- Módulo <strong>bmp_funcion.c</strong>: El bloque de código que realiza el bucle para inicializar los pixeles del cuadrado convertirlo en la función:</p><div class="ulist"><ul><li><p>prototipo: <em>void pixels_generator(unsigned int x, unsigned int y, unsigned int maximo, RGB_data reg_mem[][top])</em></p><div class="ulist"><ul><li><p>x e y son el origen de coordenadas del cuadrado</p></li><li><p>maximo es la coordenada mayor del cuadrado</p></li><li><p>llamada a la función: pixels_generator(xcoor,ycoor,top,buffer);</p><div class="ulist"><ul><li><p>los argumentos xcoor=top/8, ycoor=top/8 y top=512 definirlos mediante macros</p></li></ul></div></li></ul></div></li></ul></div></li></ol></div></li></ul></div>
<h level="3">Programación en ASM</h><div class="olist arabic"><ol class="arabic"><li><p>- Módulo <strong>bmp_as.c</strong>: Implementar la función <em>void pixels_generator(unsigned int maximo, RGB_data reg_mem[][top])</em> desarrollando en lenguaje ensamblador la subrutina  <em>pixels_generator</em> en el nuevo fichero <strong>array_pixel.s</strong>. El fichero en lenguaje ensamblador únicamente contendrá la subrutina.</p><div class="ulist"><ul><li><p>La subrutina implementa el doble bucle.</p></li><li><p>De forma implicita en la propia subrutina consideraremos los argumentos x=y=0.</p></li><li><p>Azul, rojo y verde son las intensidades de todos los pixeles del cuadrado.</p></li></ul></div></li></ol></div>
<h level="3">GDB</h><div class="olist arabic"><ol class="arabic"><li><p>En el programa en <strong>bmp_funcion.c</strong> indicar la posición de la pila donde se salva la dirección de retorno de la subrutina <strong>pixels_generator</strong>, así como el contenido del frame pointer y del stack pointer.</p></li><li><p>Lo mismo que en el apartado anterior con el programa <strong>bmp_as.c</strong> para la subrutina <em>pixels_generator</em></p></li></ol></div></div></section></section></div></section>
<section id="_viii_apéndices"><h2>VIII Apéndices</h2><div class="slide-content"><section><section id="_arquitectura_de_una_computadora"><h2>21. Arquitectura de una Computadora</h2></section><section id="estr_comp"><h2>21.1. Estructura de la  Computadora</h2><div class="slide-content"><h level="3">Contexto</h><div class="ulist"><ul><li><p>El significado del término arquitectura en una computadora depende del contexto.</p><div class="ulist"><ul><li><p>La primera gran división sería: Arquitectura Hardware y Arquitectura Software</p></li><li><p>Arquitectura de un computadora: es la organización en grandes bloques como CPU,Memoria,controladores de periféricos,buses, etc</p></li><li><p>Arquitectura de un procesador: Es el repertorio de instrucciones y datos capaz  de interpretar y ejecutar la cpu. Puede haber dos procesadores fabricados con distinta estructura interna pero que procesen las mismas instrucciones y datos ,es decir, que procesen el mismo el lenguaje máquina y por lo tanto tienen la misma arquitectura. En este contexto utilizaremos el termino ISA (Instruction Set Architecture ). La ISA de un procesador AMD64 y un procesador Intel x86-64 es la misma, operan con el mismo lenguaje máquina. Un programa binario en AMD64 es compatible con Intel x86-64.</p></li><li><p>Microarquitectura de un microprocesador: es la organización interna de un procesador.</p></li></ul></div></li></ul></div>
<h level="3">Arquitectura HW</h><div class="listingblock"><div class="content"><pre>+-------------+             +------------+
|             |             |            |
|             |  ADDRESS    |            |
|             +------------&gt;+            |
|             |    Bus      |            |
|             |             |            |
|             |             |            |
|             |             |            |
|             |             |            |
|             |   DATA      |            |
|  C P U      +&lt;-----------&gt;+   MEMORIA  |
|             |   Bus       |            |
|             |             |            |
|             |             |            |
|             |             |            |
|             |             |            |
|             |   R/W       |            |
|             +------------&gt;+            |
|             |   Bus       |            |
|             |             |            |
|             |             |            |
+-------------+             +------------+</pre></div></div>
<h level="3">CPU</h><div class="ulist"><ul><li><p>Componentes básicos de la CPU</p><div class="ulist"><ul><li><p>ALU</p></li><li><p>FPU</p></li><li><p>Unidad de Control</p></li><li><p>Registros internos</p></li></ul></div></li><li><p>Función de la CPU</p><div class="ulist"><ul><li><p>Llevar a cabo el ciclo de instrucción de las instrucciones almacenadas en la memoria principal</p></li></ul></div></li></ul></div>
<div class="listingblock"><div class="content"><pre>            Central Processor Unit (CPU)	                                  Memoria Externa RAM
+----------------------------------------------------+		               +----------------------+
|						     |                         |                      |
|						     |			       +----------------------+
|                +--------------+		     |			       |		      |
|                | Resultado    |		     |    BUS Direcciones      +----------------------+
|                +--------------+		     o------------------------&gt;|		      |
|                      ^			     |      64 líneas          +----------------------+
|                      |			     |			       |                      |
|          /------------------------		     |			       +----------------------+
|         /                         \		     |			       |		      |
|        /	      ALU            \		     |			       +----------------------+
|       /	        X             \		     |			       |		      |
|      /               / \             \	     |			       +----------------------+
|     /	              /   \             \	     |			       |                      |
|    ----------------/     \-------------\	     |			       +----------------------+
|            ^                    ^		     |			       |		      |
|            |                    |		     |			       +----------------------+
|    +--------------+      +--------------+	     |			       |		      |
|    | Operando_1   |      | Operando_2   |	     |   BUS Read/Write	       +----------------------+
|    +--------------+      +--------------+	     o------------------------&gt;|                      |
|						     |                         +----------------------+
|              +--------------+			     |			       |		      |
|              | Registro A   |			     |			       +----------------------+
|              +--------------+			     |			       |		      |
|              | Registro B   |			     |			       +----------------------+
|              +--------------+			     |			       |                      |
|              | Registro     |			     |			       +----------------------+
|              +--------------+			     |			       |		      |
|              | Registro     |			     |			       +----------------------+
|              +--------------+			     |			       |		      |
|              | Registro     |			     |			       +----------------------+
|              +--------------+			     |			       |                      |
|              | Registro Z   |			     |			       +----------------------+
|              +--------------+			     |			       |&lt;-----  1 Byte ------&gt;|
|             Banco de Registros		     |			       +----------------------+
|              Memoria Interna			     |			       |		      |
|						     |			       +----------------------+
|						     |			       |                      |
+----------------------------------------------------+                         +----------------------+
                      ^                                                                   ^
                      |                          BUS Datos                                |
                      +-------------------------------------------------------------------+
                                                 64 líneas</pre></div></div>
<div class="imageblock" style="text-align: center"><img src="./images/von_neumann/ias_structure.png" alt="ias structure" /></div><div class="title">Figure 94. IAS Structure</div>
<h level="3">Memoria</h><div class="ulist"><ul><li><p>Jerarquía de Memoria: Registros internos a la CPU y Memoria principal (DRAM) externa a la CPU</p></li></ul></div>
<h level="4">Memoria Principal</h><div class="ulist"><ul><li><p>Memoria DRAM: Dynamic Random Access Memory</p></li><li><p>Almacena la secuencia de instrucciones máquina binarias y los datos en formato binario.</p></li><li><p>Espacio de direcciones lineal: Notación hexacecimal</p></li><li><p>Direccionamiento: bytes : notación hexadecimal</p></li></ul></div>
<div class="listingblock"><div class="content"><pre>DIRECCIONES         CONTENIDO

              +----------------------+
0x00000000    |    1 0 1 0 1 0 1 0   |
              +----------------------+
0x00000001    |    1 0 1 0 1 0 1 0   |
              +----------------------+
0x00000002    |    1 0 1 0 1 0 1 0   |
              +----------------------+
              |    1 1 1 1 1 1 1 1   |
              +----------------------+
              |                      |
              +----------------------+
              |                      |
              +----------------------+
              |                      |
              +----------------------+
0x00000009    |                      |
              +----------------------+
0x0000000a    |                      |
              +----------------------+
              |                      |
              +----------------------+
              |                      |
              +----------------------+
              |                      |
              +----------------------+
              |                      |
              +----------------------+
0x0000000f    |                      |
              +----------------------+</pre></div></div>
<h level="4">Registros internos a la CPU</h>
<h level="4">Registros NO visibles al programador</h><div class="ulist"><ul><li><p>Registos NO accesibles por el programador en la arquitectura amd64</p><div class="ulist"><ul><li><p>PC: Contador del Programa : x86 lo denomina RIP: 64 bits</p></li><li><p>IR: Registro de instrucción : 64 bits</p></li><li><p>MBR: Registro buffer de Memoria : 64 bits &#8594; WORD SIZE : 64</p></li><li><p>MAR: Registro de direcciones de Memoria: 40 bits</p><div class="ulist"><ul><li><p>Capacidad de Memoria: 2<sup>40</sup> : 1TB</p></li></ul></div></li></ul></div></li><li><p>Para el caso de la arquitectura i386 sustituir 64 bits por 32 bits y el registro MAR también es de 32 bits.</p></li></ul></div>
<h level="4">Registros visibles al programador</h><div class="ulist"><ul><li><p>El programador utiliza dichos registros para almacenar datos (escribir y leer).</p></li><li><p>Hay operaciones (suma,resta, etc&#8230;&#8203;) donde los operandos pueden estar en los registros.</p></li><li><p>El acceso de la CPU a un registro es mucho más RAPIDO que el acceso a una posición de la memoria principal RAM.</p></li></ul></div>
<div class="imageblock" style="text-align: center"><img src="./images/von_neumann/ias_architecture.png" alt="ias architecture" /></div><div class="title">Figure 95. IAS_Architecture</div></div></section><section id="_instruction_set_architecture_isa"><h2>21.2. Instruction Set Architecture (ISA)</h2><div class="slide-content"><div class="ulist"><ul><li><p>La arquitectura del repertorio de instrucciones (<strong>ISA</strong>: instruction set architecture) de una computadora comprende definir principalmente:</p><div class="ulist"><ul><li><p>Estructura de la Computadora: CPU-Memoria-Bus-I/O</p></li><li><p>La representación y formato de los datos .</p></li><li><p>La representación y formato de las instrucciones.</p></li><li><p>Repertorio de instrucciones: Las operaciones y modos de direccionamiento que ha de interpretar y ejecutar la computadora.</p></li></ul></div></li><li><p>La arquitectura ISA define la potencialidad de la CPU de la computadora.</p></li><li><p>El diseño de la arquitectura ISA va a afectar al rendimiento de la computadora.</p><div class="ulist"><ul><li><p>Programa binario resultado de la compilación del programa fuente.</p></li><li><p>Ocupación de Memoria</p></li><li><p>Implementación (dificultad) y rendimiento de la CPU.</p></li></ul></div></li></ul></div>
<div class="listingblock"><div class="content"><pre>digraph G {
 ISA -&gt; "Estructura de la Computadora";
 ISA -&gt; "Formatos";
 ISA -&gt; "Repertorio de instrucciones";
 "Estructura de la Computadora" -&gt; CPU;
 "Estructura de la Computadora" -&gt; Memoria;
 "Estructura de la Computadora" -&gt; "I/O";
 "Estructura de la Computadora" -&gt; Bus;
 Memoria -&gt; Jerarquía ;
 Jerarquía -&gt; "Memoria Principal";
 "Memoria Principal" -&gt; "Espacio Lineal"
 "Memoria Principal" -&gt; "Bus direcciones 12 bits"
 Jerarquía -&gt; Registros;
 Registros -&gt; "Accesibles AC,AR"
 Registros -&gt; "No Accesibles: PC,IBR,IR,MBR,MAR"
 "Formatos" -&gt; Instrucciones;
 "Instrucciones" -&gt; "Código Operaciones"
 "Instrucciones" -&gt; "Ref Operando Fuente" -&gt; "Dirección Absoluta"
 "Formatos" -&gt; "Datos";
  "Datos" -&gt; "Enteros Complemento a 2";
 "Repertorio de instrucciones" -&gt; Operaciones;
 "Operaciones" -&gt; "Transferencia-Aritmética-Lógica-SaltoCondicional"
 "Repertorio de instrucciones" -&gt; "Modos de Direccionamiento";
 "Modos de Direccionamiento" -&gt; "Dirección Absoluta";
}</pre></div></div>
<h level="3">Ejemplos: Intel x86, Motorola 68000, MIPS, ARM</h><div class="ulist"><ul><li><p>Ver <a href="#leng_asm">Apéndice Lenguajes Ensamblador</a></p></li></ul></div></div></section><section id="_procesadores_intel_con_arquitectura_x86"><h2>21.3. Procesadores Intel con arquitectura x86</h2><div class="slide-content"><h level="3">Nomenclatura</h><h level="4">General</h><div class="ulist"><ul><li><p>Los procesadores intel reciben nombres por todos conocidos: Pentium II, Pentium III, Corei3, Corei5, Corei7, etc</p></li><li><p>La arquitectura de las computadoras que utilizan dichos procesadores responden a una arquitectura común</p><div class="ulist"><ul><li><p>Arquitectura x86 en el caso de la arquitectura de 32 bits</p></li><li><p>Arquitectura x86-64 en el caso de la arquitectura de 64 bits.</p></li></ul></div></li><li><p>Procesadores con arquitectura x86 de 32 bits</p><div class="listingblock"><div class="content"><pre>*** 1978 y 1979 Intel 8086 y 8088. Primeros microprocesadores de la arquitectura x86.
    1980 Intel 8087. Primer coprocesador numérico de la arquitectura x86, inicio de la serie x87.
    1980 NEC V20 y V30. Clones de procesadores 8088 y 8086, respectivamente, fabricados por NEC.
    1982 Intel 80186 y 80188. Mejoras del 8086 y 8088.
    1982 Intel 80286. Aparece el modo protegido, tiene capacidad para multitarea.
*** 1985 Intel 80386. Primer microprocesador x86 de 32 bits.
    1989 Intel 80486. Incorpora el coprocesador numérico en el propio circuito integrado.
    1993 Intel Pentium. Mejor desempeño, arquitectura superescalar.
    1995 Pentium Pro. Ejecución fuera de orden y Ejecución especulativa
    1996 Amd k5. Rival directo del Intel Pentium.
    1997 Intel Pentium II. Mejora la velocidad en código de 16 Bits, incorpora MMX
    1998 AMD K6-2. Competidor directo del Intel Pentium II, introducción de 3DNow!
    1999 Intel Pentium III. Introducción de las instrucciones SSE
    2000 Intel Pentium 4. NetBurst. Mejora en las instrucciones SSE
    2005 Intel Pentium D. EM64T. Bit NX, Intel Viiv</pre></div></div></li><li><p>Procesadores con arquitectura x86-64 de 64 bits</p><div class="listingblock"><div class="content"><pre>*** 2003 AMD Opteron. Primer microprocesador x86 de 64 bits, con el conjunto de instrucciones AMD64)
    2003 AMD Athlon.
    2006 Intel Core 2. Introducción de microarquitectura Intel P8. Menor consumo, múltiples núcleos, soporte de virtualización en     hardware    incluyendo x86-64 y SSSE3.
    2008 Core i7
    2009 Core i5
    2010 Core i3</pre></div></div></li><li><p><a href="https://computerhoy.com/noticias/hardware/que-significan-numeros-letras-procesadores-intel-56812">significado del código de los nombres de procesadores intel serie Core</a>: El primer dígito del código indica la generación (en el 2017 salió la 8ª generación)</p></li><li><p>Intel Serie Core:</p><div class="ulist"><ul><li><p><a href="https://www.intel.com/content/www/us/en/products/processors/core/view-all.html" class="bare">https://www.intel.com/content/www/us/en/products/processors/core/view-all.html</a></p></li></ul></div></li><li><p>Intel Serie Core X : familias i9, i7 ,i5</p><div class="ulist"><ul><li><p><a href="https://www.intel.com/content/www/us/en/products/processors/core/x-series.html">Intel Serie X</a>:</p></li><li><p><a href="https://ark.intel.com/products/series/123588/Intel-Core-X-series-Processors" class="bare">https://ark.intel.com/products/series/123588/Intel-Core-X-series-Processors</a></p></li></ul></div></li><li><p><a href="https://es.wikipedia.org/wiki/Anexo:Procesadores_AMD" class="bare">https://es.wikipedia.org/wiki/Anexo:Procesadores_AMD</a></p></li><li><p>COMPETENCIA INTEL-AMD año 2018 en computadoras de sobremesa.</p><div class="ulist"><ul><li><p><a href="https://www.techradar.com/news/intel-coffee-lake-release-date-news-and-rumors">AMD Ryzen 2nd Generation - INTEL Core i7-8086K</a></p></li></ul></div></li></ul></div></div></section></section>
<section><section id="_rtl_register_transfer_language"><h2>22. RTL Register Transfer Language</h2></section><section id="RTL_lang"><h2>22.1. Lenguaje RTL</h2><div class="slide-content"><h level="3">Introducción</h><div class="ulist"><ul><li><p>Lenguaje de descripción de INSTRUCCIONES: Register Transfer Language (RTL)</p></li><li><p>El lenguaje RTL tiene como objetivo poder expresar las instrucciones que ejecuta la CPU como sumar(ADD),restar(SUB),mover(MOV), etc. La descripción se realiza a nivel de transferencia de datos entre <em>registros</em> internos de la CPU o entre registros internos y la memoria externa.</p></li><li><p>El lenguaje RTL , mediante símbolos interpretables por el programador, permite describir su comportamiento a nivel hardware y así definir el diseño de la arquitectura de una máquina.</p></li><li><p>Los <em>registros</em> son el elemento fundamental de memoria en la ruta de los datos e instrucciones entre las distintas unidades básicas de la computadora. Un registro es un circuito digital que almacena, memoriza, un dato.</p></li><li><p>La ruta de los datos está formada por los buses y los elementos (<em>registros</em>, multiplexores, switches, contadores, etc ) que se conectan a través de los buses</p><div class="ulist"><ul><li><p>Ejemplo: ruta de un dato desde una posición de la memoria principal hacia los registros de operando de la ALU.</p></li><li><p>Concepto de buffer: etapa intermedia de memoria en la ruta de los datos.</p></li></ul></div></li><li><p>La ejecución de las instrucciones que ejecuta la CPU implica la transferencia de datos a través de los registros de la ruta de datos.</p></li></ul></div>
<div class="admonitionblock caution"><table><tr><td class="icon"><i class="fa fa-fire" title="Caution"></i></td><td class="content">No confundir el RTL (Register Transfer Language) con el RTL (Register Transfer Level). El Register Transfer Level es utilizado por los lenguajes de descripción de HARDWARE (Hardware Description Language HDL)</td></tr></table></div>
<h level="3">Registros</h><h level="4">Arquitectura</h><div class="ulist"><ul><li><p>La arquitectura de un registro comprende su funcionalidad y la estructura su implementación</p></li><li><p>Los registros:</p><div class="ulist"><ul><li><p><em>almacenan</em> una palabra formada por una secuencia de bits.</p></li><li><p>son una array de celdas en una dimensión, donde cada celda almacena un bit.</p></li></ul></div></li><li><p>Su tamaño normalmente es un múltiplo de 8 bytes y recibe un nombre.</p><div class="ulist"><ul><li><p>8 bits: 1 Byte</p></li><li><p>16 bits: Word. Por razones históricas.(recordad que el tamaño de una palabra en otro contexto depende de la máquina de que se trate)</p></li><li><p>32 bits: double word</p></li><li><p>64 bits: quad word</p></li></ul></div></li><li><p>Las celdas se enumeran empezando por cero.</p><div class="ulist"><ul><li><p>LSB: Least Significant Bit es el bit de menor peso</p></li><li><p>MSB: Most Significant Bit es el bit de mayor peso</p><div class="listingblock"><div class="content"><pre>+---+---+---+---+---+---+---+---+
| 7 |   |   |   |   |   |   | 0 |
+---+---+---+---+---+---+---+---+
 MSB                         LSB

+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 15|   |   |   |   |   |   |   |   |   |   |   |   |   |   | 0 |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
 MSB                                                         LSB


+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 1 | 0 | 1 | 0 | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 0 | 1 | 1 | 1 | 0 |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
 MSB                                                         LSB</pre></div></div></li></ul></div></li></ul></div>
<h level="4">Estructura</h><div class="ulist"><ul><li><p>La  estructura del registro es la implementación de su funcionalidad</p></li><li><p>Cada bit del dato a registrar se almacena en una celda con capacidad de memoria. Las celdas de un registro se implementan con un circuito digital denominado flip-flop. Cada flip-flop almacena un bit.</p></li></ul></div>
<div class="listingblock"><div class="content"><pre>       Chip Select (CS)
             |
             v
          +-----+
          |     |
          |     |
          |     |
          |     |
          |     |
          |     |
   Input  |     | Output
  +--/--&gt; |  R0 | ---/--&gt;
    16    |     |   16
          |     |
          |     |
          |     |
          |     |
          |     |
          |     |
          +-----+
            ^  ^
            |  |
         Load  Clock</pre></div></div>
<div class="ulist"><ul><li><p>El registro está conectado al mundo exterior mediante buses: bus de entrada y bus de salida</p></li><li><p>CS: Chip Select : conecta la salida interna del registro R0 al bus de salida &#8594; Operación de lectura del registro</p></li><li><p>Load: Si la señal está activa se ordena la carga del valor del bus de entrada en el registro R0, se registra el dato de entrada. Operación de escritura en el registro.</p></li><li><p>Clock: señal digital binaria periódica.</p></li><li><p>La carga es síncrona con la señal de reloj clock CLK. El sincronismo se produce en los flancos positivos <em>_\|</em>  o negativos</p><div class="listingblock"><div class="content"><pre>          T = 1/f
&lt;--------------------&gt;

               +-----+               +-----+               +-----+               +-----+
               |     |               |     |               |     |               |     |
               |     |               |     |               |     |               |     |
               |     |               |     |               |     |               |     |
               |     v               |     v               |     v               |     v
               |     |               |     |               |     |               |     |
               |     |               |     |               |     |               |     |
               |     |               |     |               |     |               |     |
+--------------+     +---------------+     +---------------+     +---------------+     +

Señal de reloj, clock.</pre></div></div></li></ul></div>
<h level="3">Símbolos</h><div class="ulist"><ul><li><p>Los nombres de los registros se expresan mediante mayúsculas</p><div class="ulist"><ul><li><p>PC: Program Counter</p></li><li><p>IR: Instruction Regiter</p></li><li><p>R2: Registro 2</p></li></ul></div></li><li><p>Secciones de un registro</p><div class="ulist"><ul><li><p>PC(L) : Byte de menor peso del registro contador de programa</p></li><li><p>PC(H) : Byte de mayor peso del registro contador de programa</p></li><li><p>PC(7:0): Secuencia de bits de la posición cero hasta la posición séptima del registro contador de programa.</p></li></ul></div></li></ul></div>
<h level="3">Sentencias RTL</h><h level="4">Operaciones y Sentencias RTL</h><div class="ulist"><ul><li><p>En lenguaje RTL entendemos por sentencia una expresión que implica realizar operaciones con los registros.</p></li><li><p>Operaciones RTL:</p><div class="ulist"><ul><li><p>transferencias entre registros, suma del contenido de dos registros, invertir el contenido de un registro, etc</p></li></ul></div></li></ul></div>
<h level="4">Microoperación</h><div class="ulist"><ul><li><p>MICROoperaciones: operaciones realizadas por el MICROprocesador internamente, al ejecutar una Instrucción Máquina.</p><div class="ulist"><ul><li><p>Ejemplos: escribir en un registro, orden de lectura a la M.Principal, leer de un registro, Decodificar una instrucción, incrementar un contador, sumar (microordenes al circuito sumador), desplazamiento de los bits de un registro, lógica AND,  etc&#8230;&#8203;</p></li></ul></div></li><li><p>La operación de escribir en un registro o leer en un registro para la CPU es una microoperación.</p></li></ul></div>
<h level="4">Transferencia entre registros</h><div class="ulist"><ul><li><p>Operador transferencia &#8592;</p></li><li><p>Sentencia transferencia: R2&#8592;R1</p><div class="ulist"><ul><li><p>A R1 se le llama registro fuente y a R2 registro destino</p></li><li><p>Copiamos el contenido del registro R1 en el registro R2</p></li></ul></div></li></ul></div>
<h level="4">Sentencia Condicional</h><div class="ulist"><ul><li><p>If (K1=1) then R2&#8592;R1</p><div class="ulist"><ul><li><p>K1:R2&#8592;R1</p></li><li><p>La transferencia o copia se realiza únicamente si K1 es verdad es decir K1 vale el valor lógico 1.</p></li></ul></div></li></ul></div>
<h level="4">Sentencia Concurrente</h><div class="ulist"><ul><li><p>Operador coma</p></li><li><p>K3:R2&#8592;R1,R3&#8592;R1</p><div class="ulist"><ul><li><p>Si K3 es verdad el contenido de R1 se copia en R2 y R3</p></li></ul></div></li></ul></div>
<h level="4">Referencia a la Memoria Principal</h><div class="ulist"><ul><li><p>Se utilizan los corchetes y el símbolo M.</p></li><li><p>M[0x80000] : contenido de la posición de memoria 0x8000</p></li><li><p>AC &#8592; M[0x80000] : copiar  el contenido de memoria de la posición 0x8000 al registro AC</p></li><li><p>AC &#8592; M[AC] : copiar el contenido de la posición de memoria a la que <strong>apunta</strong> el registro AC en el registro AC</p></li><li><p>M[0x8000] &#8592; AC: copiar el contenido del registro AC en la posición de Memoria 0x8000</p><div class="ulist"><ul><li><p>M[0x8000] &#8592; R[AC]: copiar el contenido del registro AC en la posición de Memoria 0x8000</p></li></ul></div></li></ul></div>
<h level="4">Left-Right Value</h><div class="ulist"><ul><li><p>Este concepto se utiliza en el lenguaje C al definir la sentencia asignación <em>=</em></p></li><li><p>M[0x1000] &#8592; M[0x2000]</p><div class="ulist"><ul><li><p>El contenido de la posición 0x2000 se copia en la posición 0x1000</p></li><li><p>Lo que hay a la derecha del operador &#8592; se evalua y se obtiene un VALOR</p></li><li><p>Lo que hay a la izda del operador &#8592; es una DIRECCION o REFERENCIA a Memoria (Principal o Registro)</p></li></ul></div></li></ul></div>
<h level="3">Ejemplos RTL con expresiones aritmetico-lógicas</h><div class="ulist"><ul><li><p>AC &#8592; R1 v R2</p><div class="ulist"><ul><li><p>Operación lógica OR</p></li></ul></div></li><li><p>(K1+K2):R1 &#8592; R2+R3,R4&#8592;R5^R6</p><div class="ulist"><ul><li><p>El símbolo <em>+</em> tiene dos significados: booleano o aritmético.</p><div class="ulist"><ul><li><p>En k1+k2 tiene significado booleano: or. Aquí no tiene sentido la suma aritmética de señales lógicas. Tiene sentido evaluar si la señales están activas o no.</p></li><li><p>En R2+R3 tiene significado aritmético.</p></li></ul></div></li></ul></div></li><li><p>Para indicar prioridad en una expresión utilizaremos los paréntesis.</p></li></ul></div></div></section></section>
<section><section id="_programas_ensamblador_iassim"><h2>23. Programas ensamblador IASSim</h2></section><section id="iassim_ejemplos"><h2>23.1. Ejemplo 1: sum1toN.ias</h2><div class="slide-content"><div class="ulist"><ul><li><p><strong>Versión Demo</strong> <em>tutorial.ias</em>: la versión demo que se incluye en el archivo de descarga del simulador.</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-sh" data-lang="sh">loop:   S(x)-&gt;Ac+  n    ;load n into AC
        Cc-&gt;S(x)   pos  ;if AC &gt;= 0, jump to pos
        halt            ;otherwise done
        .empty          ;a 20-bit 0
pos:    S(x)-&gt;Ah+  sum  ;add n to the sum
        At-&gt;S(x)   sum  ;put total back at sum
        S(x)-&gt;Ac+  n    ;load n into AC
        S(x)-&gt;Ah-  one  ;decrement n
        At-&gt;S(x)   n    ;store decremented n
        Cu-&gt;S(x)   loop ;go back and do it again
n:     .data 5  ;will loop 6 times total
one:   .data 1  ;constant for decrementing n
sum:   .data 0  ;where the running/final total is kept</code></pre></div></div></li><li><p>Ejemplo con la <strong>Versión Demo</strong>  <em>tutorial.ias</em>:</p><div class="ulist"><ul><li><p>cambiar el nombre del módulo fuente: <em>sum1toN.ias</em></p></li><li><p>reeditar el programa con etiquetas y comentarios en castellano.</p></li><li><p>comentar el código con la información de los módulos descritos en las fases previas del desarrollo del programa</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-sh" data-lang="sh">;;;;;;;;;;;;;; CABECERA
; Modulo fuente sum1toN.ias
; Calcula la suma de una secuencia de numeros enteros: suma = 1+2+..+n
; dato de entrada : N y dato de salida : suma
; Algoritmo : bucle de N iteraciones
;             Los sumandos se van generando en sentido descendente de n a -1
;             Si el sumando es negativo -&gt; -1 , no se realiza la suma y finaliza el bucle
; Estructuras de datos : variables n y suma . Constante uno.
; Lenguaje ensamblador: IASSim
; ISA: Arquitectura de la maquina IAS de Von Neumann

;;;;;;;;;;;;;;;; SECCION DE INSTRUCCIONES
;Arquitectura orientada a Acumulador (AC)
;Registros accesibles : AC
; algoritmo: Bucle que genera los sumandos n, n-1, .... -1
;	     y realiza la operación suma = n + suma si n&gt;=0

; inicio bucle : suma y generacion de sumandos
bucle:  S(x)-&gt;Ac+  n    	;cargar sumando
        Cc-&gt;S(x)   sumar  	;si el sumando &lt; 0 fin del bucle
	; fin del bucle
        halt            	; stop
        .empty          	;a 20-bit 0 para que el nº de instrucciones sea par.
	; realizar la suma
sumar:  S(x)-&gt;Ah+  sum  ;
        At-&gt;S(x)   sum  ;
	; actualizar sumando
        S(x)-&gt;Ac+  n    ;
        S(x)-&gt;Ah-  uno  ;
        At-&gt;S(x)   n    ;
        ; siguiente iteracion
	Cu-&gt;S(x)   bucle ;

;;;;;;;;;;;;;;;;;;;SECCION DE DATOS
; Declaracion de etiquetas, reserva de memoria externa, inicializacion.
; Variables ordinarias
n:     .data 5  ; sumando e inicializacion
sum:   .data 0  ; suma parcial y final
; constantes
uno:   .data 1  ;</code></pre></div></div></li></ul></div></li></ul></div>
<h level="3">Ejemplo 2: Producto/Cociente</h><h level="4">Enunciado</h><div class="ulist"><ul><li><p>Desarrollar el programa que realice la operación \(N(N+1)/2\) equivalente a obtener el resultado de la suma del Tutorial1 \(\sum_{i=1}^{N}i=N(N+1)/2\).</p><div class="ulist"><ul><li><p>Pseudocódigo del algoritmo</p></li><li><p>Organigrama del algoritmo</p></li><li><p>Programa en lenguaje RTL&#8594; Comentar apropiadamente el programa (cabecera con metainformación,secciones estructurales,bloques funcionales).</p></li><li><p>Programa en lenguaje Ensamblador</p></li><li><p>Ejecutar el programa paso a paso analizando el valor de los registros al ejecutar la multiplicación y la división.</p></li></ul></div></li><li><p>A TENER EN CUENTA en la descripción RTL:</p><div class="ulist"><ul><li><p>El producto de dos números de M dígitos da como resultado un número de 2M dígitos, es decir, el doble que los multiplicandos. Esto dificulta las operaciones aritméticas posteriores a la multiplación en la expresión matemática. Por ello dejaremos la operación multiplicación para el final dando prioridad a la suma y a la división</p><div class="ulist"><ul><li><p>\(N(N+1)/2 = ((N+1)/2) * N \)</p></li></ul></div></li><li><p>La división de un  número entero por 2 puede tener resto 1 ó 0 dependiendo de si el dividendo es par o impar</p><div class="ulist"><ul><li><p>Si N es impar &#8594; (N+1)/2 tiene el resto 0 &#8594;  \(((N+1)/2) * N \) donde N+1 es par</p></li><li><p>Si N es par   &#8594; (N+1)/2 tiene el resto 1 &#8594; (N+1) = Cociente*2+Resto &#8594; \(N(N+1)/2 = N*C+N/2\) donde N es par</p></li></ul></div></li><li><p>La división por una potencia de 2 como 2<sup>1</sup> se realiza mediante una operación lógica: desplazar 1  bit a la izda el dividendo. El número de bits a desplazar es el valor del exponente.</p><div class="ulist"><ul><li><p>descripción RTL  <strong>AC &#8592; AC&lt;&lt;1</strong></p></li></ul></div></li></ul></div></li></ul></div>
<h level="4">Pseudocódigo</h><div class="ulist"><ul><li><p>Descripción del algoritmo mediante expresiones modo texto en lenguaje NATURAL</p></li><li><p>VARIABLES:</p><div class="ulist"><ul><li><p>variable suma : almacena los resultados parciales y final</p></li><li><p>variable N    : almacena el dato de entrada</p></li></ul></div></li><li><p>Estructura del CODIGO imperativo:</p><div class="ulist"><ul><li><p>La construcción de instrucciones básica es una asignación</p><div class="ulist"><ul><li><p>\(suma = N(N+1)/2 \)</p></li></ul></div></li></ul></div></li></ul></div>
<h level="4">Organigramas: Alto Nivel y RTL</h><div class="ulist"><ul><li><p>Descripción gráfica del algoritmo:</p><div class="ulist"><ul><li><p>Alto Nivel: lenguaje natural imperativo</p></li><li><p>RTL: lenguaje de bajo nivel que tiene en cuenta la ISA de la computadora</p><div class="imageblock text-center"><img src="./images/von_neumann/nn1_orga.png" alt="Diagrama de Flujo: Alto Nivel y RTL" /></div><div class="title">Figure 96. Diagrama de Flujo: Pseudocódigo y RTL</div></li></ul></div></li></ul></div>
<h level="4">Lenguaje Ensamblador IAS</h><div class="ulist"><ul><li><p>versión sum1toN_mul_A.ias</p><div class="listingblock"><div class="content"><pre>; Suma de los primeros N numeros enteros. Y=N(N+1)/2
; CPU IAS
; lenguaje ensamblador: simaulador IASSim
; Ejercicio 2.1 del libro de William Stalling, Estructura de Computadores

; SECCION DE INSTRUCCIONES
; ¿Es N par? -&gt; Resto de N/2
S(x)-&gt;Ac+ n    ;01 n   ;AC    &lt;- M[n]
.
.
; Caso 1º: N par
.
.
; Caso 2º: N impar
.
.
; Multiplicación N(N+1)/2
.
.
; SECCION DE DATOS
; Declaracion e inicializacion de variables
y:     .data 0  ;resultado

; Declaracion de las Constantes
n:    .data 5   ;parametro N
uno:  .data 1
dos:  .data 2</pre></div></div></li><li><p>versión simplificada sum1toM_mul.ias: realizo primero la multiplicación N(N+1) y el resultado siempre es par. A continuación divido por 2.</p><div class="listingblock"><div class="content"><pre>; Suma de los primeros N numeros enteros. Y=N(N+1)/2
; CPU IAS
; lenguaje ensamblador: simaulador IASSim
; Ejercicio 2.1 del libro de William Stalling, Estructura de Computadores

; SECCION DE INSTRUCCIONES
S(x)-&gt;Ac+ n    ;01 n   ;AC    &lt;- M[n]
S(x)-&gt;Ah+ uno  ;05 uno ;AC    &lt;- AC+1
At-&gt;S(x) y     ;11 y   ;M[y]  &lt;- AC
S(x)-&gt;R y      ;09 y   ;AR    &lt;- M[y]
S(x)*R-&gt;A n    ;0B n   ;AC:AR &lt;- AR*M[n]
; Caso particular donde AC=0
R-&gt;A           ;0A     ;AC    &lt;- AR
A/S(x)-&gt;R dos  ;0C 2   ;AR    &lt;- AC/2
;Al ser par el dividendo el resto es cero
R-&gt;A           ;0A     ;AC    &lt;- AR
At-&gt;S(x) y     ;11 y   ;M[y]  &lt;- AC
halt
; como el numero de instrucciones  es par no es necesaria la directiva .empty


; SECCION DE DATOS
; Declaracion e inicializacion de variables
y:     .data 0  ;resultado

; Declaracion de las Constantes
n:    .data 5   ;parametro N
uno:  .data 1
dos:  .data 2</pre></div></div></li></ul></div>
<h level="4">simulación</h><div class="ulist"><ul><li><p>simulación con el emulador IASsim</p></li></ul></div>
<h level="3">Ejemplo 3: Vectores</h><h level="4">Enunciado</h><div class="ulist"><ul><li><p>Realizar la suma <em>C = A + B</em> de dos vectores A y B de 10 elementos cada uno inicializados ambos con los valores del 1 al 10.</p></li></ul></div>
<div class="admonitionblock note"><table><tr><td class="icon"><i class="fa fa-info-circle" title="Note"></i></td><td class="content">Para acceder a cada elemento de un vector es necesario ir incrementando la dirección absoluta de memoria del operando en la instrucción que accede a los elementos del vector, por lo tanto, es necesario modificar el campo de operando de la instrucción. Hay una instrucción de transferencia de los 12 bits del campo de operando a los 12 bits de menor peso del registro AC , es decir,
AC(28:39) &#8592; M[operando](8:19) . Y otra instrucción que realiza la transferencia inversa M[operando (8:19)] &#8592; AC(28:39).
De esta manera se pueden realizar operaciones de aritméticas y lógicas sobre los 12 bits del campo de operando de una instrucción.</td></tr></table></div>
<div class="ulist"><ul><li><p>Pseudocódigo del algoritmo</p></li><li><p>Organigrama del algoritmo</p></li><li><p>Programa en lenguaje RTL &#8594; Comentar apropiadamente el programa (cabecera con metainformación,secciones estructurales,bloques funcionales).</p></li><li><p>Programa en lenguaje Ensamblador: Se aconseja no realizar el programa directamente en su totalidad sino por fases, comenzando por una versión sencilla e ir avanzando hasta completar el programa en la versión final. Por ejemplo:</p><div class="ulist"><ul><li><p>1ª versión : Inicializar el vector A[i]=i</p></li><li><p>2ª versión : Inicializar los vectores A[i]=i, B[i]=i, C[i]=i</p></li><li><p>3ª versión : C[i]=A[i]+B[i]</p></li><li><p>Posibles variables : len:longitud del vector, A0: dirección del primer elemento del Vector A, i: índice del vector, etc.</p></li></ul></div></li><li><p>Ejecutar el programa paso a paso depurando las distintas versiones del programa.</p></li></ul></div>
<h level="4">Pseudocódigo</h><div class="ulist"><ul><li><p>Descripción del algoritmo mediante expresiones modo texto en lenguaje NATURAL</p></li><li><p>VARIABLES:</p><div class="ulist"><ul><li><p>variables vector A,B,C : Declararlas e inicializarlas A[i]=i, B[i]=i, C[i]=0</p></li><li><p>variable len : almacena el tamaño de los vectores</p></li><li><p>variable A0    : almacena la dirección del primer elemento de vector A</p></li><li><p>variable i    : índice al elemento de posición i de cualquier vector</p></li></ul></div></li><li><p>Estructura del CODIGO imperativo:</p><div class="ulist"><ul><li><p>La construcción de instrucciones básica es un bucle</p><div class="ulist"><ul><li><p>El bucle cuenta las iteraciones en sentido descendente</p></li><li><p>Se inicializa el índice "i"=len-1 y</p></li><li><p>En cada iteración se asigna A[i]=i , B[i]=i, C[i]=A[i]+B[i]</p></li><li><p>En cada iteración se actualiza el índice i=i-1</p></li><li><p>Se sale del bucle cuando i=-1</p></li></ul></div></li></ul></div></li></ul></div>
<h level="4">Organigramas (1ª versión): Alto Nivel y RTL</h><div class="ulist"><ul><li><p>Descripción gráfica del algoritmo:</p><div class="ulist"><ul><li><p>Alto Nivel: lenguaje natural imperativo</p></li><li><p>RTL: lenguaje de bajo nivel que tiene en cuenta la ISA de la computadora</p><div class="imageblock text-center"><img src="./images/von_neumann/vectorABC_orga.png" alt="Diagrama de Flujo: Alto Nivel y RTL" /></div><div class="title">Figure 97. Diagrama de Flujo: Pseudocódigo y RTL</div></li></ul></div></li></ul></div>
<h level="4">Organigrama (2ª versión):  RTL</h><div class="ulist"><ul><li><p>Una posibilidad: inicializar los 3 vectores A[], B[] y C[]</p></li></ul></div>
<h level="4">Organigrama (3ª versión): RTL</h><div class="ulist"><ul><li><p>Versión definitiva: El vector C[] = A[]+B[]</p></li></ul></div>
<h level="4">Lenguaje Ensamblador IAS (1ª versión)</h><div class="ulist"><ul><li><p>vector_iniciar_A.ias</p><div class="listingblock"><div class="content"><pre>; vector_iniciar_A.ias
; Inicializar el vector A
; A es un vector  de tamano "len" que esta almacenados en secuencia. La direccion del primer elemento de A se guardo en la variable A0
; inicializamos el vector  A[i]=i
; El acceso a los elementos del array se realiza escribiendo en el campo de direcciones de la instruccion de lectura/escritura.
; Unicamente puden tener etiquetas las instrucciones de las izquierda por lo que habrá que utilizar las instrucciones Cu'-&gt;S(x) etiqueta [Salto a la instrucción derecha en la posición etiqueta] y Cu'-&gt;S(x) etiqueta [Salto a la instrucción izquierda en la posición etiqueta] para ALINEAR todas las etiquetas en instrucciones izquierda.
; Es necesario saber si las instrucciones de las direcciones bucle,suma y C estan a la izda o derecha de la palabra de memoria.
; El numero de instrucciones ha de ser par. Utilizar .empty en caso impar.
; sin acentos en los comentarios
; Help online : manual de referencia -&gt; tipos de datos
; View -&gt; Preferences -&gt; Capacidad de Memoria Selectron


;;;;;;;;;;;;;;;;;;SECCION DE INSTRUCCIONES

;;;;;;;;;;; Inicializo indice i = len - 1
dcha1:	Cu'-&gt;S(x)   dcha1	; salta a la dcha de dcha1
	S(x)-&gt;Ac+  len		;
	S(x)-&gt;Ah-  uno		;
	At-&gt;S(x)   i		;

;;;;;;;;; inicio while : condicion elemento &gt; 0
bucle: 	Cc-&gt;S(x)   actu_A   	;si AC &gt;= 0, salto a Actu_A
	Cu-&gt;S(x)   fin

;;;;;;;;; Actualizo vector A[i]=i
	; actualizo el puntero a A[i]
actu_A:		S(x)-&gt;Ac+  cero		;
	S(x)-&gt;Ah+  A0		;inicializo puntero con A[0]
	S(x)-&gt;Ah+  i		;inicializo puntero con A[0]+i
	Ap-&gt;S(x)  wa		;Actualizo campo de direcciones de la instruccion IZDA localizada en "wa" M[wa](8:19) &lt;- AC(28:39)
	; actualizo A[i]=i
	S(x)-&gt;Ac+  i	  	;
	Cu-&gt;S(x)  wa		; salta a la izda de wa
wa:	At-&gt;S(x)   100		;M[100]&lt;-AC. La direccion 100 cambia en tiempo de ejecucion.


;;;;;;;;;; Siguiente iteracion
	S(x)-&gt;Ac+  i		;
	S(x)-&gt;Ah-  uno		;
	At-&gt;S(x)   i		;
	Cc-&gt;S(x)   bucle
	.empty
fin:	halt
	.empty


;;;;;;;;;;;;;;;;SECCION DE DATOS

;;;;;;; variables ordinarias
len:		.data 10	; longitud vectores A[], B[] y C[]
A0:		.data 30	; direccion A[0]
i:		.data 0		; indice del array

;;;;;;;; constantes
uno:		.data 1		;
cero:		.data 0</pre></div></div></li></ul></div>
<h level="4">Simulación (1ª versión)</h><div class="ulist"><ul><li><p>Realizar la ejecución del código binario con el emulador IASsim</p></li></ul></div>
<h level="4">Lenguaje Ensamblador IAS (2ª versión)</h><div class="ulist"><ul><li><p>Desarrollar el código fuente del programa vector_iniciar_A_B_C.ias:</p></li></ul></div>
<h level="4">Simulación (2ª versión)</h><div class="ulist"><ul><li><p>Realizar la ejecución del código binario con el emulador IASsim</p></li></ul></div>
<h level="4">Lenguaje Ensamblador IAS (3ª versión)</h><div class="ulist"><ul><li><p>Desarrollar el código fuente del programa vectorA+B.ias:</p></li></ul></div>
<h level="4">Simulación (3ª versión)</h><div class="ulist"><ul><li><p>Realizar la ejecución del código binario con el emulador IASsim</p></li></ul></div></div></section></section>
<section><section id="_simulador_iassim_2"><h2>24. Simulador IASSim</h2></section><section id="iassim_install"><h2>24.1. Máquina Virtual Java JVM</h2><div class="slide-content"><div class="ulist"><ul><li><p>Instalar el Kit de Desarrollo Java (<a href="http://openjdk.java.net/">Java Development Kit-JDK</a>) en el sistema ubuntu</p><div class="ulist"><ul><li><p><a href="https://packages.ubuntu.com/bionic/openjdk-11-jdk">openjdk-11-jdk</a> en la distribución linux/GNU ubuntu 18.0 bionic.</p></li><li><p>Comprobar que se tiene acceso al paquete: <code>apt-cache search openjdk-11-jdk</code></p></li><li><p>Instalar el paquete: <code>sudo apt-get install openjdk-11-jdk</code></p></li><li><p>Comprobar que está instalado el paquete: <code>dpkg -l openjdk-11-jdk</code></p></li><li><p>Comprobar la versión de java instalada: <code>java --version</code></p></li></ul></div></li><li><p>datos de la instalación en Ubuntu 17</p><div class="listingblock"><div class="content"><pre>Date: September 15, 2017.
Emulator version: IASSim2.0.4
Emulator command: java -cp IASSim2.0.4.jar:jhall.jar:IASSimHelp2.0.jar iassim.Main -m IAS.cpu
Operating System: GNU/linux
	Distributor ID:	Ubuntu
	Description:	Ubuntu 17.04
	Release:	17.04
	Codename:	zesty
Java version: openjdk version "1.8.0_131"
              OpenJDK Runtime Environment (build 1.8.0_131-8u131-b11-2ubuntu1.17.04.3-b11)
              OpenJDK 64-Bit Server VM (build 25.131-b11, mixed mode)</pre></div></div></li></ul></div>
<div class="sidebarblock"><div class="content"><div class="paragraph"><p>IASSim se ejecuta en la máquina virtual de Java JVM, por lo tanto es un requisito tener instalada la máquina virtual JVM. Virtualizar una máquina consiste en instalar una capa SW por encima de cualquier Sistema Operativo (Linux, MacOS, Windows) de tal forma que cualquier aplicación (Por ejemplo IASSim) que se instale sobre la capa de virtualización no depende del Sistema Operativo y así se consigue independizar la aplicación (Por ejemplo IASSim) de los diferentes Sistemas Operativos.</p></div></div></div></div></section><section id="_simulador_ias"><h2>24.2. Simulador IAS</h2><div class="slide-content"><div class="ulist"><ul><li><p>IASSim : Herramienta de simulación de la computadora IAS de Von Neumann útil para la simulación de la ejecución paso a paso de las instrucciones de un programa en código máquina. Permite visulalizar el contenido de la memoria principal Selectron y de los registros de la CPU al finalizar cada ciclo de instrucción.</p></li><li><p><a href="http://www.cs.colby.edu/djskrien/IASSim/">Colby IASSim Web</a> : Al hacer click nos conectamos al repositorio del simulador IASSim.</p><div class="ulist"><ul><li><p>Descargar el Simulador IASSim2.0.4 : archivo zip</p></li><li><p>Descomprimir el archivo IASSim2.0.4.zip.</p></li></ul></div></li><li><p>Abrir el Simulador mediante el comando:</p><div class="olist arabic"><ol class="arabic"><li><p>../IASSim2.0.4$ <code>java -cp IASSim2.0.4.jar:jhall.jar:IASSimHelp2.0.jar iassim.Main -m IAS.cpu</code></p><div class="ulist"><ul><li><p>En Windows se puede hacer doble click sobre el archivo por lotes con extensión <em>.bat</em>.</p></li></ul></div></li></ol></div></li></ul></div></div></section><section id="_simulacióndepuración"><h2>24.3. Simulación/Depuración</h2><div class="slide-content"><div class="ulist"><ul><li><p>Los objetivos de la simulación son dos:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Interpretar la ejecución de cada instrucción observando como  varía la memoria y los registros</p></li><li><p>Depurar posibles errores en el desarrollo del programa.</p></li></ol></div></li><li><p><a href="https://www.linuxvoice.com/john-von-neumann/" class="bare">https://www.linuxvoice.com/john-von-neumann/</a></p></li><li><p>Es necesario conocer la codificación hexadecimal de los números enteros y su conversión a código binario.</p></li><li><p>Al programa <strong>Demo</strong> <em>tutorial.ias</em> que viene con el propio emulador le llamaremos <em>sum1toN.ias</em></p><div class="olist arabic"><ol class="arabic"><li><p>El archivo zip descargado ha debido de ser descomprimido: observar los archivos extraídos, uno de ellos son las instrucciones de apertura del emulador.</p></li><li><p>Abrir el emulador:</p><div class="ulist"><ul><li><p>En linux mediante el comando en línea: <code>java -cp IASSim2.0.4.jar:jhall.jar:IASSimHelp2.0.jar iassim.Main -m IAS.cpu</code></p></li><li><p>En windows: Doble click en el archivo por lotes con la extensión <em>*.bat</em></p></li></ul></div></li><li><p>Ayuda: <code>Help &#8594; General IASSim Help &#8594; Assembly Language &#8594; Sintaxis y Regular Instructions</code> : manual del lenguaje ensamblador</p></li><li><p>Borrar el contenido de la memoria tanto interna como externa. <code>Execute &#8594; Clear all</code></p></li><li><p>Desactivar el modo depuración : <code>Execute &#8594; Debug Mode NO seleccionado</code></p></li><li><p>Cargar el programa <em>sum1toN.ias</em> en lenguaje ensamblador : <code>File &#8594; Open &#8594;  sum1toN.ias</code></p><div class="ulist"><ul><li><p>Lenguaje ensamblador: creado por los autores de la aplicación <em>IASSim</em>.</p></li></ul></div></li><li><p>Ventana RAM Selectrons: direcciones y contenido en código hexadecimal,decimal,binario&#8230;&#8203; Anchura memoria : 20 ó 40 bits.</p></li><li><p>Seleccionar la ventana con el código fuente en lenguaje ensamblador.</p></li><li><p>Ensamblar y Cargar el módulo ejecutable en memoria     : <code>Execute &#8594; Assemble &amp; Load</code></p></li><li><p>Analizar el mapa de memoria : sección de instrucciones y sección de datos</p></li><li><p>Activar el modo depuración 				    : <code>Execute &#8594; Debug Mode</code></p></li><li><p>Ejecución de cada instrucción paso a paso               : <code>Step by Step</code></p></li></ol></div></li><li><p>Contenido de la Memoria</p><div class="ulist"><ul><li><p>La primera instrucción está almacenada en los 20 bits de la izda de la posición de memoria y la segunda instrucción en la dcha.</p><div class="imageblock text-center" style="text-align: center"><img src="./images/von_neumann/ias_code_machine.png" alt="ias code machine" /></div><div class="title">Figure 98. IAS Codigo Maquina</div></li></ul></div></li><li><p>Contenido de los Registros:</p><div class="imageblock text-center" style="text-align: center"><img src="./images/von_neumann/ias_registers.png" alt="ias registers" /></div><div class="title">Figure 99. IAS Registros</div></li><li><p>Ejercicio:</p><div class="ulist"><ul><li><p>Antes de la ejecución de cada instrucción interpretarla: interpretar la instrucción en lenguaje máquina.</p></li><li><p>preveer el nuevo contenido de la sección de datos de la memoria</p></li><li><p>preveer el nuevo contenido de los registros de la CPU.</p></li><li><p>preveer la próxima instrucción a ejecutar</p></li><li><p>Deducir el organigrama del programa.</p></li></ul></div></li></ul></div></div></section></section>
<section><section id="_lenguajes_de_programación_de_alto_y_bajo_nivel"><h2>25. Lenguajes de programación de Alto y Bajo Nivel</h2></section><section id="lang_altovsbajo"><h2>25.1. Lenguajes de programación de alto nivel vs lenguajes de bajo nivel</h2><div class="slide-content"><div class="ulist"><ul><li><p>Aunque en los años 1960 se programaba en el lenguaje máquina y lenguaje ensamblador, esto resultaba muy poco productivo ya que refequería mucho esfuerzo y tiempo.</p></li><li><p>La solución fue abstraer funciones de la computadora mediante lenguajes de alto nivel:</p><div class="ulist"><ul><li><p><a href="https://www.tiobe.com/tiobe-index/" class="bare">https://www.tiobe.com/tiobe-index/</a></p></li></ul></div></li><li><p>El empleo de lenguajes de alto nivel efectivos para los programadores requiere de un traductor al lenguaje máquina de la computadora.</p></li></ul></div></div></section><section id="sum1toN_lang"><h2>25.2. Ejemplo sum1toN en distintos lenguajes de Programación</h2><div class="slide-content"><div class="ulist"><ul><li><p>Algoritmo sum1toN &#8594; \(\sum_{i=1}^{N}i=N(N+1)/2\)</p></li><li><p>Refs</p><div class="ulist"><ul><li><p><a href="http://wiki.c2.com/?ArraySumInManyProgrammingLanguages" class="bare">http://wiki.c2.com/?ArraySumInManyProgrammingLanguages</a></p></li><li><p><a href="https://www.rosettacode.org/wiki/Sum_and_product_of_an_array#With_explicit_conversion" class="bare">https://www.rosettacode.org/wiki/Sum_and_product_of_an_array#With_explicit_conversion</a></p></li></ul></div></li><li><p>Desarrollar el algoritmo sum1toN en :  Lisp, Python, Java, C, Pascal,  &#8230;&#8203;</p></li><li><p>elisp</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-lisp" data-lang="lisp">(setq array [1 2 3 4 5])
(apply '+ (append array nil))
(apply '* (append array nil))</code></pre></div></div></li><li><p>Phyton</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; sum(range(5,0,-1))</code></pre></div></div></li><li><p>Java</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-java" data-lang="java">/* Programa Fuente: sum1toN.java

 compilación: javac sum1toN.java -&gt; genera el BYTECODE sum1toN.class
 ejecución   -&gt; java -cp . sum1toN  ; necesita el bytecode *.class y ejecutará el main de class

*/

public class sum1toN {
// método main encapsulado en la clase class, static para que main no pueda cambiar los atributos, publico para ser accesible.
    public static void main(String[] args) {
        System.out.println("Suma de Números enteros");
	int x=5, suma=0;

      while (x &gt;= 0 ) {
         System.out.print( x );
         System.out.print(",");
	 suma=suma+x;
	 x--;
      }
      System.out.print("\n");
      System.out.print("suma="+suma);
      System.out.print("\n");
    }
}</code></pre></div></div></li><li><p>C</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">/*
  Programa:       sum1toN.c
  Descripción:    realiza la suma de la serie 1,2,3,...N
                  Es el programa en lenguaje C equivalente a sum1toN.ias de la máquina IAS de von Neumann
  Lenguaje:       C99
  Descripción:    Suma de los primeros 5 números naturales
  Entrada:        Definida en una variable
  Salida:         Sin salida
  Compilación:    gcc -m32 -g -o sum1toN sum1toN.c -&gt; -g: módulo binario depurable
                                                   -&gt; -m: módulo binario arquitectura x86-32 bits
  S.O:            GNU/linux 4.10 ubuntu 17.04 x86-64
  Librería:       /usr/lib/x86_64-linux-gnu/libc.so
  CPU:            Intel(R) Core(TM) i5-6300U CPU @ 3.0GHz
  Compilador:     gcc version 6.3
  Ensamblador:    GNU assembler version 2.28
  Linker/Loader:  GNU ld (GNU Binutils for Ubuntu) 2.28
  Asignatura:     Estructura de Computadores
  Fecha:          20/09/2017
  Autor:          Cándido Aramburu
*/

#include &lt;stdio.h&gt;  // cabecera de la librería de la función printf()

// función de entrada al programa
void  main (void)
{
  // Declaración de variables locales
  char suma=0;
  char n=0b101;
  // bucle
  while(n&gt;0){
    suma+=n;
    n--;
  }
 printf("\n La suma es = %d \n",suma);
}</code></pre></div></div></li><li><p>Lenguaje ensamblador ATT para la arquitectura x86-32</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-nasm" data-lang="nasm">### Programa: sum.s
### Descripción: realiza la suma de la serie 1,2,3,...N
### gcc -m32 -g -nostartfiles -o sum1toN sum1toN.s
### Ensamblaje as --32 --gstabs fuente.s -o objeto.o
### linker -&gt; ld -melf_i386 -I/lib/i386-linux-gnu/ld-linux.so.2   -o ejecutable objeto.o -lc

        ##  Declaración de variables
        .section .data

n:	.int 5

        .global _start

        ##  Comienzo del código
        .section .text
_start:
        mov $0,%ecx # ECX implementa la variable suma
        mov n,%edx
bucle:
        add %edx,%ecx
        sub $1,%edx
        jnz bucle

        mov %ecx, %ebx # el argumento de salida al S.O. a través de EBX según convenio

        ## salida
        mov $1, %eax  # código de la llamada al sistema operativo: subrutina exit
        int $0x80     # llamada al sistema operativo


        .end</code></pre></div></div></li><li><p>Lenguaje ensamblador AT&amp;T para la arquitectura x86-64</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-nasm" data-lang="nasm">	#### Programa: sum1toN.s
	### Descripción: realiza la suma de la serie 1,2,3,...N. La entrada se define en el propio programa y la salida se pasa al S.O.
	### Lenguaje: Lenguaje ensamblador de GNU para la arquitectura AMD64
	### gcc  -no-pie -g -nostartfiles -o sum1toN  sum1toN.s
	### Ensamblaje as  --gstabs sum1toN.s -o sum1toN.o
        ### linker -&gt; ld    -o sum1toN sum1toN.o
	##  Declaración de variables
	##  SECCION DE DATOS
	  .section .data

n:      .quad 5

	  .global _start

	  ##  Comienzo del código
	  ##  SECCION DE INSTRUCCIONES

	  .section .text
_start:
        movq $0,%rdi # RDI implementa la variable suma
        movq n,%rdx
bucle:
        add %rdx,%rdi
        sub $1,%rdx
        jnz bucle

        ## el argumento de salida al S.O. a través de RDI según convenio ABI AMD64
	## salida
          mov $60, %rax	# código de la llamada al sistema operativo: subrutina exit
	  syscall # llamada al sistema operativo para que ejecute la subrutina según el valor de RAX


	  .end</code></pre></div></div></li><li><p>ARM</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-armasm" data-lang="armasm">/*      Programa: sum1toN.s
        Descripción: realiza la suma de la serie 1,2,3,...N
        Es el programa en lenguaje ARM equivalente a sum1toN.ias de la máquina IAS de von Neumann
        gcc  -g -nostartfiles -o sum1toN sum1toN.s
        Ensamblaje as  --gstabs sum1toN.s -o sum1toN.o
        linker -&gt; ld     -o sum1toN sum1toN.o
*/
        @  Declaración de variables
        .section .data
n:      .int 5

        .global _start

        @ Comienzo del código
        .section .text
_start:
        mov r0,#0       @ R0 implementa la variable suma
        ldr r2,=n       @ R1 implementa la variable n indirectamente
        ldr r1,[r2]
/* Direccionamiento directo:
        mov r1,n da error porque mov no admite direccionamiento a memoria directo.
                 mov admite direccionamiento inmediato si el literal de  32 bits no tiene repetición de ceros a izda y dcha
                 para convertirlo en un literal de 8 bits seguido de desplazamientos
        ldr r1,n Error: reubicación_interna (tipo OFFSET_IMM) no compuesta
                 Da error al intentar codificar un literal (dirección n) de 32 bits.
*/

bucle:
        add r0,r1
        subs  r1,#1
        bne bucle

        @r0 es el argumento de salida al S.O. a través de EBX según convenio

        /* exit syscall */
        mov r7, #1
        swi #0

        .end</code></pre></div></div></li></ul></div></div></section></section>
<section><section id="_lenguajes_de_programación_en_ensamblador"><h2>26. Lenguajes de programación en Ensamblador</h2></section><section id="leng_asm"><h2>26.1. Manuales de referencia</h2><div class="slide-content"><h level="3">Lenguaje Intel</h><div class="ulist"><ul><li><p>Manuales oficiales</p><div class="ulist"><ul><li><p><a href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html">Intel</a>: Vol 2</p></li><li><p><a href="http://developer.amd.com/resources/documentation-articles/developer-guides-manuals/">AMD</a>: apartado Manuals : vol 3</p></li><li><p><a href="http://developer.amd.com/wordpress/media/2008/10/24594_APM_v3.pdf">AMD64 Architecture Programmer’s Manual Volume 3: General Purpose and</a> System Instructions</p></li></ul></div></li><li><p>Manuales no oficiales:</p><div class="ulist"><ul><li><p><a href="http://www.felixcloutier.com/x86/">manual Intel quick</a>: <strong>recomendado</strong></p></li><li><p><a href="http://www.cs.nyu.edu/~mwalfish/classes/ut/s13-cs439/ref/i386/toc.htm">intel descriptivo i386</a></p><div class="ulist"><ul><li><p><a href="http://www.cs.nyu.edu/~mwalfish/classes/ut/s13-cs439/ref/i386/c17.htm">Repertorio ISA y Formato de Instrucción</a></p></li></ul></div></li><li><p><a href="http://kluge.in-chemnitz.de/docs/notes/assembly.php">kluge</a></p></li><li><p><a href="http://www.unixwiz.net/techtips/x86-jumps.html">Saltos Condicionales</a></p></li></ul></div></li></ul></div>
<h level="4">Netwide ASM (NASM) para el lenguaje de intel</h><div class="ulist"><ul><li><p>Ejemplo <a href="#sum1toN_nasm">sum1toN.asm</a> de programa en lenguaje ensamblador intel y assembler "NetWide Asm" (nasm).</p></li><li><p>Tutorial completo <a href="#NASM_tuto">NASM tutorialspoint</a></p></li><li><p>Apuntes de la  <a href="#NASM_bristol">Universidad de Bristol</a></p></li><li><p>Apuntes del <a href="#paul_carter">Dr. Paul Carter</a> y <a href="#pc_asm">Dr. Paul Carter</a></p></li></ul></div>
<h level="3">lenguaje AT&amp;T</h><div class="ulist"><ul><li><p><a href="https://docs.oracle.com/cd/E53394_01/html/E54851/eqbsu.html">Oracle Solaris ASM</a></p><div class="ulist"><ul><li><p>En este documento  a la sintaxis AT&amp;T la denomina "Oracle Solaris".</p></li><li><p><a href="http://docs.oracle.com/cd/E19253-01/817-5477/817-5477.pdf">AT&amp;T Solaris Manual amd64-i386 </a>: lenguaje y traductor assembler.</p></li></ul></div></li></ul></div>
<h level="3">Características arquitectura i386</h><div class="ulist"><ul><li><p><a href="https://sourceware.org/binutils/docs-2.26/as/i386_002dDependent.html#i386_002dDependent:">Assembler: Características dependientes de la arquitectura x86</a></p></li></ul></div>
<h level="3">Assembler (Traductor Ensamblador): Directivas</h><div class="ulist"><ul><li><p><a href="https://sourceware.org/binutils/docs-2.26/as/Pseudo-Ops.html#Pseudo-Ops:">Directivas del traductor Assembler</a></p></li></ul></div>
<h level="3">Discusión por qué ASM AT&amp;T</h><div class="ulist"><ul><li><p><a href="http://es.tldp.org/Presentaciones/200002hispalinux/conf-28/28.ps.gz" class="bare">http://es.tldp.org/Presentaciones/200002hispalinux/conf-28/28.ps.gz</a></p></li></ul></div>
<h level="3">TRANSFERENCIA</h><table class="tableblock frame-all grid-all" style="width:100%"><colgroup><col style="width:9.0909%" /><col style="width:18.1818%" /><col style="width:18.1818%" /><col style="width:36.3636%" /><col style="width:18.1819%" /></colgroup><thead><tr><th class="tableblock halign-left valign-top">Nombre</th><th class="tableblock halign-left valign-top">Comentario</th><th class="tableblock halign-left valign-top">Código</th><th class="tableblock halign-left valign-top">Operación</th><th class="tableblock halign-left valign-top">O D I T S Z A P C</th></tr><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock">MOV</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Mover (copiar)</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">MOV Fuente,Dest</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Dest:=Fuente</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">XCHG</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Intercambiar</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">XCHG Op1,Op2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Op1:=Op2 , Op2:=Op1</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">STC</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Set the carry (Carry = 1)</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">STC</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">CF:=1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">CLC</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Clear Carry (Carry = 0)</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">CLC</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">CF:=0</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">CMC</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Complementar Carry</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">CMC</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">CF:=Ø</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">±</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">STD</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Setear dirección</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">STD</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">DF:=1(interpreta strings de arriba hacia abajo)</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">CLD</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Limpiar dirección</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">CLD</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">DF:=0(interpreta strings de abajo hacia arriba)</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">STI</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Flag de Interrupción en 1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">STI</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">IF:=1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">CLI</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Flag de Interrupción en 0</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">CLI</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">IF:=0</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">PUSH</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Apilar en la pila</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">PUSH Fuente</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">DEC SP, [SP]:=Fuente</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">PUSHF</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Apila los flags</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">PUSHF</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">O, D, I, T, S, Z, A, P, C 286+: También NT,IOPL</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">PUSHA</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Apila los registros generales</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">PUSHA</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">AX, CX, DX, BX, SP, BP, SI, DI</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">POP</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Desapila de la pila</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">POP Dest</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Destino:=[SP], INC SP</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">POPF</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Desapila a los flags</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">POPF</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">O,D,I,T,S,Z,A,P,C 286+: También NT,IOPL</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">± ± ± ± ± ± ± ± ±</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">POPA</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Desapila a los reg. general.</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">POPA</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">DI, SI, BP, SP, BX, DX, CX, AX</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">CBW</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Convertir Byte a Word</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">CBW</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">AX:=AL (con signo)</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">CWD</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Convertir Word a Doble</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">CWD</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">DX:AX:=AX (con signo)</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">CWDE</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Conv. Word a Doble Exten.</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">CWDE 386</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">EAX:=AX (con signo)</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">IN</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Entrada</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">IN Dest,Puerto</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">AL/AX/EAX := byte/word/double del puerto esp.</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">OUT</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Salida</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">OUT Puer,Fuente</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Byte/word/double del puerto := AL/AX/EAX</p></td><td class="tableblock halign-left valign-top"></td></tr></table>
<div class="ulist"><ul><li><p>Flags: <strong>±</strong> =Afectado por esta instrucción, <strong>?</strong> =Indefinido luego de esta instrucción</p></li></ul></div>
<h level="3">ARITMÉTICOS</h><table class="tableblock frame-all grid-all" style="width:100%"><colgroup><col style="width:9.0909%" /><col style="width:18.1818%" /><col style="width:18.1818%" /><col style="width:36.3636%" /><col style="width:18.1819%" /></colgroup><thead><tr><th class="tableblock halign-left valign-top">Nombre</th><th class="tableblock halign-left valign-top">Comentario</th><th class="tableblock halign-left valign-top">Código</th><th class="tableblock halign-left valign-top">Operación</th><th class="tableblock halign-left valign-top">O D I T S Z A P C</th></tr><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock">ADD</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Suma</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">ADD Fuente,Dest</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Dest:=Dest+ Fuente</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">±       ± ± ± ± ±</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">ADC</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Suma con acarreo</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">ADC Fuente,Dest</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Dest:=Dest+ Fuente +CF</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">±       ± ± ± ± ±</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">SUB</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Resta</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">SUB Fuente,Dest</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Dest:=Dest- Fuente</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">±       ± ± ± ± ±</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">SBB</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Resta con acarreo</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">SBB Fuente,Dest</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Dest:=Dest-(Fuente +CF)</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">±       ± ± ± ± ±</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">DIV</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">División (sin signo)</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">DIV Op</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Op=byte: AL:=AX / Op AH:=Resto</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">?       ? ? ? ? ?</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">DIV</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">División (sin signo)</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">DIV Op</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Op=word:         AX:=DX:AX / Op DX:=Resto</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">?       ? ? ? ? ?</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">DIV</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">386 División (sin signo)</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">DIV Op</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Op=doublew.:     EAX:=EDX:EAX / Op EDX:=Resto</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">?	 ? ? ? ? ?</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">IDIV</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">División entera con signo</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">IDIV Op</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Op=byte:        AL:=AX / Op AH:=Resto</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">?	 ? ? ? ? ?</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">IDIV</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">División entera con signo</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">IDIV Op</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Op=word: AX:=DX:AX / Op DX:=Resto</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">?	 ? ? ? ? ?</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">IDIV</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">386 División entera con signo</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">IDIV Op</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Op=doublew.: EAX:=EDX:EAX / Op EDX:=Resto</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">?	 ? ? ? ? ?</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">MUL</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Multiplicación (sin signo)</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">MUL Op</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Op=byte: AX:=AL*Op si AH=0 #</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">±	 ? ? ? ? ±</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">MUL</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Multiplicación (sin signo)</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">MUL Op</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Op=word: DX:AX:=AX*Op si DX=0 #</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">±	 ? ? ? ? ±</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">MUL</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">386 Multiplicación (sin signo)</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">MUL Op</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Op=double: EDX:EAX:=EAX*Op si EDX=0 #</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">±	 ? ? ? ? ±</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">IMUL</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">i Multiplic. entera con signo</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">IMUL Op</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Op=byte: AX:=AL*Op si AL es suficiente #</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">±	 ? ? ? ? ±</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">IMUL</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Multiplic. entera con signo</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">IMUL Op</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Op=word: DX:AX:=AX*Op si AX es suficiente #</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">±	 ? ? ? ? ±</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">IMUL</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">386 Multiplic. entera con signo</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">IMUL Op</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Op=double: EDX:EAX:=EAX*Op si EAX es sufi. #</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">±	 ? ? ? ? ±</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">INC</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Incrementar</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">INC Op</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Op:=Op+1 (El Carry no resulta afectado !)</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">±	 ± ± ± ±</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">DEC</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Decrementar</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">DEC Op</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Op:=Op-1 (El Carry no resulta afectado !)</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">±       ± ± ± ±</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">CMP</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Comparar</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">CMP Fuente,Destino</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Destino-Fuente</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">±       ± ± ± ± ±</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">SAL</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Desplazam. aritm. a la izq.</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">SAL</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Op,Cantidad</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">i       ± ± ? ± ±</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">SAR</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Desplazam. aritm. a la der.</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">SAR</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Op,Cantidad</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">i       ± ± ? ± ±</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">RCL</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Rotar a la izq. c/acarreo</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">RCL Op,Cantidad</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock">i               ±</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">RCR</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Rotar a la derecha c/acarreo</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">RCR Op,Cantidad</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock">i               ±</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">ROL</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Rotar a la izquierda</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">ROL Op,Cantidad</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock">i               ±</p></td></tr></table>
<div class="ulist"><ul><li><p><strong>i</strong>:para más información ver especificaciones de la intrucción,</p></li><li><p><strong>#</strong>:entonces CF:=0, OF:=0 sino CF:=1, OF:=1</p></li></ul></div>
<h level="3">LÓGICOS</h><table class="tableblock frame-all grid-all" style="width:100%"><colgroup><col style="width:9.0909%" /><col style="width:18.1818%" /><col style="width:18.1818%" /><col style="width:36.3636%" /><col style="width:18.1819%" /></colgroup><thead><tr><th class="tableblock halign-left valign-top">Nombre</th><th class="tableblock halign-left valign-top">Comentario</th><th class="tableblock halign-left valign-top">Código</th><th class="tableblock halign-left valign-top">Operación</th><th class="tableblock halign-left valign-top">O D I T S Z A P C</th></tr><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock">NEG</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Negación (complemento a 2)</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">NEG Op</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Op:=0-Op si Op=0 entonces CF:=0 sino CF:=1</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">±       ± ± ± ± ±</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">NOT</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Invertir cada bit</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">NOT Op</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Op:=Ø~Op (invierte cada bit)</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">AND</p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><em>Y</em> (And) lógico</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">AND Fuente,Dest</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Dest:=Dest ^ Fuente</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">0       ± ± ? ± 0</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">OR</p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><em>O</em> (Or) lógico</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">OR  Fuente,Dest</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Dest:=Dest v Fuente</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">0       ± ± ? ± 0</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">XOR</p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><em>O</em> (Or) exclusivo</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">XOR Fuente,Dest</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Dest:=Dest (xor) Fuente</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">0       ± ± ? ± 0</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">SHL</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Desplazam. lógico a la izq.</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">SHL Op,Cantidad</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock">i       ± ± ? ± ±</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">SHR</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Desplazam. lógico a la der.</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">SHR Op,Cantidad</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock">i       ± ± ? ± ±</p></td></tr></table>
<h level="3">MISCELÁNEOS</h><table class="tableblock frame-all grid-all" style="width:100%"><colgroup><col style="width:9.0909%" /><col style="width:18.1818%" /><col style="width:18.1818%" /><col style="width:36.3636%" /><col style="width:18.1819%" /></colgroup><thead><tr><th class="tableblock halign-left valign-top">Nombre</th><th class="tableblock halign-left valign-top">Comentario</th><th class="tableblock halign-left valign-top">Código</th><th class="tableblock halign-left valign-top">Operación</th><th class="tableblock halign-left valign-top">O D I T S Z A P C</th></tr><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock">NOP</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Hacer nada</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">NOP</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">No hace operación alguna</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">LEA</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Cargar direciión Efectiva</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">LEA Fuente,Dest</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Dest := dirección fuente</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">INT</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Interrupción</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">INT Num</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Interrumpe el proceso actual y salta al vector Num</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">0 0</p></td></tr></table>
<h level="3">SALTOS  (generales)</h><div class="ulist"><ul><li><p><a href="https://en.wikibooks.org/wiki/X86_Assembly/Control_Flow#Jump_if_Lesser">wiki x86 assembly</a></p></li></ul></div>
<div class="listingblock"><div class="content"><pre>Nombre  Comentario                      Código          Operación
CALL    Llamado a subrutina             CALL Proc
JMP     Saltar                          JMP Dest
JE      Saltar si es igual              JE Dest         (= JZ)
JZ      Saltar si es cero               JZ Dest         (= JE)
JCXZ    Saltar si CX es cero            JCXZ Dest
JP      Saltar si hay paridad           JP Dest         (= JPE)
JPE     Saltar si hay paridad par       JPE Dest        (= JP)
JPO     Saltar si hay paridad impar     JPO Dest        (= JNP)
JNE     Saltar si no es igual           JNE Dest        (= JNZ)
JNZ     Saltar si no es cero            JNZ Dest        (= JNE)
JECXZ   Saltar si ECX es cero           JECXZ Dest 386
JNP     Saltar si no hay paridad        JNP Dest        (= JPO)
RET     Retorno de subrutina            RET</pre></div></div>
<h level="3">SALTOS  Sin Signo (Cardinal) SALTOS Con Signo (Integer)</h><div class="listingblock"><div class="content"><pre>Nombre  Comentario                      Código          Operación
JA      Saltar si es superior           JA Dest         (= JNBE)
JAE     Saltar si es superior o igual   JAE Dest        (= JNB = JNC)
JB      Saltar si es inferior           JB Dest         (= JNAE = JC)
JBE     Saltar si es inferior o igual   JBE Dest        (= JNA)
JNA     Saltar si no es superior        JNA Dest        (= JBE)
JNAE    Saltar si no es super. o igual  JNAE Dest       (= JB = JC)
JNB     Saltar si no es inferior        JNB Dest        (= JAE = JNC)
JNBE    Saltar si no es infer. o igual  JNBE Dest       (= JA)
JC      Saltar si hay carry JC Dest     JO  Dest        Saltar si hay Overflow
JNC     Saltar si no hay carry          JNC Dest
JNO     Saltar si no hay Overflow       JNO Dest
JS      Saltar si hay signo (=negativo) JS Dest
JG      Saltar si es mayor              JG Dest         (= JNLE)
JGE     Saltar si es mayor o igual      JGE Dest        (= JNL)
JL      Saltar si es menor              JL Dest         (= JNGE)
JLE     Saltar si es menor o igual      JLE Dest        (= JNG)
JNG     Saltar si no es mayor           JNG Dest        (= JLE)
JNGE    Saltar si no es mayor o igual   JNGE Dest       (= JL)
JNL     Saltar si no es inferior        JNL Dest        (= JGE)
JNLE    Saltar si no es menor o igual   JNLE Dest       (= JG)</pre></div></div>
<h level="3">FLAGS (ODITSZAPC)</h><div class="listingblock"><div class="content"><pre>O: Overflow resultado de operac. sin signo es muy grande o pequeño.
D: Dirección
I: Interrupción Indica si pueden ocurrir interrupciones o no.
T: Trampa Paso, por paso para debugging
S: Signo Signo del resultado. Razonable sólo para enteros. 1=neg. 0=pos.
Z: Cero Resultado de la operación es cero. 1=Cero
A: Carru Aux. Similar al Carry, pero restringido para el nibble bajo únicamente
P: Paridad 1=el resultado tiene cantidad par de bits en uno
C: Carry resultado de operac. sin signo es muy grande o inferior a cero</pre></div></div>
<h level="3">Sufijos</h><div class="ulist"><ul><li><p>Sufijos de los mnemónicos del código de operación:</p><div class="ulist"><ul><li><p><em>q</em> : quad: operando de 8 bytes: cuádruple palabra</p></li><li><p><em>l</em> : long: operando de 4 bytes: doble palabra</p></li><li><p><em>w</em> : word: operando de 2 bytes: palabra</p></li><li><p><em>b</em> : byte: operando de 1 byte</p></li></ul></div></li><li><p>Si el mnemónico de operación no lleva sufijo el tamaño por defecto del operando es <em>long</em></p></li></ul></div></div></section><section id="_intel_x86_32_i386"><h2>26.2. Intel x86-32 /i386</h2><div class="slide-content"><h level="3">sum1toN.s</h><div class="ulist"><ul><li><p>Lenguaje ensamblador ATT para la arquitectura x86-32</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-nasm" data-lang="nasm">### Programa: sum1toN.s
### Descripción: realiza la suma de la serie 1,2,3,...N
### gcc -m32 -g -nostartfiles -o sum1toN sum1toN.s
### Ensamblaje as --32 --gstabs fuente.s -o objeto.o
### linker -&gt; ld -melf_i386 -I/lib/i386-linux-gnu/ld-linux.so.2   -o ejecutable objeto.o -lc

        ##  Declaración de variables
        .section .data

n:	.int 5

        .global _start

        ##  Comienzo del código
        .section .text
_start:
        mov $0,%ecx # ECX implementa la variable suma
        mov n,%edx
bucle:
        add %edx,%ecx
        sub $1,%edx
        jnz bucle

        mov %ecx, %ebx # el argumento de salida al S.O. a través de EBX según convenio

        ## salida
        mov $1, %eax  # código de la llamada al sistema operativo: subrutina exit
        int $0x80     # llamada al sistema operativo


        .end</code></pre></div></div></li></ul></div>
<h level="3">hola_mundo.s</h><div class="ulist"><ul><li><p>Compilar el programa en lenguaje ensamblador hola_mundo.s y volcar el módulo objeto binario.</p><div class="ulist"><ul><li><p>Módulo fuente: <em>hola_mundo.s.</em></p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-nasm" data-lang="nasm">###
### 	hola_mundo.s
###
### 	Programa simple de iniciación para el desarrollo de programas en Ensamblador x86-32 AT&amp;T.
###
### Compilación:
### 		assemble using: as --32 hola_mundo.s -o hola_mundo.o
### 		link using:   	ld -melf-i386 hola_mundo.o -o hola_mundo
###             Driver gcc: 	gcc  -m32 -nostartfiles   hola_mundo.s  -o hola_mundo
###
### 	revised on: Septiembre 2022 -- for Linux's i386 environment
###
###
	.att_syntax


	## Declaración de símbolos externos
	.global	_start		# visible entry-point


	## Reserva de Memoria para datos variables
	.section	.data

mensaje:	.ascii "Hola mundo\n"
longitud:	.2byte	. - mensaje 	#tamaño en bytes de la cadena mensaje

	## Sección para el Código de las Instrucciones en Lenguaje Ensamblador
	.section .text

_start:


	mov 	$4, %eax	# SYS_WRITE
	mov 	$1, %ebx	# device ID-number
	mov 	$mensaje, %ecx	# message address
	mov 	longitud, %edx	# message length
	int 	$0x80		# enter the kernel

	## terminate this program
	mov 	$1, %eax		# SYS_EXIT
	mov 	$0, %ebx		# return value
	int 	$0x80			# enter the kernel

	.end				# no more to assemble</code></pre></div></div></li></ul></div></li></ul></div>
<h level="3">hola_mundo: Código Máquina Binario</h><div class="ulist"><ul><li><p><strong>Sección de Datos</strong></p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-nasm" data-lang="nasm">08049ff4 &lt;mensaje&gt;: 48 6f 6c 61 20 4d 75 63 64 6f 0a       H o l a SP m u n d o /n
08049fff &lt;longitud&gt;: 0b 00</code></pre></div></div>
<div class="ulist"><ul><li><p>En un lenguaje de alto nivel sería la declaración e inicialización de variables.</p></li><li><p>Etiqueta: referencia a memoria</p></li><li><p>Cada caracter ocupa un byte (codificación ASCII). No interpretar el string como un todo (no little endian) a diferencia de los números enteros y reales.</p></li><li><p>El dato referenciado por la etiqueta longitud está en formato <em>little endian</em> &#8594; 00 0b</p></li></ul></div></li><li><p><strong>Sección de Instrucciones</strong></p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-nasm" data-lang="nasm">## Sección para el Código de las Instrucciones en Lenguaje Ensamblador

08048190 &lt;_start&gt;:
 8048190:	b8 04 00 00 00       	mov    $0x4,%eax
 8048195:	bb 01 00 00 00       	mov    $0x1,%ebx
 804819a:	b9 f4 9f 04 08       	mov    $0x8049ff4,%ecx
 804819f:	8b 15 ff 9f 04 08    	mov    0x8049fff,%edx
 80481a5:	cd 80                	int    $0x80

## terminate this program

 80481a7:	b8 01 00 00 00       	mov    $0x1,%eax
 80481ac:	bb 00 00 00 00       	mov    $0x0,%ebx
 80481b1:	cd 80                	int    $0x80</code></pre></div></div></li></ul></div>
<h level="4">Volcado de un programa binario</h><div class="ulist"><ul><li><p>Mediante el comando: <code>objdump -d hola_mundo</code>, donde hola_mundo es el módulo binario ejecutable.</p></li></ul></div>
<h level="4">Almacenamiento del programa binario en la Memoria Principal</h><div class="ulist"><ul><li><p>Una vez realizado el proceso de traducción del módulo fuente en lenguaje ensamblador se genera un módulo objeto en lenguaje binario que se almacena en el disco duro en forma de fichero.</p></li><li><p>El fichero que contiene el módulo objeto ejecutable en lenguaje binario es necesario cargarlo en la memoria principal. Esta tarea la realiza el <strong>cargador</strong> del sistema operativo.</p></li><li><p>Cada dirección de memoria apunta a 1 byte.</p></li><li><p>La dirección más baja apunta a todo el objeto: instrucción o dato.</p></li><li><p>Ejemplo:</p><div class="ulist"><ul><li><p>instrucción máquina arquitectura amd64.</p><div class="ulist"><ul><li><p><strong>4001a4:       48 83 ec 10   &#8594;  subq    $16,%rsp</strong></p></li></ul></div></li><li><p><strong>4001a4:       48 83 ec 10</strong></p><div class="ulist"><ul><li><p>En la posición <strong>0x4001A4</strong> está el byte <strong>48</strong></p></li><li><p>En la posición <strong>0x4001A4+1</strong> está el byte <strong>83</strong></p></li><li><p>En la posición <strong>0x4001A4+2</strong> está el byte <strong>EC</strong></p></li><li><p>En la posición <strong>0x4001A4+3</strong> está el byte <strong>10</strong></p></li><li><p>En la posición de memoria principal <code>0x4001A4</code> está almacenada la instrucción de 4 Bytes</p></li></ul></div></li></ul></div></li></ul></div>
<h level="4">Interpretación de una instrucción en Código Máquina: Formato de Instrucción de la ISA Intel x86-64</h><div class="ulist"><ul><li><p>Ejemplo:</p><div class="ulist"><ul><li><p>instrucción máquina arquitectura amd64.</p><div class="ulist"><ul><li><p><strong>4001a4:       48 83 ec 10   &#8594;  subq    $16,%rsp</strong></p></li></ul></div></li><li><p>Interpretación del programador:</p><div class="ulist"><ul><li><p>lenguaje ensamblador AT&amp;T de la arquitectura x86.</p></li><li><p>Descripción de la instrucción en lenguaje <strong>RTL</strong>: <em>RSP &#8592; RSP - 16</em></p></li><li><p>En la posición de memoria principal 0x4001A4 está almacenada la instrucción <code>subq    $16,%rsp</code></p></li><li><p>subq indica la operación de resta con datos enteros de 64 bits (sufijo q). Resta del operando destino el operando fuente.</p></li><li><p>El operando fuente  tiene valor decimal 16, 0x10 en hexadecimal y el direccionamiento de este operando es inmediato, es decir, su valor es 16 y está ubicado en la propia instrucción.</p></li><li><p>El operando destino está almacenado en el registro interno de la CPU denominado RSP</p></li><li><p>La referencia a la Próxima Instrucción la realiza no la instrucción sino la CPU realizando la opeación PC&#8592;PC+tamaño de la instrucción en bytes.</p></li></ul></div></li><li><p>¿Cómo interpretar una instrucción máquina  en lenguaje binario ? Es necesario consultar el <strong>Manual de Referencia de la Arquitectura ISA de la máquina x86</strong> y tener conocimientos de los modos de direccionamiento.</p></li><li><p><a href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html">manual oficial de intel x86 ó x86-64</a>: cuidado con la sintaxis intel.</p><div class="ulist"><ul><li><p>consultar el volumen 2B (capítulo 4, pag 394)para la instrucción <em>SUB</em>. Hay que tener encuenta el tamaño de los operandos y los modos de direccionamiento.</p></li><li><p>El sufijo q de la operación <strong>SUBQ</strong> indica operando de 64 bits. El operando fuente <strong>$16</strong> es referenciado con direccionamiento inmediato y se puede codificar con 8 bits y el operando destino <strong>%RSP</strong> es un registro de 64 bits. Por lo tanto la descripcion intel en el manual será <strong>SUB r64, imm8</strong> que se corresponde con el código de operación <strong>REX.W + 83 /5 ib</strong>.</p></li><li><p>La descripción del código de operación que hace intel no es sencilla y es necesario consultar la Interpretación de la Instrucción en el <strong>volumen 3 3.1 INTERPRETING THE INSTRUCTION REFERENCE PAGES</strong> y el Formato de Instrucción en el <strong>volumen 2A (capítulo 2 Formato de Instrucción)</strong></p></li><li><p>Figura 2.1 Intel 64 and IA-32 Architectures Instruction Format</p></li><li><p>El formato de instrucción tiene los campos: <strong>REXprefix-CodOp-ModRB</strong> que en nuestro caso valen <strong>48-83-EC</strong></p><div class="ulist"><ul><li><p>interpretación del campo REXprefix: <strong>REX.W</strong>: Manual &#8594; El prefijo REX se utiliza para operandos de 64 bits bien inmediatos y/o registros GlobalPurposeRegister(rax,rbx, etc), 2.2.1.2 More on REX Prefix Fields</p><div class="ulist"><ul><li><p>El primer byte es <code>48</code> &#8594; <code>01001000</code> donde el bit de la posición 3 está activado por lo que según la tabla "Table 2-4. REX Prefix Fields [BITS: 0100WRXB]" quiere decir que el <strong>operando es de 64bits</strong></p></li></ul></div></li><li><p><strong>/5</strong> : the ModR/M byte of the instruction uses only the r/m (register or memory) operand. <strong>En este caso register</strong>.Ver el subcampo R/M más abajo.</p></li><li><p><strong>ib</strong> : A 1-byte (ib) immediate operand.</p></li><li><p>Campo Primary Opcode: El segundo byte vale <code>83</code> &#8594; Operación de resta <strong>SUB</strong></p></li><li><p>Campo ModRB: El tercer byte vale <code>EC</code> &#8594; <code>1110-1100</code> hace referencia al registro RSP.</p><div class="ulist"><ul><li><p>2.1.3 ModR/M and SIB Bytes: Many instructions that refer to an operand in memory (memoria principal o registro interno CPU) ha
ve an addressing-form specifier byte (called the ModR/M &#8230;&#8203;). Este campo se divide en subcampos: <strong>Mod-Reg/Opcode-R/M</strong></p></li><li><p>Subcampo Mod: <code>11</code> : The mod field combines with the r/m field to form 32 possible values: eight registers (rax, rbx, rcx, rdx, rsi, rdi, rsp, rbp) and 24 addressing modes</p></li><li><p>Subcampo Reg/Opcode: En este caso no es Secondary Opcode sino que es Reg: rrr= <code>101</code></p></li><li><p>Subcampo R/M: En este caso R: bbb= <code>100</code> The r/m field can specify a register as an operand or it can be combined with the mod field to encode an addressing mode. <strong>En este caso es el registro operando con código 4</strong>. En la tabla 3.1 el código del <strong>quad word register</strong> con el <strong>Reg Field</strong> de valor <strong>4</strong> es el registro <strong>RSP</strong></p></li><li><p>Figure 2-5. Register-Register Addressing (No Memory Operand); REX.X Not Used &#8594; Mod=11 &#8594; Rrrr =0101 &#8594; Bbbb=0100</p></li></ul></div></li><li><p>El cuarto byte vale en hexadecimal <code>10</code> que se corresponde con el valor inmediato 16 en decimal y debe ser expandido a 64bits.</p></li></ul></div></li></ul></div></li></ul></div></li></ul></div></div></section><section id="_intel_x86_64_amd_64"><h2>26.3. Intel x86-64 / AMD 64</h2><div class="slide-content"><h level="3">sum1toN.s</h><div class="listingblock"><div class="content"><pre>	#### Programa: sum1toN.s
	### Descripción: realiza la suma de la serie 1,2,3,...N. La entrada se define en el propio programa y la salida se pasa al S.O.
	### Lenguaje: Lenguaje ensamblador de GNU para la arquitectura AMD64
	### gcc  -no-pie -g -nostartfiles -o sum1toN  sum1toN.s
	### Ensamblaje as  --gstabs sum1toN.s -o sum1toN.o
        ### linker -&gt; ld    -o sum1toN sum1toN.o
	##  Declaración de variables
	##  SECCION DE DATOS
	  .section .data

n:      .quad 5

	  .global _start

	  ##  Comienzo del código
	  ##  SECCION DE INSTRUCCIONES

	  .section .text
_start:
        movq $0,%rdi # RDI implementa la variable suma
        movq n,%rdx
bucle:
        add %rdx,%rdi
        sub $1,%rdx
        jnz bucle

        ## el argumento de salida al S.O. a través de RDI según convenio ABI AMD64
	## salida
          mov $60, %rax	# código de la llamada al sistema operativo: subrutina exit
	  syscall # llamada al sistema operativo para que ejecute la subrutina según el valor de RAX


	  .end</pre></div></div>
<h level="3">Hola Mundo</h><div class="ulist"><ul><li><p>Módulo Fuente hola_mundo.s en lenguaje ensamblador.</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-nasm" data-lang="nasm">### ----------------------------------------------------------------
### 	hola_x86-64_att.s
###
### 	Programa simple de iniciación para el desarrollo de programas en Ensamblador x86-64 AT&amp;T.
###
### 	Ficheros complementarios: macros_x86-64_gas.h
###
###
### Compilación:
### 		assemble using: as  hola_intel_gas.s -o hola_intel_gas.o
### 		link using:   	ld  hola_intel_gas.o -o hola_intel_gas
###             Driver gcc: 	gcc   -nostartfiles   hola_intel_gas.s  -o hola_intel_gas
###
### 	revised on: FEBRERO 2015 -- for Linuxs x86_64 environment
###
### ----------------------------------------------------------------
	.att_syntax

	## Incluir el fichero con las Macros
	.include "macros_x86-64_gas.h"

	## Declaración de símbolos externos
	.global	_start		# visible entry-point


	## Reserva de Memoria para datos variables
	.section	.data

msg0:	.ascii "Hola Mundo\n"
len0:	.quad	. - msg0 	#tamaño en bytes de la cadena msg0


	## Sección para el Código de las Instrucciones en Lenguaje Ensamblador
	.section .text

_start:

	## Prompt del programa: imprimir mensaje

	## Llamada al kernel para que acceda a la pantalla e imprima.
	mov 	$SYS_WRITE, %rax	# service ID-number
	mov 	$STDOUT_ID, %rdi	# device ID-number
	mov 	$msg0, %rsi		# message address
	mov 	len0, %rdx	# message length
	syscall



	## terminate this program
	mov 	$SYS_EXIT, %eax		# service ID-number
	mov 	$0, %rdi		# setup exit-code
	syscall 			# enter the kernel

	.end				# no more to assemble</code></pre></div></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code class="language-nasm" data-lang="nasm">## Macros en el fichero macros_x86-64_gas.h

## Llamadas al Sistema
.equ	STDIN_ID,  0		# input-device (keyboard)
.equ	STDOUT_ID, 1		# output-device (screen)
.equ	SYS_READ,  0		# ID-number for 'read'
.equ	SYS_WRITE, 1		# ID-number for 'write'
.equ	SYS_OPEN,  2		# ID-number for 'open'
.equ	SYS_CLOSE, 3		# ID-number for 'close'
.equ	SYS_EXIT,  60		# ID-number for 'exit'</code></pre></div></div></li></ul></div>
<h level="3">Miscellaneous</h><h level="4">Tipos de Datos</h><div class="ulist"><ul><li><p>Tipos de Datos:</p><div class="ulist"><ul><li><p>Dirección de memoria o referencia a memoria: la  etiqueta de nombre longitud</p><div class="ulist"><ul><li><p><code>mov $longitud,%edx</code>   &#8594;  <em>mov    0x8049fff,%edx</em> &#8594; en lenguage de alto nivel es la inicialización de un puntero</p></li></ul></div></li><li><p>número entero con signo : formato complemento a 2.</p><div class="ulist"><ul><li><p><code>mov    $0x4,%eax</code></p></li><li><p>El operando 0x4 está  localizado en la propia instrucción, en el campo de operando. El dato 0x4 se almacena en "little endian" &#8594; Campo de operando: double word: 32 bits 0x00000004 &#8594; En memoria ascendente : dirección 8048191: 04 00 00 00</p></li></ul></div></li><li><p>carácter: codificación ASCII</p><div class="ulist"><ul><li><p><code>08049ff4 &lt;mensaje&gt;:</code> 48 6f 6c 61 20 &#8594; H o l a SP</p></li></ul></div></li></ul></div></li></ul></div>
<h level="4">Números Reales</h><div class="ulist"><ul><li><p><a href="http://kluge.in-chemnitz.de/docs/notes/assembly.php">kluge</a></p><div class="ulist"><ul><li><p>interesantes los ejemplos de operaciones con números reales</p></li></ul></div></li></ul></div>
<h level="4">Ciclo de Instrucción</h><div class="ulist"><ul><li><p>Intervención de la CPU en la instrucción <strong>4001a4:       48 83 ec 10   &#8594;  subq    $16,%rsp</strong></p><div class="ulist"><ul><li><p>La CPU durante el ciclo de instrucción (fase captura- fase decodificación-fase ejecución) realiza una secuencia de tareas.</p></li><li><p>La secuencia de tareas a realizar la CPU durante el ciclo de instrucción lo describimos en lenguaje RTL.</p></li><li><p>MBR &#8592;M[0x4001a4]</p></li><li><p>IR  &#8592;MBR</p></li><li><p>AC  &#8592; RSP</p></li><li><p>AC  &#8592; AC-16 ; (ALU resta)</p></li><li><p>RSP &#8592; AC</p></li><li><p>PC  &#8592; PC+1</p></li><li><p>MAR &#8592; PC</p></li></ul></div></li></ul></div>
<h level="3">sum1toN.s: lenguaje intel</h><div class="ulist"><ul><li><p>Lenguaje ensamblador INTEL y assembler nasm</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-nasm" data-lang="nasm">;;; Programa: sum1toN.asm
;;; Descripción: realiza la suma de la serie 1,2,3,...N
;;; Lenguaje INTEL
;;; Assembler NASM

;;; nasm -hf -&gt; ayuda de la opción f
;;; Ensamblaje nasm -g -f elf  sum1toN.asm -o sum1toN.o
;;; linker -&gt; ld -m elf_i386    -o sum1toN sum1toN.o

	BITS 32	; cpu MODE
        ;;  Declaración de variables
        section .data

n:	dd 5	; 4 bytes

        global _start

        ;;  Comienzo del código
        section .text
_start:
        mov ecx,0 ; ECX implementa la variable suma
        mov edx,[n]  ; EDX implementa es un alias de la variable n
bucle:
        add ecx,edx
        sub edx,1
        jnz bucle

        mov ebx, ecx ; el argumento de salida al S.O. a través de EBX según convenio

        ;; salida
        mov eax,1  ; código de la llamada al sistema operativo: subrutina exit
        int 0x80     ; llamada al sistema operativo</code></pre></div></div></li></ul></div></div></section><section id="_arquitectura_arm"><h2>26.4. Arquitectura ARM</h2><div class="slide-content"><h level="3">Hola Mundo</h><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-nasm" data-lang="nasm">/*

 Programa en lenguaje ensamblador AT&amp;T para el procesador ARM

 Programa fuente: hello_world.s
 Assembler:       arm-linux-gnueabi-as -o hello_world.o hello_world.s
 Linker:          arm-linux-gnueabi-ld -o hello_world hello_world.o

*/
	.data

	msg:
	.ascii "Hello, ARM World!\n"
	len = . - msg


	.text

	.globl _start
_start:
	/* write syscall */
	mov %r0, $1
	ldr %r1, =msg
	ldr %r2, =len
	mov %r7, $4
	swi $0

	/* exit syscall */
	mov %r0, $0
	mov %r7, $1
	swi $0</code></pre></div></div>
<h level="3">ISA</h><div class="ulist"><ul><li><p><a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.subset.architecture.reference/index.html">ARM</a>: Advanced RISC Machine</p><div class="ulist"><ul><li><p><a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.subset.architecture.reference/index.html">Developer Guides</a></p></li></ul></div></li></ul></div></div></section><section id="_motorola_68000"><h2>26.5. Motorola 68000</h2><div class="slide-content"><h level="3">Hola Mundo</h><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-nasm" data-lang="nasm">;CISC Sharp X68000 (Human68K): Motorola 68000
        pea (string)    ; push string address onto stack
        dc.w $FF09      ; call DOS "print" by triggering an exception
        addq.l #4,a7    ; restore the stack pointer

        dc.w $FF00      ; call DOS "exit"

string:
        dc.b "Hello, world!",13,10,0</code></pre></div></div>
<h level="3">ISA</h><div class="ulist"><ul><li><p>Referencias</p><div class="ulist"><ul><li><p><a href="http://lux.dmcs.pl/pn/asembler_68000/asm.html">Instruction Set Basic</a></p></li><li><p><a href="https://en.wikibooks.org/wiki/68000_Assembly#Indirect_addressing_with_postincrement">Wikibook</a></p></li><li><p><a href="https://www.nxp.com/files-static/archives/doc/ref_manual/M68000PRM.pdf">Manual de Referencia</a></p></li><li><p><a href="http://www.freescale.com/files/archives/doc/ref_manual/M68000PRM.pdf">Motorola 68K ó M68000</a></p></li><li><p>m68k hasta 1991</p></li><li><p>ppc (powerpc) desde 1991 con Apple e IBM &#8594; iMac (1996-2006)</p></li></ul></div></li><li><p>arquitectura general</p><div class="listingblock"><div class="content"><pre>2 versiones: Procesador de 16 bits ó 32 bits
Aprox . 90 instrucciones máquina
12 modos de  direccionamiento
9 formatos de instrucción distintos y con tamaños de una a cinco palabras
Ancho del  bus  de datos: 16 bits ó 32 bits
Tamaño mínimo  direccionable : 1 byte
Ancho del  bus  de direcciones: 24 bits (2^24^bytes = 16 Mbytes de memoria direccionables )</pre></div></div></li><li><p>Registros:</p><div class="ulist"><ul><li><p>8 Registros de Datos de propósito general (16/32): D0-D7</p></li><li><p>7 Registros de Instrucciones de propósito general (16/32) :A0-A6</p></li></ul></div></li><li><p>modos de direccionamiento</p><div class="ulist"><ul><li><p># : inmediato</p></li><li><p>Di : registro directo</p></li><li><p>(Ai):  indirecto de registro</p></li><li><p>+(Ai): indirecto de registro con postincremento con la escala del tamaño del operando (1,2,4 bytes)</p></li><li><p>(Ai)+: indirecto de registro con postincremento con la escala del tamaño del operando</p></li><li><p>-(Ai): indirecto de registro con predecremento con la escala del tamaño del operando</p></li><li><p>(Ai)-: indirecto de registro con preincremento con la escala del tamaño del operando</p></li><li><p>D(Ai): indirecto de registro con desplazamiento D</p></li><li><p>D(Ai,Ri.X) : registro Ai indirecto indexado Ri con desplazamiento D</p></li><li><p>D(PC) : relativo al PC con desplazamiento D</p></li><li><p>D(PC,Ri.X) : relativo al PC indexado Ri con desplazamiento D</p></li></ul></div></li><li><p>Datos</p><div class="ulist"><ul><li><p>Enteros en Complemento a 2 .</p></li><li><p>Sufijos Operación: B byte (1 byte), W word (2 bytes) , L long (4 Byte)</p></li><li><p>Prejijos datos: $ hexadecimal</p></li></ul></div></li><li><p>Memoria</p><div class="ulist"><ul><li><p>Big Endian : LSB en la dirección más alta y MSB en la dirección más baja</p></li></ul></div></li></ul></div></div></section><section id="_arquitectura_mips"><h2>26.6. Arquitectura MIPS</h2><div class="slide-content"><h level="3">ISA</h><div class="ulist"><ul><li><p>Procesador con una arquitectura de 32 bits</p></li><li><p>Microprocessor without Interlocked Pipeline Stages (MIPS) Architecture</p></li><li><p>Versiones de la arquitectura MIPS:</p><div class="ulist"><ul><li><p>MIPS I ( R2000 cpu), II ( R6000), III (R4000), IV (R8000, R5000, R10000), and V (nunca implementada);</p></li><li><p>MIPS32/64 :MIPS32 is based on MIPS II with some additional features from MIPS III, MIPS IV, and MIPS V; MIPS64 is based on MIPS V</p><div class="listingblock"><div class="content"><pre>70 instrucciones máquina
Instrucciones clasificadas en cuatro grupos
	Movimiento de datos
Aritmética entera, logicas y desplazamiento
	Control de flujo
	Aritmética en punto flotante
4 modos de  direccionamiento
	Inmediato
	Directo de registros
	Indirecto con desplazamiento
	Indirecto con desplazamiento relativo al PC
Banco de 64 registros (32 bits cada uno)
	32 de propósito general (R0-R31)
	32 para instrucciones en punto flotante (F0-F31). Pueden usarse como:
	32 registros para operaciones en simple precisión (32 bits)
	16 registros para operaciones en doble precisión (64 bit)
3 formatos de instrucción distintos con longitud única de 32 bits:
	 Op Code: 6 bits
	 R :three registers, a shift amount field, and a function field;
	 I :two registers and a 16-bit immediate value
	 J :26-bit jump target
Arquitectura registro-registro
	Sólo las instrucciones de LOAD y STORE hacen referencia a memoria
	El resto de instrucciones operan sobre registros
		Instrucciones con tres operandos: 2 op.fuente y 1 op.Destino

Notación ensamblador: op  x, y, z    x&lt;-(y)op(z)
Datos:
	Enteros Complemento a 2 : byte (1B), media palabra (2B), palabra (4B)
	Nº Reales: IEEE-754 simple y doble precisión</pre></div></div></li></ul></div></li><li><p><a href="https://en.wikipedia.org/wiki/MIPS_architecture">MIPS architecture</a></p></li><li><p><a href="https://en.wikipedia.org/wiki/List_of_MIPS_architecture_processors">Versiones de la ISA MIPS</a></p></li><li><p><a href="https://en.wikipedia.org/wiki/MIPS_architecture_processors">procesadores con arquitectura MIPS</a>: R2000, etc</p></li><li><p><a href="http://logos.cs.uic.edu/366/notes/mips%20quick%20tutorial.htm">quick tutorial</a></p></li><li><p><a href="https://rivoire.cs.sonoma.edu/cs351/wemips/">Emulador MIPS Online</a></p></li></ul></div></div></section></section>
<section><section id="_toolchain_cadena_de_herramientas_en_el_proceso_de_compilación"><h2>27. Toolchain: Cadena de Herramientas en el proceso de compilación</h2></section><section id="toolchain"><h2>27.1. Toolchain</h2><div class="slide-content"><div class="ulist"><ul><li><p>Se conoce por Toolchain a los distintos programas o herramientas que intervienen en la obtención de una aplicación en lenguaje máquina a partir de módulos en lenguajes símbolicos como C, ensamblador y módulos librería.</p></li><li><p>Las 3 herramientas principales en el proceso de traducción son : el compilador, el ensamblador y el linker. También hay herramientas de análisis de los programas en lenguaje binario (Pej desensamblador).</p><div class="ulist"><ul><li><p><a href="https://sourceware.org/binutils/docs-2.25/">binutils</a>:</p><div class="ulist"><ul><li><p><a href="https://sourceware.org/binutils/docs-2.25/as/index.html"><strong>as: traductor assembler</strong></a>: opciones de la línea de comandos, directivas, tipos de datos, etc</p></li><li><p><a href="https://sourceware.org/binutils/docs-2.25/ld/index.html">ld: linker</a></p></li><li><p><a href="https://sourceware.org/binutils/docs-2.25/binutils/index.html">objdump, readelf, &#8230;&#8203;.</a></p></li></ul></div></li></ul></div></li></ul></div></div></section><section id="_proceso_de_compilación_de_un_programa_en_lenguaje_c"><h2>27.2. Proceso de compilación de un programa en lenguaje C</h2><div class="slide-content"><div class="listingblock text-center"><div class="title">Proceso de Compilación</div><div class="content"><pre>digraph G {
"Módulo Fuente C" -&gt; Preprocesamiento -&gt; Compilador -&gt; "Módulo ASM" -&gt; "Ensamblaje" -&gt; "Módulo Objeto Binario Reubicable" -&gt; Linker -&gt; "Módulo Objeto Binario Ejecutable" -&gt; "Cargador en Memoria" -&gt; "Proceso en Ejecución";
"Módulos Objeto Reubicables"-&gt; Linker;
"Módulos Objeto librería_dinámica_libc_en_memoria" -&gt; "Proceso en Ejecución";
 }</pre></div></div></div></section><section id="_traductores_del_proceso_de_ensamblaje"><h2>27.3. Traductores del proceso de ensamblaje</h2><div class="slide-content"><div class="ulist"><ul><li><p>Existen dos lenguajes ensamblador para la ISA i386/amd64, dos sintaxis diferentes, que deben de ser traducidos por diferentes traductores de ensamblador produciendo un módulo binario en el mismo lenguaje máquina.</p></li><li><p>los traductores de ensamblador  "NASM" (Netwide Asm), "FASM", "MASM", "TASM", and "YASM" traducen módulos fuente que utilizan la sintaxis del lenguaje ensamblador <strong>intel</strong> a modulos binarios para las arquitecturas i386/amd64</p></li><li><p>El traductor "as" de la fundación GNU traduce módulos fuente  que utilizan las sintaxis del lenguaje de ensamblador <strong>AT&amp;T</strong> a módulos binarios para las arquitecturas i386/amd64</p></li><li><p>La traducción entre la representación del módulo fuente en lenguaje ensamblador almacenado en un fichero del disco duro y la representación del programa en lenguaje máquina se da en el <a href="#fases_compilacion">proceso de ensamblaje</a>:</p><div class="ulist"><ul><li><p>Módulo Fuente en lenguaje ensamblador &#8594; Traductor Ensamblador &#8594; Módulo Objeto Reubicable &#8594; Linker &#8594; Módulo Objeto Ejecutable Binario&#8594; Cargador &#8594; Proceso</p><div class="ulist"><ul><li><p>Ejemplo: hola_mundo.s &#8594; <strong>as</strong> &#8594; hola_mundo.o &#8594; <strong>ld</strong> &#8594; hola_mundo (formato ELF) &#8594; <strong>loader</strong> &#8594; hola_mundo (memoria principal) &#8594; creación proceso (hola_mundo en ejecución). "as", "ld" y "loader" son las herramientas GNU necesarias para la creación de un proceso a partir del módulo en lenguaje ensamblador.</p></li><li><p>el linker <strong>ld</strong> mezcla el módulo objeto con módulos del entorno del sistema operativo y con módulos de las librerías.</p></li></ul></div></li></ul></div></li></ul></div></div></section><section id="_assembler_as"><h2>27.4. Assembler "as"</h2><div class="slide-content"><h level="3">Directivas</h><div class="ulist"><ul><li><p>Directivas del traductor ensamblador "as" utilizado por el sistema GNU/linux para el lenguaje ensamblador AT&amp;T.</p><div class="ulist"><ul><li><p>Al assembler de GNU también se el conoce como "gas".</p></li><li><p><a href="https://www.gnu.org/software/binutils/">binutils</a> &#8594; <a href="https://sourceware.org/binutils/docs-2.26/as/index.html">as assembler</a>: manual oficial</p></li><li><p><a href="http://www.coranac.com/files/gba/re-ejected-gasref.pdf">gas ref card</a></p><div class="ulist"><ul><li><p>.word reserva 2 bytes en amd64.</p></li></ul></div></li><li><p><a href="https://docs.oracle.com/cd/E26502_01/html/E28388/eoiyg.html">oracle</a></p></li><li><p><a href="https://sourceware.org/binutils/docs-2.26/as/i386_002dDependent.html#i386_002dDependent">opciones para x86 y x86-64</a></p></li></ul></div></li></ul></div>
<h level="4">Manual</h><div class="ulist"><ul><li><p><a href="https://sourceware.org/binutils/docs/as/">binutils as</a>: manual oficial</p></li><li><p><a href="http://asm.sourceforge.net/howto/Assembly-HOWTO.html">Linux Assembly howto</a>: referencias a diferentes assemblers</p></li><li><p><a href="http://web.mit.edu/gnu/doc/html/as_1.html">MIT</a></p></li></ul></div></div></section></section>
<section><section id="_practicando_la_programación_desde_el_principio"><h2>28. Practicando la Programación desde el Principio</h2></section><section id="prac_apu"><h2>28.1. Documentación: guiones, bibliografía, apuntes</h2><div class="slide-content"><div class="ulist"><ul><li><p>Disponible en miaulario:</p><div class="ulist"><ul><li><p>Apuntes <em>eecc_book.pdf</em> que incluyen los guiones, hojas de referencia, apéndices, ejercicios de autoevaluación y teoría.</p></li><li><p>Los módulos con el código fuente <strong>.s</strong> (miaulario/Recursos/prácticas/codigo_fuente.zip) <a href="https://miaulario.unavarra.es/portal/site/2018_0_240306_1/tool/d61518aa-72cb-45df-a7f8-b71f90e7907e?panel=Main">link G1</a> utilizados en todas las prácticas están disponibles en el servidor de miaulario de la <em>UPNA:Recursos/prácticas</em></p></li><li><p>El libro de texto en que se basan los guiones de prácticas en lenguaje ensamblador : <a href="#PGU"><em>Programming from the Ground-Up</em></a>.</p></li><li><p>Libro de introducción a la programación en lenguaje ensamblador : <a href="#UPC">'Programar ASM &#8230;&#8203; pero sí es muy fácil</a></p></li></ul></div></li></ul></div></div></section><section id="prac_plat_des"><h2>28.2. Plataforma de Desarrollo</h2><div class="slide-content"><h level="3">Herramientas</h><div class="ulist"><ul><li><p>Editores</p><div class="ulist"><ul><li><p><a href="https://www.tecmint.com/best-open-source-linux-text-editors/">Editores</a>: gedit, emacs, vim, sublime, kate,</p></li><li><p><a href="https://www.tecmint.com/best-linux-ide-editors-source-code-editors/">Herramientas integradas de edición,compilación,depuración</a>:  eclipse CDT, netbeans, code::blocks, codelite, Microsoft’s Visual Studio Code Editor, jetbrains clion, jeany, ajunta , GNAT Programming Studio, emacs, kdevelop, codestudio, etc</p></li></ul></div></li><li><p>Denominaciones</p><div class="ulist"><ul><li><p><code>i386</code> : denominación de linux a la arquitectura  x86-32</p></li><li><p><code>amd64</code>: denomiación de linux a la arquitectura x86-64</p></li><li><p><code>IA32</code>: denominación de Intel para la arquitectura  x86-32</p></li><li><p><code>IA64</code>: denominación de Intel para la arquitectura  x86-64</p></li></ul></div></li><li><p>Sistema Operativo GNU/linux: Distribución Ubuntu : cualquier versión posterior al año 2014: 14.04, 14.08,..,17.04, 17.08</p><div class="ulist"><ul><li><p><code>lsb_release -a</code>: distribución</p></li><li><p><code>uname -o</code> : S.O.</p></li><li><p><code>uname -r</code> : kernel</p></li><li><p><code>uname -a</code> : procesador</p></li></ul></div></li><li><p>Librerías necesarias para que las herramientas <em>gcc, as, ld</em> sean operativas en la arquitectura <strong>i386</strong> de 32 bits.</p><div class="ulist"><ul><li><p><code>dpkg -l gcc-multilib</code> :</p><div class="listingblock"><div class="content"><pre>Deseado=desconocido(U)/Instalar/eliminaR/Purgar/retener(H)
|
Estado=No/Inst/ficheros-Conf/desempaqUetado/medio-conF/medio-inst(H)/espera-disparo(W)/pendienTe-disparo
|/ Err?=(ninguno)/requiere-Reinst (Estado,Err: mayúsc.=malo)
||/ Nombre         Versión      Arquitectura Descripción
+++-==============-============-============-=================================
ii  gcc-multilib   4:7.3.0-3ubu amd64        GNU C compiler (multilib files)</pre></div></div></li><li><p>Si en las dos primeras columnas "Deseado/Estado" no pone <strong>ii</strong> significa que no están instaladas las librerías.</p><div class="ulist"><ul><li><p>Compruebo que están en el repositorio accesible a través de la red internet:</p><div class="ulist"><ul><li><p><code>apt-cache show gcc-multilib</code> : repositorio</p></li><li><p><code>sudo apt-get install gcc-multilib</code> : descarga e instalación sólo en caso de tener derechos de administridor</p></li></ul></div></li></ul></div></li></ul></div></li><li><p>Toolchain</p><div class="ulist"><ul><li><p><code>as --version &amp; ld --version &amp; gcc --version</code> : anotar las versiones</p></li></ul></div></li></ul></div>
<h level="3">Programación online</h><div class="ulist"><ul><li><p><a href="https://www.ic.unicamp.br/en/~edson/disciplinas/mc404/2017-2s/abef/IAS-Assembler/assembler.html">ias assembler unicamp online</a></p></li><li><p><a href="https://www.onlinegdb.com/classroom">gdb online</a></p></li></ul></div>
<h level="3">Referencias</h><div class="ulist"><ul><li><p>Recursos <a href="#GNU"><em>GNU</em> </a>:</p><div class="ulist"><ul><li><p>Herramienta  integrada de desarrollo IDE (Emacs,Eclipse,<a href="#VIM">Vim</a>, etc&#8230;&#8203;) o un Editor (Geany,Kate,Gedit,Sublime, etc&#8230;&#8203;)</p></li><li><p><a href="#GAS">as</a> : ensamblador del lenguaje AT&amp;T</p></li><li><p>ld : linker</p></li><li><p>cc : compilador de C</p></li><li><p><a href="#GCC">GCC</a> : front-end del toolchain automático : Gnu Compiler Collection. Driver de diferentes lenguajes dependiendo de la extensión del fichero fuente.</p><div class="ulist"><ul><li><p><code>man gcc</code></p></li></ul></div></li><li><p><a href="#GDB">GDB</a> : depurador.</p><div class="ulist"><ul><li><p><code>man gdb</code></p></li></ul></div></li></ul></div></li></ul></div></div></section><section id="prac_doc_mem"><h2>28.3. Documento Memoria: Contenido y Formato</h2><div class="slide-content"><h level="3">Contenido</h><div class="ulist"><ul><li><p>Durante el desarrollo de la práctica :</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Es necesario reeditar el código fuente de los programas desarrollados con <em>comentarios</em>.</p></li><li><p>Compilar el módulo fuente mediante <em>comandos en línea</em></p></li><li><p>Análizar el código fuente y binario mediante el <em>depurador</em>: las operaciones a realizar con el depurador es necesario salvarlas en un fichero.</p></li></ol></div></li><li><p>Durante la realización de la práctica es necesario tener abierto un Editor de texto para ir realizando la memoria simultáneamente a la ejecución de la práctica.</p></li><li><p>El Documento Memoria ha de contener:</p><div class="ulist"><ul><li><p>Una portada con el título de la práctica y los datos personales.</p></li><li><p>La primera hoja con una tabla de contenidos a modo de índice, no es necesario indicar Nº de página.</p></li><li><p>Los módulos fuente comentados,</p></li><li><p>Los comandos de compilación y análisis.</p></li><li><p>El historial de comandos GDB y sus salidas, utilizados durante la práctica.</p></li><li><p>Un apartado de conclusiones con lo aprendido en la práctica.</p></li><li><p>Un apartado de dudas sin resolver.</p></li><li><p>Preguntas explícitas que aparecen a lo largo de la memoria, si las hay.</p></li><li><p><strong>OPCIONALMENTE</strong> las preguntas y respuestas del cuestionario de Autoevaluación de Prácticas. Ver apartado Evaluación.</p></li><li><p>Todo tipo Informacion Personal Necesaria a modo de apuntes para utilizar en el exámen.</p></li></ul></div></li></ul></div>
<h level="3">Formato</h><div class="ulist"><ul><li><p>La estructura interna de la memoria es libre.</p></li><li><p>El formato de la memoria ha de ser <strong>PDF</strong>, y no microsoft word u otro formato diferente.</p></li><li><p>El nombre del fichero memoria ha de ser <strong>N-XXX-apellido1_apellido2.pdf</strong></p><div class="ulist"><ul><li><p>el nombre del ficheero no contendrá ni acentos, ni espacios en blanco</p></li><li><p>XXX significa el grupo de prácticas: P1 ó P2 ó P1P2 ó P91</p></li><li><p>N significa el número de la sesión de prácticas: 1,2,3,4 ó 5.</p></li></ul></div></li></ul></div>
<h level="3">Entrega del Documento Memoria</h><div class="ulist"><ul><li><p>Entregar el Documento Memoria a través de la aplicación <strong>Tareas</strong> del Servidor Miaulario. El plazo será el indicado por el profesor a través del calendario de tareas. La entrega de memorias fuera de plazo significa tener que examinarse de dicha práctica en la convocatoria ordinaria.</p></li></ul></div></div></section><section id="prac_eval"><h2>28.4. Evaluación</h2><div class="slide-content"><div class="ulist"><ul><li><p>Se evaluará:</p><div class="ulist"><ul><li><p>La entrega de la memoria por el canal establecido con una penalización de 1 punto por cada día de retraso.</p></li><li><p>La estructura y formato de la memoria con los datos personales, índice, introducción, desarrollo, conclusiones y formato pdf con el nombre apropiado.</p></li><li><p>Los comentarios de alto nivel (pseudocódigo) especificados en el módulo fuente tanto a nivel de bloque de instrucciones como instrucciones complicadas de interpretar o que se consideren importantes en la comprensión del código.</p></li><li><p>El cuestionario <strong>opcional</strong> de <strong>Autoevaluación de Prácticas</strong>. Si no se realizan los ejercicios de autoevaluación de prácticas y se añaden a las memorias la nota máxima de las memorias será de <strong>6 puntos</strong>.</p></li></ul></div></li></ul></div>
<div class="admonitionblock important"><table><tr><td class="icon"><i class="fa fa-exclamation-circle" title="Important"></i></td><td class="content">El profesor evaluará de forma continua la actitud y labor del estudiante en el laboratorio pudiendo liberar al alumno de la realización del exámen si los conocimientos y tareas realizadas así lo demuestran.</td></tr></table></div></div></section><section id="prac_prog"><h2>28.5. Programación</h2><div class="slide-content"><h level="3">Metodología</h><div class="ulist"><ul><li><p>Leer el enunciado del programa a desarrollar.</p></li><li><p>Editar la descripción del algoritmo como Pseudocódigo:</p><div class="ulist"><ul><li><p>Desarrollar el algoritmo definiendo las estructuras de datos y estructuras de instrucciones.</p><div class="ulist"><ul><li><p>constantes,variables, arrays, punteros, inicalizaciones, bucles, sentencias selección, funciones y parámetros, entrada y salida del programa, etc</p></li></ul></div></li></ul></div></li><li><p>Dibujar el Organigrama de alto nivel</p><div class="ulist"><ul><li><p>Para un lenguaje de alto nivel (Pascal,C &#8230;&#8203;), basado en el pseudocódigo.</p></li></ul></div></li><li><p>Dibujar Organigrama de bajo nivel</p><div class="ulist"><ul><li><p>Desarrollar el algoritmo en lenguaje <strong>RTL</strong> basándose en la arquitectura x86. Traducir el organigrama de alto nivel a bajo nivel. Traduciendo  secciones, variables, arrays, punteros, inicializaciones, bucles, sentencias selección, subrutinas y parámetros, entrada y salida del programa etc.</p></li></ul></div></li><li><p>Convertir el código RTL en lenguaje ensamblador <strong>AT&amp;T</strong> para la arquitectura x86.</p></li><li><p>Compilación con <strong>gcc</strong> o mediante la cadena de herramientas (toolchain) : <strong>as</strong>-<strong>ld</strong></p><div class="ulist"><ul><li><p>Depurar errores de síntesis.</p></li></ul></div></li><li><p>Ejecución: depurar errores en modo paso a paso mediante el depurador <strong>GDB</strong></p></li></ul></div></div></section><section id="compilacion"><h2>28.6. Compilación</h2><div class="slide-content"><h level="3">Módulo fuente en lenguaje C</h><div class="ulist"><ul><li><p>Compilación</p><div class="ulist"><ul><li><p><code>gcc -m32 -o sum1toN sum1toN.c</code></p><div class="ulist"><ul><li><p><em>m32</em> : 32 bits architecture machine</p></li><li><p><em>sum1toN.c</em> : módulo fuente en lenguaje C</p></li><li><p><em>-o</em> : output</p></li><li><p><em>sum1toN</em> sin extensión: módulo objeto ejecutable aunque sería más preciso decir cargable en la memoria principal.</p></li></ul></div></li><li><p>carga en memoria principal</p><div class="ulist"><ul><li><p>la hace automáticamente el S.O. al llamar al programa ejecutable desde un terminal o escritorio.</p></li></ul></div></li><li><p><code>gcc -m32 -g -o sum1toN sum1toN.c</code></p><div class="ulist"><ul><li><p><em>-g</em>: especifica que se genere la tabla de símbolos del programa fuente <em>sum1toN.c</em> para el debuger GDB y se inserte en el módulo ejecutable <em>sum1toN</em> . De está manera se asocian el código binario, por ejemplo de una etiqueta, a su símbolo (lenguaje texto).</p></li></ul></div></li></ul></div></li></ul></div>
<h level="3">Punto de entrada al programa: main vs <em>_start</em></h><div class="ulist"><ul><li><p>El punto de entrada al programa ha de ser nominado mediante la etiqueta <strong>_start</strong> ó <strong>main</strong>.</p><div class="ulist"><ul><li><p>Directiva <strong>global</strong>: el punto de entrada se define en el módulo fuente y se declara como global, es decir tiene que se accesible por otros programas. El punto de entrada tiene que ser accesible por el <em>linker</em> que lo declara como un símbolo definido externamente.</p></li></ul></div></li></ul></div>
<div class="admonitionblock caution"><table><tr><td class="icon"><i class="fa fa-fire" title="Caution"></i></td><td class="content">Si no se especifica la opción  -nostartfiles del compilador gcc, la etiqueta de entrada al programa ensamblador ha da ser <strong>main</strong>. Si se especifica la opción -nostartfiles entonces la entrada al programa será <strong>_start</strong></td></tr></table></div>
<div class="ulist"><ul><li><p>Compilación si el punto de entrada es <em>_start</em>: <code>gcc -nostartfiles -g -m32 -o sum1toN sum1toN.s</code></p></li><li><p>Compilación si el punto de entrada es <em>main</em>: <code>gcc -g -m32 -o sum1toN sum1toN.s</code></p></li></ul></div>
<h level="3">Fases de la compilación</h><div class="listingblock text-center"><div class="title">Proceso de Compilación</div><div class="content"><pre>digraph G {
"Módulo Fuente C" -&gt; Preprocesamiento -&gt; Compilador -&gt; "Módulo ASM" -&gt; "Ensamblaje" -&gt; "Módulo Objeto Binario Reubicable" -&gt; Linker -&gt; "Módulo Objeto Binario Ejecutable" -&gt; "Cargador en Memoria" -&gt; "Proceso en Ejecución";
"Módulos Objeto Reubicables"-&gt; Linker;
"Módulos Objeto librería_dinámica_libc_en_memoria" -&gt; "Proceso en Ejecución";
 }</pre></div></div>
<div class="ulist"><ul><li><p>Parar la compilación en la 1ª fase: preprocesamiento: <code>gcc -E sum1toN.c -o sum1toN.i</code></p><div class="ulist"><ul><li><p><em>*.i</em>: Salida del preprocesador: elimina la información que no es código (comentarios,etc)</p></li></ul></div></li><li><p>Parar la compilación en la 2ª fase: traducir C a ensamblador: <code>gcc -S sum1toN.c -o sum1toN.s</code></p><div class="ulist"><ul><li><p><em><strong>.s</em>: módulo en lenguaje fuente ensamblador <em></strong>.s</em></p></li></ul></div></li><li><p>Parar la compilación en la 3ª fase: Generar el módulo objeto reubicable: <code>gcc -c sum1toN.c -o sum1toN.o</code></p><div class="ulist"><ul><li><p><em>*.o</em>: módulo objeto reubicable : código binario antes de ser enlazado mediante el linker con otros módulos objeto del sistema operativo, de la librería de C <em>libc</em> u otros módulos del programador.</p></li></ul></div></li><li><p>Realizar las 4 fases : Generar el módulo objeto ejecutable: <code>gcc -c sum1toN.c -o sum1toN</code></p><div class="ulist"><ul><li><p>fichero sin extensión: módulo objeto ejecutable: módulo binario configurado para ser cargado en la memoria principal y ejecutado por la CPU.</p></li></ul></div></li><li><p><code>gcc -m32 --save-temps -o sum1toN sum1toN.c</code></p><div class="ulist"><ul><li><p><em>--save-temps</em>: gcc genera (save) los 3 ficheros parciales (temps) del proceso total de compilación <em><strong>.i</em>,<em></strong>.s</em>,<em>*.o</em> .</p></li><li><p>Comprobar que en total disponemos de 5 ficheros: <em><strong>.c</em>,<em></strong>.i</em>,<em><strong>.s</em>,<em></strong>.o</em> y el ejecutable sin extensión.</p></li></ul></div></li></ul></div>
<h level="3">Toolchain</h><div class="ulist"><ul><li><p>Cómo alternativa a realizar la compilación mediante un único comando con el driver <strong>gcc</strong> que ejecuta las distintas fases de compilación el proceso de compilación de puede realizar mediante el encadenamiento de herramientas que realizan cada una de ellas una de las distintas fases.</p></li><li><p>Herramientas del toolchain:</p><div class="ulist"><ul><li><p>Traducción de C a Ensamblador: no tiene una herramienta propia: <code>gcc -S sum1toN.c -o sum1toN.s</code></p></li><li><p><strong>as</strong>: Herramienta de Ensamblaje o ensamblador: <code>as --32 --gstabs -o sum1toN.o sum1toN.s</code></p><div class="ulist"><ul><li><p><em>--32</em>: arquitectura de 32 bits</p></li><li><p><em>--gstabs</em>: genera la tabla de símbolos</p></li><li><p><em>-o</em> : fichero de salida : módulo binario reubicable <em>*.o</em></p></li></ul></div></li><li><p><strong>ld</strong>: Herramienta de Enlazado ó Lincado: <code>ld -melf_i386  -o sum1toN sum1toN.o</code></p><div class="ulist"><ul><li><p><em>-melf_i386</em> : arquitectura 32 bits</p></li><li><p><em>-o</em>: fichero de salida : módulo binario ejecutable</p></li></ul></div></li></ul></div></li></ul></div>
<h level="3">módulo fuente en lenguaje ensamblador</h><div class="ulist"><ul><li><p>Comentar el programa fuente de manera abstracta funcional/operativa y no literal RTL</p></li><li><p>Toolchain manual:</p><div class="ulist"><ul><li><p><code>as --32 --gstabs -o sum1toN.o sum1toN.s</code> : ensamblaje</p><div class="ulist"><ul><li><p><em>*.s</em> : módulo fuente en lenguaje asm</p></li><li><p><em>*.o</em> : módulo objeto reubicalble</p></li><li><p><em>--stabs</em>: generación de la tabla de símbolos e inserción en el módulo ejecutable.</p></li><li><p><em>--32</em>  :  módulos fuente y objeto para la ISA de 32 bits</p></li></ul></div></li><li><p><code>ld -melf_i386 -o sum1toN sum1toN.o</code></p><div class="ulist"><ul><li><p><em>-melf_i386</em>: módulos objeto para la ISA de 32 bits</p></li></ul></div></li></ul></div></li><li><p>Toolchain automático</p><div class="ulist"><ul><li><p><code>gcc -m32 -nostartfiles -g -o sum1toN sum1toN.s</code></p><div class="ulist"><ul><li><p><em>-m32</em>: módulos fuente y objeto para la arquitectura i386.</p></li><li><p><em>-nostartfiles</em> : especifica que el punto de entrada no es main sino <em>_start</em>.</p></li></ul></div></li></ul></div></li></ul></div>
<div class="admonitionblock note"><table><tr><td class="icon"><i class="fa fa-info-circle" title="Note"></i></td><td class="content">Si el punto de entrada es <strong>main</strong> entonces es necesario informar al linker de que el punto de entrada (entry) es main:  <code>gcc  -e main -m32 -nostartfiles -g -o sum1toN sum1toN.s</code> y <code>ld -e main -melf_i386 -o sum1toN sum1toN.o</code></td></tr></table></div>
<div class="ulist"><ul><li><p><em>g</em>: especifica que se genere la tabla de símbolos del programa fuente <em>sum1toN.s</em> para el debuger GDB y se se inserte en el módulo ejecutable <em>sum1toN</em></p></li></ul></div></div></section><section id="_depuración_3"><h2>28.7. Depuración</h2><div class="slide-content"><div class="ulist"><ul><li><p>El debugger que utilizamos es el programa <em>gdb</em> de GBU : Gnu DeBugger</p></li><li><p><a href="#GDB">Manual GDB</a></p></li><li><p>Para poder depurar un programa hay que compilarlo con la opción de depuración <strong>-g</strong>:  <code>gcc -g -m32 -o sum1toN sum1toN.s</code></p><div class="ulist"><ul><li><p>comprobar con <code>file sum1toN</code> que contiene los símbolos para la depuración</p></li></ul></div></li><li><p>Ejecutar <code>gdb</code> &#8594; se abre la ventana de comandos del depurador  . El prompt es (gdb)</p><div class="listingblock"><div class="content"><pre>(gdb) file sum1toN -&gt; reading symbols from binary program
(gdb) breakpoint main -&gt; añade un punto de ruptura donde se detendrá la ejecución
(gdb) run -&gt; ejecución
(gdb) layout src ó Contol-x Control-a -&gt; se añade la ventana con el código fuente
(gdb) focus src ó Conrol-x o -&gt; se cambia de ventana donde están activadas las flechas del teclado para poder navegar.</pre></div></div></li><li><p>Las expresiones que emplean los comandos están en el lenguaje de programación de C</p><div class="listingblock"><div class="content"><pre>print &amp;sum -&gt; imprime la dirección de la variable sum
print sum  -&gt; imprime el contenido de la variable sum
print *sum_pointer -&gt; imprime el contenido del objeto al que apunta el puntero sum_pointer</pre></div></div></li></ul></div></div></section><section id="_errores_comunes"><h2>28.8. Errores Comunes</h2><div class="slide-content"><h level="3">gcc</h><div class="ulist"><ul><li><p>En Ubuntu 18.0 si se compila para amd64 (gcc -nostartfiles -g -o sum1to64 sum1to64.s) la compilación se detiene con el mensaje de error:</p><div class="listingblock"><div class="content"><pre>/usr/bin/x86_64-linux-gnu-ld: /tmp/ccbhD6Vr.o: relocation R_X86_64_32S against `.data' can not be used when making a PIE object; recompile con -fPIC
/usr/bin/x86_64-linux-gnu-ld: falló el enlace final: Sección no representable en la salida
collect2: error: ld returned 1 exit status</pre></div></div>
<div class="ulist"><ul><li><p>causa: está activada por defecto al opción -pie y hay que desactivarla</p></li><li><p>solución: (gcc <strong>-no-pie</strong> -nostartfiles -g -o sum1to64 sum1to64.s)</p></li></ul></div></li></ul></div>
<h level="3">gdb</h><div class="ulist"><ul><li><p>El logging histórico de los comandos gdb para salvarlos en un fichero se encuentra desactivado</p></li></ul></div></div></section><section id="_programar_y_depurar_desde_cero"><h2>28.9. Programar y Depurar desde cero</h2><div class="slide-content"><h level="3">Empezando: ASM</h><h level="4">herramientas</h><div class="ulist"><ul><li><p><code>gdb --version</code></p></li><li><p><code>gcc --version</code></p></li></ul></div>
<h level="4">Módulo fuente ASM</h><div class="ulist"><ul><li><p>sum1toN.s</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-nasm" data-lang="nasm">### Programa: sum1toN.s
### Descripción: realiza la suma de la serie 1,2,3,...5
### gcc -m32 -g -nostartfiles -o sum1toN sum1toN.s
### Ensamblaje as --32 --gstabs fuente.s -o objeto.o
### linker -&gt; ld -melf_i386 -I/lib/i386-linux-gnu/ld-linux.so.2   -o ejecutable objeto.o -lc

        ##  Declaración de variables
        .section .data

n:	.int 5

        .global _start

        ##  Comienzo del código
        .section .text
_start:
        mov $0,%ecx # ECX implementa la variable suma
        mov n,%edx
bucle:
        add %edx,%ecx
        sub $1,%edx
        jnz bucle

        mov %ecx, %ebx # el argumento de salida al S.O. a través de EBX según convenio

        ## salida
        mov $1, %eax  # código de la llamada al sistema operativo: subrutina exit
        int $0x80     # llamada al sistema operativo


        .end</code></pre></div></div></li></ul></div>
<h level="4">Compilación</h><div class="ulist"><ul><li><p>Con <em>_start</em>: <code>gcc -nostartfiles -g -m32 -o sum1toN sum1toN.s</code></p></li><li><p>Con <em>main</em>: <code>gcc -g -m32 -o sum1toN sum1toN.s</code></p></li></ul></div>
<h level="4">Propiedades Módulo Binario</h><div class="ulist"><ul><li><p>Módulo Binario: <code>file sum1toN</code></p></li></ul></div>
<h level="4">Ejecución</h><div class="ulist"><ul><li><p><code>./sum1toN</code></p></li><li><p><code>echo $?</code></p></li></ul></div>
<h level="4">Depurando</h><div class="ulist"><ul><li><p>Depurador <code>gdb</code></p><div class="listingblock"><div class="content"><pre>file sum1toN
layout src  ó Control-x Control-a
break main ó b main
run ó r
rTAB    -&gt; autocompletado
help r  -&gt; ¿ r es run?
print n ó p n
print /x n
p /t n
p /o n
next ó n
n 6
continue ó c
start ó s
n 6
p $ecx

set $ecx=-1
p $ecx
info regs
layout regs
layout src

set var n=10
set var &amp;n=10
set var {int}&amp;n=10
set var {int *}&amp;n=10

set var {char[10]}&amp;n="Hola"
p /s n

set $pc=&amp;main

quit</pre></div></div>
<div class="listingblock"><div class="content"><pre>info sources
shell ls
help layout
layout src
layout asm
layout split
help p
  formatos de print: /t /x /o /s /a</pre></div></div></li></ul></div>
<h level="3">Empezando: C</h><div class="ulist"><ul><li><p>sum1toN.c</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">/*
Programa: sum1toN.c

gcc -g -m32 -o sum1toN sum1toN.c
file sum1toN
./sum1toN
echo $?

*/

// Declaración de la función exit()
#include &lt;stdlib.h&gt;

// Módulo Principal
int  main (void) {
  //Declaración de variables locales e inicialización de los parámetros del bucle
  int sum=0,n=5;
  //Bucle que genera los sumandos y realiza la suma
  while(n&gt;0){ 	//Condición de salida del bucle cuando el sumando es negativo
    sum+=n;
    n--;     	//Actualización del sumando
  }
  exit (sum);
}	   	//exit: finaliza la ejecución del programa y devuelve el argumento sum al S.operativo.</code></pre></div></div></li><li><p>Compilación: <code>gcc -g -m32 -o sum1toN sum1toN.c</code></p></li><li><p>Módulo Binario: <code>file sum1toN</code></p></li><li><p>Depurador <code>gdb</code></p><div class="listingblock"><div class="content"><pre>file sum1toN
layout src
break main
run
next
continue
start
next 6
print sum
quit</pre></div></div>
<div class="listingblock"><div class="content"><pre>file sum1toN  -&gt; symbols table confirmation
layout src
breakpoint main ó b main
r ó run
h l ó help list
n ó next -&gt; ejecutar siguiente línea del módulo fuente
n 6  -&gt; ejecuta 6 veces n
c ó continue
s ó start
q ó quit</pre></div></div></li></ul></div>
<div class="listingblock"><div class="content"><pre>ptype sum
whatis sum
p /d sum
p /x sum
p /t sum
p /o sum
p /a &amp;sum
p sum
p &amp;sum
set var sum=22
p sum
set var {int}&amp;sum=-3
p /x sum</pre></div></div>
<div class="paragraph"><p>+</p></div>
<div class="listingblock"><div class="content"><pre>info sources
shell ls
help layout
layout src
layout asm
layout split</pre></div></div></div></section></section>
<section><section id="_llamadas_al_sistema_operativo_2"><h2>29. Llamadas al Sistema Operativo</h2></section><section id="llamadas_SO"><h2>29.1. Introducción</h2><div class="slide-content"><div class="ulist"><ul><li><p>Se conoce con el nombre de <em>llamadas al sistema</em> a las Llamadas que realizar el programa de usuario a subrutinas del Kernel del Sistema Operativo.</p></li><li><p>Para realizar funciones privilegiadas del sistema operativo como el acceso a los dispositivos i/o de la computadora es necesario que los programas de usuario llamen al kernel para que sea éste quien realice la operación de una manera segura y eficaz. De esta forma se evita que el programador de aplicaciones acceda al hardware y al mismo tiempo se facilita la programación.</p></li><li><p>Ejemplos de llamadas</p><div class="ulist"><ul><li><p><strong>exit</strong> : el kernel suspende la ejecución del programa eliminando el proceso</p></li><li><p><strong>read</strong> : el kernel lee los datos de un fichero accediendo al disco duro</p></li><li><p><strong>write</strong>: el kernel escribe en un fichero</p></li><li><p><strong>open</strong> : el kernel abre un fichero</p></li><li><p><strong>close</strong>: el kernel cierra el proceso</p></li><li><p>más ejemplos de llamada en el listado <code>man 2 syscalls</code></p></li></ul></div></li><li><p>La llamada a los servicios del kernel denominados <em>syscalls</em> se puede realizar de dos formas: <strong>directa</strong> o <strong>indirecta</strong></p><div class="ulist"><ul><li><p>Directa: desde ASM mediante la instrucción <code>syscall</code></p></li><li><p>Indirecta: desde C o ASM mediante funciones de la librería <code>libc</code>: wrappers de las llamadas directas</p></li></ul></div></li><li><p>API/ABI</p><div class="listingblock"><div class="content"><pre> system call wrapper () -&gt; C function
          |
          | INDIRECTA
          v
+------------------------+
|     C library libc     |    syscall -&gt; assembly instruction
|         |              |
|         |              |      |
|         |              |      |DIRECTA
|         |              |      |
+---------|--------------+------|----+-------ABI
|         v                     v    |
|              kernel                |
|        (syscall functions)         |
+------------------------------------+
               HW</pre></div></div></li><li><p>Ejemplo</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">* printf() -&gt; write(int fd, const void *buf, size_t count) -&gt; [RAX-RDI-RSI-RDX-R10-R8-R9,syscall] -&gt; kernel syscall write
* API      -&gt;        wrapper function                      -&gt;                ABI                  -&gt;  kernel syscall</code></pre></div></div></li></ul></div></div></section><section id="_manuales_de_las_llamadas"><h2>29.2. Manuales de las llamadas</h2><div class="slide-content"><div class="ulist"><ul><li><p>Los syscall están descritos en los manuales de los wrappers de la librería libc</p></li><li><p>listado de los syscall</p><div class="ulist"><ul><li><p><code>info syscalls</code> o <code>man syscalls</code></p></li></ul></div></li><li><p>syscalls:</p><div class="ulist"><ul><li><p>exit  &#8594; <code>man 3 exit</code></p></li><li><p>read  &#8594; <code>man 2 read</code></p></li><li><p>write &#8594; <code>man 2 write</code></p></li><li><p>open  &#8594; <code>man 2 open</code></p></li><li><p>close &#8594; <code>man 2 close</code></p></li><li><p>etc..</p></li></ul></div></li><li><p>Los argumentos de la llamada al sistema son los asociados a la función wrapper de la biblioteca libc.</p><div class="ulist"><ul><li><p>El 1º argumento de la llamada al sistema es el argumento de la IZDA de la función en libc y el último el de la DCHA.</p></li></ul></div></li></ul></div></div></section><section id="_llamada_indirecta"><h2>29.3. Llamada INDIRECTA</h2><div class="slide-content"><div class="ulist"><ul><li><p><strong>C</strong>: El programador de aplicaciones en C utiliza las funciones interfaz de la librería <em>libc</em> de GNU para acceder <strong>indirectamente</strong> al kernel a través de los <em>contenedores (wrapper)</em>.</p><div class="ulist"><ul><li><p>system calls wrapper: adaptación al lenguaje C de las llamadas implementadas en lenguaje ASM</p></li></ul></div></li></ul></div></div></section><section id="_llamada_directa"><h2>29.4. LLamada DIRECTA</h2><div class="slide-content"><div class="ulist"><ul><li><p><strong>ASM</strong>: El programador de aplicaciones en lenguaje ASM utiliza las <em>llamadas al sistema</em> para acceder <strong>directamente</strong> al kernel</p><div class="ulist"><ul><li><p>La llamada se realiza mediante la instrucción ensamblador <code>syscall</code> en x86-64 y <code>int $0x80</code> en x86-32</p></li><li><p>Los argumentos de la llamada se pasan a través de los registros de propósito general GPR</p></li><li><p>El tipo de llamada se especifica a través de un número entero y se pasa a través <strong>RAX</strong></p><div class="ulist"><ul><li><p>Códigos "System call number" disponibles en el fichero <em>/usr/include/asm/unistd_32.h</em></p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">## Macros en el fichero macros_x86-64_gas.h

## Llamadas al Sistema
.equ	STDIN_ID,  0		# input-device (keyboard)
.equ	STDOUT_ID, 1		# output-device (screen)
.equ	SYS_READ,  0		# ID-number for 'read'
.equ	SYS_WRITE, 1		# ID-number for 'write'
.equ	SYS_OPEN,  2		# ID-number for 'open'
.equ	SYS_CLOSE, 3		# ID-number for 'close'
.equ	SYS_EXIT,  60		# ID-number for 'exit'</code></pre></div></div></li></ul></div></li></ul></div></li></ul></div>
<h level="3">Argumentos de la llamada directa</h><div class="ulist"><ul><li><p>El convenio de la llamada está descrito en la norma ABI</p></li><li><p>x86-64</p><div class="ulist"><ul><li><p>Los 6 primeros argumentos de la llamada se pasan a través de los registros siguiendo la secuencia: <strong>RDI-RSI-RDX-R10-R8-R9</strong></p></li><li><p>El valor de retorno de la llamada se pasa a través del registro <strong>RAX</strong></p></li></ul></div></li><li><p>x86-32</p><div class="ulist"><ul><li><p>Los 6 primeros argumentos se pasan a través de de los registros siguiendo la secuencia: <strong>EBX-ECX-EDX-ESI-EDI-EBP</strong></p></li><li><p>El valor de retorno de la llamada se pasa a través del registro <strong>EAX</strong></p></li></ul></div></li><li><p>manual libc: Información sobre cuáles son los argumentos de las llamadas</p></li></ul></div>
<h level="3">Códigos de la llamada directa</h><div class="ulist"><ul><li><p>El código de llamada es un número entero asociado a la función que va a ejecutar el kernel</p></li><li><p>El código de llamada se pasa al kernel a través de <strong>RAX</strong></p></li><li><p>Códigos:</p><div class="ulist"><ul><li><p><em>/usr/include/asm/unistd_64.h</em>: declaración de macros con el código de la llamada en la arquitectura x86-64</p><div class="ulist"><ul><li><p>exit &#8594; 60, read &#8594; 0, write &#8594; 1, open &#8594; 2, close &#8594; 3, etc..</p></li></ul></div></li><li><p><em>/usr/include/asm/unistd_32.h</em> : declaración de macros con el código de la llamada en la arquitectura x86-32</p></li><li><p><em>/usr/include/bits/syscall.h</em>  : macros antiguas también válidas en la arquitectura x86-32</p></li></ul></div></li></ul></div></div></section><section id="_ejemplos_lenguaje_c"><h2>29.5. Ejemplos: lenguaje C</h2><div class="slide-content"><div class="ulist"><ul><li><p><code>exit (status_value)</code> y <code>syscall(exit_code,status_value)</code></p><div class="ulist"><ul><li><p>exit(0xFF) y syscall(60,0xFF)</p></li></ul></div></li><li><p><code>write (int fd, const void *buf, size_t count)</code> y <code>syscall(write_code,int fd, const void *buf, size_t count)</code></p><div class="ulist"><ul><li><p>write (0,buffer,80) y syscall(1,1,buffer,80)</p></li></ul></div></li></ul></div></div></section><section id="_ejemplos_asm_indirecto"><h2>29.6. Ejemplos: ASM INDIRECTO</h2><div class="slide-content"><div class="ulist"><ul><li><p>Programando en lenguaje ASM podemos llamar a los wrappers de la librería libc.</p></li><li><p><code>exit(status_value)</code></p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">mov $status_value,%rdi
call exit</code></pre></div></div></li><li><p><code>syscall(exit_code,status_value)</code></p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">mov $60,%rax
mov $status_value,%rdi
call syscall</code></pre></div></div></li><li><p><code>write(int fd, const void *buf, size_t count)</code></p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">mov fd,%rdi			#fd es la refencia al fichero donde se va a escribir
mov $buffer_address_label, %rsi #dirección de memoria de lo que se va a escribir en el fichero
mov size,%rdx			#tamaño del buffer de memoria que se va a escribir
call write			#orden de escritura al kernel a través de la librería libc</code></pre></div></div></li><li><p><code>syscall(write_code,int fd, const void *buf, size_t count)</code></p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">mov $1,%rax
mov $1,%rdi			# 1 es el código del fichero pantalla. En unix los dispositivos son ficheros.
mov $buffer_address_label,%rsi
mov size,%rdx
call syscall</code></pre></div></div></li></ul></div></div></section><section id="_ejemplos_asm_directo"><h2>29.7. Ejemplos: ASM DIRECTO</h2><div class="slide-content"><div class="ulist"><ul><li><p>exit</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">mov $60,%rax
mov $status_value,%rdi
syscall</code></pre></div></div></li><li><p>write</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">mov $1,%rax
mov $1,%rdi			# 1 es el código del fichero pantalla. En unix los dispositivos son ficheros.
mov $buffer_address_label,%rsi
mov size,%rdx
syscall</code></pre></div></div></li></ul></div></div></section><section id="_línea_de_comandos_2"><h2>29.8. Línea de Comandos</h2><div class="slide-content"><h level="3">Procedimiento</h><div class="ulist"><ul><li><p>Process Initialization</p><div class="ulist"><ul><li><p>Cuando escribimos un comando o programa  en la línea de comandos del shell el sistema operativo los interpreta como una secuencia de strings. Por ejemplo <code>$suma 2 3</code> son tres argumentos en la línea de comandos:</p><div class="ulist"><ul><li><p>La codificación de un string es la secuencia de sus caracteres en código ASCII y finalizada con el caracter NULL cuyo código es 0x00</p></li><li><p>el string "suma": 5 caracteres ASCII: 0x73,0x75,0x6d,0x61,0x00</p></li><li><p>el string "2"   : 2 caracteres ASCII: 0x32,0x00</p></li><li><p>el string "3"   : 2 caracteres ASCII: 0x33,0x00</p></li><li><p>Como son 3 los argumentos de la línea el parametro argument counter <strong>argc</strong> valdrá 3.</p></li></ul></div></li><li><p>Los tres strings de la línea de comandos, "suma"-"2"-"3", son asignados a la variable array de strings <em>argv</em></p><div class="ulist"><ul><li><p>argv[0] apunta al string "suma"</p></li><li><p>argv[1] apunta al string "2"</p></li><li><p>argv[2] apunta al string "3"</p></li><li><p>argv[argc] apunta al caracter NULL</p></li><li><p>argv es una array de punteros, por lo tanto, es del tipo (char **)argv</p></li></ul></div></li></ul></div></li><li><p>kernel</p><div class="ulist"><ul><li><p>El kernel declara el prototipo <code>extern int main (int argc , char* argv[] , char* envp[]) ;</code></p></li><li><p>declaración y definición del módulo principal <code>main</code></p><div class="ulist"><ul><li><p>La función <code>main</code> es declarada como global por el kernel y es definida por el usuario.</p></li></ul></div></li><li><p><em>argc</em> is a non-negative argument count;</p></li><li><p><em>argv</em> is an array of argument strings, with argv[argc]==0;</p></li><li><p><em>envp</em> is an array of environment strings, also terminated by a null pointer.</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-C" data-lang="C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

/*
 * Introducimos en la línea de comandos el programa y un argumento
 * Si el argumento tiene espacios en blanco, entrecomillarlo con comillas simples:'Hola Mundo'
 * gcc -g -o linea_comandos linea_comandos.c
 * ./programa 'Hola Mundo'
 */

int  main (int parc, char *parv[])
{
  if (parc==1){
    printf("Introducimos en la línea de comandos cualquier mensaje\n\n");
    exit (EXIT_FAILURE);
  }
  printf("%s\n",parv[1]);
  return EXIT_SUCCESS;
}</code></pre></div></div></li></ul></div></li></ul></div>
<h level="3">Stack Initialization</h><div class="ulist"><ul><li><p>Cuando comienza a ejecutarse al función <em>main()</em> o la instrucción <em>_start</em> el estado de la pila es el siguiente:</p></li><li><p>Stack Initialization</p><div class="ulist"><ul><li><p>El kernel pasa los argumentos <strong>argc</strong> y <strong>argv</strong> de la función global main a través de la PILA. La función main es la función llamada.</p><table class="tableblock frame-all grid-all" style="width:50%"><caption class="title">Table 19. Convenio ABI: Stack</caption><colgroup><col style="width:50%" /><col style="width:50%" /></colgroup><thead><tr><th class="tableblock halign-left valign-top">Stack Reference</th><th class="tableblock halign-center valign-top">Interpretation</th></tr><tbody><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-center valign-top"><p class="tableblock">arguments strings</p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">1 word cada variable</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">Environment pointers</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">8+8*argc(%rsp)</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">8*argc(%rsp)</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">- pointer to argcº string</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">- - - - - - - -</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">- - - - - - - - - - -</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">16(%rsp)</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">- pointer to 2º argument string &#8594; argv[1]</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">8(%rsp)</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">- pointer to 1º argument string &#8594; string argv[0]</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">0(%rsp)</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">- argument count &#8594; argc</p></td></tr></table></li></ul></div></li></ul></div>
<h level="3">Rutina principal con Retorno</h><div class="ulist"><ul><li><p>Si la rutina principal no termina con la llamada <strong>exit</strong> y termina con la instrucción <strong>ret</strong> el convenio de llamada es el de llamada a función por lo que los parámetros <em>argc</em> y <em>argv</em> se pasan a través de los registros <strong>RDI-RSI-RDX-RCX-R8-R9</strong></p></li><li><p>Ejemplo: <em>imprimir_arg.s</em></p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">### gcc imprimir_arg.s
### ./a.out 'Hola Mundo'
###
###

        .equ STDOUT,1
        .equ SYSWRITE,1
        .equ EXIT_SUCCESS,0XFF
        .equ ARGV1,8


mensaje:
        .ascii "Introducir un mensaje como argumento del programa. Si el mensaje tiene espacios blancos, poner el mensaje entre comillas simples ''\n"
        .equ LON,. - mensaje    #longitud del mensaje

        .section .text
        .global main
main:
        push %rsi               #salvo el argumento argv
        ## comprobar que la ĺínea de comandos tiene dos argumentos
        cmp $2,%rdi
        je imp_arg
        ## si solo tengo el programa sin argumentos :imprimir en la pantalla
        mov $SYSWRITE,%rax
        mov $STDOUT,%rdi        #fd es la refencia al fichero donde se va a escribir
        mov $mensaje, %rsi               #dirección de memoria de lo que se va a escribir en el fichero
        mov $LON,%rdx                   #tamaño del buffer de memoria que se va a escribir
        syscall                  #orden de escritura al kernel
        jmp salida
imp_arg:
        pop  %rsi           #el stack pointer apunta al %rsi salvado y lo recupero -&gt; argv -&gt; argv[0]
        add $ARGV1, %rsi    #rsi apunta al primer puntero, si le sumo 8 apunto al segundo puntero
        mov (%rsi), %rdi    #mediante la indirección tengo el segundo puntero
        call puts

salida:
        ret

        .end</code></pre></div></div></li></ul></div>
<h level="3">Ejercicios: suma_linea_com.s ,maximum_linea_com.s</h><div class="olist arabic"><ol class="arabic"><li><p>suma_linea_com.s</p><div class="ulist"><ul><li><p>Introducir los datos del programa <em>suma_linea_com.s</em> (suma de dos sumandos) a través de la línea de comandos</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">### función: sumar dos números enteros de un dígito.
###          los sumandos se pasan a través de la línea de comandos
        ## Compilación en la arquitectura x86-64
        ## gcc  -nostartfiles -g -o sum_input sum_imput.s
        ## run 5 7
        ##  x /x  %rsp              -&gt;3                 argc:número de argumentos
        ##  x /a  (char**)($rsp+8)  -&gt; 0xffffd0a4:	0xffffd26e
        ##  x /c  *(char**)($rsp+8) -&gt; 0xffffd26e:	47 '/'
        ##  x /s  *(char**)($rsp+8) -&gt; 0xffffd26e:	 "/home/candido/tutoriales/as_tutorial/algoritmos_x86-32/basicos/sum_input"
        ##  p /s *(char**)($rsp+8)  -&gt; 0xffffd26e "/home/candido/tutoriales/as_tutorial/algoritmos_x86-32/basicos/sum_input"
        ##  x /s  *(char**)($rsp+16) -&gt; 0xffffd2b7:	 "5"
        ##  x /s  *(char**)($rsp+24) -&gt; 0xffffd2b9:	 "7"

        .section .text
.globl _start
_start:

        ## instrucciones aclaratorias

	lea 8(%rsp),%rax       #eax contiene argv[1] la dirección de la pila que contiene el pointer al argumento string
        mov 8(%rsp),%rbx       #ebx tiene el contendio de la pila= dirección del string
        xor %rcx,%rcx
        movb (%rbx),%cl        #caracter ASCII

        ## string argument pointers
        mov 16(%rsp),%rax       #eax tiene el contendio de la pila= dirección del string. argv[2]
        mov 24(%rsp),%rbx       #eax tiene el contendio de la pila= dirección del string. argv[3]
        ## fetch string indirect
        ## convert ascii numbers to values
        xor %rcx,%rcx
        xor %rdx,%rdx
        movb (%rax),%cl         # indirección para acceder al string referenciado por argv[1]
        movb (%rbx),%dl         # indirección para acceder al string referenciado por argv[1]
        sub $0x30,%rcx
        sub $0x30,%rdx

        mov %rcx,%rsi
        mov %rdx,%rdi

        call suma

	## salida
        mov %rax,%rdi
	mov  $60, %rax	    #1 is the exit() syscall
	syscall


### Función que calcula la suma entre dos valores
	.type suma, @function
	.section .text
suma:
	## prologo
	push %rbp
	mov %rsp,%rbp
	sub $8,%rsp            #reserva de memoria

	## captura de argumentos
	mov %rdi,%rax      #1º argumento
	mov %rsi,%rcx     #2º argumento
	## cuerpo
	addl %ecx,%eax          #
	## guardar resultado
	## el resultado está en EAX
salto:
	## epilogo

	mov %rbp,%rsp           # frame anterior
	pop %rbp
	ret                     # recuperar dirección de retorno</code></pre></div></div></li></ul></div></li><li><p>maximum_linea_com.s</p><div class="ulist"><ul><li><p>Introducir los datos del programa <em>maximum_linea_com.s</em> a través de la línea de comandos</p></li></ul></div></li></ol></div></div></section></section>
<section><section id="_pila"><h2>30. Pila</h2></section><section id="pila"><h2>30.1. Concepto</h2><div class="slide-content"><div class="ulist"><ul><li><p>Stack ó Pila:</p><div class="ulist"><ul><li><p>Estructura de Datos Last Input First Output (LIFO)</p></li></ul></div></li><li><p>Memoria Externa</p></li><li><p>Dirección de apilamiento: En sentido de direcciones de memoria DECRECIENTE.</p></li><li><p>Un programa está estructurado en segmentos: Segmento datos, Segmento instrucciones, Segmento pila, &#8230;&#8203;</p><div class="ulist"><ul><li><p>Memoria Principal Segmentada:</p><div class="listingblock"><div class="content"><pre> 0x00000000+---------+
           | cBLU    |
           |         |
           +---------+
           |         |
           | Segmento|
           | Datos   |
           |         |
           +---------+
           |         |
           | Segmento|
           | Instruc.|
           |         |
           +---------+
           |         |
           | Segmento|
           | Pila    |
           |         |
           +---------+
           |         |
           | cBLU    |
           |         |
 0xFFFFFFFF+---------+
           &lt;-4Bytes--&gt;</pre></div></div></li></ul></div></li></ul></div></div></section><section id="_anchura"><h2>30.2. Anchura</h2><div class="slide-content"><div class="ulist"><ul><li><p>Anchura de la pila &#8594; Word Size :</p><div class="ulist"><ul><li><p>En el caso de x86-64 : anchura de 64 bits</p></li><li><p>En la arquitectura i386 son 32 bits</p></li></ul></div></li><li><p>Alineamiento de memoria de pila&#8594; múltiplos del word size</p><div class="ulist"><ul><li><p>En el caso de x86-64 : múltiplos de 8 bytes (64 bits) &#8594; Direcciones en hexadecimal finalizadas en 0 y en 8.</p></li><li><p>Si el dato a apilar es menor que la anchura de la pila será necesario extenderlo. El tipo de extensión dependerá del tipo de dato (entero con signo, etc)</p></li></ul></div></li><li><p>Segmento Pila de la arquitectura i386:</p><div class="listingblock"><div class="content"><pre> 0x00000000+---------+
           | cBLU    |
           |         |
           +---------+
 0xA0000000|  cDDD   |
           +---------+
 0xA0000004|  cBBB   |
           +---------+
 0xA0000008|  cBBB   |
           +---------+
 0xA000000C|  c999   |
           +---------+
 0xA0000010|  c999   |
           +---------+
 0xA0000014|  c999   |
           +---------+
 0xA0000018|  c999   |
           +---------+
 0xB000001C|         |
           | cBLU    |
           |         |
 0xFFFFFFFF+---------+
           &lt;-4Bytes--&gt;</pre></div></div></li></ul></div></div></section><section id="_frame_frame_pointer_y_stack_pointer"><h2>30.3. Frame: frame pointer y stack pointer</h2><div class="slide-content"><div class="ulist"><ul><li><p>Frame: Partición de la sección pila</p><div class="ulist"><ul><li><p>Cada función que es llamada genera un frame</p></li><li><p>Los límites del <strong>frame activo</strong>  se señalan con dos punteros:</p><div class="ulist"><ul><li><p>límite inferior: frame pointer, señala la ubicación del <em>primer</em> elemente apilado.</p></li><li><p>límite superior: stack pointer, señala la ubicación del <em>último</em> elemento apilado.</p></li></ul></div></li></ul></div></li><li><p>Stack Pointer (<strong>sp</strong>)</p><div class="ulist"><ul><li><p>Puntero que apunta al elemento TOP del frame: límite alto de la pila  donde se ubica el último elemento apilado.</p></li><li><p>En intel x86 es el registro RSP</p></li></ul></div></li><li><p>Frame pointer (<strong>fp</strong>)</p><div class="ulist"><ul><li><p>Puntero que apunta al elemento BOTTOM del frame : límite bajo de la pila  donde se ubica el primer elemento apilado.</p></li><li><p>En intel x86 es el registro RBP</p></li></ul></div></li><li><p>Sección de Pila (partición en Frames)</p><div class="listingblock"><div class="content"><pre> Address   ---DRAM----
 0x00000000+---------+    0x00000000+---------+      0x00000000+---------+      0x00000000+---------+
           |         |              |         |                |         |                |         |
           +         |              +         |                +         |                +         |
           | cBLU    |              | cBLU    |                | cBLU    |                | cBLU    |
           |         |              |         |                |         |                |         |
           +---------+              +         +                +         +                +         +
 0xA0000000|  cDDD   |              |         |                |         |                |         |
           +---------+              +         +                +         +                +---------+
 0xAFFFFFF9|  cBBB   |              |         |                |         |           sp-&gt; |         |
           +---------+              +         +                +         +                +  printf +
           |  cBBB   |              |         |                |         |                |         |&lt;-fp
           +---------+              +         +                +---------+                +---------+
 0xAFFFFFFD|  c999   |              |         |                |         | &lt;-sp           |         |
           +---------+              +         +                + sumMtoN +                + sumMtoN +
           |  c999   |              |         |           fp-&gt; |         |                |         |
           +---------+              +---------+                +---------+                +---------+
           |  c999   |              |         | &lt;-sp           |         |                |         |
           +---------+              +   main  +                +  main   +                +  main   +
           |  c999   |         fp-&gt; |         |                |         |                |         |
           +---------+              +---------+                +---------+                +---------+
 0xB0000000|         |              |         |                |         |                |         |
           | cBLU    |              | cBLU    |                |  cBLU   |                |  cBLU   |
           |         |              |         |                |         |                |         |
 0xFFFFFFFF+---------+    0xFFFFFFFF+---------+      0xFFFFFFFF+---------+      0xFFFFFFFF+---------+
           &lt;--Word---&gt;
   	        (a)                    (b)                        (c)                         (d)</pre></div></div></li><li><p>(a) La pila no esta formada</p></li><li><p>(b) llamada a main: se forma el frame de main. El frame crece y decrece según apilamos y extraemos</p></li><li><p>(c) llamada de main a sumMtoN: el frame sumMtoN se forma sobre el anterior de main: nuevos punteros FP y SP.</p></li><li><p>(d) llamada de sumMtoN a printf: el frame printf se forma sobre el anterior de sumMtoN: nuevos punteros FP y SP.</p></li></ul></div>
<div class="admonitionblock note"><table><tr><td class="icon"><i class="fa fa-info-circle" title="Note"></i></td><td class="content">La pila es una estructura dinámica que se genera en el momento de la llamada de una función y desaparece con el retorno de la función</td></tr></table></div></div></section><section id="_instrucciones_ensamblador_push_pop"><h2>30.4. Instrucciones Ensamblador Push-Pop</h2><div class="slide-content"><div class="ulist"><ul><li><p>Instrucción Push-Pop : Apilamiento-Extracción</p><div class="ulist"><ul><li><p>Push Op_source</p><div class="ulist"><ul><li><p>Operación: insertar dato.</p></li><li><p>Operando destino: la pila.</p></li><li><p>El stack pointer se DECREMENTA en una palabra . SP &#8592; SP-1*WordSize y después se inserta el operando fuente en el destino.</p></li></ul></div></li><li><p>Pop Op_dest</p><div class="ulist"><ul><li><p>Operación: extraer dato.</p></li><li><p>Operando fuente: El último objeto apilado.</p></li><li><p>Primero se extrae el objeto referenciado por el stack pointer. A continuación el stack pointer se INCREMENTA en una palabra. SP &#8592; SP+1*WordSize</p></li></ul></div></li></ul></div></li></ul></div>
<div class="listingblock"><div class="content"><pre> Address   ---DRAM----
 0xFFFFFFFF+---------+    0xFFFFFFFF+---------+      0xFFFFFFFF+---------+      0xFFFFFFFF+---------+
           |         |              |         |                |         |                |         |
           +         |              +         |                +         |                +         |
           | cBLU    |              | cBLU    |                | cBLU    |                | cBLU    |
           |         |              |         |                |         |                |         |
           +---------+              +---------+                +---------+                +---------+
 0x0B000000|  cDDD   |         fp-&gt; |         |&lt;-sp       fp-&gt; |         |           fp-&gt; |         |
           +---------+              +---------+                +---------+                +---------+
 0x0AFFFFFF|  cBBB   |              |         |                |         |&lt;-sp            |         |
           +---------+              +         +                +---------+                +---------+
           |  cBBB   |              |         |                |         |                |         |&lt;-sp
           +---------+              +         +                +         +                +---------+
 0xAFFFFFFD|  c999   |              |         |                |         |                |         |
           +---------+              + cBLU    +                + cBLU    +                + cBLU    +
           |  c999   |              |         |                |         |                |         |
           +---------+              +         +                +         +                +         +
           |  c999   |              |         |                |         |                |         |
           +---------+              +         +                +         +                +         +
           |  c999   |              |         |                |         |                |         |
           +---------+              +         +                +         +                +         +
 0xAFFFFFF9|         |              |         |                |         |                |         |
           |         |              |         |                |         |                |         |
           |         |              |         |                |         |                |         |
 0x00000000+---------+    0x00000000+---------+      0x00000000+---------+      0x00000000+---------+
           &lt;--Word---&gt;
   	        (a)                    (b)                        (c)                         (d)

  0xFFFFFFFF+---------+
            |         |
            +         |
            | cBLU    |
            |         |
            +---------+
       fp-&gt; |         |
            +---------+
            |         |&lt;-sp
            +---------+
            |         |
            +         +
            |         |
            + cBLU    +
            |         |
            +         +
            |         |
            +         +
            |         |
            +         +
            |         |
            |         |
            |         |
  0x00000000+---------+
                (e)</pre></div></div>
<div class="ulist"><ul><li><p>(a) La pila no esta formada</p></li><li><p>(b) Se forma la pila inicializando los punteros de pila: frame pointer (fp) y stack pointer (sp)</p></li><li><p>(c) Ejecución de push</p></li><li><p>(d) Ejecución de push</p></li><li><p>(e) Ejecución de pop</p></li></ul></div>
<h level="3">Anidamiento de llamadas</h><div class="ulist"><ul><li><p>TODO</p></li></ul></div></div></section></section>
<section><section id="_programas_en_lenguaje_ensamblador_propuestas"><h2>31. Programas en Lenguaje Ensamblador: Propuestas</h2></section><section id="asm_propu"><h2>31.1. Nivel Medio</h2><div class="slide-content"><h level="3">Formato BMP</h><h level="4">Circulo</h><div class="ulist"><ul><li><p><a href="https://en.wikipedia.org/wiki/Midpoint_circle_algorithm">Algoritmo del Punto Medio</a></p><div class="listingblock"><div class="content"><pre>x: eje abscisa -&gt; positivo hacia dcha
y: eje ordenada -&gt; positivo hacia arriba
ecuación círculo: centro (0,0) y primer octante (x_positivo, y_positivo, y&lt;x). Los órdenes de los octantes van en el sentido contrario a las agujas del reloj
ecuación discreta yn e xn números enteros:
  xn e yn limitados al primer octante:
  primer punto : x1=r y1=0
  segundo punto: y2 se incrementa en 1 -&gt; y2=y1+1
               : x2 sólo tiene dos alternativas: idéntico al anterior x1 ó incrementar en una unidad
               : obtener x2 según la ecuación del círculo -&gt; x^2^~n+1~ = x^2^~n~ -2*y~n~-1</pre></div></div>
<div class="ulist"><ul><li><p>x<sup>2</sup><sub>n+1</sub> = x<sup>2</sup><sub>n</sub> -2*y<sub>n</sub>-1: se puede resolver con números reales pero interesa la aritmética con números enteros y así poder programar en lenguaje ensamblador.</p></li><li><p>Variant with <strong>integer-based</strong> arithmetic &#8594;  Bresenham&#8217;s line algorithm: desarrollada con aritmética entera</p></li></ul></div></li><li><p>Bresenham circle:</p><div class="listingblock"><div class="content"><pre>xn e yn números enteros
coordenadas en el primer octante
origen círculo (0,0)
x_inicio=r
y_inicio=0
E_inicio=3-2r

en cada interacción:
	E_actual &lt;0 -&gt; E_next=Ecur + 2*(3+2*yc) ; x_next=x_actual ; y_next=y_actual+1
	E_actual &gt;0 -&gt; E_next=Ecur + 2*(5+2*yc-2*xc) ; x_next=x_actual-1 ; y_next=y_actual+1)
siguiente interacción:
        E_actual=E_next ; y_actual=y_next ; x_actual=x_next</pre></div></div></li><li><p>Código fuente en C</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">/*

Programa: pixel_circulo.c
Descripción: algoritmo de  Bresenham  . https://en.wikipedia.org/wiki/Midpoint_circle_algorithm
             OJO: las ecuaciones matemáticas está desarrolladas para un OCTANTE de centro (y=0,x=0) (abajo esquina izda). Eje vertical -&gt; x, Eje horizontal -&gt; y
              OJO: por eso las ecuaciones matemáticas empiezan el octante en (xc=r,yc=0) (abajo derecha) y el octante se pinta subiendo (yc+1) y va hacia la izda (xc no cambia o xc=xc-1) hacia el centro x=0.
              OJO: el orden de los octantes se puede denominar de dos formas. En el artículo el primer octante es el x_positivo , y positivo e y&lt;x y lo siguientes octantes van en el sentido contrario a las agujas del reloj. Yo he ordenado los octantes según un reloj donde el primer octante va de las 12:00 a las dos agujas entre la 1 y las dos enumerando los octantes a favor de las agujas del reloj. Para que el primer octante empiece el primer punto en las 12:00 y no en las 3:00 como en las ecuaciones matemáticas, lo que hago es mapear la x que es la abcisa matemática no como columna j del bmp sino como fila i, es decir, x-&gt;i y-&gt;j. Al CAMBIAR filas por columnas el primer octante empieza en las 12:00.
              OJO: el formato BPM tiene el (0,0) (abajo esquina izda). Eje vertical -&gt; filas i, Eje horizontal -&gt; columnas j


          pixels_generator(): Función externa para la definición de los colores RGB en una imagen de formato BMP
          Programa principal main(): bmp_funcion_arguDimension.c

gcc -m32 -g -c  -o pixel_circulo.o pixel_circulo.c
 con la opción -c se genera el módulo objeto sin generar el módulo ejecutable

ATENCION: la DIMENSION DEL ARRAY se declara tanto en el fichero con la llamada a la funcion_mod como en el fichero con la definición de la función.He probado a poner diferentes valores a DIMENSION en los dos ficheros (llamada y definición ) y no hay error de compilación ni de ejecución pero el resultado de la ejecución si que cambia.




El primer octante se calcula con el centro en (0,0) y luego se traslada.
El segundo octante y hasta el octavo se calcula haciendo simetria directa y traslación del primer octante

*/



#define DIMENSION  512 // OJO: es obligatorio que los array multidimensionales tengan definido por lo menos TODAS las dimensiones menos una

//
typedef unsigned char BYTE;

// definición del tipo de cada pixel. Cada pixel son tres bytes . Cada byte es tipo BYTE.
typedef struct
{
        BYTE    b;
        BYTE    g;
        BYTE    r;
} RGB_data;

void  pintar(int i,int j,BYTE blue, BYTE green, BYTE red, RGB_data reg_mem[][DIMENSION]);

void pixels_generator_circulo(unsigned int origen_x, unsigned int origen_y, unsigned int radio, unsigned int proporcion,unsigned int dimension,  RGB_data reg_mem[][DIMENSION])
{

int Ecur,Enext,xn,xc,yn,yc,i,j;

// las ecuaciones matemáticas está desarrolladas para un circulo de centro (0,0)
Ecur=3-2*radio;
xc=radio;
yc=0;


while (yc&lt;xc) {  // primer octante (x,y) -&gt; (x e y positivo con y&lt;x) Eje vertical -&gt; x Eje horizontal -&gt; y =&gt; (abcisa,ordenada)...(x,y)
  if (Ecur &lt; 0) {
    xn=xc;
    yn=yc+1;
    Enext = Ecur + 2*(3+2*yc);

    }
  else {
    xn=xc-1;
    yn=yc+1;
    Enext = Ecur + 2*(5+2*yc-2*xc);
    //printf ("i=%d x=%d y=%d Ecur=%d Enext=%d \n",i,x[i],y[i],Ecur,Enext);

    }

 // traslación del centro (0,0) (x_origen,y_origen)
  i=origen_x+xc; // la x como FILA
  j=origen_y+yc; // la j como COLUMNA -&gt; entonces la j es la abscisa -&gt; (j,i). Este cambio en el espacio matematico es (y,x)

  // coordenadas primer octante (y,x)
  pintar(i,j,0,0,0xFF,reg_mem);

  // SIMETRIA segundo octante respecto del primero -&gt; (x,y)
  i=origen_y+yc;
  j=origen_x+xc;
  pintar(i,j,0,0xFF,0,reg_mem);

// SIMETRIA tercer octante respecto del primero -&gt; (x,-y) -&gt; la ordenada es negativa -&gt; la i
  i=origen_y-yc;
  j=origen_x+xc;
  pintar(i,j,0xFF,0,0,reg_mem);

// SIMETRIA cuarto octante respecto del primero -&gt; (y,-x) -&gt; la ordenada es negativa -&gt; la i
  i=origen_x-xc;
  j=origen_y+yc;
  pintar(i,j,0xFF,0xFF,0XFF,reg_mem);

// SIMETRIA quinto octante respecto del primero -&gt; (-y,-x)
  i=origen_x-xc;
  j=origen_y-yc;
  pintar(i,j,0,0,0XFF,reg_mem);

 // SIMETRIA sexto octante respecto del primero -&gt; (-x,-y)
  i=origen_y-yc;
  j=origen_x-xc;
  pintar(i,j,0,0xFF,0,reg_mem);

 // SIMETRIA septimo octante respecto del primero -&gt; (-x,y)
  i=origen_y+yc;
  j=origen_x-xc;
  pintar(i,j,0xFF,0,0,reg_mem);

// SIMETRIA octavo octante respecto del primero -&gt; (-y,x)
  i=origen_x+xc;
  j=origen_y-yc;
  pintar(i,j,0xFF,0xFF,0XFF,reg_mem);

  Ecur=Enext;
  yc=yn;
  xc=xn;

  }


}

void pintar(int i,int j,BYTE blue, BYTE green, BYTE red, RGB_data reg_mem[][DIMENSION]){

 // intensidad de rojo
  reg_mem[i][j].r = red;
  // intensidad de verde
  reg_mem[i][j].g = green;
  // intensidad de azul
  reg_mem[i][j].b = blue;

}</code></pre></div></div></li></ul></div>
<h level="4">Línea</h><div class="ulist"><ul><li><p><a href="https://en.wikipedia.org/wiki/Bresenham&#8217;s_line_algorithm">Bresenham&#8217;s_line_algorithm</a></p><div class="ulist"><ul><li><p>x: eje abscisa &#8594; positivo hacia dcha</p></li><li><p>y: eje ordenada &#8594; positivo hacia abajo</p></li><li><p>(0,0) : esquina arriba,izda</p></li><li><p>(x0,y0) e (x1,y1) son los extremos de la recta</p></li><li><p>la recta tiene pendiente &lt; 1</p></li><li><p>Ecuación de la línea &#8594; f(x,y)=0</p></li><li><p>f(x,y) = A*X+B*y+C = 0</p></li><li><p>Código fuente en C</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">#define DIMENSION  1024
typedef unsigned char BYTE;
typedef struct
{
        BYTE    b;
        BYTE    g;
        BYTE    r;
} RGB_data;

void  pintar(int i,int j,BYTE blue, BYTE green, BYTE red, RGB_data reg_mem[][DIMENSION]);

void pixels_generator_linea(unsigned int x1, unsigned int y1, unsigned int x2, unsigned int y2, unsigned int dimension,  RGB_data reg_mem[][DIMENSION]) {

int i1,i2,dx,dy,d,x,y,xmax;
// las ecuaciones matemáticas está desarrolladas para una recta de pendiente MENOR que 1
// (x1,y1) y (x2,y2) son los extremos de la recta en el PRIMER CUADRANTE

dx=x2-x1;
dy = y2-y1;
i1=2*dy;
i2=2*(dy-dx);
d=i1-dx;

if (dx&lt;0) {
    x=x2;
    y=y2;
    xmax=x1;
    }
else {
    x=x1;
    y=y1;
    xmax=x2;
    }
while (x &lt; xmax){
  if (d&lt;0)
    d=d+i1;
  else {
    d=d+i2;
    y=y+1;
    }
  x=x+1;
// x columnas -&gt; j
// y filas -&gt; i
  pintar(y,x,0,0,0xFF,reg_mem);
}
}

void pintar(int i,int j,BYTE blue, BYTE green, BYTE red, RGB_data reg_mem[][DIMENSION]){

 // intensidad de rojo
  reg_mem[i][j].r = red;
  // intensidad de verde
  reg_mem[i][j].g = green;
  // intensidad de azul
  reg_mem[i][j].b = blue;

}</code></pre></div></div></li></ul></div></li><li><p>Código para pedientes menor y mayor que 1</p></li></ul></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">/*

Programa: pixel_linea.c
Descripción: algoritmo de  Bresenham: https://en.wikipedia.org/wiki/Bresenham's_line_algorithm -&gt; concepto
                                    : https://www.javatpoint.com/computer-graphics-bresenhams-line-algorithm -&gt; algoritmo
                                    :https://iq.opengenus.org/bresenham-line-drawining-algorithm/ -&gt; pendiente &gt;1
             ejes: x abcisa ( positivo de izda a derecha) e y ordenada (positivo de arriba abajo)
             origen coordenadas : (esquina izda arriba)
             algoritmo matemático para rectas con pendiente inferior a la unidad
             pixels_generator(): Función externa para la definición de los colores RGB en una imagen de formato BMP
             Programa principal main(): bmp_funcion_arguDimension.c

gcc -m32 -g -c  -o pixel_linea.o pixel_linea.c
 con la opción -c se genera el módulo objeto sin generar el módulo ejecutable

ATENCION: la DIMENSION DEL ARRAY se declara tanto en el fichero con la llamada a la funcion_mod como en el fichero con la definición de la función.He probado a poner diferentes valores a DIMENSION en los dos ficheros (llamada y definición ) y no hay error de compilación ni de ejecución pero el resultado de la ejecución si que cambia.

*/



#define DIMENSION  1024 // OJO: es obligatorio que los array multidimensionales tengan definido por lo menos TODAS las dimensiones menos una

//
typedef unsigned char BYTE;

// definición del tipo de cada pixel. Cada pixel son tres bytes . Cada byte es tipo BYTE.
typedef struct
{
        BYTE    b;
        BYTE    g;
        BYTE    r;
} RGB_data;

void  pintar(int i,int j,BYTE blue, BYTE green, BYTE red, RGB_data reg_mem[][DIMENSION]);

void pixels_generator_linea(unsigned int x1, unsigned int y1, unsigned int x2, unsigned int y2, unsigned int dimension,  RGB_data reg_mem[][DIMENSION]) {

int i1,i2,i3,dx,dy,d,x,y,xmax;
float p;
// // (x1,y1) y (x2,y2) son los extremos de la recta en el PRIMER CUADRANTE

dx=x2-x1;
dy = y2-y1;
i1=2*dy;
i2=2*(dy-dx);
i3=2*dx;
p=(float)dy/dx;//pediente


  // el extremo inicial (izda) puede ser (x1,y1) ó (x2,y2)
  if (dx&lt;0) {
    x=x2;
    y=y2;
    xmax=x1;
    }
  else {
    x=x1;
    y=y1;
    xmax=x2;
    }

    if (p&lt;1.0) { // pendiente menor que 1
      d=2*dy-dx;
      while (x &lt; xmax){
      if (d&lt;0)
        d=d+i1;
      else { // pendiente mayor que 1
        d=d+i2;
        y=y+1;
        }
      x=x+1;
      pintar(y,x,0,0,0xFF,reg_mem);
      }
      }
    else {
   // p&gt;1
     d=2*dx-dy;
     while (x &lt; xmax){
     if (d&lt;0)
       d=d+i3;
     else {
       d=d-i2;
       x=x+1;
       }
     y=y+1;
     pintar(y,x,0,0,0xFF,reg_mem);
     }
     }
// x columnas -&gt; j
// y filas -&gt; i

}


void pintar(int i,int j,BYTE blue, BYTE green, BYTE red, RGB_data reg_mem[][DIMENSION]){

 // intensidad de rojo
  reg_mem[i][j].r = red;
  // intensidad de verde
  reg_mem[i][j].g = green;
  // intensidad de azul
  reg_mem[i][j].b = blue;

}</code></pre></div></div></div></section></section>
<section><section id="_apéndice_unidad_cpu"><h2>32. Apéndice: Unidad CPU</h2></section><section id="apendice_cpu"><h2>32.1. Microarquitecturas Modernas (Año 2000 en adelante)</h2><div class="slide-content"><div class="ulist"><ul><li><p><a href="https://mitterandekole.medium.com/modern-cpu-architecture-2-microarchitecture-8bcd80ce52ae">Blog Medimu: mitterandekole</a></p></li><li><p>branch prediction : La cpu tiene capacidad para adelantarse a las instrucciones de salto y predecir la dirección del salto. De esta forma no se producen fallos en la ejecución "pipeline" y se puede "predecir" que instrucciones se van a ejecutar antes de comenzar sus ciclos de instrucción asociados.</p></li><li><p>ejecución especulativa: consiste en comenzar el ciclo de instrucción de instrucciones que no se sabe si van a ser finalmente ejecutadas.</p></li><li><p>Front End: El bloque Front End de la Unidad de Control consiste en predecir que instrucciones se van a ejecutar, capturarlas de la memoria Caché y decodificarlas en microoperanciones antes de que llegue su turno &#8594; Pre-Fetch (Pre-Captura). Se precapturan y se guardan en el buffer del Front-End. De esta forma cuando comience el ciclo de instrucción de las instrucciones precapturadas ya están decodificadas, es decir, tienen las primeras fases del ciclo de instrucción ya realizadas.</p></li></ul></div></div></section><section id="_intel_3"><h2>32.2. Intel</h2><div class="slide-content"><div class="ulist"><ul><li><p><a href="https://www.youtube.com/watch?v=1CXE2f2Syd4">Youtube Coffe Lake (2017), Ice Lake(2019)</a></p></li></ul></div></div></section><section id="_amd"><h2>32.3. AMD</h2><div class="slide-content"><div class="ulist"><ul><li><p><a href="https://www.tomshardware.com/reviews/amd-4th-gen-epyc-genoa-9654-9554-and-9374f-review-96-cores-zen-4-and-5nm-disrupt-the-data-center/2">: Zen4</a></p></li></ul></div></div></section><section id="_skylake_u"><h2>32.4. Skylake-U</h2><div class="slide-content"><div class="ulist"><ul><li><p>Procesador Intel: Core i5-6300U</p></li></ul></div>
<div class="imageblock" style="text-align: center"><img src="./images/cpu/skylake_block_diagram.svg.png" alt="skylake block diagram.svg" width="700" height="400" /></div><div class="title">Figure 100. Skylake microarchitecture</div>
<div class="ulist"><ul><li><p>Front End &#8594; Bloque de la U.C. que adelanta las fases de captura y decodificación.</p></li><li><p>Concepto de out-of-order execution (OoO) y microoperación (uOP, no confundir con el microcódigo de la unidad de control):</p><div class="listingblock"><div class="content"><pre>The microprocessors with out-of-order execution are translating all instructions into microoperations - abbreviated µops or uops. A simple instruction such as ADD EAX,EBX generates only one µop, while an instruction like ADD EAX,[MEM1] may generate two: one for reading from memory into a temporary (unnamed) register, and one for adding the contents of the temporary register to EAX. The instruction ADD [MEM1],EAX may
generate three µops: one for reading from memory, one for adding, and one for writing the result back to memory. The advantage of this is that the µops can be executed out of order.
Example:
	; Example 2.1. Out of order processing
	mov eax, [mem1]
	imul eax, 5
	add eax, [mem2]
	mov [mem3], eax
Here, the ADD EAX,[MEM2] instruction is split into two µops. The advantage of this is that the microprocessor can fetch the value of [MEM2] at the SAME TIME as it is doing the multiplication. If none of the data are in the cache, then the microprocessor will start to fetch [MEM2] immediately after starting to fetch [MEM1], and long before the multiplication can start.</pre></div></div></li><li><p>Observar dos rutas de operaciones completamente diferentes: MOP y uOP.</p><div class="ulist"><ul><li><p>MOP: macro instrucciones : son las instrucciones ISA de intel de tipo CISC</p></li><li><p>uOP: las instrucciones ISA del tipo CISC se dividen en instrucciones más sencillas del tipo RISC.</p></li></ul></div></li></ul></div></div></section><section id="_arm_cortex_a76cortex_a55"><h2>32.5. ARM Cortex-A76/Cortex-A55</h2><div class="slide-content"><h level="3">Intro</h><div class="ulist"><ul><li><p><a href="https://en.wikipedia.org/wiki/Arm_(company" class="bare">https://en.wikipedia.org/wiki/Arm_(company</a>)</p></li><li><p>ARM : Acorn (bellota) RISC Machine &#8594; Advanced RISC Machines</p></li><li><p>Arquitectura RISC.</p></li></ul></div>
<h level="3">Teléfono Huawei P30 Pro</h><div class="ulist"><ul><li><p>El teléfono Huawei P30 Pro modelo VOG-L29 incorpora un MultiProcessor System On Chip (MPSoC) Huawei <strong>Kirin 980</strong>. El SoC integra tanto los cores como el chipset.</p><div class="listingblock"><div class="content"><pre>August 31, 2018
Kirin 980 is a 64-bit high-performance mobile ARM LTE SoC designed by HiSilicon and introduced in late 2018. Fabricated on TSMC's 7 nm process, the 980 incorporates four big Cortex-A76 cores operating at up to 2.6 GHz along with four little Cortex-A55 cores operating at up to 1.8 GHz. This SoC has an LTE modem supporting 1.4 Gbps download (Cat21), incorporates an ARM Mali-G76, and supports LPDDR4X-4266 memory.</pre></div></div></li></ul></div>
<div class="imageblock" style="text-align: center"><img src="./images/cpu/Huawei-HiSilicon-Kirin-980-MPSoC.png" alt="Huawei HiSilicon Kirin 980 MPSoC" width="400" height="300" /></div><div class="title">Figure 101. Kirin MPSoC</div>
<h level="3">ISA Cortex-A76/Cortex-A55</h><div class="ulist"><ul><li><p>Arquitectura  ISA ARMv8.2-A</p><div class="listingblock"><div class="content"><pre>64 bits
ver manual ISA ARMv8.2-A de la compañia ARM</pre></div></div></li><li><p>Microarquitectura</p><div class="ulist"><ul><li><p><a href="https://en.wikipedia.org/wiki/Comparison_of_Armv8-A_processors" class="bare">https://en.wikipedia.org/wiki/Comparison_of_Armv8-A_processors</a></p></li></ul></div></li></ul></div>
<h level="3">Multicore</h><div class="ulist"><ul><li><p>8 núcleos</p></li><li><p>arquitectura heterogénea big.LITTLE: 2 tipos de core &gt; 4+4</p><div class="ulist"><ul><li><p>big cores : alto rendimiento y consumo moderado &#8594; Cortex-A76</p></li><li><p>LITTLE.cores: rendimiento moderado y bajo consumo &#8594; Cortex-A55</p></li></ul></div></li></ul></div>
<h level="3">Microarquitectura Cortex-A76</h><div class="ulist"><ul><li><p><a href="https://en.wikipedia.org/wiki/Comparison_of_Armv8-A_processors" class="bare">https://en.wikipedia.org/wiki/Comparison_of_Armv8-A_processors</a></p></li><li><p><a href="https://en.wikipedia.org/wiki/ARM_Cortex-A76" class="bare">https://en.wikipedia.org/wiki/ARM_Cortex-A76</a></p><div class="listingblock"><div class="content"><pre>The Cortex-A76 frontend is a 4-wide decode out-of-order superscalar design. It can fetch 4 instructions per cycle. And[clarification needed] rename and dispatch 4 Mops, and 8 µops per cycle. The out-of-order window size is 128 entries. The backend is 8 execution ports with a pipeline depth of 13 stages and the execution latencies of 11 stages</pre></div></div>
<div class="ulist"><ul><li><p>superscalar : ruta de datos de 4 vías (4-way)</p></li><li><p>pipeline: 13 etapas</p></li></ul></div></li></ul></div>
<h level="3">Microarquitectura Cortex-A55</h><div class="ulist"><ul><li><p><a href="https://en.wikipedia.org/wiki/ARM_Cortex-A55" class="bare">https://en.wikipedia.org/wiki/ARM_Cortex-A55</a></p></li><li><p><a href="https://en.wikipedia.org/wiki/Comparison_of_Armv8-A_processors" class="bare">https://en.wikipedia.org/wiki/Comparison_of_Armv8-A_processors</a></p><div class="ulist"><ul><li><p>superscalar: ruta de datos de 2 vías (2-way)</p></li><li><p>pipeline: 8 etapas</p></li></ul></div></li></ul></div></div></section></section>
<section><section id="_apéndice_unidad_de_memoria_dram"><h2>33. Apéndice: Unidad de Memoria DRAM</h2></section><section id="_memoria_principal_dram"><h2>33.1. Memoria Principal: DRAM</h2><div class="slide-content"><h level="3">Temporización de la operación de lectura/escritura</h><table class="tableblock frame-all grid-all" style="width:50%"><caption class="title">Table 20. Asignación de terminales de la SDRAM</caption><colgroup><col style="width:33.3333%" /><col style="width:66.6667%" /></colgroup><thead><tr><th class="tableblock halign-left valign-top">Señales</th><th class="tableblock halign-left valign-top">Descripción</th></tr><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>A0-A29</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Entrada de dirección de celda</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>CLK</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Entrada del reloj del bus de memoria</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>/CS</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Selección del chip</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>/RAS</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Selección de dirección de fila</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>/CAS</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Selección de dirección de columna</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>/WE</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Habilitación de escritura</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>DQ0-DQ7</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Entrada/Salida de datos</code></p></td></tr></table>
<div class="paragraph"><p>La barra inclinada / significa señal negada: lógica negativa : se activa a nivel Low (<em>L</em>).</p></div>
<div class="paragraph"><p>Ejemplo extraido de <a href="http://en.wikipedia.org/wiki/Dynamic_random-access_memory#Memory_timing">wikipedia</a>:</p></div>
<table class="tableblock frame-topbot grid-all" style="width:100%"><caption class="title">Table 21. DRAM Asíncrona: Temporización</caption><colgroup><col style="width:11.1111%" /><col style="width:11.1111%" /><col style="width:11.1111%" /><col style="width:66.6667%" /></colgroup><thead><tr><th class="tableblock halign-center valign-top"></th><th class="tableblock halign-center valign-top">"50 ns"</th><th class="tableblock halign-center valign-top">"60 ns"</th><th class="tableblock halign-left valign-top">Description</th></tr><tbody><tr><td class="tableblock halign-center valign-top"><p class="tableblock"><code>tRC</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>84 ns</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>104 ns</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Random read or write cycle time (from one full /RAS cycle to another)</code></p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock"><code>tRAC</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>50 ns</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>60 ns</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Access time: /RAS low to valid data out</code></p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock"><code>tRCD</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>11 ns</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>14 ns</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>/RAS low to /CAS low time</code></p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock"><code>tRAS</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>50 ns</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>60 ns</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>/RAS pulse width (minimum /RAS low time)</code></p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock"><code>tRP</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>30 ns</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>40 ns</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>/RAS precharge time (minimum /RAS high time)</code></p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock"><code>tPC</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>20 ns</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>25 ns</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Page-mode read or write cycle time (/CAS to /CAS)</code></p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock"><code>tAA</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>25 ns</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>30 ns</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Access time: Column address valid to valid data out (includes address setup time before /CAS low)</code></p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock"><code>tCAC</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>13 ns</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>15 ns</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Access time: /CAS low to valid data out</code></p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock"><code>tCAS</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>8 ns</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>10 ns</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>/CAS low pulse width minimum</code></p></td></tr></table>
<div class="ulist"><ul><li><p>Sincronismo</p><div class="ulist"><ul><li><p>DRAM : asíncrona: responds as quickly as possible to changes</p></li><li><p>SDRAM significantly revises the asynchronous memory interface, adding a <strong>clock</strong> (and a clock enable) line. All other signals are received on the <em>rising edge</em> of the clock. No responde tan rápido como es posible, sino que espera al flanco de subida.</p></li></ul></div></li><li><p>NO vemos la memoria DRAM asíncrona, únicamente el concepto.</p></li></ul></div>
<table class="tableblock frame-topbot grid-all" style="width:100%"><caption class="title">Table 22. DRAM Síncrona: Temporización</caption><colgroup><col style="width:5.8823%" /><col style="width:5.8823%" /><col style="width:5.8823%" /><col style="width:5.8823%" /><col style="width:5.8823%" /><col style="width:5.8823%" /><col style="width:5.8823%" /><col style="width:5.8823%" /><col style="width:5.8823%" /><col style="width:5.8823%" /><col style="width:5.8823%" /><col style="width:5.8823%" /><col style="width:5.8823%" /><col style="width:23.5301%" /></colgroup><thead><tr><th class="tableblock halign-center valign-top"></th><th class="tableblock halign-center valign-top" colspan="4">PC-3200 (DDR-400)</th><th class="tableblock halign-center valign-top" colspan="4">PC2-6400 (DDR2-800)</th><th class="tableblock halign-center valign-top" colspan="4">PC3-12800 (DDR3-1600)</th><th class="tableblock halign-center valign-top" rowspan="3">Description</th></tr><tbody><tr><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-center valign-top" colspan="2"><p class="tableblock"><code>Typical</code></p></td><td class="tableblock halign-center valign-top" colspan="2"><p class="tableblock"><code>Fast</code></p></td><td class="tableblock halign-center valign-top" colspan="2"><p class="tableblock"><code>Typical</code></p></td><td class="tableblock halign-center valign-top" colspan="2"><p class="tableblock"><code>Fast</code></p></td><td class="tableblock halign-center valign-top" colspan="2"><p class="tableblock"><code>Typical</code></p></td><td class="tableblock halign-center valign-top" colspan="2"><p class="tableblock"><code>Fast</code></p></td></tr><tr><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>cycles</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>time</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>cycles</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>time</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>cycles</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>time</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>cycles</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>time</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>cycles</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>time</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>cycles</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>time</code></p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock"><code>tCL</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>3</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>15ns</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>2</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>10ns</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>5</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>12.5ns</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>4</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>10ns</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>9</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>11.25ns</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>8</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>10 ns</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>/CAS low to valid data out (equivalent to tCAC)</code></p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock"><code>tRCD</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>4</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>20ns</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>2</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>10ns</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>5</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>12.5ns</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>4</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>10ns</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>9</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>11.25ns</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>8</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>10ns</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>/RAS low to /CAS low time</code></p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock"><code>tRP</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>4</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>20ns</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>2</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>10ns</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>5</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>12.5ns</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>4</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>10ns</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>9</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>11.25ns</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>8</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>10ns</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>/RAS precharge time (minimum precharge to active time)</code></p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock"><code>tRAS</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>8</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>40ns</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>5</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>25ns</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>16</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>40ns</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>12</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>30ns</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>27</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>33.75ns</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>24</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>30ns</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Row active time (minimum active to precharge time)</code></p></td></tr></table>
<div class="ulist"><ul><li><p>When describing synchronous memory, timing is described by <strong>memory bus clock cycle counts</strong> separated by hyphens. These numbers represent tCL‐tRCD‐tRP‐tRAS in multiples of the DRAM <em>clock cycle time</em></p></li></ul></div>
<h level="3">latency times</h><div class="ulist"><ul><li><p>En este contexto latency es sinónimo de <strong>retardo</strong>. Distinto concepto de Memory Latency que es el tiempo de acceso.</p></li><li><p>tCL  :Cas Latency . Retardo desde la señal CAS hasta la obtención del dato en el buffer i/o</p></li><li><p>tRCD :Ras Cas Delay. Retardo de la señasl RAS hasta la señal CAS</p></li><li><p>tRP  :Ras Precharge. Mínimo retardo entre la precarga y la activación</p></li><li><p>tRAS :Row Active Time. Mínimo tiempo que tiene que transcurrir la activación de la fila y el inicio de la precarga.</p></li><li><p><strong>Tacceso</strong>: tCL+tRCD : desde que se valida la dirección del bus hasta la obtención en el buffer i/o del dato referenciado.</p></li><li><p><strong>Tciclo</strong>(lectura o escritura) del bus: tCL+tRCD+tRP+tBURST ó tCL+tRCD+tRAS(si hemos transferido un comando a la MP):</p><div class="ulist"><ul><li><p>Tacceso más el retardo en ser transferido a la CPU. Tiempo entre dos lecturas o dos escrituras consecutivas,</p></li></ul></div></li><li><p>tBURST: tiempo necesario para transferir un bloque de palabras:RAFAGAS: no se realizan transferencias de 1 byte: 2,4,8,16, ..</p></li><li><p>El módulo MP es programable por lo que podemos alterar los tiempos tCL-tRCD-tRP-tRAS y también la longitud de la ráfaga(burst o bloque)</p></li><li><p>El módulo MP suele indicar la secuencia tCL-tRCD-tRP-tRAS con valores típicos de ciclos reloj</p></li></ul></div>
<h level="3">Ejemplo PC2-6400 (DDR2-800) 5-5-5-16</h><div class="ulist"><ul><li><p>Módulo PC2-6400 (DDR2-800) 5-5-5-16</p></li><li><p>PC2 : SDRAM de segunda generación &#8594; Double_Data_Rate x2</p></li><li><p>6400 MB/s de <strong>ancho de banda</strong> ó <strong>througput</strong></p></li><li><p>800MHz de ciclo efectivo de reloj del bus del sistema</p><div class="ulist"><ul><li><p>Cada palabra se transfiere en un ciclo de 800MHz.</p></li><li><p>Ciclo de Reloj del Bus de memoria 400MHz</p></li><li><p>Clock cycle time = 1/400Mhz = 2.5ns</p></li></ul></div></li><li><p>5-5-5-16 son los <strong>ciclos de reloj</strong> (400MHz&#8592;&#8594;2.5ns) de los tiempos tCL-tRCD-tRP-tRAS &#8594; 12.5ns-12.5ns-12.5ns-40ns</p></li></ul></div>
<table class="tableblock frame-topbot grid-all" style="width:100%"><caption class="title">Table 23. Glosario</caption><colgroup><col style="width:10%" /><col style="width:40%" /><col style="width:10%" /><col style="width:40%" /></colgroup><thead><tr><th class="tableblock halign-left valign-top">tiempo</th><th class="tableblock halign-left valign-top">Descripción</th><th class="tableblock halign-left valign-top">tiempo</th><th class="tableblock halign-left valign-top">Descripción</th></tr><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>tCL</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>CAS latency</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>tRRD</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>RAS to RAS delay</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>tCR</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Command rate</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>tRTP</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Read to precharge delay</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>tPTP</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>precharge to precharge delay</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>tRTR</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Read to read delay</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>tRAS</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>RAS active time</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>tRTW</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Read to write delay</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>tRCD</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>RAS to CAS delay</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>tWR</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Write recovery time</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>tREF</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Refresh period</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>tWTP</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Write to precharge delay</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>tRFC</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Row refresh cycle time</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>tWTR</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Write to read delay</code></p></td></tr></table>
<div class="ulist"><ul><li><p><a href="http://en.wikipedia.org/wiki/Dynamic_random-access_memory#Memory_timing">memory timing</a></p></li><li><p>Fig 5.13 del libro de texto: Lectura de SDRAM (longitud de ráfaga=4, CL=2)</p></li></ul></div></div></section><section id="apendice_organizacion_dram"><h2>33.2. Organización avanzada de memorias DRAM</h2><div class="slide-content"><h level="3">DRAM asincrona</h><div class="ulist"><ul><li><p>En la memoria asíncrona las acciones realizadas dependen del diálogo entre el controlador y la memoria.</p></li><li><p>La memoria síncrona comienza y finaliza las acciones en el flanco de subida o bajada del reloj facilitando el diseño del circuito digital electrónico y permitiendo mayores velocidades en el bus.</p></li><li><p>Although the RAM is asynchronous, the signals are typically generated by a clocked memory controller, which limits their timing to multiples of the controller&#8217;s clock cycle.</p></li><li><p><a href="http://en.wikipedia.org/wiki/Dynamic_random-access_memory">DRAM</a></p></li></ul></div>
<h level="3">SDRAM (Synchronous DRAM)</h><h level="4">Referencias</h><div class="ulist"><ul><li><p><a href="http://es.wikipedia.org/wiki/SDRAM">SDRAM</a></p></li><li><p><a href="http://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">SDRAM</a></p></li><li><p><a href="http://en.wikipedia.org/wiki/DDR_SDRAM">DDR_SDRAM</a></p></li><li><p><a href="http://en.wikipedia.org/wiki/DDR2_SDRAM">DDR2_SDRAM</a></p></li><li><p><a href="http://en.wikipedia.org/wiki/DDR3_SDRAM">DDR3_SDRAM</a></p></li><li><p><a href="http://www.jedec.org/standards-documents/docs/jesd-79-3d">jedec standard</a></p></li><li><p><a href="http://www.freescale.com/webapp/sps/site/overview.jsp?code=784_LPBB_DDR" class="bare">http://www.freescale.com/webapp/sps/site/overview.jsp?code=784_LPBB_DDR</a></p></li><li><p><a href="http://en.wikipedia.org/wiki/Dynamic_random-access_memory#Memory_timing">memory timing</a></p></li><li><p><a href="http://en.wikipedia.org/wiki/Memory_timings" class="bare">http://en.wikipedia.org/wiki/Memory_timings</a></p></li><li><p><a href="http://en.wikipedia.org/wiki/SDRAM_latency" class="bare">http://en.wikipedia.org/wiki/SDRAM_latency</a></p></li><li><p><a href="http://en.wikipedia.org/wiki/CAS_latency" class="bare">http://en.wikipedia.org/wiki/CAS_latency</a></p></li></ul></div>
<h level="4">Introducción</h><div class="ulist"><ul><li><p>El flanco del reloj es el patrón de comienzo y fin de las operaciones</p></li><li><p><strong>DDR (Double Data Rate)</strong></p><div class="ulist"><ul><li><p>Permite transferir el bit tanto en el flanco de bajada como de subida del reloj (<strong>doble bombeo</strong>)</p></li></ul></div></li><li><p>frecuencia del buffer i/o</p><div class="ulist"><ul><li><p>El buffer i/o de la memoria pude ir a frecuencias x2, x4 y x8 respecto de la frecuencia de acceso a la celda.</p></li><li><p><strong>Supercelda</strong>:Ahora una selección (fila,columna) de un array supone no la seleccion de 1 celda sino la de 2, 4 u 8 CELDAS del array.</p></li><li><p>DDR1: una macrocelda de 2<sup>1</sup> celdas &#8594; 2 celdas</p></li><li><p>DDR2: una macrocelda de 2<sup>2</sup> celdas &#8594; 4 celdas</p></li><li><p>DDR1: una macrocelda de 2<sup>3</sup> celdas &#8594; 8 celdas</p></li><li><p>DDR1: una macrocelda de 2<sup>4</sup> celdas &#8594; 16 celdas</p></li><li><p>DDR1: una macrocelda de 2<sup>5</sup> celdas &#8594; 32 celdas</p></li></ul></div></li><li><p>Fabricantes: Samsung, Hitachi, NEC, IBM, Siemens.</p></li></ul></div>
<table class="tableblock frame-all grid-all" style="width:60%"><caption class="title">Table 24. Módulos DDR para PC  : características</caption><colgroup><col style="width:50%" /><col style="width:16.6666%" /><col style="width:16.6666%" /><col style="width:16.6668%" /></colgroup><thead><tr><th class="tableblock halign-left valign-top"></th><th class="tableblock halign-center valign-top">DDR1</th><th class="tableblock halign-center valign-top">DDR2</th><th class="tableblock halign-center valign-top">DDR3</th></tr><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>bit i/o: celdas/ciclo_bus</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>x2</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>x4</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>x8</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>frecuencia bus</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>f</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>2f</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>4f</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>burst mínimo</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>2</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>4</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>8</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>pines DIMM</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>184</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>240</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>240</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>pines SO-DIMM</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>200</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>200</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>144/200/204</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>alimentación(v)</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>2.5</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>1.8</code></p></td><td class="tableblock halign-center valign-top"><p class="tableblock"><code>1.5</code></p></td></tr></table></div></section></section>
<section><section id="_apéndice_memoria_virtual"><h2>34. Apéndice: Memoria Virtual</h2></section><section id="apendice_memvirtual"><h2>34.1. Bibliografia</h2><div class="slide-content"><div class="ulist"><ul><li><p>Computer Organization and Architecture: Designing for Performance. William Stalling, Cap8 Sistemas Operativos: 8.3 Gestión de la Memoria</p><div class="ulist"><ul><li><p>Sistema Operativo:  Gestión de la Memoria</p></li></ul></div></li><li><p>Computer Systems A Programmer’s Perspective, Randal E. Bryant. Capítulo 9. Virtual Memory</p></li></ul></div></div></section><section id="_sistemas_operativos_gestión_de_la_memoria"><h2>34.2. Sistemas Operativos: Gestión de la Memoria</h2><div class="slide-content"><h level="3">Sistemas Multiproceso</h><div class="ulist"><ul><li><p>En un sistema multitarea hay más de un proceso ejecutándose y residente en la memoria principal.</p></li><li><p>La memoria principal es un recurso compartido por todos los procesos. En un entorno multiproceso, es necesario gestionar el recurso compartido para asignar regiones de memoria física a cada proceso, para proteger espacios de memoria entre los distintos procesos, etc</p></li><li><p>Históricamente la memoria principal era muy limitada frente al tamaño de los programas.</p></li><li><p>Técnicas de gestión de la memoria en sistemas operativos: swapping, particionamiento, memoria virtual, segmentación, paginación. .</p></li></ul></div>
<h level="3">Gestión de la Memoria Fisica</h><h level="4">Memoria Principal</h><div class="ulist"><ul><li><p>La memoria principal es la memoria física externa a la CPU e implementada en tecnología SDRAM con una capacidad típica en el año 2010 de 4GB.</p></li></ul></div>
<h level="4">Swapping</h><div class="ulist"><ul><li><p>Significa intercambio.</p></li><li><p>Los programas se almacenan en el disco duro como módulos objeto ejecutables.</p></li><li><p>Los módulos ejecutables deben cargarse en memoria para ser ejecutados, convirtiéndose en procesos.</p></li><li><p>La memoria es <em>limitada</em> por lo que no puede almacenar todos los procesos requeridos por el usuario.</p></li><li><p>Una solución es que los procesos utilicen tanto la memoria principal como el disco duro. En memoria  residen los procesos  que son ejecutados en un momento dado y cuando uno de dichos procesos  no requiere de la CPU (espera a un evento i/o)(no está en estado <em>ready</em>) se intercambia con el disco duro por un proceso que si requiere de la CPU (está en estado ready). La transferencia del proceso hacia la memoira principal se denomina swap-in y la transferencia hacia el disco duro swap-out.</p></li><li><p>Se <strong>intercambia todo</strong> el proceso.</p></li><li><p>Hay un intercambio  de procesos completos entre la memoria  y el disco duro. Este es el concepto de swap para algunos sistemas operativos como Solaris y el que se toma por definición. En Linux tiene otro significado.</p></li><li><p>Al trasladar un proceso de memoria al disco duro se genera un <strong>hueco en la memoria</strong>. La existencia de múltiples huecos dispersados por la memoria se le denomina <em>fragmentación externa</em>.</p></li><li><p>El inconveniente es que el swapping requiere de un operación i/o con el disco duro ralentizando el rendimiento de la computadora.</p></li></ul></div>
<h level="4">Particionamiento (Fragmentación)</h><div class="ulist"><ul><li><p><strong>La clave</strong>:</p><div class="ulist"><ul><li><p>Sin memoria virtual el código de los procesos en la memoria física ha de ser <strong>contiguo</strong>.</p></li><li><p>Si no utilizamos memoria virtual el <em>particionamiento dinámico</em> (el proceso ocupa justo la región de memoria que necesita)  produce fragmentación externa al eliminar particiones y el <em>particionamiento fijo</em> (el proceso ocupa menos de la región que tiene reservada) produce fragmentación interna</p></li></ul></div></li><li><p><strong>La Solución</strong> para que un proceso pueda ocupar particiones <strong>NO CONTIGUAS</strong> en la memoria FISICA : memoria VIRTUAL.</p><div class="ulist"><ul><li><p>Al poder asignar particiones pequeñas fijas no contiguas el fraccionamiento externo desaparece y el interno se reduce al máximo (inferior al tamaño de la partición)</p></li></ul></div></li><li><p>El <strong>particionamiento</strong> es una técnica para asignar memoria principal a los distintos procesos que están siendo ejecutados concurrentemente en la computadora.</p></li><li><p>La memoria se divide en múltiples regiones o <em>particiones</em> de tamaño no uniforme.</p></li><li><p>A un proceso se le asigna una partición de <em>igual o mayor tamaño</em>.</p></li><li><p>Se utiliza en sistemas multitarea donde la memoria principal es compartida por múltiples procesos. De esta manera se puede <em>gestionar el compartir</em> la memoria entre los diferentes procesos, protección, permisos, superusuario, etc</p></li><li><p>Cuando el proceso no está ready se realiza un swapping con el disco duro.</p></li><li><p>Dos alternativas : la estructura de las particiones puede ser fijo o variable en el tiempo. En los dos casos un proceso requiere una partición, es decir, una región de posiciones de memoria <strong>contiguas</strong>.</p></li><li><p>Particionamiento <strong>FIJO</strong> :</p><div class="ulist"><ul><li><p>La memoria principal se parte en regiones cuyo tamaño no varía durante la ejecución de los procesos.</p></li><li><p>Pariticionamiento fijo con regiones de igual tamaño o particionamiento fijo con regiones de diferente tamaño.</p></li><li><p>A los procesos se les asigna una partición de tamaño mayor que el requerido. Esto produce <strong>fragmentación interna</strong>, ya que una zona de la partición no es aprovechada por ningún proceso.</p></li></ul></div></li><li><p>Particionamiento variable o <strong>DINAMICO</strong>:</p><div class="ulist"><ul><li><p>A cada proceso se le asigna justo la memoria que necesita. No hay fragmentación interna.</p></li><li><p>El tamaño de las particiones cambia dinámicamente según se intercambian procesos con el disco duro adaptándose al tamaño de estos.</p></li><li><p>La <strong>fragmentación externa</strong> es considerable. Se podría reducir compactando los huecos dispersos, para lo cual es necesario mover o reubicar los procesos en la memoria principal. La reubicación de procesos significa resolver todas las direcciones físicas nuevamente en tiempo de ejecución &#8594; puede resultar inviable el tiempo requerido.</p></li><li><p>Hay publicidad de programas que defragmentan la memoria principal lo cual no es posible ya que únicamente el S.O. conoce las direcciones físicas de un proceso.</p></li></ul></div></li></ul></div>
<h level="4">Alternativa</h><div class="ulist"><ul><li><p>La solución a la fragmentación debido a la técnica del particionamiento de la memoria física es la técnica de memoria virtual bien segmentada o bien paginada o ambas.</p></li></ul></div>
<h level="3">Gestión mediante la Memoria Virtual</h><h level="4">Alternativa</h><div class="ulist"><ul><li><p>Los problemas de gestionar la memoria de los procesos asignando a los procesos <em>directamente</em> un espacio de direcciones físico se resuelven mediante el mecamismo de la <em>memoria virtual</em>.</p></li></ul></div>
<h level="4">Espacio de direcciones virtual</h><div class="ulist"><ul><li><p>El programador, el compilador, el linker y los procesos no operan con direcciones físicas.</p></li><li><p>El programador referencia la memoria en el módulo fuente con símbolos (etiquetas, variables, nombres de funciones, etc)</p></li><li><p>El compilador y el linker traducen los símbolos a direcciones de una memoria imaginaria lineal y contigua denominada memoria virtual.</p></li><li><p>Esta independencia de las direcciones físicas simplifica enormemente la gestión de la memoria.</p></li></ul></div>
<h level="4">Ejemplo: programa exit</h><div class="ulist"><ul><li><p>Desensamblado del módulo objeto ejecutable residente en el disco</p><div class="ulist"><ul><li><p><code>objdump -S exit</code></p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">exit:     file format elf64-x86-64


Disassembly of section .text:

0000000000400078 &lt;.text&gt;:
  400078:	48 c7 c0 3c 00 00 00 	mov    $0x3c,%rax
  40007f:	48 c7 c7 ff 00 00 00 	mov    $0xff,%rdi
  400086:	0f 05                	syscall</code></pre></div></div></li><li><p>Las direcciones 0x400078,.. son direcciones del espacio virtual. El espacio de direcciones virtual es <em>lineal</em>, contiguo y único.</p></li><li><p>La dirección virtual <em>0x0000000000400078</em> comprende 16 dígitos hexadecimales, es decir, el espacio de direcciones virtual del proceso <em>exit</em> tiene capacidad para 2<sup>64</sup> Bytes.</p></li></ul></div></li></ul></div>
<h level="4">Memoria: Recurso compartido</h><div class="ulist"><ul><li><p>Cada proceso tiene su propio espacio de direcciones virtual.</p></li><li><p>Todos los procesos han de compartir la misma memoria física.</p></li><li><p>Todos los espacios virtuales han de ser traducidos al mismo espacio físico.</p></li></ul></div>
<h level="4">Traducción virtual &#8594; fisico</h><div class="ulist"><ul><li><p>Cada vez que la CPU acceda a memoria para capturar instrucciones y datos o escribir resultados, será necesario <em>traducir</em> la dirección lógica en una dirección física. Es decir, las direcciones</p></li><li><p>Esta traducción la realiza la unidad hardware <em>Management Memory Unit (MMU)</em>.</p></li></ul></div>
<h level="4">Direccionamiento lógico</h><div class="ulist"><ul><li><p>En el intercambio de procesos entre la memoria y el disco duro, las direcciones físicas de memoria donde son cargados los datos y las instrucciones pueden cambiar. Debido a ello no es factible un modelo de direccionamiento que utilice direcciones físicas absolutas.</p></li><li><p>Las direcciones del proceso se expresan de forma <strong>relativa</strong> respecto de una <strong>dirección base</strong>. Al par dirección base y offset se le denomina <em>dirección lógica</em>.</p></li><li><p>Esta dirección lógica es una dirección virtual, no física.</p></li></ul></div>
<h level="4">Dos tipos: Segmentación y Paginación</h><div class="ulist"><ul><li><p>El espacio de memoria virtual se puede gestionar utilizando dos mecanismos o la combinaición de ellos:</p><div class="ulist"><ul><li><p><strong>Segmentación</strong></p><div class="ulist"><ul><li><p>La memoria virtual de un proceso se divide en unidades lógicas indivisibles denominadas segmentos</p></li></ul></div></li><li><p><strong>Paginación</strong></p><div class="ulist"><ul><li><p>La memoria virtual de un proceso y la memoria física de la computadora se dividen en unidades denominadas páginas (lógicas en la memoria virtual y físicas en la memoria principal).</p></li></ul></div></li></ul></div></li></ul></div></div></section><section id="apendice_segmentos_secciones"><h2>34.3. Memoria Virtual Segmentada</h2><div class="slide-content"><h level="3">Interpretación de la segmentación</h><div class="ulist"><ul><li><p>La segmentación se puede aplicar tanto al espacio de direcciones físico como al espacio de direcciones virtual.</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Segmentación del espacio de direcciones virtual</p><div class="ulist"><ul><li><p>División de un programa (proceso) en unidades lógicas: código,variables inicializados, variables sin inicializar, datos read only, etc. División de la memoria virtual de un proceso en áreas de <strong>memoria contigua</strong> y cuyo tamaño puede variar dinámicamente. Los segmentos lógicos no se pueden dividir.</p></li><li><p>Facilita el trabajo del compilador,linker,sharing, etc</p></li><li><p>El espacio total de la memoria virtual formado por todos los procesos estaría formado por la dirección base  segmento y el desplazamiento (offset) del registro contador de programa.</p></li><li><p>Se ha utilizado memoria virtual segmentada en las CPU: 80286,80386,80486 y Pentium</p></li></ul></div></li><li><p>Segmentación del espacio de direcciones físico.</p><div class="ulist"><ul><li><p>Se utilizó en la arquitectura intel 8086 para pasar de un bus de direcciones de 16 bits a 20 bits manteniendo el tamaño de los registros con 16 bits.</p></li><li><p>Incrementar el espacio de direcciones físicas añadiendo un registro de segmento y sin incrementar el tamaño del registro contador de programa. Por ejemplo un microprocesador Intel de 16 bits sin segmentación tiene límitado el espacio físico a 2<sup>16</sup> = 64KB. Con el mismo micro y un registro adicional de segmento RS de 16 bits podemos concatenar el registro RS con el contador de programa PC formando direcciones físicas de 32 bits con lo que tendríamos un espacio de direcciones físicas de 2<sup>32</sup> = 4GB</p></li></ul></div></li></ol></div></li></ul></div>
<h level="3">Secciones</h><div class="ulist"><ul><li><p>cada módulo objeto reubicable está estructurado en secciones</p></li><li><p>una sección es una división lógica, no física.</p></li><li><p>la estructura en secciones se define en el módulo fuente</p></li><li><p>Secciones principales</p><div class="ulist"><ul><li><p>text : instrucciones</p></li><li><p>data : variables inicializadas</p></li><li><p>rodata: variables readonly</p></li><li><p>bss:    variables sin inicializar</p></li></ul></div></li><li><p><code>readelf -S maximum</code></p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-sh" data-lang="sh">There are 16 section headers, starting at offset 0x448:

Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .interp           PROGBITS         0000000000400158  00000158
       000000000000001c  0000000000000000   A       0     0     1
  [ 2] .hash             HASH             0000000000400178  00000178
       000000000000000c  0000000000000004   A       3     0     8
  [ 3] .dynsym           DYNSYM           0000000000400188  00000188
       0000000000000000  0000000000000018   A       4     1     8
  [ 4] .dynstr           STRTAB           0000000000400188  00000188
       000000000000000b  0000000000000000   A       0     0     1
  [ 5] .text             PROGBITS         0000000000400193  00000193
       0000000000000037  0000000000000000  AX       0     0     1
  [ 6] .eh_frame         PROGBITS         00000000004001d0  000001d0
       0000000000000000  0000000000000000   A       0     0     8
  [ 7] .dynamic          DYNAMIC          00000000006001d0  000001d0
       00000000000000d0  0000000000000010  WA       4     0     8
  [ 8] .data             PROGBITS         00000000006002a0  000002a0
       000000000000000e  0000000000000000  WA       0     0     1
  [ 9] .debug_aranges    PROGBITS         0000000000000000  000002b0
       0000000000000030  0000000000000000           0     0     16
  [10] .debug_info       PROGBITS         0000000000000000  000002e0
       0000000000000078  0000000000000000           0     0     1
  [11] .debug_abbrev     PROGBITS         0000000000000000  00000358
       0000000000000014  0000000000000000           0     0     1
  [12] .debug_line       PROGBITS         0000000000000000  0000036c
       000000000000004a  0000000000000000           0     0     1
  [13] .shstrtab         STRTAB           0000000000000000  000003b6
       000000000000008d  0000000000000000           0     0     1
  [14] .symtab           SYMTAB           0000000000000000  00000848
       0000000000000240  0000000000000018          15    20     8
  [15] .strtab           STRTAB           0000000000000000  00000a88
       000000000000006f  0000000000000000           0     0     1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), l (large)
  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)
  O (extra OS processing required) o (OS specific), p (processor specific)</code></pre></div></div></li></ul></div>
<h level="3">Enlace de Secciones</h><div class="ulist"><ul><li><p>el linker mezcla de forma organizada cada tipo de sección de todos los módulos objeto reubicables generando un único módulo objeto ejecutable</p></li><li><p>Ejemplo de tres módulos objeto reubicables:</p><div class="ulist"><ul><li><p>los tres módulos fuente p1.c, p2.c, p3.c  se compilan dando lugar a p1.o, p2.o y p3.o los cuales se enlazan dando lugar al ejecutable <em>p</em></p></li></ul></div></li></ul></div>
<div class="imageblock"><img src="./images/memvirtual/linksections.png" alt="enlace de secciones" /></div>
<h level="3">Segmentos lógicos</h><div class="ulist"><ul><li><p>El módulo ejecutable está estructurado en segmentos</p><div class="ulist"><ul><li><p>text</p><div class="ulist"><ul><li><p>código de las instrucciones a ejecutar</p></li></ul></div></li><li><p>data</p><div class="ulist"><ul><li><p>código de datos: variables inicializadas, sin inicializar</p></li></ul></div></li><li><p>stack</p><div class="ulist"><ul><li><p>pila</p></li></ul></div></li><li><p>heap</p><div class="ulist"><ul><li><p>montículo</p></li><li><p>es la asignación de memoria en tiempo de ejecución</p></li><li><p>en C la función <code>malloc()</code>: memory allocation: <code>void *malloc(size_t size)</code></p><div class="ulist"><ul><li><p>size: tamaño en bytes de la memoria a asignar</p></li><li><p>devuelve un puntero a la región de memoria asignada</p></li></ul></div></li></ul></div></li></ul></div></li><li><p>mapa de memoria del programa en ejecución</p><div class="listingblock"><div class="content"><pre>Virtual Address	  -----------DRAM--------------
0xFFFFFFFFFFFFFFFF+----------------------------+
                  |                            |
                  |                            |
                  | ....                       |
                  | c999                       |
     0x80000000000| Dynamic Segments  (Heap)   |
                  +----------------------------+
     0x7FFFFFFFFFF| Stack    Segment           |
                  |                            |
                  | ...                        |
                  +----------------------------+
                  |                            |
                  | ...                        |
                  | Data    Segments           |
                  +----------------------------+
                  |                            |
                  | ...                        |
          0x400000| Text    Segments           |
                  +----------------------------+
                  |                            |
        0x00000000| c999 Unmapped              |
                  +----------------------------+
                  &lt;-------------Word-----------&gt;</pre></div></div></li></ul></div>
<div class="imageblock" style="text-align: center"><img src="./images/memvirtual/linux_vm_map.png" alt="MMU" /></div><div class="title">Figure 102. linux_vm_map</div>
<div class="imageblock" style="text-align: center"><img src="./images/memvirtual/linux_vm_map_2.png" alt="MMU" /></div><div class="title">Figure 103. linux_vm_map_2</div>
<div class="ulist"><ul><li><p>Cada proceso tiene su propia memoria virtual independiente del resto de los procesos</p></li><li><p>Los segmentos pueden cambiar de tamaño dinámicamente en tiempo de ejecución.</p><div class="ulist"><ul><li><p>Carga del módulo objeto ejecutable</p></li></ul></div></li><li><p>El loader no carga el módulo ejecutable en DRAM, sino que mapea el fichero a memoria virtual, creando la tabla de páginas.</p></li><li><p>La carga efectiva se realiza bajo demanda.</p></li></ul></div>
<div class="imageblock"><img src="./images/memvirtual/load_segments.png" alt="load segments" /></div>
<h level="3">Evolución memoria Intel 8086-80286</h><h level="4">8086</h><div class="ulist"><ul><li><p>80x86 &#8594; (bits bus direcciones, bits bus datos)</p></li><li><p>8086  &#8594; (20,16) &#8594; 2<sup>20</sup>=1MB de memoria física&#8594; Modo Real</p><div class="ulist"><ul><li><p>Segmentación</p><div class="ulist"><ul><li><p>La dirección lógica esta formada por un tuple de dos valores: dirección base y offset.</p></li><li><p>Conversión de dirección lógica a dirección física:</p><div class="ulist"><ul><li><p>Con un contador de programa de 16 bits se pueden direccionar 64KB. Si añadimos un registro segmento adicional de 16 bits cuyo contenido lo desplazamos 4 bits a la izda (equivale a <strong>multiplicar por 2<sup>4</sup></strong>) tendríamos una dirección base de 20 bits a la cual añadiríamos el offset del PC de 16 bits obteniendo una dirección  física de 20 bits- &gt; espacio físico de 1MB.</p></li></ul></div></li><li><p>Este modo de memoria se denominó <em>modo real</em>: espacio de direcciones memoria segmentada de 20 bits.</p></li></ul></div></li></ul></div></li></ul></div>
<h level="4">80286</h><div class="ulist"><ul><li><p>80286 &#8594; (24,16) &#8594; 2<sup>24</sup>=16MB de memoria física&#8594; Modos Real y protegido.</p><div class="ulist"><ul><li><p>Concepto de memoria Virtual: memoria generada por el compilador y por los procesos al ejecutarse</p><div class="ulist"><ul><li><p>En este caso son 4 bytes de memoria virtual &#8594; los 2 bytes más altos son el selector de segmento y los dos bytes más bajos el offset.</p></li><li><p>Capacidad de memoria virtual &#8594; 2<sup>32</sup> = 4GB</p></li></ul></div></li><li><p>La memoria virtual de los procesos se parte en segmentos.</p></li><li><p>Segmentación</p><div class="ulist"><ul><li><p>Forming different segments for data, code, and stack, and preventing their overlapping</p></li><li><p>Cada segmento únicamente puede direccionar 64KB ya que el Contador de Programa es de 16 bits</p></li><li><p>La conversión memoria lógica a memoria física:</p><div class="ulist"><ul><li><p>Se utiliza uno de los 4 registros de segmento CS,DS,ES,SS: son de 64 bits: 16 bits visibles y 6 bytes escondidos</p></li><li><p>Se utiliza una tabla de descripción del segmento residente en la memoria principal: cada entrada de la tabla son 8 bytes de los cuales 3 bytes son la dirección base física asociada a la dirección virtual segmentada.</p></li><li><p>En la parte visible del registro de segmento se cargan los 2 bytes más altos de la dirección virtual (selector de segmento)</p></li><li><p>El selector de segmento apunta a una de las entradas de la tabla de selección de descripción de segmento y carga 6 bytes de la tabla en la zona escondida del registro de segmento el cual contiene: dirección base física (3bytes), tamaño del segmento (2 bytes) y propiedades del segmento (1byte)</p></li><li><p>dirección física: la dirección base (3bytes) más el offset (2bytes): con 3 bytes &#8594; 2<sup>24</sup>=16MB de espacio físico</p></li><li><p>El espacio de direcciones de 4GB de memoria virtual de un segmento debiera poder traducirse en el espacio de direcciones físico de 16MB, pero únicamente puede acceder a 64KB.</p></li><li><p>Espacio físico total: de los 16MB posibles un segmento direcciona solo 64KB y como tenemos 4 segmentos &#8594; 4*64KB=256KB totales.</p></li></ul></div></li></ul></div></li><li><p>Multitasking, memory management (on chip MMU), protected memory &#8594; <em>modo protegido</em>: espacio de direcciones memoria segmentada de 24 bits.</p></li></ul></div></li></ul></div>
<h level="4">80386</h><div class="ulist"><ul><li><p>80386 &#8594; (32,32) &#8594; Espacio Físico: 2<sup>32</sup> = 4GB</p><div class="ulist"><ul><li><p>Misma arquitectura que el 286 pero incrementa la ruta de datos de 16 bits a 32 bits, añade dos registros de segmento más (FS,GS) y añade la técnica de la paginación.</p></li><li><p>Memoria Virtual: 6 bytes : 2<sup>48</sup> = 64TB . Los 2 bytes altos son el selector de registro y los 4 bytes bajos el offset</p><div class="ulist"><ul><li><p>de los 64TB posibles los 6 segmentos pueden direccionar <em>en un momento dado</em> 4GB cada uno &#8594; 6*4GB=24GB</p></li></ul></div></li><li><p>Segmentación</p><div class="ulist"><ul><li><p>Selector de Segmento = 2 bytes como en el 286 &#8594; puntero a la entrada de la tabla descriptor de segmento</p></li><li><p>Descriptor de Segmento = Contiene 4 bytes de la dirección base física</p></li></ul></div></li><li><p>Conversión de la dirección lógica a dirección física con sólo segmentación</p><div class="ulist"><ul><li><p>A la dirección base física (4 bytes) se le añade el offset de la dirección virtual (4bytes) &#8594; dirección física de 32 bits.</p></li><li><p>En este caso, a diferencia del 80286, el espacio de memoria virtual de 4GB de cada segmento se pueden traducir en el espacio físico de 4GB.</p></li></ul></div></li><li><p>instrucciones</p><div class="ulist"><ul><li><p><code>movl $42,%fs:(%eax)</code></p></li><li><p>implícitamente</p><div class="ulist"><ul><li><p>push, pop &#8594; SS,DS</p></li></ul></div></li></ul></div></li><li><p>Ver paginación 80386</p></li></ul></div></li></ul></div>
<h level="4">amd64</h><div class="ulist"><ul><li><p>amd64 &#8594; (52,64) &#8594; Espacio Físico: 2<sup>52</sup> = 4PetaBytes y Espacio Virtual 2<sup>48</sup> = 256TB</p><div class="ulist"><ul><li><p><a href="https://en.wikipedia.org/wiki/X86-64#Physical_address_space_details" class="bare">https://en.wikipedia.org/wiki/X86-64#Physical_address_space_details</a></p></li><li><p><strong>No utiliza la segmentación lógica</strong> del espacio de direcciones virtual debido a que el espacio de memoria virtual de 256TB es suficiente para todos los procesos. Los segmentos lógicos (text,data,stack,heap, etc ) de un proceso se almacenan en el mismo espacio virtual asignado a dicho proceso mediante la técnica de paginación.</p></li><li><p>Hay que tener en cuenta la limitación de la tabla de paginas virtual que depende del número de páginas virtuales y la dirección de una página física. El area de memoria principal ocupada crece exponencialmente con el tamaño de la tabla y de forma innecesaria.</p></li></ul></div></li></ul></div>
<div class="imageblock" style="text-align: center"><img src="./images/memvirtual/amd64_virtualformat.png" alt="MMU" /></div><div class="title">Figure 104. Formato de direcciones amd64</div></div></section><section id="_memoria_virtual_paginada"><h2>34.4. Memoria Virtual Paginada</h2><div class="slide-content"><h level="3">Fundamento</h><div class="ulist"><ul><li><p>La paginación consiste en dividir tanto la memoria <em>física</em> como la memoria <em>virtual</em> de los procesos en pequeños <em>pedazos</em> denominados páginas.</p></li><li><p>Los pedazos de memoria física se denominan <em>marcos de página</em> y los pedazos de memoria virtual del proceso se denominan <em>páginas</em></p></li><li><p>En este caso se asigna cada página a un marco de página diferente, quedando los trozos de proceso diseminados en zonas <strong>NO CONTIGUAS</strong> de la memoria.</p></li><li><p>De esta manera se reduce la fragmentación interna ,ya que la memoria infrautilizada siempre será menor al tamaño de una página.</p></li><li><p>El sistema operativo genera para cada proceso la <em>tabla de páginas</em> que mapea páginas con marcos.</p><div class="ulist"><ul><li><p>PTE: Page Table Entry &#8594; (index,PhysPageNumber)</p></li></ul></div></li><li><p>Dirección lógica</p><div class="ulist"><ul><li><p>Cada dirección lógica estará formada por la dirección base de la página y el offset dentro de la página. Direccionamiento <strong>no lineal</strong>, (dirección base, desplazamiento)</p></li></ul></div></li><li><p>Traducción de dirección lógica a física.</p><div class="ulist"><ul><li><p>El espacio de direcciones físico es único y contiguo, es decir, lineal.</p></li><li><p>La dirección base de la página del proceso se asocia con la dirección base del marco: tabla de páginas.</p></li><li><p>El offset dentro del marco será el mismo que el offset dentro de la página.</p></li><li><p>La gestión de la paginación la realiza la MMU</p></li></ul></div></li></ul></div>
<h level="3">Concepto de Memoria Virtual Paginada</h><div class="ulist"><ul><li><p>Debido a que no es necesario cargar todas las páginas del proceso &#8594; el espacio de memoria del <strong>PROCESO</strong> puede ser <strong>mayor</strong> que la memoria física &#8594; concepto de <strong>memoria virtual</strong></p></li><li><p>La memoria virtual es única, contigua, es decir, <em>LINEAL</em>. Es una abstracción para no depender de las direcciones físicas.</p></li><li><p>Por el principio de localidad en la memoria física sólo está la copia de las páginas virtuales que son necesarias dinámicamente en un momento dado.</p><div class="ulist"><ul><li><p><strong>concepto de cache</strong></p></li></ul></div></li><li><p>La memoria principal es la cache de la memoria secundaria (ficheros el disco o pendrive)</p></li><li><p>SDRAM cache</p></li></ul></div>
<h level="3">Fragmentación</h><div class="ulist"><ul><li><p>En el desalojo de áreas de memoria que no son necesarias se generan huecos que fragmentan la memoria física en una sucesión de áreas de memoria utilizadas y áreas no utilizadas</p></li><li><p>La fragmentación interna será menor cuanto más pequeñas sean las páginas.</p><div class="ulist"><ul><li><p>En la paginación las páginas pueden tener bytes sin utilizar, son huecos internos a las páginas.</p></li></ul></div></li><li><p>La fragmentación externa se reduce ya que los marcos de página pueden ser asignados a un proceso independientemente del tamaño del proceso.</p><div class="ulist"><ul><li><p>Un proceso ocupará los huecos dejados por las páginas que no tienen porque ser contiguas. El tamaño del proceso afectará al número de páginas requeridas en caso de que queramos tener todo el proceso residente en memoria principal.</p></li></ul></div></li></ul></div>
<h level="3">MMU</h><div class="ulist"><ul><li><p>Unidad Hardware interna a la CPU</p></li><li><p>Su entrada es el bus de direcciones virtuales y su salida el bus de direcciones físicas.</p></li><li><p>La MMU accede a la tabla de descripción de segmentos y a la tabla de páginas y realiza la traducción de dirección virtual en dirección física</p></li><li><p>La tabla de páginas de la MMU es la función de correspondencia que mapea el espacio virtual y el físico.</p></li></ul></div>
<h level="3">Virtual Memory Cached</h><div class="ulist"><ul><li><p>Tabla de páginas con función de correspondencia fully associative (las VPages se asocian con cualquier Marco de página)</p></li><li><p>Bit de validación</p><div class="ulist"><ul><li><p>1 &#8594; cached page</p></li><li><p>o &#8594; uncached page: allocated o unallocated</p></li></ul></div></li></ul></div>
<div class="imageblock" style="text-align: center"><img src="./images/memvirtual/vm_concept.png" alt="MMU" /></div><div class="title">Figure 105. MMU</div>
<div class="imageblock" style="text-align: center"><img src="./images/memvirtual/vm_table.png" alt="MMU" /></div><div class="title">Figure 106. MMU</div>
<h level="3">Tabla de paginas</h><div class="ulist"><ul><li><p>La tabla de páginas reside en la memoria principal SDRAM.</p></li><li><p>Las entradas de la tabla son un puntero a marcos de página física</p></li><li><p>Tantas entradas como páginas virtuales</p></li><li><p>El número de página virtual es el índice de la tabla.</p></li><li><p>La MMU accede a la tabla de páginas y realiza la traducción de dirección virtual en dirección física</p></li><li><p>El kernel actualiza la tabla de páginas y activa las transferencias</p></li></ul></div>
<div class="imageblock" style="text-align: center"><img src="./images/memvirtual/vm_table_protection.png" alt="MMU" /></div><div class="title">Figure 107. Protección</div>
<div class="ulist"><ul><li><p>SUP: SUPervisor: únicamente el kernel tiene acceso</p></li><li><p>Write No: read only.</p></li></ul></div>
<div class="imageblock" style="text-align: center"><img src="./images/memvirtual/formato_direcciones.png" alt="MMU" /></div><div class="title">Figure 108. Formato de Direcciones</div>
<h level="3">Multilevel paging</h><div class="ulist"><ul><li><p>Debido a qué la tabla de páginas puede ser enorme se considera reducir el área de ram que consume la tabla mediante una organización jerárquica de múltiples tablas.</p></li><li><p>La memoria se puede dividir jerárquicamente en agrupamientos de páginas. Superpáginas que agrupan páginas, hiperpáginas que agrupan superpáginas.</p></li><li><p>Ejemplo: Paginación de 3 niveles: Nivel 1 de pedazos de 16 MB, nivel 2 de pedazos de 2MB, nivel 2 de páginas de 4KB.</p></li><li><p>Cada nivel de agrupamiento lleva asociada una tabla de descripción de dicho nivel. La tabla de páginas se convierte en una jerarquía de múltiples tablas.</p></li><li><p>En el proceso de traducción de la MMU la dirección virtual se descompone en múltiples campos. Cada campo será un índice de cada tabla asociada, enlazando tantas páginas como niveles.</p></li><li><p>Si la tabla de nivel i tiene un contenido NULL no existirá las tablas de niveles superiores i+1,i+2,etc de la cadena de enlaces.</p></li><li><p>El  hecho de acceder a múltiples tablas no ralentiza la traducción de direcciones si las tablas están implementadas en la cache interna de la MMU. Sería distinto si dichas páginas estuviesen en la memoria DRAM.</p></li></ul></div>
<div class="imageblock" style="text-align: center"><img src="./images/memvirtual/table_multiple.png" alt="MMU" height="400" /></div><div class="title">Figure 109. Tabla de dos niveles</div>
<div class="imageblock" style="text-align: center"><img src="./images/memvirtual/table_level_k.png" alt="MMU" /></div><div class="title">Figure 110. Tabla de K niveles</div>
<h level="3">Intel: Evolución memoria virtual</h><h level="4">80386</h><div class="ulist"><ul><li><p>Se utiliza por primera vez la paginación.</p></li><li><p>La traducción de memoria virtual en física conlleva dos fases: primero la segmentación y a continuación la paginación (opcional)</p></li><li><p>Ver mecanismo de segmentación.</p></li><li><p>La segmentación traduce el espacio virtual en un espacio  lineal de 32 bits con campos:dir(10 bits)-pag(10)-offset(12)</p></li><li><p>Se implementa dos niveles de tablas de paǵinas: dir es una tabla de punteros de tablas de páginas (directorio de páginas)</p><div class="ulist"><ul><li><p>con 10 bits se consiguen 2<sup>10</sup> punteros a tablas &#8594; 1K tablas</p></li></ul></div></li><li><p>pag es el índice de la tabla de páginas</p><div class="ulist"><ul><li><p>con 10 bits se consiguen 2<sup>10</sup> entradas de tabla &#8594; 1K páginas virtuales asociadas a 1K páginas físicas</p><div class="ulist"><ul><li><p>La dirección de página física son 32 bits</p></li></ul></div></li></ul></div></li><li><p>Con 12 bits de offset el tamaño de página es 2<sup>12</sup>=4KB</p></li><li><p>1K tablas donde cada tabla contiene 1K páginas son en total 1M de páginas y cada página 4KB da un total de 4GB de direcciones de memoria física.</p></li><li><p>Por lo que de los 64TB de memoria virtual posible podemos traducir en un momento dado a 24GB de memoria segmentada y cada segmento de 4GB lineales a 4GB de memoria física.</p></li></ul></div>
<h level="4">amd64</h><div class="ulist"><ul><li><p>amd64 &#8594; 64 bits &#8594; Espacio Virtual teórico = 2<sup>64</sup> = 16 ExaBytes</p><div class="ulist"><ul><li><p>Paginación y <strong>no segmentación</strong>.</p></li><li><p>Espacio Virtual = 256 TeraBytes ya que la CPU únicamente utiliza 48 bits para el espacio de direcciones virtual <em>porque</em> es suficiente memoria para las aplicaciones actuales, utilizar los 64 bits provocaría tablas de páginas enormes bajando el rendimiento del sistema sin necesidad. No hay ni memoria secundaria para tanta memoria virtual.</p></li></ul></div></li></ul></div>
<h level="3">Glosario</h><div class="ulist"><ul><li><p>Espacios: Logic (segmentation) &#8594; Logic Linear (virtual,pagination) &#8594; Physical Linear</p></li><li><p>VP: Virtual Page</p></li><li><p>VA: Virtual Address</p></li><li><p>PP: Physical Page</p></li><li><p>PA: Physical Address</p></li><li><p>VPO:VP offset</p></li><li><p>VPN:VP number</p></li><li><p>TLB: Translation lookaside Buffer: buffer (cache) de anticipación de la tabla de páginas. Residente en la MMU.</p></li><li><p>PTE: Page Table Entry &#8594; (index/contenido)&#8594;(VPN/PPN)</p></li><li><p>PTBR: Registro de control de la CPU: page table base register: pointer to TLB</p></li><li><p>TLBI:TLB index &#8594; campo set de la cache</p></li><li><p>TLBT: TLB tag</p></li><li><p>PPO: PP offset</p></li><li><p>PPN: PP number</p></li><li><p>CO: Cache offset en el superbloque</p></li><li><p>CT: Cache tag</p></li><li><p>CI: Cache index ó línea</p></li></ul></div>
<h level="3">Traducción: dirección virtual a fisica</h><div class="imageblock" style="text-align: center"><img src="./images/memvirtual/virtualtoframe.png" alt="MMU" /></div><div class="title">Figure 111. Traducción Virtual &#8594; Física</div>
<div class="imageblock" style="text-align: center"><img src="./images/memvirtual/mmu_hit.png" alt="MMU" height="200" /></div><div class="title">Figure 112. Resultado con éxito</div>
<div class="olist arabic"><ol class="arabic"><li><p>CPU: vuelca la dirección de memoria virtual</p></li><li><p>MMU: apunta a la entrada de la tabla de páginas ubicada en la memoria principal</p></li><li><p>Memoria Principal: devuelve el contenido de la entrada de la tabla. MMU: A partir de la dirección lógica obtiene al dirección física.</p></li><li><p>MMU: vuelca la dirección física en el bus de direcciones del bus del sistema.</p></li><li><p>El dato referenciado puede estar en la memoria caché o en la memoria principal.</p></li></ol></div>
<div class="imageblock" style="text-align: center"><img src="./images/memvirtual/mmu_fault.png" alt="MMU" height="300" /></div><div class="title">Figure 113. Resultado con fracaso</div>
<h level="3">Translation Lookaside Buffer</h><div class="ulist"><ul><li><p>TLB</p></li><li><p>Es una Caché de la tabla de páginas virtuales TPV. Además de residir la tabla de páginas en la memoria principal se tiene una copia parcial de dicha tabla en una unidad de memoria interna de la MMU. Objetivo: aumentar la velocidad de acceso a la tabla ya que la solución de múltiples tablas en niveles jerárquicos requiere múltiples accesos a la memoria principal externa.</p></li><li><p>Formato de dirección virtual si la TLB es una caché con función de correspondencia asociativa</p><div class="ulist"><ul><li><p>El índice es el campo set o superbloque típico de la cache</p></li></ul></div></li></ul></div>
<div class="imageblock" style="text-align: center"><img src="./images/memvirtual/tlb_connection.png" alt="MMU" /></div><div class="title">Figure 114. Operación con TLB</div>
<div class="imageblock" style="text-align: center"><img src="./images/memvirtual/tlb_entry.png" alt="MMU" height="100" /></div><div class="title">Figure 115. Formato Virtual con TLB</div>
<div class="ulist"><ul><li><p>TLBTag</p></li><li><p>TLBIndex</p></li></ul></div>
<h level="3">Ejercicio</h><div class="ulist"><ul><li><p>La arquitectura de una computadora dispone de TLB y L1 d-Cache. La memoria es direccionable byte a byte y tiene palabras de 1 byte.</p></li><li><p>La MMU tiene una Tabla TLB (Translation Lookup Buffer)   y una memoria d-Cache según las figuras</p><div class="imageblock" style="text-align: center"><img src="./images/memvirtual/tabla_cache_ejercicio.png" alt="MMU" /></div><div class="title">Figure 116. TLB y d-cache </div>
<div class="ulist"><ul><li><p>Virtual addresses are 14 bits wide (n = 14).</p></li><li><p>Physical addresses are 12 bits wide (m = 12).</p></li><li><p>The page size is 64 bytes (P = 64).</p></li><li><p>The TLB is four-way set associative with 16 total entries.</p></li><li><p>The L1 d-cache is physically addressed and direct mapped, with a 4-byte line size and 16 total set.</p></li></ul></div></li><li><p>Calcular la dirección física de la DIRECCION VIRTUAL <strong>0x03d4</strong></p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Formato de Direcciones</p><div class="olist lowerroman"><ol class="lowerroman" type="i"><li><p>Dimensión de VPO</p></li><li><p>Dimensión de PPO</p></li><li><p>Dimensión de VPN</p></li><li><p>Dimensión de PPN</p></li></ol></div></li><li><p>Número de entradas de la tabla de páginas en memoria principal y la caché TLB</p></li><li><p>TLB</p><div class="olist lowerroman"><ol class="lowerroman" type="i"><li><p>Líneas por set de TLB</p></li><li><p>Sets de TLB</p></li><li><p>Tamaño TLBI</p></li><li><p>Tamaño TLBT</p></li><li><p>Bits por Word</p></li><li><p>Words por línea de TLB</p></li><li><p>Valores TLBI-TLBT</p></li></ol></div></li><li><p>Está PPN en TLB?</p></li><li><p>Valor de PPN</p></li><li><p>Valor de PA</p></li><li><p>d-Cache</p><div class="olist lowerroman"><ol class="lowerroman" type="i"><li><p>Memory Cache: Tipo</p></li><li><p>Sets</p></li><li><p>Líneas/Set</p></li><li><p>Words/Línea</p></li><li><p>Bytes/Word</p></li></ol></div></li><li><p>Formato Dirección Física</p><div class="olist lowerroman"><ol class="lowerroman" type="i"><li><p>CO</p></li><li><p>CI</p></li><li><p>CT</p></li><li><p>Valores CT/CI/CO &#8594; PA</p></li></ol></div></li><li><p>Está PA en la caché?</p></li><li><p>Contenido de la PA</p></li><li><p>Resumen del resultado final</p></li></ol></div></li></ul></div>
<h level="4">Desarrollo</h><div class="ulist"><ul><li><p>Respuestas</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>El formato de direcciones es</p><div class="olist lowerroman"><ol class="lowerroman" type="i"><li><p>VO y PO &#8594; tamaño de página : 64 bytes &#8594; 2<sup>6</sup> &#8594; 6 bits de offset tanto virtual como físico</p></li><li><p>bits VPN= VA-VPO=14-6=8 bits &#8594; 2<sup>8</sup> = 256 páginas virtuales</p></li><li><p>bits PPN= PA-PPO=12-6=6 bits &#8594; 2<sup>6</sup> = 64 marcos de página</p><div class="imageblock" style="text-align: center"><img src="./images/memvirtual/formato_direcciones.png" alt="MMU" /></div><div class="title">Figure 117. Formato de Direcciones</div></li></ol></div></li><li><p>Valores de VPN y VPO</p><div class="ulist"><ul><li><p>La dirección virtual VA de 14 bits 0x03D4 se codifica en binario como: 00-0011-1101-0100 &#8594; 00001111-010100 &#8594; VPN-VPO</p><div class="ulist"><ul><li><p>VPO=PPO=010100=01x4</p></li><li><p>VPN=00001111=0x0F</p></li></ul></div></li></ul></div></li><li><p>Tabla de páginas</p><div class="ulist"><ul><li><p>256 puntos de entrada. Cada entrada contiene la dirección de uno de los 64 marcos de página. Es decir una tabla de 256 direcciones y palabras de 6 bits más los bits de validación, protección, etc</p></li><li><p>La tabla en MP son 256 entradas, en cambio la TLB en caché tiene 16 entradas &#8594; direccionables con 4 bits.</p></li></ul></div></li><li><p>TLB</p><div class="olist lowerroman"><ol class="lowerroman" type="i"><li><p>Líneas por set de TLB: 4 vías &#8594; 4 líneas/set</p></li><li><p>Sets de TLB: 16 entradas son 16 líneas en total agrupadas por 4 líneas/set = 4 sets</p></li><li><p>Tamaño TLBI : para 4 set son necesarios 2 bits</p></li><li><p>Tamaño TLBT :</p><div class="ulist"><ul><li><p>De los 8 bits necesarios para direccionar 256 entradas si 2 son para el índice TLBI, 6 serán para la etiqueta TLBT</p></li></ul></div></li><li><p>Bits por Word: 1 byte por palabra según el enunciado</p></li><li><p>Words por línea de TLB</p><div class="ulist"><ul><li><p>Si me fijo en el díbujo de la tabla, cada línea contiene únicamente un PPN+tag, es decir, una palabra.</p></li></ul></div></li><li><p>Valores TLBI-TLBT</p><div class="ulist"><ul><li><p>VPN es una dirección de la tabla de páginas en la memoria RAM. El controlador de caché la descompone en TLBT-TLBI</p></li><li><p>VPN=00001111=000011-11=TLBT-TLBI=0x3-0x3</p></li></ul></div></li></ol></div></li><li><p>Está PPN en TLB?</p><div class="ulist"><ul><li><p>busco en el set 0x3 de TLB si alguno de las líneas tiene un tag TLBT de 0x3 y lo tiene la segunda línea.</p></li><li><p>La segunda línea del set 3 tiene el bit de validación a 1 por lo que la página virtual está en la memoria principal y/o d-cache.</p></li></ul></div></li><li><p>Valor de PPN</p><div class="ulist"><ul><li><p>La segunda línea del set 3 tiene el contenido PPN=0x0D</p></li></ul></div></li><li><p>Valor de PA</p><div class="ulist"><ul><li><p>Son 12 bits</p></li><li><p>La concatenación PPN(6)-PPO(6): 001101-010100=001101010100=0011-0101-0100= <strong>0x354</strong> =PA</p></li></ul></div></li><li><p>d-Cache</p><div class="olist lowerroman"><ol class="lowerroman" type="i"><li><p>Memory Cache: Tipo : mapeo directo</p><div class="ulist"><ul><li><p>Al ser de mapeo directo los set son de 1 línea por lo que es lo mismo decir set que línea.</p></li></ul></div></li><li><p>Sets</p><div class="ulist"><ul><li><p>16 líneas</p></li></ul></div></li><li><p>Líneas/Set : 1</p></li><li><p>Words/Línea: 4</p></li><li><p>Bytes/Word: 1</p></li></ol></div></li><li><p>Formato dirección física</p><div class="olist lowerroman"><ol class="lowerroman" type="i"><li><p>CO: para direccionar 4 palabras son necesarios 2 bits</p></li><li><p>CI: para direccionar 16 líneas son necesarios 4 bits</p></li><li><p>CT: la dirección física PA son 12 bits &#8594; CT=PA-DI-CO=12-4-2=6 bits</p></li><li><p>Valores CT/CI/CO &#8594; PA=001101010100=001101-0101-00</p><div class="ulist"><ul><li><p>Línea 0005; Palabra 00: Tag 001101=0x0D</p></li></ul></div></li></ol></div></li><li><p>Está PA en la d-Cache?</p><div class="ulist"><ul><li><p>En la línea 5 el tag es 0D &#8594; coíncide con el tag de la dirección física &#8594; acierto &#8594; el dato está en d-cache</p></li><li><p>El bit de validación es 1 por lo que su contenido está actualizado y por lo tanto válido.</p></li></ul></div></li><li><p>Contenido de la PA:</p><div class="ulist"><ul><li><p>El contenido de la palabra 0 de la linea 5 de la d-cache es el byte <strong>0x36</strong></p></li></ul></div></li><li><p>Resumen del resultado final.</p><div class="ulist"><ul><li><p>La dirección virtual <strong>0x03d4</strong> se corresponde con la dirección física <strong>0x354</strong> cuyo contenido es <strong>0x36</strong></p></li></ul></div></li></ol></div></li></ul></div>
<h level="3">Intel Core i7</h><div class="imageblock" style="text-align: center"><img src="./images/memvirtual/corei7_virtual_memory.png" alt="MMU" /></div><div class="title">Figure 118. Memoria Core i7</div>
<div class="imageblock" style="text-align: center"><img src="./images/memvirtual/corei7_mmu.png" alt="MMU" /></div><div class="title">Figure 119. Operación MMU</div>
<div class="imageblock" style="text-align: center"><img src="./images/memvirtual/corei7_tlb_entry_123.png" alt="MMU" /></div><div class="title">Figure 120. Formato para las tablas de los tres primeros niveles</div>
<div class="imageblock" style="text-align: center"><img src="./images/memvirtual/corei7_tlb_entry_4.png" alt="MMU" /></div><div class="title">Figure 121. Formato de la tabla del 4º nivel </div>
<div class="imageblock" style="text-align: center"><img src="./images/memvirtual/corei7_address_translation.png" alt="MMU" /></div><div class="title">Figure 122. Linux: 4 niveles</div></div></section><section id="_sistemas_operativos_gestión_de_la_memoria_2"><h2>34.5. Sistemas Operativos: Gestión de la Memoria</h2><div class="slide-content"><h level="3">Protección</h><div class="ulist"><ul><li><p>Page level protection. HW isolation. Las páginas que gestiona la MMU tiene <em>bits de control</em> que indican los permisos de acción, acceso, etc</p></li><li><p>Segmentation fault o Protection Fault</p></li></ul></div>
<h level="3">Paginación Bajo Demanda</h><div class="ulist"><ul><li><p>Paginación bajo demanda</p><div class="ulist"><ul><li><p>Las páginas de un proceso se cargan en memoria únicamente cuando son <em>demandadas</em>.No se cargan todas las páginas de un proceso de una tacada.</p></li><li><p>Cuando una página es requerida y no está en la memoria, se genera un <em>page fault</em> por parte de la MMU y el SO se encargará de cargar la página requerida.</p></li></ul></div></li><li><p>Principio de localidad</p><div class="ulist"><ul><li><p>Un proceso en un momento dado tiene en memoria únicamente las páginas que están utilizándose o con las que tienen probabilidad alta de ser utilizadas.</p></li><li><p>Furthermore, time is saved because unused pages <strong>are not swapped</strong> in and out of memory, ya que ese trozo puede ser requerido con inmediatez.</p></li></ul></div></li></ul></div>
<h level="3">Reemplazo</h><div class="ulist"><ul><li><p>Reemplazar una página</p><div class="ulist"><ul><li><p>Dilema:¿qué página extraigo de la memoria? Algoritmos de reemplazo  &#8594;  Least Recently Used LRU, First Input Output (FIFO)</p></li><li><p>La política de reemplazo la gestiona el SO.</p></li></ul></div></li></ul></div>
<h level="3">VM Tool</h><div class="ulist"><ul><li><p>La Memoria Virtual es una herramienta para:</p><div class="ulist"><ul><li><p>que la M. Principal sea una cache del disco</p></li><li><p>Gestionar la Memoria</p><div class="ulist"><ul><li><p>Simplifying linking: mezcla con direcciones independientes de la dirección física final</p></li><li><p>Simplifying loading: se carga bajo demanda las páginas requeridas</p></li><li><p>Simplifying sharing: procesos (librerías) que son compartidos.</p></li><li><p>Simplifying memory allocation:En memoria virtual el SO o compilador distribuye los segmentos de forma contigua y luego está la flexibilidad de ubicarlos arbitrariamente en memoria física.</p></li><li><p>Proteger los segmentos: control con los bits sup(supervisor),read,write</p></li></ul></div></li></ul></div></li></ul></div></div></section></section>
<section><section id="_lenguaje_de_programación_c_2"><h2>35. Lenguaje de Programación C</h2></section><section id="prog_C"><h2>35.1. Introducción</h2><div class="slide-content"><div class="ulist"><ul><li><p>Esto no es un tutorial de Programación en Lenguaje C, el objetivo de este capítulo es comentar aspectos puntuales de la programación en lenguaje C que son utilizados en la asignatura de Estructura de Computadores.</p></li></ul></div></div></section><section id="_casting"><h2>35.2. Casting</h2><div class="slide-content"><h level="3">Concepto</h><div class="ulist"><ul><li><p>Sintaxis</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">(type_name) expression</code></pre></div></div>
<div class="ulist"><ul><li><p>Conversión explícita mediante el operador unitario <strong>( )</strong>.</p></li><li><p>Los operadores unitarios tienen mayor precedencia que los binarios.</p></li></ul></div></li></ul></div>
<h level="3">Ejemplo</h><div class="ulist"><ul><li><p>Ejemplo de la división de números enteros</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">int i=8,j=5;
float x;
x = i / j;
x = (float) i / j;</code></pre></div></div></li><li><p>La variable ordinaria es declarada inicialmente como tipo <em>int</em></p><div class="ulist"><ul><li><p>La operación i/j &#8594; 8/5 daría como resultado el número entero 1</p></li></ul></div></li><li><p>Si realizamos el casting <strong>(float)</strong> sobre la variable <strong>i</strong> entonces la variable i es de tipo float y no int, por lo que su valor será el número real 8.000 y no el entero 8.</p><div class="ulist"><ul><li><p>(float)i/j = 8.0000/5 = 1.6000</p></li></ul></div></li></ul></div></div></section><section id="_puntero"><h2>35.3. Puntero</h2><div class="slide-content"><h level="3">Referencias</h><div class="paragraph"><p>Libro de texto K.N. King: Capítulo 11. Pointers. Pg241</p></div>
<h level="3">Introducción</h><div class="paragraph"><p>El concepto de puntero es fundamental en programación imperativa de bajo nivel ya que simplifica el código para la programación de algoritmos que incluyen estructuras de datos sencillas o complejas.</p></div>
<div class="admonitionblock important"><table><tr><td class="icon"><i class="fa fa-exclamation-circle" title="Important"></i></td><td class="content">Para el aprendizaje de: conceptos relacionados con los punteros, su sintaxis, su aplicación, etc&#8230;&#8203;, es necesesaria la ejecución de los programas en modo PASO A PASO para poder visualizar los contenidos y referencias de los objetos en memoria. Utilizaremos el debugger GDB.</td></tr></table></div>
<h level="3">Concepto</h><h level="4">Memoria</h><div class="ulist"><ul><li><p>La memoria principal RAM esta organizada en Bytes direccionables.</p></li><li><p>El rango de direcciones depende de la arquitectura de la máquina.</p></li><li><p>P.ej: un Bus de direcciones de 48 líneas podría direccionar 2<sup>48</sup> = 2<sup>8</sup> x 2<sup>40</sup> = 256 TB</p></li><li><p>Un <em>objeto</em> es una región de memoria (múltiples bytes ) asignada a un dato entero, dato caracter, array de datos float, bloque de instrucciones, etc. En este contexto de memoria el concepto objeto difiere del concepto objeto de programación orientada a objetos.</p></li><li><p>En la memoria RAM se implementan <em>objetos</em> que son referenciados por las direcciones de memoria donde se encuentran. La referencia es la dirección del primer byte donde se almacena el objeto de múltiples bytes.</p></li><li><p>Mapa de memoria:</p><div class="listingblock"><div class="content"><pre>ADDRESS   ----RAM----

0x0000000 +---------+
0x0000001 |         |
          |         |
          | cBLU    |
          |         |
          +---------+
0x0B000000|  c000   |
          +---------+
0x0B000001|  c111   |
          +---------+
0x0B000002|  c222   |
          +---------+
0x0B000003|  c333   |
          +---------+
0x0B000004|  c444   |
          +---------+
	  |         |
          |         |

          |         |
          |         |
	  +---------+
	  |  c555   |
	  +---------+
	  |  c666   |
	  +---------+
	  |  c777   |
	  +---------+
          |  c888   |
	  +---------+
	  |  c999   |
	  +---------+
	  |  cAAA   |
	  +---------+
	  |  cBBB   |
	  +---------+
          |  cCCC   |
	  +---------+
	  |  cDDD   |
	  +---------+
      	  |  cEEE   |
	  +---------+
   	  |  cFFF   |
          +---------+
          |         |
0xFFFFFFFD|         |
0xFFFFFFFE| cBLU    |
0xFFFFFFFF+----+----+

    ^     &lt;-1 byte -&gt;
    |
/--------------\
|cRED PUNTEROS |
\--------------/</pre></div></div></li></ul></div>
<h level="4">Puntero</h><div class="paragraph"><p>Un puntero equivale a una dirección de memoria</p></div>
<div class="paragraph"><p>En cambio una VARIABLE PUNTERO:</p></div>
<div class="ulist"><ul><li><p>Es una variable que almacena un dato que representa una dirección de memoria.</p></li><li><p>Las variables puntero almancenan punteros.</p></li><li><p>Restringen sus valores a los valores de las direcciones de memoria. Nunca podrá ser un valor negativo o real, etc</p></li><li><p>Apuntan a objetos</p></li><li><p>Hacen referencia a objetos</p></li></ul></div>
<div class="admonitionblock caution"><table><tr><td class="icon"><i class="fa fa-fire" title="Caution"></i></td><td class="content">El libro de K.N.King distingue entre "variable puntero" y puntero. En la literatura en general cuando se habla de punteros se está hablando de variables puntero, en cuyo caso al contenido del puntero se le llama referencia o dirección al objeto referenciado.</td></tr></table></div>
<div class="paragraph"><p>Representación gráfica de la "variable puntero" <em>p</em></p></div>
<div class="listingblock"><div class="content"><pre>          +---------+       	+---------------+
      	p |    	o---|-----------|---&gt;           | x
	  +---------+       	+---------------+</pre></div></div>
<div class="paragraph"><p>p	: identificador de la variable puntero</p></div>
<div class="paragraph"><p>x	: identificador del objeto referenciado, por ejemplo una variable ordinaria.</p></div>
<div class="paragraph"><p>flecha	: <em>inicialización</em> de la variable puntero <em>p</em> apuntando al objeto <em>x</em></p></div>
<div class="paragraph"><p>Ejemplos de punteros, objetos y variables de punteros</p></div>
<div class="listingblock"><div class="content"><pre>ADDRESS   ----RAM----

0x0000000 +---------+                      +---------------+
0x0000001 |         |       		   |               |
          |         |       		   |               |
          | cBLU    |       		   | cBLU          |
          |         |       		   |               |
          +---------+         		   +---------------+
0x0B000000|         |      		   |  c00F         | OBJETOS REFERENCIADOS
          +--    ---+         		   +---------------+
0x0B000001|         |         		   |  cF00         |
          +--    ---+      		   +---------------+
0x0B000002|         |         		   |  cF00         |
          +--    ---+         		   +---------------+
0x0B000003|         |         		   |  c0F0         |
          +--    ---+         		   +---------------+
0x0B000004|         |         		   |  c0F0         |
          +--    ---+  			   +---------------+
0x0B000005|         |      		   |  c0F0         |
          +--    ---+         		   +---------------+
0x0B000006|         |         		   |  c0F0         |
          +--    ---+      		   +---------------+
0x0B000007|         |         		   |  cF00         |
          +--    ---+         		   +---------------+
0x0B000008|         |         		   |  c00F         |
          +--    ---+         		   +---------------+
0x0B000009|         |         		   |  c00F         |
          +--    ---+  			   +---------------+
0x0B00000A|         |      		   |  c00F         |
          +--    ---+         		   +---------------+
0x0B00000B|         |         		   |  c00F         |
          +--    ---+      		   +---------------+
0x0B00000C|         |         		   |  c00F         |
          +--    ---+         		   +---------------+
0x0B00000D|         |         		   |  c00F         |
          +--    ---+         		   +---------------+
0x0B00000E|         |         		   |  c00F         |
          +--    ---+  			   +---------------+
0x0B00000F|         |      		   |  c00F         |
          +--    ---+         		   +---------------+
0x0B000010|         |         		   |  c00F         |
          +--    ---+      		   +---------------+
0x0B000011|         |         		   |  c00F         |
          +--    ---+         		   +---------------+
0x0B000012|         |         		   |  c00F         |
          +--    ---+         		   +---------------+
0x0B000013|         |         		   |  c00F         |
          +---------+  			   +---------------+
	  |         |			   |               |
          |         |			   |               |

          |         |			   |               |
          |         |			   |               |
	  +---------+       		   +---------------+
0x0B000100|  c666   |       		   |c00F  00       |  VARIABLES PUNTERO
	  +---------+       		   +---------------+
0x0B000101|  c777   |       		   |c00F  00       |
	  +---------+       		   +---------------+
0x0B000102|  c888   |         		   |c00F  00       |
	  +---------+          		   +---------------+
0x0B000103|  c999   |       		   |c00F  0B       |
	  +---------+       		   +---------------+
0x0B000104|  cAAA   |       		   |cF00  01       |
	  +---------+       		   +---------------+
0x0B000105|  cBBB   |       		   |cF00  00       |
	  +---------+       		   +---------------+
0x0B000106|  cCCC   |         		   |cF00  00       |
	  +---------+       		   +---------------+
0x0B000107|  cDDD   |       		   |cF00  0B       |
	  +---------+       		   +---------------+
0x0B000108|  cEEE   |              	   |c0F0  03       |
	  +---------+       		   +---------------+
0x0B000109|  cFFF   |       		   |c0F0  00       |
          +---------+         		   +---------------+
0x0B00010A|  c999   |       		   |c0F0  00       |
	  +---------+       		   +---------------+
0x0B00010B|  cAAA   |       		   |c0F0  0B       |
	  +---------+       		   +---------------+
0x0B00010C|  cBBB   |       		   |cF00  07       |
	  +---------+       		   +---------------+
0x0B00010D|  cCCC   |         		   |cF00  00       |
	  +---------+       		   +---------------+
0x0B00010E|  cDDD   |       		   |cF00  00       |
	  +---------+       		   +---------------+
0x0B00010F|  cDDD   |       		   |cF00  0B       |
	  +---------+       		   +---------------+
      	  |  cEEE   |              	   |  cEEE         |
	  +---------+       		   +---------------+
   	  |  cFFF   |       		   |  cFFF         |
          +---------+         		   +---------------+
          |         |       		   |               |
          |         |       		   |               |
          | cBLU    |       		   | cBLU          |
          +----+----+       		   +----+----------+

          &lt;-1 byte -&gt;   		   &lt;-   1 byte    -&gt;</pre></div></div>
<div class="ulist"><ul><li><p>La variable puntero de la dirección 0x0B000100 (bytes <em>+0,+1,+2,+3</em>) contiene la dirección 0x0B000000 que apunta a un objeto de 1 byte.</p></li><li><p>La variable puntero de la dirección 0x0B000104 (bytes <em>+0,+1,+2,+3</em>) contiene la dirección 0x0B000001 que apunta a un objeto de 2 bytes.</p></li><li><p>La variable puntero de la dirección 0x0B000108 (bytes <em>+0,+1,+2,+3</em>) contiene la dirección 0x0B000003 que apunta a un objeto de 4 bytes.</p></li></ul></div>
<h level="4">LeftValue-RightValue</h><div class="ulist"><ul><li><p>Una variable ordinaria referenciada en un operador asignación (=) tiene diferente interpretación si está a la izquierda o derecha del operador asignación:</p><div class="ulist"><ul><li><p>x=y</p><div class="ulist"><ul><li><p>x : la variable ordinaria a la izda se interpreta como la dirección en memoria de x : leftvalue de x</p></li><li><p>y : la variable ordinaria a la derecha se interpreta como el contenido en memoria de y : rightvalue de y</p></li></ul></div></li></ul></div></li><li><p>El contenido del objeto es el RightValue</p></li><li><p>La referencia al objeto es el LeftValue</p></li><li><p>El contenido de una variable puntero es el LeftValue del objeto referenciado.</p></li></ul></div>
<h level="3">Módulo Ilustrativo</h><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">/* Iniciación a los punteros.*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void main (void)
{

  /* Concepto */



  /*Operador Dirección*/

  int   i, k, *p, *q;
  float x, y, *r, *s;
  char  c, d, *u, *v;
  i = 10;
  k = 100;
  x = 3E-10f;
  y = 3.1416;
  c = 'A';
  d = '@';

  p = &amp;i;
  q = &amp;k;
  r = &amp;x;
  s = &amp;y;
  u = &amp;c;
  v = &amp;d;

  printf("Introducir un carácter \n");
  scanf("%c",&amp;c);
  printf("El carácter leído es el %c \n", c);

  /*Operador Indirección*/

  printf("El carácter leído es el %c \n", *u);
  printf("El valor de la variable i es %d o también  %d \n", i, *p);
  printf("El valor de PI es %f o también %f \n", y, *s);

  /*String Variable*/
  /*Array*/
  char cadena[]="Hola";

  /*Puntero*/
  char *saludo="Hola";
  char **pt_saludo;

  pt_saludo = &amp;saludo;

  exit (0);
}</code></pre></div></div>
<h level="3">Declaración</h><div class="paragraph"><p>Syntaxis: <code>type *pointer_variable</code></p></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">int   i, k, *p, *q;
float x, y, *r, *s;
char  c, d, *u, *v;
i = 10;
k = 100;
x = 3E-10f;
y = 3.1416;
c = 'A';
d = '@';</code></pre></div></div>
<div class="paragraph"><p><em>*p</em>, <em>*q</em>, etc&#8230;&#8203; son declaraciones de  <em>variable puntero</em>. El asterisco NO realiza ninguna operación sobre la variable, únicamente es el prefijo para indicar el TIPO puntero.</p></div>
<h level="3">Operador Dirección</h><div class="paragraph"><p>Símbolo <em>&amp;</em></p></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">p = &amp;i;
q = &amp;k;
r = &amp;x;
s = &amp;y;
u = &amp;c;
v = &amp;d;
scanf(&amp;c);
scanf(u);</code></pre></div></div>
<div class="paragraph"><p>El operador &amp; obtiene el LeftValue de la variable y se utiliza para inicializar punteros.</p></div>
<div class="listingblock"><div class="content"><pre>    +--+    +-----+
  p |  |---&gt;|     |i
    +--+    +-----+


    +--+    +-----+
  s |  |---&gt;|     |y
    +--+    +-----+</pre></div></div>
<h level="3">Operador Indirección o Dereferencia</h><div class="paragraph"><p>Símbolo <em>*</em></p></div>
<div class="paragraph"><p>Prefijo de una variable puntero: accede al objeto referenciado</p></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code class="language-c" data-lang="c">printf("El valor de la variable i es %d o %d \n", i, *p);
printf("El valor de PI es %f o %f \n", y, *s);</code></pre></div></div>
<h level="3">Ejemplo</h><div class="ulist"><ul><li><p>Declarar objetos de distintos tipos: integer, float, char</p></li><li><p>Declarar objetos de tipo puntero e inicializarlos con los objetos anteriores</p></li><li><p>Representar gráficamente los punteros</p><div class="ulist"><ul><li><p>Low Level: memoria RAM</p></li><li><p>High Level: diagramas con cajas que apuntan con flechas.</p></li></ul></div></li></ul></div>
<h level="3">Aplicaciones de los punteros</h><div class="ulist"><ul><li><p>Array</p><div class="ulist"><ul><li><p>Puntero Array</p></li><li><p>Aritmética de Punteros</p></li></ul></div></li><li><p>String Literal</p></li><li><p>Puntero a Puntero</p></li><li><p>Acceso a String</p><div class="ulist"><ul><li><p>Nombre del array</p></li><li><p>Variable puntero</p></li></ul></div></li><li><p>Estructura de datos</p><div class="ulist"><ul><li><p>Lista de Nombres (Array de punteros a strings)</p></li></ul></div></li><li><p>Funciones</p><div class="ulist"><ul><li><p>Pase de argumentos por referencia</p></li><li><p>Retorno por referencia.</p></li></ul></div></li><li><p>Argumentos del comando en línea del shell de Linux.</p></li></ul></div>
<h level="4">Puntero Array</h><div class="ulist"><ul><li><p>Concepto</p><div class="ulist"><ul><li><p>Un array es un puntero y una lista de elementos. El puntero apunta al primer elemento de la lista.</p></li><li><p>Cuando se crea un array se crean dos objetos</p><div class="ulist"><ul><li><p>Los elementos del array cuya asignación de memoria es contigua</p></li><li><p>El puntero que apunta al primer elemento del array</p></li></ul></div></li></ul></div></li><li><p>Ejemplo</p><div class="ulist"><ul><li><p>Array de Números : <code>data_items : 3,67,34,222,45,75,54,34,44,33,22,11,66,0</code></p></li><li><p>Declarar e inicializar</p></li><li><p>Lectura</p></li><li><p>Escritura</p></li></ul></div></li><li><p>Puntero CONSTANTE</p><div class="ulist"><ul><li><p>NO SE PUEDE MODIFICAR EL VALOR DEL PUNTERO</p></li><li><p>Modificar el puntero</p></li></ul></div></li><li><p>Ejemplo:</p><div class="ulist"><ul><li><p>Array de Caracteres: <code>cadena : H,o,l,a,<em>\0</em></code></p></li><li><p>Declarar e inicializar <code>char cadena[]={<em>H</em>,<em>o</em>,<em>l</em>,<em>a</em>,<em>\0</em>};</code></p></li><li><p>Lectura</p></li><li><p>Escritura</p></li></ul></div></li></ul></div>
<h level="4">Aritmética de Punteros</h><div class="ulist"><ul><li><p>Indexación: primer elemento MÁS la posición elemento <em>i</em></p><div class="ulist"><ul><li><p><em>data_items + i</em></p></li></ul></div></li><li><p>Modificar las expresiones de referencia a los elementos del array por expresiones aritmética de punteros</p></li></ul></div>
<h level="3">String Literal</h><div class="ulist"><ul><li><p>Concepto en dos fases</p><div class="ulist"><ul><li><p>Array de nombre "Hola" cuyos elementos son de tipo caracter.</p><div class="listingblock"><div class="content"><pre> "Hola"
+-------+                   +---+---+---+---+------+
|       | ----------------&gt; |   |   |   |   |      |
+-------+                   +---+---+---+---+------+</pre></div></div></li><li><p>Inicializar Array con el String <em>Hola</em></p><div class="listingblock"><div class="content"><pre> "Hola"
+-------+                   +---+---+---+---+------+
|       | ----------------&gt; | H | o | l | a | NULL |
+-------+                   +---+---+---+---+------+</pre></div></div></li></ul></div></li><li><p>Ejemplo</p><div class="ulist"><ul><li><p>Declarar un array tipo carácter e inicializarlo con un string literal <code>"Hola"</code></p><div class="ulist"><ul><li><p><code>char cadena[]="Hola";</code></p></li></ul></div></li><li><p>String literal:</p><div class="ulist"><ul><li><p>Cadena de carácteres</p></li><li><p>Dobles comillas</p></li></ul></div></li></ul></div></li><li><p>Arrays</p><div class="ulist"><ul><li><p>Acceder al array declarado : lectura y escritura</p></li><li><p>Acceder al array de inicialización: lectura y escritura</p></li><li><p>¿ Copia de arrays mediante asignación <code>cadena1=cadena2</code> ?</p></li></ul></div></li></ul></div>
<h level="3">Puntero a Puntero</h><div class="listingblock"><div class="content"><pre>    pt_pt     u        c
    +--+    +---+   +-----+
    |  |---&gt;|   |--&gt;|     |
    +--+    +---+   +-----+</pre></div></div>
<div class="ulist"><ul><li><p>Ejemplo</p><div class="ulist"><ul><li><p><em>u</em> apunta al  carácter <em>c</em></p></li><li><p><em>pt_pt</em> apunta a <em>u</em></p></li></ul></div></li></ul></div>
<h level="3">String Variable</h><h level="4">Nombre del Array</h><div class="ulist"><ul><li><p>Declaro el array de caracteres <code>cadena</code> y lo inicializo con el string Hola : <code>char cadena[]="Hola";</code></p></li></ul></div>
<h level="4">Variable Puntero</h><div class="ulist"><ul><li><p>Declaro la variable <code>saludo</code> y lo inicializo con el puntero <code>cadena</code></p><div class="ulist"><ul><li><p><code>char **saludo</code></p></li></ul></div></li></ul></div>
<h level="3">Funciones</h><div class="ulist"><ul><li><p>Pase de argumentos por <strong>Referencia</strong></p><div class="ulist"><ul><li><p>Declarar los parámetros de la función como variables puntero.</p></li></ul></div></li><li><p>Retorno por <strong>Referencia</strong>.</p><div class="ulist"><ul><li><p>Declarar el valor de retorno como puntero.</p></li></ul></div></li></ul></div></div></section></section>
<section><section id="_fpu_x87"><h2>36. FPU x87</h2></section><section id="fpu_x87"><h2>36.1. FPU x87</h2><div class="slide-content"><h level="3">Resumen</h><div class="ulist"><ul><li><p>Arquitectura x87:</p><div class="ulist"><ul><li><p><em>1980</em></p></li><li><p>es un repertorio de instrucciones que realiza operaciones matemáticas complejas con números reales como calcular la tangente,etc .</p></li></ul></div></li><li><p>x87 coprocessor o x87 FPU(Float Point Unit):</p><div class="ulist"><ul><li><p>es un procesador independiente de la CPU x86 para ejecutar instrucciones de la arquitectura x87.</p></li></ul></div></li><li><p>The x87 registers:</p><div class="ulist"><ul><li><p>Son registros internos a la FPU. 8-level deep non-strict <em>stack structure</em> ranging from ST(0) to ST(7). No son directamente accesibles, sino que se acceden con push, pop o desplazamiento relativo al top de la pila.</p></li></ul></div></li><li><p>FPU : es un componente de la unidad central de procesamiento especializado en el cálculo de operaciones en coma flotante de la misma manera que la ALU lo es con números enteros almacenados en los registros RPG.</p></li><li><p>Formato de datos:</p><div class="ulist"><ul><li><p>single precision, double precision and 80-bit double-extended precision binary floating-point arithmetic as per the IEEE 754</p></li><li><p>ó múltiples enteros en el mismo registro de 8,16 o 32 bits.</p></li></ul></div></li><li><p>FP: Float Point : Registros de la pila de la FPU, nueva denominación de los registros ST.</p></li><li><p>MMX:  Conjunto de instrucciones SIMD (Single Instruction Multiple Data) diseñado por Intel e introducido en <em>1997</em> en sus microprocesadores Pentium MMX.</p><div class="ulist"><ul><li><p>MMX reutiliza los ocho registros FPR existentes de la FPU por lo que no se puede utilizar simultáneamente con instrucciones mms e instruccioes fpu. Los registros MMX de 64 bits son directamente accesibles a diferencia de los FPR con arquitectura de pila.</p></li><li><p>Still, x87 instructions  are the default for GCC when generating IA32 floating-point code.</p></li></ul></div></li><li><p>SSE: Streaming SIMD Extensions (SSE) es un conjunto de instrucciones SIMD extension del subconjunto MMX para la arquitectura x86 , no la x87,  designed by Intel for  digital signal processing and graphics processing applications.</p><div class="ulist"><ul><li><p>Comenzó con el Pentium III en 1999.</p></li><li><p>Añade 16 nuevos registros de 128 bits XMM0-XMM15</p></li><li><p>XMM:  SSE floating point instructions operate on a new independent register set (the XMM registers), and it adds a few integer instructions that work on MMX registers.</p></li><li><p>SSE2 in the Pentium 4 (<em>2000</em>).</p></li></ul></div></li><li><p>AVX: extensiones vectoriales avanzadas</p><div class="ulist"><ul><li><p>Añade 16 registros de 256 bits: YMM0-YMM15</p></li><li><p>Las instrucciones que antes operaban con XMM de 128 bits ahora operan con los 128 bits de menor peso de los YMM.</p></li></ul></div></li></ul></div>
<h level="3">Refs</h><div class="ulist"><ul><li><p><a href="http://home.agh.edu.pl/~amrozek/x87.pdf">Programming With the x87 Floating-Point Unit</a>: Intel Vol. 1 8-1</p></li><li><p><a href="http://csapp.cs.cmu.edu/2e/waside.html">Computer Systems: A Programmer&#8217;s Perspective, 2/E (CS:APP2e) Randal E. Bryant and David R. O&#8217;Hallaron, Carnegie Mellon University</a></p></li></ul></div></div></section></section>
<section><section id="_estructura_de_computadores_2022_primer_parcial_teoría"><h2>37. Estructura de Computadores 2022: Primer Parcial Teoría</h2><div class="slide-content"><div class="ulist"><ul><li><p><strong>Apellidos:</strong></p></li><li><p><strong>Nombre:</strong></p></li><li><p><strong>Grupo:</strong></p></li></ul></div></div></section><section id="_ejercicios_de_los_temas_1_6"><h2>37.1. Ejercicios de los Temas 1-6</h2><div class="slide-content"><div class="olist arabic"><ol class="arabic"><li><p>Dado un computador con arquitectura Von Neumann, un bus de datos de 8 hilos y un bus de direcciones de 4 hilos.</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Dibuja un esquema de la arquitectura del computador en el que aparezcan los principales elementos vistos en clase (0.5 pts)</p><div class="listingblock"><div class="content"><pre>.
.
.
.
.
.
.
.
.</pre></div></div></li><li><p>Define los bits que debe tener cada uno de los siguientes registros (0.4 pts):</p><div class="olist lowerroman"><ol class="lowerroman" type="i"><li><p>PC &#8594;</p></li><li><p>IR &#8594;</p></li><li><p>MAR &#8594;</p></li><li><p>MBR &#8594;</p></li></ol></div></li><li><p>Calcula la capacidad de almacenamiento de la memoria en Bytes (0.5 pts)</p><div class="listingblock"><div class="content"><pre>.
.</pre></div></div></li><li><p>Extendiendo el bus de direcciones a 8 hilos y con la siguiente tabla de memoria:</p><table class="tableblock frame-all grid-all" style="width:30%"><caption class="title">Table 25. Memoria</caption><colgroup><col style="width:50%" /><col style="width:50%" /></colgroup><tbody><tr><td class="tableblock halign-center valign-top"><p class="tableblock">…</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">…</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">0x0A</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">LOAD 0x27</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">…</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">…</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">0x26</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">0x16</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">0x27</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">0x4A</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">0x28</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">0xF3</p></td></tr><tr><td class="tableblock halign-center valign-top"><p class="tableblock">…</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">…</p></td></tr></table>
<div style="page-break-after: always;"></div>
<div class="ulist"><ul><li><p>Empleando los registros de los apartados anteriore, más el bus del sistema y el acumulador, describe las fases del funcionamiento de un ciclo de instrucción en la máquina <strong>IAS</strong> con el PC=0x0A y el contenido de registros y buses. Para ello, rellena la siguiente tabla empleando tantas columnas como consideres necesarias.: (1’6 pts)</p><table class="tableblock frame-all grid-all" style="width:100%"><caption class="title">Table 26. Ciclo de Instrucción</caption><colgroup><col style="width:14.2857%" /><col style="width:21.4285%" /><col style="width:21.4285%" /><col style="width:21.4285%" /><col style="width:21.4288%" /></colgroup><thead><tr><th class="tableblock halign-left valign-top"></th><th class="tableblock halign-left valign-top">1</th><th class="tableblock halign-left valign-top">2</th><th class="tableblock halign-left valign-top">3</th><th class="tableblock halign-left valign-top">4</th></tr><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><em>Descripción</em></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><em>PC</em></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><em>IR</em></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><em>MAR</em></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><em>MBR</em></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><em>Bus Datos</em></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><em>Bus Control</em></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><em>Bus Direcc.</em></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><em>Acumulador</em></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr></table>
<table class="tableblock frame-all grid-all" style="width:100%"><caption class="title">Table 27. Ciclo de Instrucción</caption><colgroup><col style="width:14.2857%" /><col style="width:21.4285%" /><col style="width:21.4285%" /><col style="width:21.4285%" /><col style="width:21.4288%" /></colgroup><thead><tr><th class="tableblock halign-left valign-top"></th><th class="tableblock halign-left valign-top">5</th><th class="tableblock halign-left valign-top">6</th><th class="tableblock halign-left valign-top">7</th><th class="tableblock halign-left valign-top">8</th></tr><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><em>Descripción Fases</em></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><em>PC</em></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><em>IR</em></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><em>MAR</em></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><em>MBR</em></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><em>Bus Datos</em></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><em>Bus Control</em></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><em>Bus Direcc.</em></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><em>Acumulador</em></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr></table></li></ul></div></li></ol></div></li><li><p>Realiza la suma en hexadecimal con tres dígitos, mostrando las llevadas, de los siguientes enteros sin signo y muestra el resultado en hexadecimal y en binario: 0xF7+0x2A (0.5 pto)</p><div class="listingblock"><div class="content"><pre>Llevadas -&gt;

Sumando  -&gt;

Sumando  -&gt;

Suma     -&gt;</pre></div></div>
<div style="page-break-after: always;"></div></li><li><p>Realiza la siguiente resta de números sin signo 1010010 – 110110 (0.5 pto)</p><div class="listingblock"><div class="content"><pre>Minuendo    -&gt;

Sustraendo  -&gt;

Llevadas    -&gt;

Resta       -&gt;</pre></div></div></li><li><p>Con el <strong>mínimo</strong> número de digitos para que el resultado matemático sea correcto realizar las operaciones siguienets dados los números: A: 0101011 y B: 11011</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Siendo enteros sin signo: (1 pto)</p><div class="olist lowerroman"><ol class="lowerroman" type="i"><li><p>Realiza la suma C = A <em>+</em> B</p><div class="listingblock"><div class="content"><pre>.
.
.
.
.
.</pre></div></div></li><li><p>Representa A, B y C en hexadecimal y decimal</p><div class="listingblock"><div class="content"><pre>.
.
.
.</pre></div></div></li></ol></div></li><li><p>Siendo enteros en Complemento a 2 (1 pto)</p><div class="olist lowerroman"><ol class="lowerroman" type="i"><li><p>Realiza la suma C = A <em>+</em> B</p><div class="listingblock"><div class="content"><pre>.
.
.
.
.
.</pre></div></div></li><li><p>Representa A, B y C en hexadecimal y decimal</p><div class="listingblock"><div class="content"><pre>.
.
.
.</pre></div></div></li></ol></div></li><li><p>Siendo enteros en Signo-Magnitud (1 pto)</p><div class="olist lowerroman"><ol class="lowerroman" type="i"><li><p>Razona para obtener el resultado de la suma C = A <em>+</em> B</p><div class="listingblock"><div class="content"><pre>.
.
.
.
.
.</pre></div></div></li><li><p>Representa A, B y C en hexadecimal y decimal</p><div class="listingblock"><div class="content"><pre>.
.
.
.</pre></div></div></li></ol></div></li></ol></div></li><li><p>Realiza la multiplicación en binario de los números naturales 0x26 y 0x3C (0.4 pto)</p><div class="listingblock"><div class="content"><pre>.
.
.
.
.
.
.
.</pre></div></div></li><li><p>Un computador tiene los siguientes valores almacenados:</p><table class="tableblock frame-all grid-all" style="width:100%"><caption class="title">Table 28. Memoria</caption><colgroup><col style="width:25%" /><col style="width:25%" /><col style="width:25%" /><col style="width:25%" /></colgroup><thead><tr><th class="tableblock halign-left valign-top" colspan="2">REGISTROS</th><th class="tableblock halign-left valign-top" colspan="2">MEMORIA</th></tr><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Registro</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Contenido</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Dirección</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Contenido</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">EAX</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">87</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">87</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">01</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">EBX</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">02</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">88</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">07</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">ECX</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">8C</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">89</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">03</p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock">8A</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">02</p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock">8B</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">08</p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock">8C</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">0F</p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock">8D</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">24</p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock">…</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">…</p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock">94</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">32</p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock">95</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">00</p></td></tr></table>
<div class="ulist"><ul><li><p>Indica el modo de direccionamiento de cada instrucción y determina para una de ellas el valor del operando introducido en EDX con los siguientes modos de direccionamiento: (0.3 pts cada uno)</p><table class="tableblock frame-all grid-all" style="width:100%"><colgroup><col style="width:33.3333%" /><col style="width:50%" /><col style="width:16.6667%" /></colgroup><thead><tr><th class="tableblock halign-left valign-top"></th><th class="tableblock halign-left valign-top">Modo</th><th class="tableblock halign-left valign-top">Valor Operando</th></tr><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock">movb $0x89, %edx</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">movb %eax, %edx</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">movb (%ecx,%ebx,4), %edx</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">movb (%eax), %edx</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">movb 0x88, %edx</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">movb -3(%ecx), %edx</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr></table></li></ul></div></li><li><p>Si la última operación realizada en un computador intel de 8 bits es la suma de los siguientes números en complemento a 2: 10001011 y 10101101, <strong>razona</strong> cuál el valor de los siguientes banderines (0,2 pts cada una)</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Overflow Flag :</p></li><li><p>Carry Flag :</p></li><li><p>Zero Flag :</p></li><li><p>Sign Flag :</p></li></ol></div></li></ol></div></div></section><section id="_programación_en_lenguaje_ensamblador"><h2>37.2. Programación en Lenguaje Ensamblador</h2><div class="slide-content"><div class="olist arabic"><ol class="arabic"><li><p>Desarrolla el programa <strong>main</strong> completo en el lenguaje ensamblador AT&amp;T de la arquitectura intel x86 que sume 4 a una variable entera <strong>n</strong> (tamaño 2 bytes) inicialmente definida con valor n = 5 y almacene el resultado en otra variable <strong>sum</strong> (tamaño 4 bytes) y devuelva el resultado al sistema operativo. Añadir al programa 5 comentarios que consideres básicos.</p></li></ol></div></div></section></section>
<section><section id="_estructura_de_computadores_2022_primer_parcial_prácticas"><h2>38. Estructura de Computadores 2022: Primer Parcial Prácticas</h2><div class="slide-content"><div class="ulist"><ul><li><p><strong>Apellidos:</strong></p></li><li><p><strong>Nombre:</strong></p></li><li><p><strong>Grupo:</strong></p></li></ul></div></div></section><section id="_introducción_27"><h2>38.1. Introducción</h2><div class="slide-content"><div class="ulist"><ul><li><p>Día del examen: 28 de Octubre 2022 Viernes 8:00AM-10:00AM</p></li><li><p>Lugar: Aulas A307(grupos euskera y lunes 19:00-21:00)-A308(grupo miércoles 15:00-17:00)-A015(grupo miércoles 17:00-19:00):</p></li><li><p>El examen consistirá en el desarrollo de un programa en lenguaje ensamblador y  el empleo del depurador GDB teniendo en cuenta lo visto en las prácticas P1 y P2 y el tema 6 de teoría sobre programación en lenguaje ensamblador x86, del cual no entran las subrutinas, donde es requisito imprescindible haber realizado los ejercicios 15(instrucción CMP),16(flags CF/OF) y 17(instrucciones JLE,SETcc) tanto manualmente como su programación en código ensamblador, compilación, ejecución y <strong>depuración</strong>. El objetivo del ejercicio es demostrar habilidades en cuanto a desarrollo de programas de bajo nivel y su depuración.</p></li></ul></div></div></section><section id="_módulo_fuente_3"><h2>38.2. Módulo fuente</h2><div class="slide-content"><div class="ulist"><ul><li><p>Ejemplo o prototipo de lo que <strong>podría ser</strong> el enunciado del programa a desarrollar en lenguaje ensamblador</p></li><li><p>A continuación se especifica <strong>parte</strong> del código fuente que es necesario completar y depurar por parte del alumnado ya que está incompleto y puede contener algún error o errores.</p></li><li><p>Hay que respetar los comentarios ya que indican lo que hay que programar a continuación del mismo y es motivo de evaluación.</p></li><li><p>El módulo fuente ha de contener la siguiente cabecera:</p><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-nasm" data-lang="nasm">### Estructura de Computadores. Examen 1º parcial curso 2022.
### Programación en lenguaje ensamblador AT&amp;T para la arquitectura x86 32 bits
### Programa: Apellido1_Apellido2.s, por ejemplo, Alen_Urra.s
### 1ª parte del programa apellido1_apellido2.s (3 pts)
###     Declarar la variable mensaje inicializandola con el caracter "m"
###	Convertir el caracter "m" en una mayúscula "M"
###     sabiendo que las letras mayúsculas tienen un código ASCII 0x20 menor que las minúsculas.
###	código ASCII de "a" = 0x61 y de "A"=0x41
### Preguntas sobre el depurador GDB (4 pts):
###    las respuestas han de incluir tanto los comandos GDB como el resultado de ejecutar dichos comandos.
###    a) imprimir el contenido ......... con el comando print -&gt; p
###    comando (gdb):
###    resultado:
###
###    b) imprimir el contenido .... en código hexadecimal con el comando examine -&gt; x
###    comando (gdb):
###    resultado:
###
###    c) imprimir la dirección de ..... en código hexadecimal con el comando p
###    comando (gdb):
###    resultado:
##
###
### 2ª parte del programa apellido1_apellido2.s (3 pts):
### 	Descripción: programar el siguiente algoritmo condicional
### 	Lógica positiva: Z=TRUE=1 ó Z=FALSE=0
### 	La variable Z se implementará con el registro DL
### 	Devuelve el valor de la variable Z al Sistema Operativo
###     Valor de las variables X e Y con un tamaño de 1 byte -&gt; X=-3 e Y=-1
###     Z=TRUE si el producto lógico XY tiene un número par de unos
###     Utilizar todos los mensajes que informan sobre el resultado del algoritmo durante la ejecución del mismo. NO cambiar ni añadir ningún mensaje.

	# sección rodata: read only data -&gt; variables de solo lectura -&gt; constantes
	.section .rodata
saludo:	.string "Estructura de Computadores curso 2022. UPNA 28 de Octubre"
resultado: .string



	# imprimir saludo
        push $saludo
        call puts

	# Convertir la letra minúscula en mayúscula

	# Operación multiplicación lógica Z=XY


	Imprimir el resultado
	call puts

	# Pasar el resultado al sistema operativo

	# Fin</code></pre></div></div></li></ul></div></div></section><section id="_metodología_del_examen"><h2>38.3. Metodología del examen</h2><div class="slide-content"><div class="ulist"><ul><li><p>No se puede conectar telemáticamente ni a la red de la UPNA ni al exterior de la Universidad</p></li><li><p>Se puede utilizar un pendrive conteniendo cualquier tipo de información: guiones de prácticas, memorias de prácticas, apuntes, hojas de referencia rápida.</p></li><li><p>Se puede utilizar cualquier tipo de material impreso: apuntes, memorias, libros, etc &#8230;&#8203;</p></li><li><p>Una vez arrancada la computadora el alumno ha de crear la carpeta <strong>/home/alumno/examen_parte_I</strong></p></li><li><p>El alumno dispondrá de 10 minutos al comienzo del examen para descargarse el enunciado del examen de MiAulario &#8594; Recursos &#8594; Prácticas &#8594; <strong>examen_1parcial.s</strong> en la carpeta  <strong>/home/alumno/examen_parte_I</strong></p><div class="ulist"><ul><li><p>A continuación cambiará el nombre del fichero <strong>examen_1parcial.s</strong> con el enunciado por el nombre del fichero a entregar según se indica más abajo.</p></li></ul></div></li><li><p>El examen consta de <strong>3 ejercicios</strong>.</p></li><li><p>El programa fuente a entregar es UNO y el programa binario también es UNO, pero se entregará el mismo programa dos veces.</p><div class="ulist"><ul><li><p>La primera entrega correspondiente a los ejercicios 1º y 2º se deberá realizar antes de las <strong>9:15 horas</strong> a través de miaulario en la TAREA <strong>examen_parte_I</strong></p></li><li><p>La segunda entrega (continuación de la primera parte) correspondiente a los ejercicios 1º, 2º y 3º se deberá entregar antes de las <strong>10:00 horas</strong> a través de miaulario en la TAREA <strong>examen_parte_II</strong></p></li></ul></div></li><li><p>Las dos partes se desarrollarán en carpetas diferentes del ordenador. La primera parte se desarrollará en la carpeta <strong>/home/alumno/examen_parte_I</strong> y la segunda parte se desarrollará en la carpeta <strong>/home/alumno/examen_parte_II</strong></p></li><li><p>Habrá abiertas dos tareas desde el comienzo del examen con limitación de tiempo para entregar el resultado del examen en formato digital en un <strong>único</strong> archivo en formato ZIP en cada una de las tareas. En cada tarea el archivo a entregar tendrá <strong>EL MISMO NOMBRE</strong>. Se avisará cuando falten 10 y 5 minutos para el cierre de cada una de las tareas</p></li><li><p>El archivo ZIP de cada una de las dos tareas contendrá:</p><div class="ulist"><ul><li><p>el módulo fuente: Apellido1_Apellido2.s, pej, <strong>Alen_Urra.s</strong>, cada alumno con sus propios apellidos.</p><div class="ulist"><ul><li><p>código fuente y preguntas/respuestas en los comentarios.</p></li></ul></div></li><li><p>el módulo binario: Apellido1_Apellido2 , pej, <strong>Alen_Urra</strong>, cada alumno con sus propios apellidos.</p></li></ul></div></li></ul></div>
<div class="admonitionblock important"><table><tr><td class="icon"><i class="fa fa-exclamation-circle" title="Important"></i></td><td class="content">el nombre del fichero con el código fuente ha de ser <strong>obligatoriamente</strong> uno de los nombres del listado del apéndice "Nominación de los ficheros del examen" de los apuntes.</td></tr></table></div>
<div class="ulist"><ul><li><p>Módulo fuente</p><div class="ulist"><ul><li><p>se ha de completar y depurar</p></li><li><p>añadir los comentarios que se considere ayudan a la lectura e interpretación del programa</p></li><li><p><strong>responder</strong> a las preguntas sobre el depurador GDB en el propio módulo fuente.</p></li></ul></div></li></ul></div></div></section><section id="_evaluación_2"><h2>38.4. Evaluación</h2><div class="slide-content"><div class="ulist"><ul><li><p>Parte de la evaluación se realizará durante la propia prueba, siendo los profesores quienes preguntarán a cada alumno antes y después de la primera tarea <strong>examen_parte_I</strong> sobre el resultado accediendo tanto al programa fuente como a la ejecución del programa binario. En caso de que el alumno haya finalizado la primera parte antes de las 10:15 deberá llamar al profesor para ser evaluado.</p></li></ul></div></div></section></section>
<section><section id="_estructura_de_computadores_2022_segundo_parcial_prácticas"><h2>39. Estructura de Computadores 2022: Segundo Parcial Prácticas</h2><div class="slide-content"><div class="ulist"><ul><li><p><strong>Apellidos:</strong></p></li><li><p><strong>Nombre:</strong></p></li><li><p><strong>Grupo:</strong></p></li></ul></div></div></section><section id="_introducción_28"><h2>39.1. Introducción</h2><div class="slide-content"><div class="ulist"><ul><li><p>Día del examen: 12 Enero 2023 Jueves 8:00AM-12:00AM</p></li><li><p>Lugar:</p></li></ul></div></div></section><section id="_metodología_del_examen_2"><h2>39.2. Metodología del examen</h2><div class="slide-content"><div class="ulist"><ul><li><p>Elegir uno y sólo uno de los dos ejercicios: ejercicio "subrutinas" ó ejercicio "líneas"</p></li><li><p>Ejercicio "subrutinas": Nota máxima 6 puntos. Desarrollar una rutina y una subrutina simples. Preguntas sobre el contenido de la pila con el debugger. Tiempo de realización del examen 45 minutos.</p></li><li><p>Ejercicio "líneas": Nota máxima 10 puntos. Desarrollar un programa que en lenguaje ensamblador x86 que dibuje una recta en formato BMP basándose en su solución en lenguaje C y en la solución incompleta en código ensamblador con comentarios sobre el código a desarrollar, por lo que se parte de la solución en pseudocódigo. Requisito imprescindible: conocimiento detallado de la práctica BMP, soltura con el código de acceso a la pila (epilogo, prologo, salvar contexto, implementar variables locales, etc&#8230;&#8203;) y habilidad en la detección de errores en tiempo de compilación y en tiempo de ejecución. A modo de ejemplo esta disponible en la carpeta de prácticas de mi aulario el módulo bmp_linea.c y pixel_linea.c que genera la imagen de una recta en formato BMP.</p></li><li><p>Una vez arrancada la computadora el alumno ha de crear la carpeta <strong>/home/alumno/subrutinas</strong> ó <strong>/home/alumno/lineas</strong></p></li><li><p>El alumno dispondrá de 10 minutos al comienzo del examen para descargarse el enunciado del examen de MiAulario &#8594; Recursos &#8594; Prácticas &#8594;</p><div class="ulist"><ul><li><p>En el caso del examen tipo "subrutinas" descargarse únicamente el fichero <strong>subrutinas.c</strong> en la carpeta <strong>/home/alumno/subrutinas</strong></p><div class="ulist"><ul><li><p>A continuación cambiará el nombre del fichero <strong>subrutinas.c</strong> con el enunciado, por el nombre del único fichero personalizado a entregar según se indica más abajo. Sólo se entregar UN fichero con extensión s.</p></li></ul></div></li><li><p>En el caso del examen tipo "líneas" descargarse los ficheros <strong>pixel_linea.s</strong>, <strong>pixel_linea.c</strong> y <strong>bmp_linea.c</strong></p><div class="ulist"><ul><li><p>A continuación cambiará el nombre del fichero <strong>pixel_linea.s</strong> con el enunciado, por el nombre del único fichero personalizado a entregar según se indica más abajo. Sólo se entregar UN fichero con extensión s.</p></li></ul></div></li></ul></div></li><li><p>Habrá abiertas dos tareas (una para cada opción) desde el comienzo del examen con limitación de tiempo para entregar el resultado del examen en formato digital en un <strong>único</strong> archivo en formato ZIP. Una tarea será <strong>examen_subrutina</strong> y la otra <strong>examen_linea</strong>. En cada tarea el archivo a entregar tendrá <strong>EL MISMO NOMBRE</strong>. Se avisará cuando falten 10 y 5 minutos para el cierre de cada una de las tareas.</p></li><li><p>Los apartados anterioreos emulan la opción "líneas" con un enunciado en caso de que los módulos fuente fuesen: bmp_linea.c y pixel_linea.s. En el examen los módulos serán otros diferentes: bmp_circulo.c y pixel_circulo.c. Por lo que la segunda opción consistirá en dibujar un círculo en lugar de una recta.</p></li><li><p>El archivo <strong>s</strong>  contendrá el módulo fuente en código asm dependiendo de la opción elegida:</p><div class="ulist"><ul><li><p>el módulo fuente: Apellido1_Apellido2.s, pej, <strong>Alen_Urra.s</strong>, cada alumno con sus propios apellidos.</p><div class="ulist"><ul><li><p>código fuente y preguntas/respuestas GDB en los comentarios.</p></li></ul></div></li></ul></div></li></ul></div>
<div class="admonitionblock important"><table><tr><td class="icon"><i class="fa fa-exclamation-circle" title="Important"></i></td><td class="content">el nombre del fichero con el código fuente ha de ser <strong>obligatoriamente</strong> uno de los nombres del listado del apéndice "Nominación de los ficheros del examen" de los apuntes. NO ES VALIDO UN NOMBRE GENERICO COMO EXAMEN.s, tiene que estar personalizado para poder distinguir cada uno de los 90 exámenes a recoger.</td></tr></table></div>
<div class="ulist"><ul><li><p>Módulo fuente ensamblador:</p><div class="ulist"><ul><li><p>se ha de completar y depurar.</p></li><li><p>añadir los comentarios que se consideren oportunos ayudan a la lectura e interpretación del programa</p></li><li><p><strong>responder</strong> a las preguntas sobre el depurador GDB en el propio módulo fuente.</p></li></ul></div></li><li><p>No se puede conectar telemáticamente ni a la red de la UPNA ni al exterior de la Universidad</p></li><li><p>Se puede utilizar un pendrive conteniendo cualquier tipo de información: guiones de prácticas, memorias de prácticas, apuntes, hojas de referencia rápida.</p></li><li><p>Se puede utilizar cualquier tipo de material impreso: apuntes, memorias, libros, etc &#8230;&#8203;</p></li></ul></div></div></section><section id="_examen_líneas"><h2>39.3. Examen "líneas"</h2><div class="slide-content"><div class="ulist"><ul><li><p>Para los alumnos que elijan hacer la segunda opción del examen, "líneas" sobre gráficas bmp se ha subido a miaulario/recursos/prácticas dos módulos fuente: bmp_linea.c y pixel_linea.c.</p><div class="ulist"><ul><li><p>bmp_linea.c llama a la función pixel_generator_linea() definida en pixel_linea.c.</p></li></ul></div></li><li><p>El módulo ensamblador pixel_linea.s ha de ser fiel reflejo del módulo pixel_linea.c. En los comentarios del módulo ensamblador deben de aparecer las sentencias del lenguaje C. por ejemplo:</p><div class="listingblock"><div class="content"><pre>#dx=x2-x1;
   neg x1
   add x2,x1

#dy = y2-y1;
   neg y1
   add y2,y1

#i1=2*dy;



#i2=2*(dy-dx);


#   while (x &lt; xmax){
while:
     mov dx,$eax

# if (d&lt;0)
     mov dx,$eax

# else
else:
     mov dx,$eax

endif:
     mov dx,$eax

while_exit:
    mov dx,$eax</pre></div></div></li><li><p>Las variables locales a la función pixels_generator_linea(), es decir,  i1,i2,dx,dy,d,x,y,xmax para ser locales también en ensamblador y por lo tanto han de definirse en el frame de la función pixels_generator_linea() y no en la "section data" común a todas las funciones del fichero.</p></li><li><p>El módulo ensamblador ha de contener los siguientes comentarios pregunta/respuesta:</p><div class="listingblock"><div class="content"><pre># comando de generación del módulo objeto pixel_linea.o
# respuesta_1:

# comando de generación del módulo ejecutable bmp_linea
# respuesta_2:

# comando de apertura de la sesión de depuración
# respuesta_3: gdb --readnow

# (gdb) captura de la dirección de retorno al programa principal bmp_linea
# comando_4:
# respuesta_4:


# (gdb) captura del primer elemento de la pila después del prólogo de pixel_linea
# comando_5:
# respuesta_5:</pre></div></div></li></ul></div></div></section></section>
<section id="_nominación_de_los_ficheros_del_examen"><h2>40. Nominación de los ficheros del examen</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre>Alen_Urra
Alonso_Gomez
Altamirano_Trujillo
Alvarez_Alonso
Andreu_Mangado
Apesteguia_Guillen
Apesteguia_Vazquez
Arrastio_Peris
Arriazu_Muñoz
Ayechu_Garriz
Azcona_Furtado
Aznarez_Gil
Baigorrotegui_Gil
Bayona_Restrepo
Bellera_Alsina
Calleja_Pascual
Cascan_Ustarroz
Cerezo_Uriz
Chacon_Flores
Cordido_Perez
Couceiro_Eizaguirre
Cuello_Tejero
de_la_Ossa_Goñi
Diaz_Ochoa
Dobromirova_Karailieva
Echenique_Arizaleta
Eguillor_Pinillos
Elcid_Beperet
Etxabe_Gil
Etxarri_Martin_de_Vidales
Ezponda_Igea
Fernandez_Illera
Fernandez_Picorelli
Flamarique_Arellano
Fortun_Iñurrieta
Gallo_Ansa
Garatea_Larrayoz
Garcia_Vilas
Gil_Gil
Goicoechea_Elio
Goikoetxea_Macua
Gomez_Ciganda
Goñi_Lara
Granda_Saritama
Hualde_Romero
Huarte_Urriza
Iribarren_Ruiz
Isturitz_Sesma
Jimenez_Nadales
Juanotena_Ezkurra
Juarez_Jimenez
Labat_Garcia
Labiano_Garcia
Lalana_Morales
Larrayoz_Diaz
Larrayoz_Urra
Latasa_Sancha
Liebana_Revuelta
Longas_Saragüeta
Lumbreras_Corredor
Martinez_Arpon
Martinez_de_Goñi
Martinez_de_Morentin_Beaumont
Martinez_Sesma
Melendez_Uriz
Mellado_Ilundain
Molina_Puyuelo
Monreal_Ayanz
Moral_Garcia
Oroz_Azcarate
Orradre_Berdusan
Pascal_Alegria
Perez_Alvarez
Portuondo_Varona
Redrejo_Fernandez
Ripoll_Baños
Romero_Sadaba
Ruiz_de_Gopegui_Rubio
Saiz_Larraz
Santos_Garzon
Sanz_Sanz
Sola_Alba
Sola_Bienzobas
Solaegui_Garralda
Taberna_Maceira
Tellechea_Zamanillo
Turrillas_Remiro
Urroz_Velasco
Vadillo_Navarro
Yaniz_Ibañez
Yarhui_Sarate
Zamboran_Maldonado
Zheng
Zulaika_Irigoien</pre></div></div></div></section>
<section><section id="_exámenes_de_cursos_anteriores"><h2>41. Exámenes de Cursos Anteriores</h2></section><section id="_año_2018"><h2>41.1. Año 2018</h2><div class="slide-content"><h level="3">Noviembre</h><div class="literalblock"><div class="content"><pre>1ª Prueba Parcial. 2018 Noviembre 10.
Grado de Informática 2º curso. Estructura de Computadores.
Universidad Pública de Navarra.
Duración: 90 minutos.
Apellidos:
Nombre:</pre></div></div>
<div class="admonitionblock important"><table><tr><td class="icon"><i class="fa fa-exclamation-circle" title="Important"></i></td><td class="content">Puede utilizarse todo tipo de información escrita como memorias de prácticas, apuntes, hojas de referencia, etc. No puede utilizarse ningún dispositivo electrónico como calculadoras, teléfonos, ordenadores, etc &#8230;&#8203; Se han de incluir en la respuetas todo tipo de desarrollo necesario para llegar al resultado.</td></tr></table></div>
<div class="olist arabic"><ol class="arabic"><li><p>Computadora Institute Advanced Studies (IAS) de von Neumann:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>(1 pto) Desarrollar un programa que realice la resta 0x00-0xFF y almacene el resultado en la variable denominada "resta". ¿Cuál será el contenido de la posición de memoria de la variable "resta"?</p></li><li><p>(1 pto) ¿Qué relación existe entre los tres componentes MAR, MBR y PC?</p></li></ol></div></li><li><p>(1 pto) Cuál es el código digital del string de seis caracteres "Hola \n"</p></li><li><p>(1 pto) Los números 0123 y 0777 son números sin signo en base octal. Realizar la suma 0123+0777 directamente en base octal.</p></li><li><p>(1 pto) Los números 0xABC y 0xEFE son números con signo en complemento a dos. Realizar la resta 0xABC-0xEFE directamente. Calcular el valor del resultado.</p></li><li><p>(1 pto) Representar el número decimal 6.25 en formato IEEE-754 de doble precisión.</p></li><li><p>Formato de instrucciones:</p><div class="ulist"><ul><li><p>Una computadora tiene una unidad de memoria de 256K palabras 32 bits cada una direccionable byte a byte. En una de las palabras de la memoria se almacena una instrucción. La instrucción tiene un formato de cuatro campos: un bit de indirección, un código de operación, un campo de operando para direccionar uno de los 64 registros y campo de operando que contiene direcciones de memoria.</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>(2 pto) ¿Cuantos bits forman el campo de código de operación?¿Y del campo de registro?¿Y del campo de direcciones?</p></li><li><p>(2 pto) ¿Cuantos bits forman parte del bus de direcciones y del bus de datos de la unidad de memoria?</p></li></ol></div></li></ul></div></li><li><p>(2 pto) En una subrutina indicar qué relación existe entre el puntero "frame pointer" del frame de la subrutina y la dirección de memoria donde se guarda la dirección de retorno.</p></li><li><p>(3 pto) Completar el código fuente del programa en lenguaje ensamblador adjunto teniendo en cuenta los comentarios que se adjuntan en el módulo fuente siguiente donde el algoritmo desarrollado realiza la conversión de un número decimal a código binario:</p><div class="listingblock"><div class="content"><pre>### Programa: convert_decbin.s
### Descripción: Convierte el número natural decimal 15 en binario mediante divisiones sucesivas por 2
### 		 El código binario tiene un tamaño de 32 bits
### gcc -m32 -g -nostartfiles -o convert_decbin convert_decbin.s
### Ensamblaje as --32 --gstabs convert_decbin.s -o convert_decbin.o
### linker -&gt; ld -melf_i386    -o convert_decbin convert_decbin.o

	## MACROS



	## DATOS

dec:    .	  15	# decimal (tamaño 4 bytes) a convertir en un código binario de 32 bits
	## bin almacena el código en sentido inverso, bin[0] almacena el bit de menor peso.
bin:	.space	32	# array de 32 bytes: almacena en cada byte un bit del código binario de 32 bits.
divisor:	.	# divisor (de tamaño 1 byte)

	## INSTRUCCIONES




	## inicializo ECX con el valor del divisor


	## inicializo el índice del array bin


	## Cargo el dividendo en EAX
        			# eax &lt;-x

	## extiendo el bit de signo del dividendo en EDX
		 		# El dividendo siempre es positivo

	## Divisiones sucesivas por 2 hasta que el cociente valga 0
bucle:
	## idivl : [EDX:EAX] / Operando_fuente
				# EAX&lt;-Cociente{x/y} , EDX&lt;-Resto{x/y}
				# guardo el resto (de tamaño 1 byte) en el array bin
	## extiendo el bit de signo en edx
				# El dividendo siempre es positivo

	## actualizo el índice del array


	## compruebo si el cociente ha llegado a cero para salir del bucle


	## Devuelvo el número de bits del código binario en EBX


	## Código de la llamada al sistema operativo


	## Interrumpo la rutina y llamo al S.O.</pre></div></div>
<div class="ulist"><ul><li><p>Mediante comandos del depurador GDB</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>(2 pto) imprimir el contenido del array "bin" con dos expresiones diferentes utilizando los comandos "examinar" y/o "imprimir".</p></li><li><p>(2 pto) imprimir el contenido del primer elemento del array bin</p></li><li><p>(2 pto) imprimir el contenido del último elemento del array bin</p></li></ol></div></li></ul></div></li><li><p>(2 pto) Llamadas al sistema</p><div class="ulist"><ul><li><p>Completar el programa "convert_decbin.s" con el código necesario para imprimir en la pantalla un mensaje de bienvenida mediante la llamada directa write.</p></li></ul></div></li></ol></div></div></section><section id="_año_2017"><h2>41.2. Año 2017</h2><div class="slide-content"><div class="literalblock"><div class="content"><pre>Prueba Parcial. 2017 Septiembre 22.
Grado de Informática 2º curso. Estructura de Computadores.
Universidad Pública de Navarra.
Duración: 30 minutos.
Apellidos:
Nombre:</pre></div></div>
<div class="olist arabic"><ol class="arabic"><li><p>En el modelo de Von Neumann cuál es la función de la Unidad de Control .</p></li><li><p>Cuáles son las distintas fases del ciclo de instrucción de la máquina de Von Neumann.</p></li><li><p>Convertir el número decimal 291 en base octal.</p></li><li><p>Realizar la operación -18-21 en complemento a 2.</p></li><li><p>En qué consiste el concepto de abstracción en al organización de una computadora.</p></li><li><p>Desarrollar el programa en lenguaje ensamblador sum.ias, de la máquina IAS, que implemente el algoritmo s=1+2.</p><div class="literalblock"><div class="content"><pre>Prueba Parcial. 2017 Octubre 10.
Grado de Informática 2º curso. Estructura de Computadores.
Universidad Pública de Navarra.
Duración: 30 minutos.
Apellidos:
Nombre:</pre></div></div></li></ol></div>
<div class="admonitionblock important"><table><tr><td class="icon"><i class="fa fa-exclamation-circle" title="Important"></i></td><td class="content">Puede utilizarse todo tipo de información escrita como memorias de prácticas, apuntes, hojas de referencia, etc</td></tr></table></div>
<div class="olist arabic"><ol class="arabic"><li><p>Completar el módulo fuente exa_2017.s en lenguaje ensamblador AT&amp;T x86-32.(6 ptos)</p><div class="listingblock"><div class="content"><pre>### Estructura de Computadores curso 2017-18. Prueba evaluatoria 2017 Octubre 10
###
### Objetivos:
### 		Manejar la codificación de datos enteros con signo
### 		Estructuras de datos: puntero y array
### 		Modos de direccionamientos indirectos e indexados
### 		Lenguaje asm x86-32
### Algoritmo:  El array lista contiene cinco números enteros negativos de tamaño dos bytes,
###		desde -5 hasta -1, siendo -5 el valor de la posición cero.
### 		Copiar el contenido del array lista en el buffer.
###		Al buffer se accede indirectamente a través de la variable puntero EAX
###		El argumento de salida enviado al sistema operativo ha de ser
###		el primer valor del array lista.
	## MACROS
	.equ	SYS_EXIT, 1	# Código de la llamada al sistema operativo
	.equ	LEN,      5	# Longitud del array y del buffer
	## VARIABLES: lista y buffer
	.data
lista: # Array inicializado con datos representados en HEXADECIMAL

	_ _ _ _
buffer: # Reserva memoria para el buffer sin inicializar.

	_ _ _ _
	## INSTRUCCIONES
	## Punto de entrada

	_ _ _ _

	_ _ _ _
_start:
	## inicializo el argumento de salida con el valor cero

	_ _ _ _

	_ _ _ _
	## inicializo la variable puntero EAX

	_ _ _ _

	_ _ _ _
	## inicializo el bucle con el número de iteracciones. Utilizar las macros.
	mov   ,%esi
bucle:
	_ _ _ _

	_ _ _ _

	_ _ _ _

	_ _ _ _
	dec %esi
	jns bucle
	## salida

	mov _ _ _ _,%eax

	int _ _ _ _
	.end</pre></div></div>
<div class="ulist"><ul><li><p>Cuestiones:</p><div class="ulist"><ul><li><p>Comando gdb para visualizar el contenido del buffer una vez finalizada la copia (2 pto):</p><div class="ulist"><ul><li><p>.</p></li><li><p>(gdb)</p></li></ul></div></li><li><p>Si la etiqueta lista apunta a la dirección 0x00555438 indicar el contenido de las direcciones (2 pto):</p><div class="ulist"><ul><li><p>.</p></li><li><p>0x0055543C :</p></li><li><p>.</p></li><li><p>0x0055543D :</p><div class="literalblock"><div class="content"><pre>Prueba Ordinaria. 2018 Diciembre 7.
Grado de Informática 2º curso. Estructura de Computadores.
Universidad Pública de Navarra.
Duración: 45 minutos.</pre></div></div></li></ul></div></li></ul></div></li></ul></div></li></ol></div>
<div class="paragraph"><p>1ª PARTE (10 ptos)</p></div>
<div class="ulist"><ul><li><p>Duración: 20 minutos</p></li><li><p>Calificación:</p><div class="olist arabic"><ol class="arabic"><li><p>(3 ptos) Resta de números sin signo: 0x8000 - 0x7AFF  &#8594; las operaciones han de realizarse en código HEXADECIMAL exclusivamente</p><table class="tableblock frame-all grid-all" style="width:100%"><colgroup><col style="width:100%" /></colgroup><tbody><tr><td class="tableblock halign-left valign-top" rowspan="7"></td></tr></table></li><li><p>(3 ptos) Resta de números con signo: 0x8000 - 0x7AFF   &#8594; las operaciones han de realizarse en código HEXADECIMAL exclusivamente</p><table class="tableblock frame-all grid-all" style="width:100%"><colgroup><col style="width:100%" /></colgroup><tbody><tr><td class="tableblock halign-left valign-top" rowspan="7"></td></tr></table></li><li><p>(3 ptos) Relacionar en una sola frase los conceptos: contador de programa, ruta de datos, ciclo de instrucción, secuenciador, microordenes, unidad aritmetico lógica, microarquitectura , captura de instrucción.</p><table class="tableblock frame-all grid-all" style="width:100%"><colgroup><col style="width:100%" /></colgroup><tbody><tr><td class="tableblock halign-left valign-top" rowspan="7"></td></tr></table>
<div style="page-break-after: always;"></div></li></ol></div></li></ul></div>
<div class="paragraph"><p>2ª PARTE (10 pts)</p></div>
<div class="ulist"><ul><li><p>Duración: 25 minutos</p></li><li><p>Calificación:</p><div class="olist arabic"><ol class="arabic"><li><p>(6 ptos) Desarrollar el módulo fuente <em>cadena_longitud.s</em> en lenguaje ensamblador AT&amp;T x86-32.</p><div class="listingblock"><div class="content"><pre>/*

Programa: calcular el tamaño de una cadena de caracteres  inicializada en el propio programa fuente con la frase "Hola"
Algoritmo: Implementar un bucle hasta encontrar el caracter fin de string :  \0
Etiquetas: La referencia al string se realizará mediante el símbolo cadena.
Comentarios: Se ha de comentar el módulo fuente por bloques de código que tengan un sentido en lenguajes de alto nivel exclusivamente, no por líneas de código que describan una instrucción máquina.
*/


	## Definición de MACROS
	.equ SUCCESS, 0
	.equ SYS_EXIT, 1
	.equ FIN_CAR, '\0'</pre></div></div>
<table class="tableblock frame-all grid-all" style="width:100%"><colgroup><col style="width:100%" /></colgroup><tbody><tr><td class="tableblock halign-left valign-top" rowspan="30"></td></tr></table></li></ol></div></li></ul></div>
<div style="page-break-after: always;"></div>
<div class="ulist"><ul><li><p>Cuestiones: (4 ptos)</p><div class="ulist"><ul><li><p>Dos comando gdb para visualizar el contenido del objeto almacenado en la dirección cadena</p><div class="ulist"><ul><li><p>(gdb)</p></li><li><p>(gdb)</p></li></ul></div></li><li><p>Comando gdb para visualizar exclusivamente el carácter fin de cadena.</p><div class="ulist"><ul><li><p>(gdb)</p></li></ul></div></li><li><p>Indicar los dos comandos necesarios para compilar el programa fuente anterior mediante un toolchain manual, sin utilizar el front-end gcc.</p><table class="tableblock frame-all grid-all" style="width:100%"><colgroup><col style="width:100%" /></colgroup><tbody><tr><td class="tableblock halign-left valign-top" rowspan="4"></td></tr></table></li></ul></div></li></ul></div>
<div style="page-break-after: always;"></div>
<div class="literalblock"><div class="content"><pre>GRUPO:
APELLIDOS:
NOMBRE:</pre></div></div>
<div class="literalblock"><div class="content"><pre>Prueba Ordinaria. 2018 Diciembre 7.
Grado de Informática 2º curso. Estructura de Computadores.
Universidad Pública de Navarra.
Duración: 50 minutos.</pre></div></div>
<div class="paragraph"><p>3ª PARTE (10 ptos)</p></div>
<div class="ulist"><ul><li><p>Duración: 50 minutos</p></li><li><p>Calificación:</p><div class="olist arabic"><ol class="arabic"><li><p>(2 ptos) En una llamada a una subrutina con 6 argumentos y una variable local al finalizar el ciclo de instrucción de la instrucción <strong>CALL subrutina</strong>  el stack pointer apunta a la dirección 0xFFFA0C. Calcular:</p><div class="ulist"><ul><li><p>La dirección de memoria donde se guarda la dirección de retorno</p><table class="tableblock frame-all grid-all" style="width:100%"><colgroup><col style="width:100%" /></colgroup><tbody><tr><td class="tableblock halign-right valign-top" rowspan="3"></td></tr></table></li><li><p>La dirección de memoria de la variable local</p><table class="tableblock frame-all grid-all" style="width:100%"><colgroup><col style="width:100%" /></colgroup><tbody><tr><td class="tableblock halign-left valign-top" rowspan="3"></td></tr></table></li><li><p>La dirección de memoria del 1º argumento de la subrutina</p><table class="tableblock frame-all grid-all" style="width:100%"><colgroup><col style="width:100%" /></colgroup><tbody><tr><td class="tableblock halign-left valign-top" rowspan="3"></td></tr></table></li></ul></div></li></ol></div></li></ul></div>
<div style="page-break-after: always;"></div>
<div class="olist arabic"><ol class="arabic"><li><p>(4 ptos) El diagrama de bloques de la microarquitectura de la cpu de una computadora con un tamaño de palabra de 16 bits se corresponde con el de la figura en la hoja adjunta. La ISA de dicha computadora dispone de un lenguaje ensamblador que se corresponde con los mnemónicos y la sintaxis AT&amp;T x86-32 . En la memoria principal se carga el código máquina, correspondiente a la sección de instrucciones del módulo fuente, siguiente:</p><div class="literalblock"><div class="content"><pre>movw $0xF000,R0
movw R0,R1
addw R1,R0
subw R1,R0</pre></div></div>
<div class="ulist"><ul><li><p>Si el secuenciador de la unidad de control está diseñado como una máquina de 4 estados T0,T1,T2 y T3 , indicar en la tabla adjunta las microórdenes a ejecutar en cada estado del ciclo de instrucción para cada instrucción del programa.</p><table class="tableblock frame-all grid-all" style="width:100%"><colgroup><col style="width:20%" /><col style="width:20%" /><col style="width:20%" /><col style="width:20%" /><col style="width:20%" /></colgroup><thead><tr><th class="tableblock halign-left valign-top"></th><th class="tableblock halign-center valign-top">T0</th><th class="tableblock halign-center valign-top">T1</th><th class="tableblock halign-center valign-top">T2</th><th class="tableblock halign-center valign-top">T3</th></tr><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>mov $0xF000,R0</strong></p></td><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-center valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>movw R0,R1</strong></p></td><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-center valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>addw R1,R0</strong></p></td><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-center valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>subw R1,R0</strong></p></td><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-center valign-top"></td></tr></table></li></ul></div></li></ol></div>
<div style="page-break-after: always;"></div>
<div class="olist arabic"><ol class="arabic"><li><p>(4 ptos) Organización de una memoria jerarquizada</p><div class="ulist"><ul><li><p>En el proceso de compilación de un programa, desde la fase inicial de edición hasta la carga del programa en un proceso en la memoria principal, la cadena de herramientas "toolchain" genera distintos espacios de memoria en los diferentes módulos del proceso de traducción de código. Rellenar la tabla adjunta con las características propias de cada espacio generado.</p><table class="tableblock frame-all grid-all" style="width:100%"><colgroup><col style="width:20%" /><col style="width:20%" /><col style="width:20%" /><col style="width:20%" /><col style="width:20%" /></colgroup><thead><tr><th class="tableblock halign-left valign-top">Herramienta</th><th class="tableblock halign-left valign-top">Programa</th><th class="tableblock halign-left valign-top">Estructura del Espacio de Memoria y Direccionamiento</th><th class="tableblock halign-left valign-top">Tipo de direcciones</th><th class="tableblock halign-left valign-top">Localización del código</th></tr><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Edición</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Módulo Fuente</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Secciones y Etiquetas</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Virtual,No lineal</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code>Mem. Secundaria: Disco duro</code></p></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr></table></li><li><p>Cómo estructura el controlador de memoria caché dentro de la jerarquía de memoria la memoria caché y la memoria RAM dinámica.</p><table class="tableblock frame-all grid-all" style="width:100%"><colgroup><col style="width:100%" /></colgroup><tbody><tr><td class="tableblock halign-left valign-top" rowspan="4"></td></tr></table></li><li><p>Físicamente, en que consiste una celda de memoria RAM dinámica.</p><table class="tableblock frame-all grid-all" style="width:100%"><colgroup><col style="width:100%" /></colgroup><tbody><tr><td class="tableblock halign-left valign-top" rowspan="4"></td></tr></table></li><li><p>Cómo sincroniza las transferencias de datos a través del bus del sistema, una memoria ram dinámica Double Data Rate DDR.</p><table class="tableblock frame-all grid-all" style="width:100%"><colgroup><col style="width:100%" /></colgroup><tbody><tr><td class="tableblock halign-left valign-top" rowspan="4"></td></tr></table></li></ul></div></li></ol></div>
<div style="page-break-after: always;"></div>
<div class="olist arabic"><ol class="arabic"><li><p>(3 ptos) Mecanismos de operaciones E/S</p><div class="ulist"><ul><li><p>Dibujar el diagrama de bloques del HW necesario entre una tecla del teclado y las unidades básicas de la arquitectura von Neumann de una computadora para realizar la transferencia de datos mediante el mecanismo de interrupciones.</p><table class="tableblock frame-all grid-all" style="width:100%"><colgroup><col style="width:100%" /></colgroup><tbody><tr><td class="tableblock halign-left valign-top" rowspan="20"></td></tr></table></li><li><p>Dibujar el diagrama de bloques del SW necesario entre una tecla del teclado y las unidades básicas de la arquitectura von Neumann de una computadora para realizar la transferencia de datos mediante el mecanismo de interrupciones.</p><table class="tableblock frame-all grid-all" style="width:100%"><colgroup><col style="width:100%" /></colgroup><tbody><tr><td class="tableblock halign-left valign-top" rowspan="27"></td></tr></table></li></ul></div></li></ol></div></div></section></section>
<section><section id="_miaulario_videoconferencia"><h2>42. Miaulario: Videoconferencia</h2></section><section id="_introducción_29"><h2>42.1. Introducción</h2><div class="slide-content"><div class="ulist"><ul><li><p>Información</p><div class="ulist"><ul><li><p><a href="https://miaulario.unavarra.es/access/content/group/b15fc60b-3c66-452d-a7d9-42ec8cdab3a1/CSIE_WEB/site_csie/zoom-gida/zoom-gida_es.html" class="bare">https://miaulario.unavarra.es/access/content/group/b15fc60b-3c66-452d-a7d9-42ec8cdab3a1/CSIE_WEB/site_csie/zoom-gida/zoom-gida_es.html</a></p></li><li><p>correo electrónico <a href="mailto:csie@unavarra.es">csie@unavarra.es</a></p></li></ul></div></li></ul></div></div></section><section id="_instalación_de_zoom"><h2>42.2. Instalación de Zoom</h2><div class="slide-content"><div class="ulist"><ul><li><p>El conferenciante necesita instalarse la aplicación ZOOM en su versión básica (gratuita)</p></li><li><p><a href="https://zoom.us/" class="bare">https://zoom.us/</a></p></li><li><p>Es necesario registrarse</p></li><li><p>En la versión Ubuntu 18.0 desde el navegador Firefox no se puede iniciar el cliente</p></li><li><p>Descargar el paquete zoom_amd64.deb</p></li><li><p>comando de instalación: <code>dpkg -i zoom_amd64.deb</code></p></li><li><p>Abrir el cliente: <code>./zoom</code></p></li></ul></div></div></section><section id="_guía_de_usuario_zoom"><h2>42.3. Guía de usuario Zoom</h2><div class="slide-content"><h level="3">Configuración</h><div class="ulist"><ul><li><p>Testear el audio</p></li></ul></div></div></section><section id="_sesión_de_videoconferencia"><h2>42.4. Sesión de videoconferencia</h2><div class="slide-content"><div class="ulist"><ul><li><p>Desde miaulario &#8594; login &#8594; asignatura &#8594; videoconferencia</p></li><li><p><a href="https://miaulario.unavarra.es/access/content/group/b15fc60b-3c66-452d-a7d9-42ec8cdab3a1/CSIE_WEB/site_csie/zoom-gida/zoom-gida_es.html" class="bare">https://miaulario.unavarra.es/access/content/group/b15fc60b-3c66-452d-a7d9-42ec8cdab3a1/CSIE_WEB/site_csie/zoom-gida/zoom-gida_es.html</a></p></li></ul></div></div></section></section></div></section>
<section id="_ix_bibliografía"><h2>IX Bibliografía</h2><div class="slide-content"><div id="arqui_computadores" class="ulist bibliography"><div class="title">Arquitectura de Computadores</div><ul class="bibliography"><li><p><a></a>[] William Stallings. Organización y arquitectura de computadores .
Edición 7, reimpresa Pearson Prentice Hall
ISBN 8489660824, 9788489660823 . 2006</p></li><li><p><a></a>[] William Stallings.Computer Organization and Architecture: Designing for Performance.
 9ª Ed Upper Saddle River (NJ) : Prentice Hall, 2013
ISBN 0-273-76919-7 . 2012</p></li><li><p><a></a>[]Randal E. Bryant, David R. O&#8217;Hallaron. Computer Systems: A Programmer&#8217;s Perspective. Addison-Wesley. 2nd Edition. 2010.</p></li><li><p><a></a>[]David A. Patterson, John L. Hennessy. Computer Organizarion and Design. The Hardware / Software Interface. Morgan Kaufmann. 2009. Libro Standard de la mayoría de las Universidades.</p></li><li><p><a></a>[] Computer System Architecture, Morris Mano.</p></li></ul></div>
<div class="ulist bibliography"><div class="title">x86</div><ul class="bibliography"><li><p><a></a>[] <a href="https://en.wikipedia.org/wiki/FLAGS_register" class="bare">https://en.wikipedia.org/wiki/FLAGS_register</a></p></li></ul></div>
<div id="prog_ensamblador" class="ulist bibliography"><div class="title">Programación Ensamblador</div><ul class="bibliography"><li><p><a></a>[] <a href="http://programminggroundup.blogspot.com.es/2007/01/programming-from-ground-up.html">Programming from the Ground Up</a>
Jonathan Bartlett Edited by Dominick Bruno, Jr.
Copyright © 2003 by Jonathan Bartlett Published by Bartlett Publishing in Broken Arrow, Oklahom
ISBN 0-9752838-4-7</p></li><li><p><a></a>[]<a href="https://upcommons.upc.edu/handle/2117/115067">El ensamblador&#8230;&#8203; pero si es muy fácil</a>: IA-32 (i386) (sintaxis AT&amp;T)</p></li><li><p><a></a>[] <a href="https://docs.oracle.com/cd/E26502_01/html/E28388/eoiyg.html">Oracle AT&amp;T language</a></p></li><li><p><a></a>[] <a href="https://en.wikibooks.org/wiki/X86_Assembly">Apuntes WikiBook:x86 Assembly: AT&amp;T</a></p></li><li><p><a></a>[]Paul Carter. PC Assembly Language. Acceso libre. 2006.</p></li><li><p><a></a>[] Jeff Duntemann. Assembly Language Step-by-Step: Programming with Linux. Wiley Ed. 3rd Edition. 2009.</p></li><li><p><a></a>[] <a href="https://www.tutorialspoint.com/assembly_programming/index.htm">Tutorial NASM tutorialspoint</a></p></li><li><p><a></a>[] <a href="http://www.c-jump.com/CIS77/CIS77syllabus.htm">Apuntes Bristol Community College: Prog. NASM </a></p></li><li><p><a></a>[] <a href="http://www.cs.nyu.edu/~mwalfish/classes/ut/s13-cs439/ref/i386/toc.htm">i386 (32 bits)</a></p></li><li><p><a></a>[] <a href="http://www.felixcloutier.com/x86/">amd64 (64 bits)</a>: <strong>recomendado</strong></p></li><li><p><a></a>[] <a href="https://software.intel.com/en-us/articles/introduction-to-x64-assembly">Intel asm language</a>: Intel oficial Vol 1 Basic Architecture</p></li><li><p><a></a>[] <a href="http://support.amd.com/TechDocs/24593.pdf">AMD oficial</a>. Vol 3. 2.3 Summary of Registers and Data Types</p></li><li><p><a></a>[] <a href="http://pacman128.github.io/pcasm/">Paul Carter PC Assembly Language. Acceso libre. 2006.</a>: Netwide Assembler NASM, Intel language</p></li><li><p><a></a>[] <a href="http://www.duntemann.com/">Jeff Duntemann</a>. Assembly Language Step-by-Step: Programming with Linux. Wiley Ed. 3rd Edition. 2009.</p></li><li><p><a></a>[] <a href="http://kipirvine.com/">Kip R. Irvine</a>. Assembly Language for x86 Processors. Pearson. 6th Edition. 2014.</p></li></ul></div>
<div id="low_level_docs" class="ulist bibliography"><div class="title">Documentos de Programación de Bajo Nivel</div><ul class="bibliography"><li><p><a></a>[] <a href="https://www.uclibc.org/docs/psABI-i386.pdf">ABI i386</a></p></li><li><p><a></a>[] <a href="https://docs.microsoft.com/es-es/cpp/build/x64-software-conventions?view=vs-2017">Convención de llamada MicroSoft</a></p></li></ul></div>
<div class="ulist bibliography"><div class="title">Lenguaje de Programación C</div><ul class="bibliography"><li><p><a></a>[] <a href="http://knking.com/books/c/">K.N.King</a> C programming, a Modern Approach W.W. Norton 2ªEd. 2008.</p></li></ul></div>
<div class="ulist bibliography"><div class="title">Herramientas de Desarrollo de Programas</div><ul class="bibliography"><li><p><a></a>[]<a href="https://sourceware.org/binutils/docs-2.26/as/i386_002dDependent.html#i386_002dDependent:">AS i386</a>: syntax, mnemonics, register</p></li><li><p><a></a>[] <a href="https://www.gnu.org/manual/manual.html">GNU Software Development</a></p></li><li><p><a></a>[] <a href="http://sourceware.org/binutils/docs-2.31/as/index.html">GNU ASsembler</a></p></li><li><p><a></a>[] <a href="https://www.gnu.org/software/gdb/documentation/">debugger GDB</a></p></li><li><p><a></a>[] <a href="https://gcc.gnu.org/onlinedocs/gcc/">Compilador GCC</a></p></li><li><p><a></a>[] <a href="https://gcc.gnu.org/onlinedocs/cpp/">Preprocessor cpp</a></p></li><li><p><a></a>[] <a href="http://sourceware.org/binutils/docs-2.31/binutils/index.html">herramientas GNU binutils</a>:as,ld,objdump,&#8230;&#8203;</p></li><li><p><a></a>[] <a href="https://www.vim.org/docs.php">Vim</a></p></li><li><p><a></a>[] <a href="http://www.gnu.org/software/emacs/#Manuals">Emacs</a></p></li></ul></div>
<div class="ulist bibliography"><div class="title">Artículos</div><ul class="bibliography"><li><p><a></a>[] <a href="https://www.linuxvoice.com/john-von-neumann/">linuxvoice</a></p></li><li><p><a></a>[]  <a href="http://www.cs.uwm.edu/classes/cs458/Lecture/HTML/ch04.html">wisconsin university RTL</a></p></li></ul></div></div></section>
<section id="_x_glosario"><h2>X Glosario</h2><div class="slide-content"><div class="dlist glossary"><dl><dt>Primer término</dt><dd><p>The corresponding (indented) definition.</p></dd><dt>Segundo término</dt><dd><p>The corresponding (indented) definition.</p></dd></dl></div></div></section>
<section id="_xi_colofón"><h2>XI Colofón</h2><div class="slide-content"><div class="paragraph"><p>Text at the end of a book describing facts about its production.</p></div></div></section>
<section id="_index"><h2>Index</h2></section></div></div><script src="reveal.js/js/reveal.js"></script><script>Array.prototype.slice.call(document.querySelectorAll('.slides section')).forEach(function(slide) {
  if (slide.getAttribute('data-background-color')) return;
  // user needs to explicitly say he wants CSS color to override otherwise we might break custom css or theme (#226)
  if (!(slide.classList.contains('canvas') || slide.classList.contains('background'))) return;
  var bgColor = getComputedStyle(slide).backgroundColor;
  if (bgColor !== 'rgba(0, 0, 0, 0)' && bgColor !== 'transparent') {
    slide.setAttribute('data-background-color', bgColor);
    slide.style.backgroundColor = 'transparent';
  }
});

// More info about config & dependencies:
// - https://github.com/hakimel/reveal.js#configuration
// - https://github.com/hakimel/reveal.js#dependencies
Reveal.initialize({
  // Display presentation control arrows
  controls: true,
  // Help the user learn the controls by providing hints, for example by
  // bouncing the down arrow when they first encounter a vertical slide
  controlsTutorial: true,
  // Determines where controls appear, "edges" or "bottom-right"
  controlsLayout: 'bottom-right',
  // Visibility rule for backwards navigation arrows; "faded", "hidden"
  // or "visible"
  controlsBackArrows: 'faded',
  // Display a presentation progress bar
  progress: true,
  // Display the page number of the current slide
  slideNumber: false,
  // Control which views the slide number displays on
  showSlideNumber: 'all',
  // Add the current slide number to the URL hash so that reloading the
  // page/copying the URL will return you to the same slide
  hash: false,
  // Push each slide change to the browser history. Implies `hash: true`
  history: false,
  // Enable keyboard shortcuts for navigation
  keyboard: true,
  // Enable the slide overview mode
  overview: true,
  // Disables the default reveal.js slide layout so that you can use custom CSS layout
  disableLayout: false,
  // Vertical centering of slides
  center: true,
  // Enables touch navigation on devices with touch input
  touch: true,
  // Loop the presentation
  loop: false,
  // Change the presentation direction to be RTL
  rtl: false,
  // See https://github.com/hakimel/reveal.js/#navigation-mode
  navigationMode: 'default',
  // Randomizes the order of slides each time the presentation loads
  shuffle: false,
  // Turns fragments on and off globally
  fragments: true,
  // Flags whether to include the current fragment in the URL,
  // so that reloading brings you to the same fragment position
  fragmentInURL: false,
  // Flags if the presentation is running in an embedded mode,
  // i.e. contained within a limited portion of the screen
  embedded: false,
  // Flags if we should show a help overlay when the questionmark
  // key is pressed
  help: true,
  // Flags if speaker notes should be visible to all viewers
  showNotes: false,
  // Global override for autolaying embedded media (video/audio/iframe)
  // - null: Media will only autoplay if data-autoplay is present
  // - true: All media will autoplay, regardless of individual setting
  // - false: No media will autoplay, regardless of individual setting
  autoPlayMedia: null,
  // Global override for preloading lazy-loaded iframes
  // - null: Iframes with data-src AND data-preload will be loaded when within
  //   the viewDistance, iframes with only data-src will be loaded when visible
  // - true: All iframes with data-src will be loaded when within the viewDistance
  // - false: All iframes with data-src will be loaded only when visible
  preloadIframes: null,
  // Number of milliseconds between automatically proceeding to the
  // next slide, disabled when set to 0, this value can be overwritten
  // by using a data-autoslide attribute on your slides
  autoSlide: 0,
  // Stop auto-sliding after user input
  autoSlideStoppable: true,
  // Use this method for navigation when auto-sliding
  autoSlideMethod: Reveal.navigateNext,
  // Specify the average time in seconds that you think you will spend
  // presenting each slide. This is used to show a pacing timer in the
  // speaker view
  defaultTiming: 120,
  // Specify the total time in seconds that is available to
  // present.  If this is set to a nonzero value, the pacing
  // timer will work out the time available for each slide,
  // instead of using the defaultTiming value
  totalTime: 0,
  // Specify the minimum amount of time you want to allot to
  // each slide, if using the totalTime calculation method.  If
  // the automated time allocation causes slide pacing to fall
  // below this threshold, then you will see an alert in the
  // speaker notes window
  minimumTimePerSlide: 0,
  // Enable slide navigation via mouse wheel
  mouseWheel: false,
  // Hide cursor if inactive
  hideInactiveCursor: true,
  // Time before the cursor is hidden (in ms)
  hideCursorTime: 5000,
  // Hides the address bar on mobile devices
  hideAddressBar: true,
  // Opens links in an iframe preview overlay
  // Add `data-preview-link` and `data-preview-link="false"` to customise each link
  // individually
  previewLinks: false,
  // Transition style (e.g., none, fade, slide, convex, concave, zoom)
  transition: 'slide',
  // Transition speed (e.g., default, fast, slow)
  transitionSpeed: 'default',
  // Transition style for full page slide backgrounds (e.g., none, fade, slide, convex, concave, zoom)
  backgroundTransition: 'fade',
  // Number of slides away from the current that are visible
  viewDistance: 3,
  // Number of slides away from the current that are visible on mobile
  // devices. It is advisable to set this to a lower number than
  // viewDistance in order to save resources.
  mobileViewDistance: 3,
  // Parallax background image (e.g., "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'")
  parallaxBackgroundImage: '',
  // Parallax background size in CSS syntax (e.g., "2100px 900px")
  parallaxBackgroundSize: '',
  // Number of pixels to move the parallax background per slide
  // - Calculated automatically unless specified
  // - Set to 0 to disable movement along an axis
  parallaxBackgroundHorizontal: null,
  parallaxBackgroundVertical: null,
  // The display mode that will be used to show slides
  display: 'block',

  // The "normal" size of the presentation, aspect ratio will be preserved
  // when the presentation is scaled to fit different resolutions. Can be
  // specified using percentage units.
  width: 960,
  height: 700,

  // Factor of the display size that should remain empty around the content
  margin: 0.1,

  // Bounds for smallest/largest possible scale to apply to content
  minScale: 0.2,
  maxScale: 1.5,

  // PDF Export Options
  // Put each fragment on a separate page
  pdfSeparateFragments: true,
  // For slides that do not fit on a page, max number of pages
  pdfMaxPagesPerSlide: 1,

  // Optional libraries used to extend on reveal.js
  dependencies: [
      { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
      { src: 'reveal.js/plugin/notes/notes.js', async: true }
  ],

  

});</script><script>var dom = {};
dom.slides = document.querySelector('.reveal .slides');

function getRemainingHeight(element, slideElement, height) {
  height = height || 0;
  if (element) {
    var newHeight, oldHeight = element.style.height;
    // Change the .stretch element height to 0 in order find the height of all
    // the other elements
    element.style.height = '0px';
    // In Overview mode, the parent (.slide) height is set of 700px.
    // Restore it temporarily to its natural height.
    slideElement.style.height = 'auto';
    newHeight = height - slideElement.offsetHeight;
    // Restore the old height, just in case
    element.style.height = oldHeight + 'px';
    // Clear the parent (.slide) height. .removeProperty works in IE9+
    slideElement.style.removeProperty('height');
    return newHeight;
  }
  return height;
}

function layoutSlideContents(width, height) {
  // Handle sizing of elements with the 'stretch' class
  toArray(dom.slides.querySelectorAll('section .stretch')).forEach(function (element) {
    // Determine how much vertical space we can use
    var limit = 5; // hard limit
    var parent = element.parentNode;
    while (parent.nodeName !== 'SECTION' && limit > 0) {
      parent = parent.parentNode;
      limit--;
    }
    if (limit === 0) {
      // unable to find parent, aborting!
      return;
    }
    var remainingHeight = getRemainingHeight(element, parent, height);
    // Consider the aspect ratio of media elements
    if (/(img|video)/gi.test(element.nodeName)) {
      var nw = element.naturalWidth || element.videoWidth, nh = element.naturalHeight || element.videoHeight;
      var es = Math.min(width / nw, remainingHeight / nh);
      element.style.width = (nw * es) + 'px';
      element.style.height = (nh * es) + 'px';
    } else {
      element.style.width = width + 'px';
      element.style.height = remainingHeight + 'px';
    }
  });
}

function toArray(o) {
  return Array.prototype.slice.call(o);
}

Reveal.addEventListener('slidechanged', function () {
  layoutSlideContents(960, 700)
});
Reveal.addEventListener('ready', function () {
  layoutSlideContents(960, 700)
});
Reveal.addEventListener('resize', function () {
  layoutSlideContents(960, 700)
});</script></body></html>