<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.17">
<meta name="keywords" content="computer, architecture">
<meta name="author" content="Cándido Aramburu">
<title>Estructura de Computadores  (240306)</title>
<style>
@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";
@import "https://cdn.jsdelivr.net/gh/asciidoctor/asciidoctor@2.0/data/stylesheets/asciidoctor-default.css";



h1, h2, h3, h4, h5, h6, #toctitle,
.sidebarblock > .content > .title {
  color: rgba(221, 72, 20, 0.8);
}



</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
pre.rouge table td { padding: 5px; }
pre.rouge table pre { margin: 0; }
pre.rouge .cm {
  color: #999988;
  font-style: italic;
}
pre.rouge .cp {
  color: #999999;
  font-weight: bold;
}
pre.rouge .c1 {
  color: #999988;
  font-style: italic;
}
pre.rouge .cs {
  color: #999999;
  font-weight: bold;
  font-style: italic;
}
pre.rouge .c, pre.rouge .ch, pre.rouge .cd, pre.rouge .cpf {
  color: #999988;
  font-style: italic;
}
pre.rouge .err {
  color: #a61717;
  background-color: #e3d2d2;
}
pre.rouge .gd {
  color: #000000;
  background-color: #ffdddd;
}
pre.rouge .ge {
  color: #000000;
  font-style: italic;
}
pre.rouge .gr {
  color: #aa0000;
}
pre.rouge .gh {
  color: #999999;
}
pre.rouge .gi {
  color: #000000;
  background-color: #ddffdd;
}
pre.rouge .go {
  color: #888888;
}
pre.rouge .gp {
  color: #555555;
}
pre.rouge .gs {
  font-weight: bold;
}
pre.rouge .gu {
  color: #aaaaaa;
}
pre.rouge .gt {
  color: #aa0000;
}
pre.rouge .kc {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kd {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kn {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kp {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kr {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kt {
  color: #445588;
  font-weight: bold;
}
pre.rouge .k, pre.rouge .kv {
  color: #000000;
  font-weight: bold;
}
pre.rouge .mf {
  color: #009999;
}
pre.rouge .mh {
  color: #009999;
}
pre.rouge .il {
  color: #009999;
}
pre.rouge .mi {
  color: #009999;
}
pre.rouge .mo {
  color: #009999;
}
pre.rouge .m, pre.rouge .mb, pre.rouge .mx {
  color: #009999;
}
pre.rouge .sa {
  color: #000000;
  font-weight: bold;
}
pre.rouge .sb {
  color: #d14;
}
pre.rouge .sc {
  color: #d14;
}
pre.rouge .sd {
  color: #d14;
}
pre.rouge .s2 {
  color: #d14;
}
pre.rouge .se {
  color: #d14;
}
pre.rouge .sh {
  color: #d14;
}
pre.rouge .si {
  color: #d14;
}
pre.rouge .sx {
  color: #d14;
}
pre.rouge .sr {
  color: #009926;
}
pre.rouge .s1 {
  color: #d14;
}
pre.rouge .ss {
  color: #990073;
}
pre.rouge .s, pre.rouge .dl {
  color: #d14;
}
pre.rouge .na {
  color: #008080;
}
pre.rouge .bp {
  color: #999999;
}
pre.rouge .nb {
  color: #0086B3;
}
pre.rouge .nc {
  color: #445588;
  font-weight: bold;
}
pre.rouge .no {
  color: #008080;
}
pre.rouge .nd {
  color: #3c5d5d;
  font-weight: bold;
}
pre.rouge .ni {
  color: #800080;
}
pre.rouge .ne {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nf, pre.rouge .fm {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nl {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nn {
  color: #555555;
}
pre.rouge .nt {
  color: #000080;
}
pre.rouge .vc {
  color: #008080;
}
pre.rouge .vg {
  color: #008080;
}
pre.rouge .vi {
  color: #008080;
}
pre.rouge .nv, pre.rouge .vm {
  color: #008080;
}
pre.rouge .ow {
  color: #000000;
  font-weight: bold;
}
pre.rouge .o {
  color: #000000;
  font-weight: bold;
}
pre.rouge .w {
  color: #bbbbbb;
}
pre.rouge {
  background-color: #f8f8f8;
}
</style>
<!-- Change some CSS.
<style>
.imageblock{
  &.text-center > .title {
    text-align: center !important;
  }
}
</style>

-->

<style type="text/css"> .imageblock > .title { text-align: center; } </style>

<style>.toc-current{font-weight: bold;} .toc-root{font-family: "Open Sans","DejaVu Sans",sans-serif;
                       font-size: 0.9em;} #content{display: flex; flex-direction: column; flex: 1 1 auto;}
             .nav-footer{text-align: center; margin-top: auto;}
             .nav-footer > p > a {white-space: nowrap;}</style>
</head>
<body id="_mecanismos_de_entradasalida" class="book">
<div id="header">
<h1>Estructura de Computadores  (240306)</h1>
<div class="details">
<span id="author" class="author">Cándido Aramburu</span><br>
<span id="email" class="email"><a href="mailto:candido@unavarra.es">candido@unavarra.es</a></span><br>
<span id="revdate">2022-09-11</span>
</div>
<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<p><span class="toc-root"><a href="eecc_book.html">Estructura de Computadores  (240306)</a></span></p><ul class="sectlevel0">
<li><a href="_i_arquitectura_del_repertorio_de_instrucciones_isa_computadora_von_neumann_datos_instrucciones_programación.html">I Arquitectura del Repertorio de Instrucciones (ISA): computadora von Neumann, datos, instrucciones, programación.</a>
</li>
<li><a href="_ii_unidades_básicas_procesador_central_unidad_de_memoria_mecanismos_entradasalida.html">II Unidades Básicas: Procesador Central, Unidad de Memoria, Mecanismos Entrada/Salida.</a>
<ul class="sectlevel1">
<li><a href="_procesador_central.html">7. Procesador Central</a>
</li>
<li><a href="_mecanismos_de_entradasalida.html"><span class="toc-current">8. Mecanismos de Entrada/Salida</span></a>
<ul class="sectlevel2">
<li><a href="_mecanismos_de_entradasalida.html#_temario_8">8.1. Temario</a>
</li>
<li><a href="_mecanismos_de_entradasalida.html#_bibliografia">8.2. Bibliografia</a>
</li>
<li><a href="_mecanismos_de_entradasalida.html#_periféricos">8.3. Periféricos</a>
<ul class="sectlevel3">
<li><a href="_mecanismos_de_entradasalida.html#_ejemplos_5">8.3.1. Ejemplos</a>
</li>
<li><a href="_mecanismos_de_entradasalida.html#_modelo">8.3.2. Modelo</a>
</li>
</ul>
</li>
<li><a href="_mecanismos_de_entradasalida.html#_teclado">8.4. Teclado</a>
</li>
<li><a href="_mecanismos_de_entradasalida.html#_arquitectura_computadora">8.5. Arquitectura Computadora</a>
<ul class="sectlevel3">
<li><a href="_mecanismos_de_entradasalida.html#_von_neumann">8.5.1. Von Neumann</a>
</li>
<li><a href="_mecanismos_de_entradasalida.html#_conexión_cpu_es">8.5.2. Conexión CPU-E/S</a>
</li>
<li><a href="_mecanismos_de_entradasalida.html#_controlador_io">8.5.3. Controlador I/O</a>
</li>
<li><a href="_mecanismos_de_entradasalida.html#_espacio_de_direcciones">8.5.4. Espacio de direcciones</a>
</li>
<li><a href="_mecanismos_de_entradasalida.html#_buses">8.5.5. Buses</a>
</li>
<li><a href="_mecanismos_de_entradasalida.html#_analisis_portatil_lenovo_disco_duro">8.5.6. Analisis: Portatil Lenovo - Disco Duro</a>
</li>
</ul>
</li>
<li><a href="_mecanismos_de_entradasalida.html#_programa_es">8.6. Programa E/S</a>
<ul class="sectlevel3">
<li><a href="_mecanismos_de_entradasalida.html#_módulo_fuente">8.6.1. Módulo fuente</a>
</li>
</ul>
</li>
<li><a href="_mecanismos_de_entradasalida.html#_driver_sistema_operativo">8.7. Driver: Sistema Operativo</a>
<ul class="sectlevel3">
<li><a href="_mecanismos_de_entradasalida.html#_gestor_es_jerarquía">8.7.1. Gestor E/S: jerarquía</a>
</li>
<li><a href="_mecanismos_de_entradasalida.html#_código_fuente">8.7.2. Código Fuente</a>
</li>
<li><a href="_mecanismos_de_entradasalida.html#_concepto">8.7.3. Concepto</a>
</li>
<li><a href="_mecanismos_de_entradasalida.html#_utilizacion_del_driver">8.7.4. Utilizacion del Driver</a>
</li>
</ul>
</li>
<li><a href="_mecanismos_de_entradasalida.html#_mecanismos_de_implementación_de_la_interfaz_es">8.8. Mecanismos de Implementación de la Interfaz E/S</a>
<ul class="sectlevel3">
<li><a href="_mecanismos_de_entradasalida.html#_introduccion_2">8.8.1. Introduccion</a>
</li>
<li><a href="_mecanismos_de_entradasalida.html#_sincronización_por_encuesta">8.8.2. Sincronización por Encuesta</a>
</li>
<li><a href="_mecanismos_de_entradasalida.html#_sincronización_por_interrupción">8.8.3. Sincronización por Interrupción</a>
</li>
<li><a href="_mecanismos_de_entradasalida.html#_direct_memory_access_dma">8.8.4. Direct Memory Access (DMA)</a>
</li>
<li><a href="_mecanismos_de_entradasalida.html#_channel_io">8.8.5. Channel I/O</a>
</li>
</ul>
</li>
<li><a href="_mecanismos_de_entradasalida.html#_sincronizacion_por_interrupcion">8.9. Sincronizacion por Interrupcion</a>
<ul class="sectlevel3">
<li><a href="_mecanismos_de_entradasalida.html#_concepto_2">8.9.1. Concepto</a>
</li>
<li><a href="_mecanismos_de_entradasalida.html#_mecanismo_de_interrupcion">8.9.2. Mecanismo de Interrupcion</a>
</li>
<li><a href="_mecanismos_de_entradasalida.html#_controlador_de_interrupciones">8.9.3. Controlador de Interrupciones</a>
</li>
<li><a href="_mecanismos_de_entradasalida.html#_gestor_de_interrupciones">8.9.4. Gestor de Interrupciones</a>
</li>
<li><a href="_mecanismos_de_entradasalida.html#_tipos_de_interrupciones">8.9.5. Tipos de Interrupciones</a>
</li>
<li><a href="_mecanismos_de_entradasalida.html#_tabla_de_los_vectores_de_interrupciones">8.9.6. Tabla de los Vectores de interrupciones</a>
</li>
</ul>
</li>
<li><a href="_mecanismos_de_entradasalida.html#_acceso_directo_a_memoria_dma">8.10. Acceso Directo a Memoria DMA</a>
<ul class="sectlevel3">
<li><a href="_mecanismos_de_entradasalida.html#_funcionalidad">8.10.1. Funcionalidad</a>
</li>
<li><a href="_mecanismos_de_entradasalida.html#_transferencias">8.10.2. Transferencias</a>
</li>
<li><a href="_mecanismos_de_entradasalida.html#_sincronización">8.10.3. Sincronización</a>
</li>
<li><a href="_mecanismos_de_entradasalida.html#_operación_del_controlador_dma">8.10.4. Operación del controlador DMA</a>
</li>
<li><a href="_mecanismos_de_entradasalida.html#_problemas_de_coherencia_en_la_memoria_cache">8.10.5. Problemas de coherencia en la memoria cache</a>
</li>
</ul>
</li>
<li><a href="_mecanismos_de_entradasalida.html#_buses_2">8.11. Buses</a>
<ul class="sectlevel3">
<li><a href="_mecanismos_de_entradasalida.html#_isa_2">8.11.1. ISA</a>
</li>
<li><a href="_mecanismos_de_entradasalida.html#_pci">8.11.2. PCI</a>
</li>
<li><a href="_mecanismos_de_entradasalida.html#_north_south_bridge">8.11.3. North-South Bridge</a>
</li>
<li><a href="_mecanismos_de_entradasalida.html#_chipset_x58">8.11.4. Chipset x58</a>
</li>
</ul>
</li>
<li><a href="_mecanismos_de_entradasalida.html#_programacion_de_rutinas_de_entradasalida">8.12. Programacion  de rutinas de entrada/salida</a>
<ul class="sectlevel3">
<li><a href="_mecanismos_de_entradasalida.html#_software_jerarquico_del_sistema_operativo">8.12.1. Software jerarquico del sistema operativo</a>
</li>
<li><a href="_mecanismos_de_entradasalida.html#_instruction_set_architecture">8.12.2. Instruction Set Architecture</a>
</li>
<li><a href="_mecanismos_de_entradasalida.html#_programación_del_controlador_de_interrupciones_programable">8.12.3. Programación del Controlador de Interrupciones Programable</a>
</li>
<li><a href="_mecanismos_de_entradasalida.html#_driver_del_teclado">8.12.4. Driver del Teclado</a>
</li>
<li><a href="_mecanismos_de_entradasalida.html#_paralell_port">8.12.5. paralell port</a>
</li>
<li><a href="_mecanismos_de_entradasalida.html#_serial_communication_rs_232">8.12.6. Serial communication RS-232</a>
</li>
</ul>
</li>
<li><a href="_mecanismos_de_entradasalida.html#_ejercicios_2">8.13. Ejercicios</a>
</li>
</ul>
</li>
<li><a href="_unidad_de_memoria.html">9. Unidad de Memoria</a>
</li>
</ul>
</li>
<li><a href="_iii_ejercicios_de_teoría.html">III Ejercicios de Teoría</a>
</li>
<li><a href="_iv_autoevaluación_teoría.html">IV Autoevaluación Teoría</a>
</li>
<li><a href="_v_guiones_de_prácticas_programación_ensamblador_x86.html">V Guiones de Prácticas: Programación Ensamblador x86</a>
</li>
<li><a href="_vi_hojas_de_referencia_rápida.html">VI Hojas de Referencia Rápida</a>
</li>
<li><a href="_vii_autoevaluación_prácticas.html">VII Autoevaluación Prácticas</a>
</li>
<li><a href="_viii_apéndices.html">VIII Apéndices</a>
</li>
<li><a href="_ix_bibliografía.html">IX Bibliografía</a>
</li>
<li><a href="_x_glosario.html">X Glosario</a>
</li>
<li><a href="_xi_colofón.html">XI Colofón</a>
</li>
<li><a href="_index.html">Index</a>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_mecanismos_de_entradasalida">8. Mecanismos de Entrada/Salida</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_temario_8">8.1. Temario</h3>
<div class="olist arabic">
<ol class="arabic" start="8">
<li>
<p>Sistema de entrada / salida</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Sincronización por encuesta</p>
</li>
<li>
<p>Sincornización por interrupción</p>
</li>
<li>
<p>Vector de interrupciones</p>
</li>
<li>
<p>Acceso directo a memoria DMA</p>
</li>
<li>
<p>Programación en lenguaje ensamblador de rutinas de entrada/salida</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_bibliografia">8.2. Bibliografia</h3>
<div class="ulist">
<ul>
<li>
<p>Libro de Texto:</p>
<div class="ulist">
<ul>
<li>
<p>Estructura y Organización de Computadores. William Stalling: Capítulo 7</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_periféricos">8.3. Periféricos</h3>
<div class="sect3">
<h4 id="_ejemplos_5">8.3.1. Ejemplos</h4>
<div class="ulist">
<ul>
<li>
<p>Teclado</p>
</li>
<li>
<p>Monitor</p>
</li>
<li>
<p>Disco Duro</p>
</li>
<li>
<p>Red</p>
<div class="ulist">
<ul>
<li>
<p>LAN</p>
</li>
<li>
<p>Wifi</p>
</li>
</ul>
</div>
</li>
<li>
<p>Periférico externo</p>
<div class="ulist">
<ul>
<li>
<p>Pen-Drive</p>
</li>
</ul>
</div>
</li>
<li>
<p>De cada ejemplo info de:</p>
<div class="ulist">
<ul>
<li>
<p>modelo y link a características</p>
</li>
<li>
<p>interfaz: bus eléctrico, protocolo de comunicaciones</p>
</li>
<li>
<p>ancho de banda</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_modelo">8.3.2. Modelo</h4>
<div class="ulist">
<ul>
<li>
<p>Media : Magnético (HD), Mecánico (Robot), Optico (CD), Eléctrico (pen drive), etc</p>
<div class="ulist">
<ul>
<li>
<p>Electrónica analógica.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Driver HW</p>
<div class="ulist">
<ul>
<li>
<p>Interfaz con el media:</p>
<div class="ulist">
<ul>
<li>
<p>las señales que actuan sobre el media son de distinto tipo: optica (luz), mecánica (pneumático), acústica, etc. Estas señales se obtienen normalmente de la transformación de una señal eléctrica: interfaz eléctrico/optico, eléctrico/mecánico, eléctrico/acústico</p>
</li>
<li>
<p>Ej: Un altavoz</p>
</li>
<li>
<p>Ej: Un Láser con el disco óptico.</p>
</li>
<li>
<p>Ej: El modulador electrónico del láser</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Controlador del Periférico (<strong>MCU: MicroController Unit</strong>)</p>
<div class="ulist">
<ul>
<li>
<p><a href="http://en.wikipedia.org/wiki/Disk_buffer">Imagen de un controlador de disco</a></p>
</li>
<li>
<p>El Controlador  da órdenes al Driver HW</p>
</li>
<li>
<p>Es un secuenciador que interpreta <strong>Comandos</strong> (lenguaje específico para tareas del periférico) cuya ejecución realizará funciones propias del periférico.</p>
<div class="ulist">
<ul>
<li>
<p>Lenguaje de comandos. Command Set Architecture (CSA) ¿ISA?</p>
<div class="ulist">
<ul>
<li>
<p><a href="http://en.wikipedia.org/wiki/SCSI_command">Lenguaje SCSI</a></p>
</li>
<li>
<p><a href="https://ata.wiki.kernel.org/index.php/Developer_Resources">Lenguaje ATA / ATAPI</a></p>
</li>
<li>
<p>ATA Command Set (ACS): ejemplo de comandos IDENTIFY, READ DMA, WRITE DMA and FLUSH CACHE commands</p>
</li>
</ul>
</div>
</li>
<li>
<p>comandos de transferencia de datos, de control (operaciones mecánicas como girar), de test (estado del periférico: conectado, desconectado)</p>
</li>
</ul>
</div>
</li>
<li>
<p>Ej: en el caso de un disco el comando "girar a determinadas revoluciones". El disco integra un secuenciador propio, un MCU.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Firmware</p>
<div class="ulist">
<ul>
<li>
<p>El set de comandos del periférico son interpretados por el software (firmware) cargado en la memoria del controlador MCU. Dicho software ha sido grabado por el fabricante del periférico. El usuario únicamente podrá escribir en el periférico algunos parámetros de configuración del periférico siendo accesible el Firmaware unicamente por el fabricante.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_teclado">8.4. Teclado</h3>
<div class="ulist">
<ul>
<li>
<p>Estructura</p>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/ditaa/svg/eNrT1sUE2gogoI1LBpsEXBeKVm2uGgXv1Mqk_MSiFAUFn8TK_NISBYUaBV07EAmXcc1Lzk9JLYLKIEk45-eVFOXn5EDkgACkEcR0DggF0VzaNHU9ALENO9E=" alt="Diagram">
</div>
</div>
</li>
<li>
<p>Códigos</p>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/ditaa/svg/eNrT1kUF2gogoI0ugiGAKgST4apR8E6tVMhNTc5IzMtMVlCoUdC1A5HByYl5Cs75KakQEYgyMB-qBEg5ZyQWJSaXpBZBJRRquLSp6joAzdcxKQ==" alt="Diagram">
</div>
</div>
</li>
<li>
<p>Driver</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_arquitectura_computadora">8.5. Arquitectura Computadora</h3>
<div class="sect3">
<h4 id="_von_neumann">8.5.1. Von Neumann</h4>
<div class="ulist">
<ul>
<li>
<p>3 unidades básicas</p>
</li>
<li>
<p>Controlador i/o</p>
<div class="ulist">
<ul>
<li>
<p>Controlador auxiliar, no central, con dedicación específica a las operaciones E/S.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Subsistema de Entrada/Salida : es uno de los 3 componentes del modelo Von Neumann</p>
</li>
<li>
<p>Es necesario acceder a la máquina para:</p>
<div class="ulist">
<ul>
<li>
<p>Introducir el programa : Desde un soporte de almacenamiento (papel,disco,etc) ha de cargarse el programa en la memoria</p>
</li>
<li>
<p>Extraer el resultado generado por la máquina: Desde la memoria los resultados han de almacenarse en un soporte de almacenamiento (disco, impresora, etc), visualizarse (pantalla, etc), transferirse (red, etc).</p>
</li>
</ul>
</div>
</li>
<li>
<p>Dispositivos Periféricos</p>
<div class="ulist">
<ul>
<li>
<p>Son recursos hardware que complementan y extienden los servicios del tándem CPU-MEMORIA facilitando las tareas del progamador y del usuario.</p>
</li>
<li>
<p>Gran diversidad: teclado, monitor, ratón, discos, tarjeta video, tarjeta red, &#8230;&#8203;</p>
</li>
<li>
<p>diferencia de complejidad entre un teclado y un disco duro</p>
</li>
</ul>
</div>
</li>
<li>
<p>La CPU normalmente es un recurso único compartido por todos los programas y por todos los periféricos.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_conexión_cpu_es">8.5.2. Conexión CPU-E/S</h4>
<div class="ulist">
<ul>
<li>
<p>La arquitectura está formada, por lo tanto, por dos controladores: CPU y MCU. La CPU tiene un controlador generalista (CPU) mientras que el periférico tiene un controlador (MCU) muy específico. El lenguaje máquina de la CPU es generalista mientras que el lenguaje máquina del periférico es muy específico.</p>
<div class="ulist">
<ul>
<li>
<p>El periférico se comporta como una máquina <strong>servidor</strong> con su propio procesador. Podemos hablar de la máquina <strong>host</strong> (anfitrión) y de la máquina <strong>server</strong> . El controlador host es la CPU de la computadora y el controlador server es la MCU del periférico.</p>
</li>
<li>
<p>La CPU no se comunica directamente con el MCU sino que delega la tarea de los periféricos a procesadores no centrales, es decir, a los controladores I/O. La arquitectura típica de la computadora es la de un Procesador Central y un Set de controladores i/o que Intel denomina <strong>Chipset</strong></p>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/ditaa/svg/eNrT1sULtBWAQBuPHARo6xIA2lw1CqF5mSmJKQopqQrO-XklRfk5IGZOooJzQKiCQo2Crh2QAAKoZGJKfpGCp76_ggJEGCgNZiJLp6TmKASkFmWmHV5ZlJmcr6Dg6xxaw6VNJy8BAPfCRDo=" alt="Diagram">
</div>
</div>
</li>
<li>
<p>Ejemplo: Disco Duro</p>
<div class="ulist">
<ul>
<li>
<p><a href="http://disctech.com/Seagate-ST9500420AS-SATA-Hard-Drive">Seagate Momentus 7200.4 500GB 7.2K 2.5-inch SATA Hard Drive ST9500420AS </a></p>
</li>
<li>
<p><a href="http://theithollow.com/2013/11/disk-latency-concepts/">video del movimiento del brazo</a></p>
</li>
<li>
<p><a href="http://en.wikipedia.org/wiki/Disk_buffer">Disk buffer</a>: memoria interfaz entre la transferencia del drive y la transferencia i/o del puerto.</p>
</li>
<li>
<p><a href="http://www.atmel.com/Images/ATA_HardDrive.pdf">Controlador Atmel casero</a>: Disco Sata con controladora Atmel e interfaz ethernet.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_controlador_io">8.5.3. Controlador I/O</h4>
<div class="sect4">
<h5 id="_introducción_10">Introducción</h5>
<div class="ulist">
<ul>
<li>
<p>Periférico remoto:</p>
<div class="ulist">
<ul>
<li>
<p>Ej:PC---&#8594;SATA---&#8594;Compact Disc</p>
</li>
</ul>
</div>
</li>
<li>
<p>Controlador I/O del PC :</p>
<div class="ulist">
<ul>
<li>
<p>NO es la Unidad de Control de la CPU</p>
</li>
<li>
<p>Es uno de los 3 elementos básicos de la arquitectura Von Neumann</p>
</li>
<li>
<p>La CPU delega en otro controlador denominado controlador I/O la ejecución de las instrucciones máquina de entrada/salida.</p>
</li>
<li>
<p>Es necesario una INTERFAZ entre la CPU y el PERIFERICO</p>
</li>
<li>
<p>ISA:Instrucciones máquina de entrada salida de la cpu: de lectura (IN) y de escritura (OUT). Comunicación en ambos sentidos.</p>
<div class="ulist">
<ul>
<li>
<p>Se transfieren tanto los DATOS como los COMANDOS del periférico.</p>
</li>
</ul>
</div>
</li>
<li>
<p>William denomina al controlador I/O con el nombre Módulo de E/S</p>
</li>
<li>
<p>Es el controlador I/O el que transfiere los comandos y los datos al controlador del periférico.</p>
<div class="ulist">
<ul>
<li>
<p>El controlador del periférico interpretará los COMANDOS recibidos del controlador I/O y escribirá o/y leerá los DATOS.</p>
</li>
<li>
<p>Ejemplo:The Advanced Host Controller Interface (AHCI) is a technical standard defined by Intel that specifies the operation of Serial ATA (SATA) io controller (host bus adapters).</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Estructura</p>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/ditaa/svg/eNrT1kUF2gpAoI1HUBuLPLIyJEkkbdpcNc75eSVF-TmJKflFCs4BoTUKunYKKIKe-v4QwYDS1KKS_Bp0-YDUosy0wyuLMpPzaxTACl2KMstSixQ8wiH6fFNTMhNruKA20t5LYDmFGgWyQQ0XxDBtuE0kAbhWoDFAz-fmFwG9T4YrYFq5ED4l0zWIcIFGDRnALbMotzyxKBUA461-5g==" alt="Diagram">
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_puertos">Puertos</h5>
<div class="ulist">
<ul>
<li>
<p>Los puertos son registros de memoria implementados en el controlador i/o.</p>
<div class="ulist">
<ul>
<li>
<p>Un puerto está formado por distintos tipos de registros: entrada de datos, salida de datos, estado del periférico, control del periférico</p>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/ditaa/svg/eNpLzs8rKcrPSUzJL1LI1M_nKihNLSrJ5-JSQAXaukhAG122RkHB0w_OsdHVLUgtykw7vLIoMzmfZJP8Q0NgHF1dO9JNSi4oVQA6AWhScIhjSGgw2CQS9AItBep19vcLCfL3IawXACCrQPQ=" alt="Diagram">
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>El <strong>controlador I/O</strong> controla y ejecuta las comunicaciones a través de sus puertos.</p>
<div class="ulist">
<ul>
<li>
<p>Ej: Controlador I/O con puerto SATA</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Puerto</strong> de comunicaciones: Acceso al otro interlocutor (el periférico en este caso)</p>
</li>
<li>
<p>Un controlador I/O puede tener varios puertos y controlar las comunicaciones con varios periféricos.</p>
</li>
<li>
<p>Un puerto puede ser compartido por varios periféricos</p>
</li>
<li>
<p>Linux</p>
<div class="ulist">
<ul>
<li>
<p><code>cat /proc/ioports</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_espacio_de_direcciones">8.5.4. Espacio de direcciones</h4>
<div class="ulist">
<ul>
<li>
<p>Las direcciones i/o del puerto del controlador i/o se puede implementar de dos formas:</p>
<div class="ulist">
<ul>
<li>
<p>puertos mapeados en la memoria principal</p>
</li>
<li>
<p>direcciones de los puertos en un espacio diferente de la memoria principal: espacio i/o.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_memory_mapped_io_mmio">Memory-Mapped I/O (MMIO)</h5>
<div class="ulist">
<ul>
<li>
<p>Main Memory Address Space</p>
</li>
<li>
<p>El bus del sistema shares memory address space between I/O devices and program memory</p>
</li>
<li>
<p>Interface to the I/O is treated as a set of primary memory locations (Memoria principal)</p>
</li>
<li>
<p>Software drivers determine meaning of data stored or retrieved.</p>
</li>
<li>
<p>Loss of some memory space (8086 - 300K) because it is reserved for I/O interfaces. Less important with 4GiB address space.</p>
</li>
<li>
<p>All instruction modes available &#8594; Todo el repertorio de instrucciones, no solo IN,OUT.</p>
</li>
<li>
<p>May slow overall memory bus access down.</p>
</li>
<li>
<p>Can limit or complicate contiguous memory range.</p>
</li>
<li>
<p>Original x86 architecture had a 1MiB boundary because I/O was mapped above 640K.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_port_mapped_io_pmio">Port mapped I/O (PMIO)</h5>
<div class="ulist">
<ul>
<li>
<p>I/O Address Space</p>
</li>
<li>
<p>CPU has separate set of instructions that access specific pin on CPU that act as ports or that cause a demux to connect the address and data pin-outs to a different set of lines tied to i/o.</p>
</li>
<li>
<p>Separate bus tied to I/O devices. CPU can go back to using memory bus while I/O devices responds.</p>
</li>
<li>
<p>Adds complexity to CPU design.</p>
</li>
<li>
<p>Often limited set of instructions. May need to write to memory before other actions can be taken.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_direcciones_de_los_periféricos">Direcciones de los periféricos</h5>
<div class="ulist">
<ul>
<li>
<p>Driver</p>
<div class="ulist">
<ul>
<li>
<p>El programa driver es un proceso i/o que utiliza el mecanismo de memoria virtual igual que el resto de procesos.</p>
</li>
<li>
<p>Mapa en el fichero <em>/proc/iomem</em></p>
</li>
</ul>
</div>
</li>
<li>
<p>Periférico</p>
</li>
<li>
<p>Al espacio de direcciones utilizado por los periféricos se le denomina <strong>bus address</strong></p>
</li>
<li>
<p>Hará falta mapear, traducir, direcciones bus a direcciones virtuales de la cpu</p>
<div class="ulist">
<ul>
<li>
<p>Mapa en el fichero <em>/proc/ioports</em></p>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/ditaa/svg/eNrjUkAFzgGhCgSAU2kxF4pAWGZRSWliDj49jikpRanFaPqggngtCy5ITE7lwiaGIqitCwHauE2CKtFG0VeDRsOBf1pacWoJklQNLn2ovk8sKMjJTE3Brs8ZyZ1Qhq4dSEJXF8GFuVPBEZeNuUBLMvPSIUbm55UU5eckpuQXIduoDQ8NnD4Egsx8ZKkapHAEB1MNXBifIahSyKrBLqkBJylyDHFJLctMToUaQgWXIMKEhNSCHiZEJB1fePRgSQIRWJIAWMIGkQYQlkcRZSNSGiDOheCox64Ue64CADafujQ=" alt="Diagram">
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_buses">8.5.5. Buses</h4>
<div class="ulist">
<ul>
<li>
<p>Tipos de buses</p>
<div class="ulist">
<ul>
<li>
<p>del procesador: bus interno a a la cpu</p>
</li>
<li>
<p>de memoria: bus entre el controlador de memoria y la memoria principal</p>
</li>
<li>
<p>del sistema: bus externo a la cpu para el interconexiado de dispositivos externos como la memoria principal y los controladores i/o de los periféricos.</p>
</li>
<li>
<p>local: bus i/o corto que permite elevados anchos de banda</p>
</li>
<li>
<p>de expansión: bus i/o largo que permite la conexión de múltiples <em>tarjetas</em></p>
</li>
<li>
<p>periférico: bus i/o que permite conectar dispositivos externos a la computadora</p>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/ditaa/svg/eNrT1oUAbQUgcK0oSMwrzszPU3AqLVbI1M9XAANtXWwArCMgtSizICO1KDEHrAVDtTZXjYKCc0CogkKNgi4OYAeUAyrKzyspys9JTMkvUvDU91fArsMOLA6yNe3wyqLM5HyFGi5tZAfhAHi8QEi1NgAnajyw" alt="Diagram">
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Bus i/o local; vlb,PCI, AGP</p>
</li>
<li>
<p>Bus i/o de expansión:ISA, EISA</p>
<div class="ulist">
<ul>
<li>
<p>Conexión directa de la tarjeta i/o al bus de expansión de la placa base a través de <em>slots</em>:</p>
</li>
</ul>
</div>
</li>
<li>
<p>Bus periférico:  SCSI, SATA, USB, RS232</p>
<div class="ulist">
<ul>
<li>
<p>Conexión externa a través de un <em>cableado</em></p>
</li>
</ul>
</div>
</li>
<li>
<p>La arquitectura del bus io  la componen</p>
<div class="ulist">
<ul>
<li>
<p>Interfaz (cable y conector)</p>
</li>
<li>
<p>Protocolo de comunicaciones: set of standardized rules for consistent interaction between system and i/o devices, including physical properties, access methods, data formats, etc. El Bus  da nombre al protocolo.</p>
</li>
<li>
<p>Lenguaje de comandos</p>
</li>
</ul>
</div>
</li>
<li>
<p>Ejemplos prácticos</p>
<div class="ulist">
<ul>
<li>
<p>ISA</p>
<div class="ulist">
<ul>
<li>
<p>Industry Standard Architecture</p>
</li>
<li>
<p>PC/XT 8086 (1983) 8 bits</p>
<div class="ulist">
<ul>
<li>
<p>4 canales DMA</p>
</li>
</ul>
</div>
</li>
<li>
<p>PC/AT i286 (1984) 16 bits</p>
<div class="ulist">
<ul>
<li>
<p>16 MB/s</p>
</li>
<li>
<p>7 canales DMA</p>
</li>
<li>
<p>11 líneas IRQ</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>EISA</p>
<div class="ulist">
<ul>
<li>
<p>Extended Industry Standard Architecture</p>
</li>
<li>
<p>PC Clon: i386-i486 (1988)</p>
</li>
<li>
<p>32 Bits</p>
</li>
<li>
<p>Alternativa de los clónicos al propietario MCA de IBM en su PS/2</p>
</li>
<li>
<p>33 MB/s de velocidad de transferencia para buses maestros y dispositivos DMA</p>
</li>
<li>
<p>7 canales DMA</p>
</li>
<li>
<p>15 líneas IRQ</p>
</li>
</ul>
</div>
</li>
<li>
<p>MCA</p>
<div class="ulist">
<ul>
<li>
<p>Micro Channel Architecture</p>
</li>
<li>
<p>IBM PS/2 (1987)</p>
</li>
<li>
<p>32 bits</p>
</li>
</ul>
</div>
</li>
<li>
<p>PCI: Peripheral Component Interconnect</p>
</li>
<li>
<p>PCI Express</p>
</li>
<li>
<p><a href="http://en.wikipedia.org/wiki/List_of_device_bit_rates#Computer_buses">listado de anchos de banda</a></p>
</li>
</ul>
</div>
</li>
<li>
<p><a href="http://www.karbosguide.com/hardware/module2b2.htm" class="bare">http://www.karbosguide.com/hardware/module2b2.htm</a></p>
<div class="ulist">
<ul>
<li>
<p>El controlador i/o se conecta indirectamente al bus del sistema (CPU-MP) a través de los puentes (bridges)</p>
</li>
</ul>
</div>
</li>
<li>
<p><a href="http://en.wikipedia.org/wiki/Platform_Controller_Hub">Intel</a></p>
<div class="ulist">
<ul>
<li>
<p>Intel ha evolucionado de los puentes <a href="http://en.wikipedia.org/wiki/I/O_Controller_Hub">ICH</a> con el puente <a href="http://en.wikipedia.org/wiki/Southbridge_%28computing%29">Sur</a> y <a href="http://en.wikipedia.org/wiki/Northbridge_%28computing%29">Norte</a> a un Concentrador Central PCH</p>
<div class="ulist">
<ul>
<li>
<p>Observar que la CPU integra el controlador de memoria integrado (IMC) y controladores i/o de video (PCI-E Graphics)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_analisis_portatil_lenovo_disco_duro">8.5.6. Analisis: Portatil Lenovo - Disco Duro</h4>
<div class="ulist">
<ul>
<li>
<p>Ruta de la transferencia de datos entre el disco duro y la memoria principal en la computadora Lenovo T520</p>
</li>
<li>
<p>Disco (ATA disk, ST9500420AS Seagate)&#8594; Driver Mecánico/Electrico/Magnético &#8594; Micro del Disco (SATA Interface, Seagate)  &#8594; Bus i/o serie(SATA 6Gb/s)&#8594; Host Adapter (Platform_Controller_Hub PCH, ChipSet 200C/6 Series, SATA AHCI Controller)&#8594; Flexible Display Interface (FDI) &#8594; CPU (Intel Core i5)</p>
</li>
<li>
<p>SATA: Serial Advanced Technology Attachment is a computer bus interface that connects host bus adapters (controladora de disco) to mass storage devices (MCU, MicroControllerUnit) such as hard disk</p>
</li>
</ul>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/io/Intel_5_Series_architecture.png" alt="Lenovo T520">
</div>
<div class="title">Figure 43. Lenovo T520</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_programa_es">8.6. Programa E/S</h3>
<div class="ulist">
<ul>
<li>
<p>Programmed i/o (PIO)</p>
<div class="ulist">
<ul>
<li>
<p>Las transferencias de datos mediante mecanismos de E/S por consulta la realiza un programa i/o (PIO) que ejecuta la CPU. La CPU en cada transferencia de datos entre la memoria y el periférico debe de ESPERAR a que dicha transferencia termine.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_módulo_fuente">8.6.1. Módulo fuente</h4>
<div class="ulist">
<ul>
<li>
<p>Transferencia de 512 bytes entre el puerto 0x380 y un buffer.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c">      <span class="n">mov</span> <span class="o">%</span><span class="n">bx</span><span class="p">,</span><span class="n">buf</span> <span class="p">;</span> <span class="n">destination</span> <span class="n">address</span><span class="p">.</span> <span class="n">BX</span> <span class="n">es</span> <span class="n">un</span> <span class="n">puntero</span> <span class="n">a</span> <span class="n">un</span> <span class="n">buffer</span>
      <span class="n">mov</span> <span class="err">$</span><span class="mi">512</span><span class="p">,</span><span class="o">%</span><span class="n">si</span> <span class="p">;</span> <span class="n">count</span><span class="p">.</span> <span class="n">N</span><span class="err">ú</span><span class="n">mero</span> <span class="n">de</span> <span class="n">bytes</span> <span class="n">a</span> <span class="n">transferir</span>
      <span class="n">mov</span> <span class="err">$</span><span class="mh">0x380</span><span class="p">,</span><span class="o">%</span><span class="n">dx</span> <span class="p">;</span> <span class="n">source</span> <span class="n">port</span><span class="p">.</span> <span class="n">DX</span> <span class="n">es</span> <span class="n">un</span> <span class="n">puntero</span> <span class="n">al</span> <span class="n">puerto</span>
<span class="n">loop</span><span class="o">:</span>
      <span class="n">in</span> <span class="o">%</span><span class="n">dx</span><span class="p">,</span><span class="o">%</span><span class="n">al</span> <span class="p">;</span> <span class="n">get</span> <span class="n">byte</span> <span class="n">from</span> <span class="n">i</span><span class="o">/</span><span class="n">o</span> <span class="n">port</span><span class="p">.</span> <span class="n">AL</span><span class="o">&lt;-</span><span class="n">DX</span>
      <span class="n">mov</span> <span class="o">%</span><span class="n">al</span><span class="p">,(</span><span class="o">%</span><span class="n">bx</span><span class="p">)</span> <span class="p">;</span> <span class="n">store</span> <span class="n">in</span> <span class="n">buffer</span>      <span class="n">M</span><span class="p">[</span><span class="n">bx</span><span class="p">]</span><span class="o">&lt;-</span><span class="n">AL</span>
      <span class="n">inc</span> <span class="o">%</span><span class="n">bx</span> <span class="p">;</span> <span class="n">next</span> <span class="n">memory</span> <span class="n">location</span> <span class="n">in</span> <span class="n">buf</span>
      <span class="n">dec</span> <span class="o">%</span><span class="n">si</span> <span class="p">;</span> <span class="n">decrement</span> <span class="n">bytes</span> <span class="n">left</span>
      <span class="n">jnz</span> <span class="n">loop</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_isa">ISA</h5>
<div class="ulist">
<ul>
<li>
<p>IN: leer un dato del puerto</p>
</li>
<li>
<p>OUT: escribir un dato en el puerto</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_driver_sistema_operativo">8.7. Driver: Sistema Operativo</h3>
<div class="sect3">
<h4 id="_gestor_es_jerarquía">8.7.1. Gestor E/S: jerarquía</h4>
<div class="ulist">
<ul>
<li>
<p>La gestión de las operaciones E/S las realiza el Sistema Operativo</p>
</li>
<li>
<p>La estructura del programa  gestor E/S del sistema operativo se basa en una estructura jerárquica por niveles:</p>
<div class="ulist">
<ul>
<li>
<p>Nivel más bajo: controlador sw (módulo driver) del controlador hw i/o del periférico.</p>
</li>
<li>
<p>Nivel más alto: Sistema virtual de ficheros. Las aplicaciones acceden a los periféricos mediante la abstracción de estos en ficheros virtuales.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_código_fuente">8.7.2. Código Fuente</h4>
<div class="ulist">
<ul>
<li>
<p>Pseudo-código</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">While</span> <span class="p">(</span><span class="n">STATUS</span> <span class="o">==</span> <span class="n">BUSY</span><span class="p">)</span>
   <span class="p">;</span> <span class="c1">// wait until device is not busy . Puerto ocupado.</span>
<span class="n">Write</span> <span class="n">data</span> <span class="n">to</span> <span class="n">DATA</span> <span class="k">register</span> <span class="c1">// dato a transmitir el puerto out</span>
<span class="n">Write</span> <span class="n">command</span> <span class="n">to</span> <span class="n">COMMAND</span> <span class="k">register</span>  <span class="c1">// registro de control</span>
   <span class="c1">// Doing so starts the device and executes the command</span>
<span class="n">While</span> <span class="p">(</span><span class="n">STATUS</span> <span class="o">==</span> <span class="n">BUSY</span><span class="p">)</span>
   <span class="p">;</span> <span class="c1">// wait until device is done with your request</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_concepto">8.7.3. Concepto</h4>
<div class="ulist">
<ul>
<li>
<p>El programa que implementa las funciones del periférico es un <em>módulo del kernel</em> denominado DRIVER</p>
<div class="ulist">
<ul>
<li>
<p>Driver del teclado, monitor, disco duro,</p>
</li>
</ul>
</div>
</li>
<li>
<p>Capas SW:</p>
</li>
</ul>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/ditaa/svg/eNq9kDFuhDAQRXuf4pcghwtssVIklCZNpOwFzDCrjGRhdjCk4UIpttojcLE1bBRCKqq8xvLo2TPzbbHFYsEWu9hjWzPiufVCjmS6NXj_xAgUR8zHwovQB2tAlDag5EGI8Yut_crasEepMrDOnz0cM2LL933MXNVFdfRoXjOod_7SS3rcssp5-lKhkK8-dy3TdD2natL9H8vYfwjMvK09Dz_xDKIxzW5OKabuAFQ-XHpGVks3j9pryJ9ALu0a03JZZPKuDvkduF17ng==" alt="Diagram">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Ejemplo: Escritura de un fichero en el disco duro</p>
<div class="ulist">
<ul>
<li>
<p>write &#8594; syscall &#8594; OUT &#8594; comando propio del HD</p>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/ditaa/svg/eNrT1kUF2gpAoK2LFYDlYEAbixgujejmcNWAVZcXZZakglk1Crp2CjVQQ4ori5MTc3JgZoKFgdJQjn9oiAJMKVS0xjk_NzEvJV-hoCi_IDNfISU1RyElszgZyCotyleoVHBJLMkvruHSHhC_KpAMarCLopvkWlyQmAz2rkJocWliEZCJ1SSYOu_UorzUHFTzYXIBqUWZaYdXFmUm51PPwQBe_nQm" alt="Diagram">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Espacio de usuario: write (función de escritura de datos), syscall (llamada al módulo gestor de E/S del Sistema Operativo)</p>
</li>
<li>
<p>Espacio kernel del S.O.: Driver: Orden interpretada por la CPU y ejecutada por el controlador I/O para transferir datos (comandos y datos) entre Memoria y el Controlador Periférico</p>
</li>
<li>
<p>Espacio periférico: Comandos a Interpretar por el Periférico (Firmware) y transferencia de Datos.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_utilizacion_del_driver">8.7.4. Utilizacion del Driver</h4>
<div class="ulist">
<ul>
<li>
<p>El driver está protegido por el Sistema Operativo. Hay funciones como ioctl que permite al usuario interactuar con el driver.</p>
<div class="ulist">
<ul>
<li>
<p>La interfaz entre el usuario y el driver son las llamadas al sistema operativo.</p>
<div class="ulist">
<ul>
<li>
<p>Mediante la instrucción máquina SYSCALL (x86-64) o int 0x80 (x86-32) llamamos indirectamente a las funciones del driver a través del sistema operativo.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Ejemplo</p>
<div class="ulist">
<ul>
<li>
<p>Imprimir en la pantalla: open, write, close &#8594; open y close interactuan con el sistema de ficheros virtual.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_mecanismos_de_implementación_de_la_interfaz_es">8.8. Mecanismos de Implementación de la Interfaz E/S</h3>
<div class="sect3">
<h4 id="_introduccion_2">8.8.1. Introduccion</h4>
<div class="ulist">
<ul>
<li>
<p>All data manipulation not directly performed in the CPU or between CPU and primary memory is I/O.</p>
</li>
<li>
<p>PIO:Polling</p>
</li>
<li>
<p>Interruption</p>
</li>
<li>
<p>DMA: Direct Memory Access</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_sincronización_por_encuesta">8.8.2. Sincronización por Encuesta</h4>
<div class="ulist">
<ul>
<li>
<p>Polling: encuesta</p>
</li>
<li>
<p>Query: encuesta</p>
</li>
<li>
<p>Mecanismo</p>
<div class="ulist">
<ul>
<li>
<p>Comprobación del estado o <em>encuesta-polling</em></p>
<div class="ulist">
<ul>
<li>
<p>La CPU consulta el registro de estado de cada puerto al que están conectados los periféricos. Comprueba si algún periférico requiere el servicio de la CPU. Reserves a register for each I/O device. Each register is continually polled to detect data arrival.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Es necesario ejecutar programas de atención al periférico cuando este lo requiera: sincronización</p>
</li>
<li>
<p>El anfitrión consulta el bit de estado del controlador i/o</p>
</li>
<li>
<p>Identificación</p>
<div class="ulist">
<ul>
<li>
<p>Una vez aceptada la petición del cliente (controlador i/o)</p>
<div class="ulist">
<ul>
<li>
<p>El controlador identifica el periférico que solicita el servicio</p>
</li>
<li>
<p>Comunica al S.O. qué periferico</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Estructura</p>
<div class="ulist">
<ul>
<li>
<p>CPU:</p>
<div class="ulist">
<ul>
<li>
<p>Ejecuta el programa i/o: un programa que controla DIRECTAMENTE la operación E/S: Programmed I/O &#8594; PIO</p>
</li>
<li>
<p>realiza las transferencias entre la memoria principal y el  controlador i/o</p>
</li>
<li>
<p><em>espera</em> al periférico hasta que termine. La CPU espera hasta que concluya la operación E/S.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Memoria principal: almacena el programa i/o</p>
</li>
<li>
<p>Controlador i/o</p>
<div class="ulist">
<ul>
<li>
<p>Puerto: Un puerto está compuesto por REGISTROS del tipo datos, control, test</p>
</li>
<li>
<p>transfiere los datos al periférico</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_sincronización_por_interrupción">8.8.3. Sincronización por Interrupción</h4>
<div class="ulist">
<ul>
<li>
<p>Interrupt-Driven I/O (Mecanismo de E/S por Interrupción)</p>
</li>
<li>
<p>Estructura</p>
<div class="ulist">
<ul>
<li>
<p>CPU:</p>
<div class="ulist">
<ul>
<li>
<p>Ejecuta el programa de atención a la interrupción. Un programa que controla DIRECTAMENTE la operación E/S.</p>
</li>
<li>
<p>realiza las transferencias entre la memoria principal y el controlador i/o</p>
</li>
<li>
<p><strong>no espera</strong> al periférico hasta que termine. Es <em>interrumpido</em> cada vez que es necesario realizar una transferencia</p>
<div class="ulist">
<ul>
<li>
<p>Al finalizar el ciclo de instrucción de cada instrucción que ejecuta la CPU, se comprueba si la señal de petición de interrupción está activada.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Memoria principal: almacena el programa i/o</p>
</li>
<li>
<p>Controlador i/o</p>
<div class="ulist">
<ul>
<li>
<p>Puertos: datos, control, test</p>
</li>
<li>
<p>transfiere los datos al periférico</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>allows the CPU to do other things until I/O is requested</p>
<div class="ulist">
<ul>
<li>
<p>Interrupt request - Driven I/O  (Still PIO - CPU has to move data)</p>
</li>
<li>
<p>I/O devices can request the attention of CPU with an interrupt at any time, but only when needed.</p>
</li>
<li>
<p>CPU can dedicate extended time for particular device.</p>
</li>
<li>
<p>CPU does not have to check in on I/O that does not need attention.</p>
</li>
<li>
<p>CPU can delay processing of I/O request.</p>
</li>
<li>
<p>Newer systems - cpu hands off transfer of data to secondary controller, which only interrupts cpu on completion of task or problem.</p>
</li>
<li>
<p>Requires external circuitry.</p>
<div class="ulist">
<ul>
<li>
<p>e.g 8259A programmable interrupt controller (PIC). CPU may have to communicate with the PIC to identify requesting device.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Programmed input/output (PIO) is a method of transferring data between the CPU and a peripheral such as a network adapter or an ATA storage device. In general, programmed I/O happens when software running on the CPU uses i/o instructions that access I/O address space to perform data transfers to or from an I/O device. This is in contrast to Direct Memory Access (DMA) transfers.</p>
</li>
<li>
<p>The best known example of a PC device that uses programmed I/O is the ATA interface;</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_direct_memory_access_dma">8.8.4. Direct Memory Access (DMA)</h4>
<div class="ulist">
<ul>
<li>
<p>Estructura</p>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/ditaa/svg/eNrT1kUF2gpAoI1HUBuLPLIyJEkkbdpcNc75eSVF-TmJKflFCs4BoTUKunYKKIKe-v4QwYDS1KKS_Bp0-YDUosy0wyuLMpPzaxTACl2KMstSixQ8wiH6fFNTMhNruKA20t5LYDmFGgUsIE6BGFDDBTFMG24TsiRB7XCtQGOAns_NLwJ63warD_C6AqaVC-FTbQWSAVwrOFygUUMGcMssyi1PLEoFAD73gGo=" alt="Diagram">
</div>
</div>
</li>
<li>
<p>Mapeo de direcciones</p>
</li>
<li>
<p>Hará falta una unidad hardware de traducción de direcciones bus a direcciones físicas : iommu</p>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/ditaa/svg/eNqdk10LgjAUhu_9Fede_AcRaN10MYyiqO4sZw36EKdBsB-fpu2ro5MGoj47Z3t5984Dc8yWG_gZKIwq7hlgy4qySq5m1fLy4uxk0TBNC8qt9g6CG8I6T07UQxighUalH7TDB4Ti0OgX1rv7I2QRtzDOMk5LrUT09WuGiVZ-M5nk-ZXRFO-fafq7j2AKkdIfBApLGPYpuNWbsftZF1s_xxdcHrw0FfjSoB4HtP6CpWdqwa_uj51CYnwx9Di0xWS1-CzW5FMMKFuFZECugDl9ssb9EcqEAxrKlGd_pM72zBmhqMoyWjSTRB4rEqEdGqG92neiMqTgYVSEpNF1hBYxIZsxV8dxS1ylw9a-ASV656E=" alt="Diagram">
</div>
</div>
</li>
<li>
<p>Estructura</p>
<div class="ulist">
<ul>
<li>
<p>CPU:</p>
<div class="ulist">
<ul>
<li>
<p>Ejecuta el programa i/o. El programa no controla la transferencia pero sí la inicializa (número de bytes a transferir, localización en la memoria principal, localización en el periférico, control errores, etc)</p>
</li>
<li>
<p>Cede el control de las transferencias al controlador DMA (DMAC)., offloads I/O processing to a special-purpose chip that takes care of the details. La transferencia la controla y realiza el DMAC por Hardware &#8594; No es por programa como el PIO.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Memoria principal: almacena el programa i/o</p>
</li>
<li>
<p>Controlador i/o</p>
<div class="ulist">
<ul>
<li>
<p>es el controlador DMA</p>
</li>
<li>
<p>Puertos: los puertos  ahora no son para los datos de transferencia, unicamente para el control CPU-DMA</p>
</li>
<li>
<p>transfiere los datos entre la memoria principal y el periférico</p>
</li>
<li>
<p>el controlador no espera al periférico</p>
</li>
<li>
<p>Direct Memory Access controller.</p>
<div class="literalblock">
<div class="content">
<pre>      Handles I/O interaction without the intervention of the CPU after initial
        CPU interaction. Uses interrupts to report status back to CPU.
      Requires separate arbitration protocol - shares buses with CPU.
      Predefined standardized tasks.
      CPU NOT occupied but may have to compete for resources.</pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_channel_io">8.8.5. Channel I/O</h4>
<div class="ulist">
<ul>
<li>
<p>uses dedicated I/O processors</p>
<div class="ulist">
<ul>
<li>
<p>Channel I/O (Mainframe or Supercomputer)</p>
<div class="ulist">
<ul>
<li>
<p>Estructura: integra la unidad DMA más un procesador específico.</p>
</li>
<li>
<p>Programable: ejecuta el <em>channel program</em> almacenado en la memoria principal. (Diferencia con DMA).</p>
</li>
<li>
<p>Transfiere datos ( Memoria principal &lt;&#8594; Periférico) independientemente de la CPU</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_memory_shared">Memory Shared</h5>
<div class="ulist">
<ul>
<li>
<p>Estructura</p>
<div class="ulist">
<ul>
<li>
<p>CPU</p>
<div class="ulist">
<ul>
<li>
<p>cede el control de las transferencias al procesador o canal i/o</p>
</li>
</ul>
</div>
</li>
<li>
<p>Memoria principal: almacena el programa i/o</p>
</li>
<li>
<p>Procesador i/o</p>
<div class="ulist">
<ul>
<li>
<p>Es el canal i/o</p>
</li>
<li>
<p>Ejecuta el programa i/o almacenado en la memoria principal</p>
</li>
<li>
<p>Puertos: los puertos  ahora no son para los datos de transferencia, únicamente para la control CPU-DMA</p>
</li>
<li>
<p>transfiere los datos entre la memoria principal y el periférico</p>
</li>
</ul>
</div>
</li>
<li>
<p>Memoria Principal</p>
<div class="ulist">
<ul>
<li>
<p>Compartida entre la CPU y el Canal_IO</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_memory_independent">Memory Independent</h5>
<div class="ulist">
<ul>
<li>
<p>Estructura</p>
<div class="ulist">
<ul>
<li>
<p>CPU</p>
<div class="ulist">
<ul>
<li>
<p>cede el control de las transferencias al procesador o canal i/o</p>
</li>
</ul>
</div>
</li>
<li>
<p>Memoria principal: almacena el programa i/o</p>
</li>
<li>
<p>Procesador i/o</p>
<div class="ulist">
<ul>
<li>
<p>Es el canal i/o</p>
</li>
<li>
<p>Ejecuta el programa i/o almacenado en la memoria principal</p>
</li>
<li>
<p>Puertos: los puertos  ahora no son para los datos de transferencia, unicamente para el control CPU-DMA</p>
</li>
<li>
<p>transfiere los datos entre la memoria principal y el periférico</p>
</li>
</ul>
</div>
</li>
<li>
<p>Memoria Principal</p>
<div class="ulist">
<ul>
<li>
<p>Accesible sólo por la CPU</p>
</li>
</ul>
</div>
</li>
<li>
<p>Memoria IO</p>
<div class="ulist">
<ul>
<li>
<p>Accesible sólo por el canal_IO</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_sincronizacion_por_interrupcion">8.9. Sincronizacion por Interrupcion</h3>
<div class="ulist">
<ul>
<li>
<p>Extensión del apartado anterior sobre  implementación de la interfaZ i/o driven-interruption.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_concepto_2">8.9.1. Concepto</h4>
<div class="ulist">
<ul>
<li>
<p>El inconveniente del Polling es que la CPU realiza la consulta aunque el periférico no requiera sus servicios.</p>
</li>
<li>
<p>El periférico toma la iniciativa y solicita la INTERRUPCION del programa que este ejecutando para ejecutar el programa requerido por el periférico</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_mecanismo_de_interrupcion">8.9.2. Mecanismo de Interrupcion</h4>
<div class="ulist">
<ul>
<li>
<p>El periférico a través de una línea eléctrica de entrada de la CPU, solicita al controlador i/o los servicios del kernel</p>
<div class="ulist">
<ul>
<li>
<p>El kernel va a ser <strong>INTERRUMPIDO</strong></p>
</li>
</ul>
</div>
</li>
<li>
<p>La CPU tiene dos líneas de interrupción:</p>
<div class="ulist">
<ul>
<li>
<p>Línea Interrupt ReQuest <em>(IRQ)</em> : Maskable</p>
</li>
<li>
<p>Línea Non Maskable Interrupt <em>(NMI)</em></p>
</li>
<li>
<p>La CPU en el ciclo de instrucción tiene en su última fase la fase de Chequeo de Interrupción</p>
<div class="ulist">
<ul>
<li>
<p>Si se está solicitando un servicio al kernel, la CPU entra en modo atención a la interrupción y pasa el control al módulo de <strong>Gestión de Interrupciones</strong> del Kernel</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Las lineas de los periféricos para solicitar la interrupción se denominan <em>(IRQ)</em>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_controlador_de_interrupciones">8.9.3. Controlador de Interrupciones</h4>
<div class="sect4">
<h5 id="_pic">PIC</h5>
<div class="ulist">
<ul>
<li>
<p>Controlador de Interrupciones Programable</p>
<div class="ulist">
<ul>
<li>
<p><a href="http://wiki.osdev.org/8259_PIC">PIC</a>  : Programmable Interrupt Controller</p>
<div class="ulist">
<ul>
<li>
<p>Se utiliza en arquitecturas cuya CPU tiene un único núcleo.</p>
</li>
<li>
<p>Tiene como entrada todas las líneas de interrupción de los periféricos</p>
</li>
<li>
<p>Salidas: INT (petición de interrupción) y D0-D7 (Control,Status and Interrupt-Vector )</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Ejemplo : <a href="http://pdos.csail.mit.edu/6.828/2005/readings/hardware/8259A.pdf">PIC 8259</a></p>
</li>
<li>
<p>Conexión daisy-chain</p>
<div class="ulist">
<ul>
<li>
<p>Maestro - Esclavo</p>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/ditaa/svg/eNrj0taFAW2uGgUYqAGznQNC4WxkcU-_EDAbrBdCcEGlwVQclAfRo42wAFm4BmEmQpmNrjbUdAVtGyBfwTMo0IBLAQmga0MXhmszJE-bEXHaAjydUbQZo8n7OroGhwT5E7LNhDxHmpKnzQxbdGAYokCW2eZgIzGELSiwBOFSBfyBb4miDQeoUXANdvZxDEOLE5yqMdKTAUn6yLXFkC62GNHFFmO62GJCF1tMqW8LUk4EAC8H220=" alt="Diagram">
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Acciones  que realiza el controlador PIC</p>
<div class="ulist">
<ul>
<li>
<p>Chequea si se activa alguna señal (Monitorización). En caso de activarse más de una se dar prioridad a la de menor nivel y procede:</p>
<div class="ulist">
<ul>
<li>
<p><strong>Convierte</strong> la línea activada IRQn en un vector (0x00-0xFF)</p>
</li>
<li>
<p>Escribe en el puerto i/o del PIC el vector. El puerto es accesible por parte de la CPU. El vector se apunta a la entrada de una tabla que contiene un puntero a la rutina de atención a la interrupción (ISR)</p>
</li>
<li>
<p>Activa la señal INTR de la CPU</p>
</li>
<li>
<p>Si la CPU lee el valor del vector se desactiva la señal INTR</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>A la línea IRQn le corresponde, por defecto según Intel, el vector <em>n+32</em>. Este mapeo se puede alterar programando el PIC.</p>
<div class="ulist">
<ul>
<li>
<p>A la línea IRQ0 le corresponde el vector 0x20</p>
</li>
</ul>
</div>
</li>
<li>
<p>Cada línea IRQ se puede desautorizar por programa pero dicha interrupción no se pierde.</p>
</li>
<li>
<p>Mediante la instruccion <code>cli</code> se hace un clear del flag IF del registro EFLAGS, ignorando la CPU todas las interrupciones hardware.</p>
<div class="ulist">
<ul>
<li>
<p>Mediante la instrucción <code>sli</code> hacemos un set de IF.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_nmi">NMI</h5>
<div class="ulist">
<ul>
<li>
<p>Es una entrada de la cpu.</p>
</li>
<li>
<p>The NMI (is a hardware driven interrupt much like the PIC interrupts but the NMI goes diretcly the cpu, and not via the PIC controller.</p>
</li>
<li>
<p>Aplicaciones</p>
<div class="ulist">
<ul>
<li>
<p>Temporizador watchdog</p>
<div class="ulist">
<ul>
<li>
<p>Es un temporizador que hay que poner a cero regularmente. Si la cpu está bloqueada no podrá resetear el temporizador y este generará un interrupción nmi con lo que el contador de programa se cargará con una dirección que apunta a la rutina de atención a la interrupción NMI cuya ejecución  desbloqueará el estado de la cpu.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_intel">Intel</h5>
<div class="ulist">
<ul>
<li>
<p>Intel</p>
<div class="ulist">
<ul>
<li>
<p>1º generation of interrupts (XT-PIC): only supported 15 interrupts.</p>
</li>
<li>
<p>2º generation (IO-APIC): number of supported interrupts to 24.</p>
<div class="ulist">
<ul>
<li>
<p><a href="http://wiki.osdev.org/APIC">APIC</a> : Advanced Programmable Interrupt Controller: Utilizado en modernas arquitecturas multinúcleo.</p>
</li>
</ul>
</div>
</li>
<li>
<p>3º generation, MSI: number of available interrupts to 224.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_gestor_de_interrupciones">8.9.4. Gestor de Interrupciones</h4>
<div class="ulist">
<ul>
<li>
<p>El Gestor de Interrupciones está implementado por el S.O.: entry.S en la versión linux 2.x</p>
</li>
<li>
<p>Identifica al solicitador de la interrupción para poder ejecutar la rutina específica de antención a dicha interrupción.</p>
</li>
<li>
<p>Anula la posibilidad de ser interrumpido por otros dispositivos no prioritarios, a través del flag IF , bit 9 del registro de control rflags de la CPU.</p>
</li>
<li>
<p>Consulta el Vector de interrupciones (Tabla de punteros a las rutinas de atención a la interrupción.</p>
</li>
<li>
<p>Salva el entorno del programa en ejecución que va a ser interrumpido.</p>
</li>
<li>
<p>Activa la rutina Interrupt Service Routine <em>(ISR)</em>.</p>
<div class="ulist">
<ul>
<li>
<p>Autoriza nuevamente las interrupciones</p>
</li>
<li>
<p>Dicha rutina estará implementada en el módulo driver del kernel.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_tipos_de_interrupciones">8.9.5. Tipos de Interrupciones</h4>
<div class="ulist">
<ul>
<li>
<p>Intel define dos tipos de Interrupt Signals</p>
<div class="ulist">
<ul>
<li>
<p><strong>Sincronas</strong></p>
<div class="ulist">
<ul>
<li>
<p>Son originadas por la propia CPU al final del ciclo de instrucción en la fase de interrupción</p>
</li>
<li>
<p>Se denominan <em>exceptions</em></p>
<div class="ulist">
<ul>
<li>
<p><em>Interrupt Software</em> : originadas por la instrucción <code>syscall</code>: Llamadas al Sistema</p>
</li>
<li>
<p>Originadas por un <em>Error</em>: Fault, Trap, Abort.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Asíncronas</strong></p>
<div class="ulist">
<ul>
<li>
<p>Originadas por los periféricos o  hardware que no es la CPU</p>
</li>
<li>
<p>Se denominan <em>interruptions</em> o <em>hardware interruptions</em></p>
<div class="ulist">
<ul>
<li>
<p>Maskable: IRQ</p>
</li>
<li>
<p>Non-Maskable: NMI</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_tabla_de_los_vectores_de_interrupciones">8.9.6. Tabla de los Vectores de interrupciones</h4>
<div class="sect4">
<h5 id="_modo_real_tabla_ivt">Modo Real: Tabla IVT</h5>
<div class="ulist">
<ul>
<li>
<p>En plataformas con S.O. al encender la computadora (arranque con bootloader) la CPU está operando inicialmente en  <em>Modo Real</em>   y en plataformas sin S.O.  (arranque con BIOS) la cpu opera permanentemente en Modo Real. En plataformas con S.O. el arranque se inicia en modo real y se configura la computadora para pasar al modo protegido antes de cargar el S.O. en la memoria principal.</p>
<div class="ulist">
<ul>
<li>
<p>Real Mode :</p>
</li>
<li>
<p>Is a simplistic 16-bit mode that is present on all x86 processors: Equivale a comportarse como la antigua cpu 8086.</p>
</li>
<li>
<p>la cpu 8086 tiene 20 bits de direcciones y 16 bits de datos.</p>
</li>
<li>
<p>A real mode pointer is defined as a 16-bit segment address and a 16-bit offset into that segment</p>
<div class="ulist">
<ul>
<li>
<p>El segmento se expande a 20 bits multiplicando x4.</p>
</li>
</ul>
</div>
</li>
<li>
<p>2<sup>20</sup>:El Código tiene que estar en el primer Mega de la memoria RAM</p>
</li>
</ul>
</div>
</li>
<li>
<p>Permite el acceso a funciones de la BIOS.</p>
<div class="ulist">
<ul>
<li>
<p><a href="https://es.wikipedia.org/wiki/Llamada_de_interrupci%C3%B3n_del_BIOS#Tabla_de_interrupciones">Tabla de interrupciones BIOS</a></p>
</li>
<li>
<p><a href="http://www.zator.com/Hardware/H2_4_1.htm">Tecnología del PC</a></p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">MOV</span> <span class="n">AH</span><span class="p">,</span> <span class="mi">0</span><span class="n">Eh</span>   <span class="p">;</span> <span class="n">Imprime</span> <span class="n">car</span><span class="err">á</span><span class="n">cter</span> <span class="n">en</span> <span class="n">la</span> <span class="n">pantalla</span>
<span class="n">MOV</span> <span class="n">AL</span><span class="p">,</span> <span class="sc">'!'</span>   <span class="p">;</span> <span class="n">car</span><span class="err">á</span><span class="n">cter</span> <span class="n">a</span> <span class="n">imprimir</span>
<span class="n">INT</span> <span class="mi">10</span><span class="n">h</span>       <span class="p">;</span> <span class="n">Llamada</span> <span class="n">a</span> <span class="n">las</span> <span class="n">funciones</span> <span class="n">de</span> <span class="n">video</span> <span class="n">del</span> <span class="n">BIOS</span></code></pre>
</div>
</div>
</li>
<li>
<p>Tabla IVT.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sh">Interrupt Address 	Type Description

00h 	0000:0000h 	Processor 	Divide by zero
01h 	0000:0004h 	Processor 	Single step
02h 	0000:0008h 	Processor 	Non maskable interrupt <span class="o">(</span>NMI<span class="o">)</span>
03h 	0000:000Ch 	Processor 	Breakpoint
04h 	0000:0010h 	Processor 	Arithmetic overflow
05h 	0000:0014h 	Software 	Print screen
06h 	0000:0018h 	Processor 	Invalid op code
07h 	0000:001Ch 	Processor 	Coprocessor not available
08h 	0000:0020h 	Hardware 	System timer service routine
09h 	0000:0024h 	Hardware 	Keyboard device service routine
0Ah 	0000:0028h 	Hardware 	Cascade from 2nd programmable interrupt controller
0Bh 	0000:002Ch 	Hardware 	Serial port service - COM post 2
0Ch 	0000:0030h 	Hardware 	Serial port service - COM port 1
0Dh 	0000:0034h 	Hardware 	Parallel printer service - LPT 2
0Eh 	0000:0038h 	Hardware 	Floppy disk service
0Fh 	0000:003Ch 	Hardware 	Parallel printer service - LPT 1
10h 	0000:0040h 	Software 	Video service routine
11h 	0000:0044h 	Software 	Equipment list service routine
12h 	0000:0048H 	Software 	Memory size service routine
13h 	0000:004Ch 	Software 	Hard disk drive service
14h 	0000:0050h 	Software 	Serial communications service routines
15h 	0000:0054h 	Software 	System services support routines
16h 	0000:0058h 	Software 	Keyboard support service routines
17h 	0000:005Ch 	Software 	Parallel printer support services
18h 	0000:0060h 	Software 	Load and run ROM BASIC
19h 	0000:0064h 	Software 	DOS loading routine
1Ah 	0000:0068h 	Software 	Real <span class="nb">time </span>clock service routines
1Bh 	0000:006Ch 	Software 	CRTL - BREAK service routines
1Ch 	0000:0070h 	Software 	User timer service routine
1Dh 	00000074h 	Software 	Video control parameter table
1Eh 	0000:0078h 	Software 	Floppy disk parameter routine
1Fh 	0000:007Ch 	Software 	Video graphics character routine
20h-3Fh 0000:0080f-0000:00FCh SW        DOS interrupt points
40h 	0000:0100h 	Software 	Floppy disk revector routine
41h 	0000:0104h 	Software 	hard disk drive C: parameter table
42h 	0000:0108h 	Software 	EGA default video driver
43h 	0000:010Ch 	Software 	Video graphics characters
44h 	0000:0110h 	Software 	Novel Netware API
45h 	0000:0114h 	Software 	Not used
46h 	0000:0118h 	Software 	Hard disk drive D: parameter table
47h 	0000:011Ch - 	Software 	Not used
48h 	  	Software 	Not used
49h 	0000:0124h 	Software 	Not used
4Ah 	0000:0128h 	Software 	User alarm
4Bh-63h 	0000:012Ch - 	Software 	Not used
64h 	  	Software 	Novel Netware IPX
65h-66h 	  	Software 	Not used
67h 	  	Software 	EMS support routines
68h-6Fh 	0000:01BCh 	Software 	Not used
70h 	0000:01c0h 	Hardware 	Real <span class="nb">time </span>clock
71h 	0000:01C4h 	Hardware 	Redirect interrupt cascade
72h-74h 	0000:01C8h - 0000:01D0h 	Hardware 	Reserved - Do not use
75h 	0000:01D4h 	Hardware 	Math coprocessor exception
76h 	0000:01D8h 	Hardware 	Hard disk support
77h 	0000:01DCh 	Hardware 	Suspend request
78h-79h 	0000:01E0h - 	Hardware 	Not used
7Ah 	  	Software 	Novell Netware API
78h-FFh 	0000:03FCh 	Software 	Not used</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>El contenido de la tabla depende de la generación de la cpu de intel</p>
</li>
<li>
<p>Primera columna: Número del vector de interrupción. Número de la entrada a la tabla de vectores.</p>
</li>
<li>
<p>Segunda columna: el offset en la tabla del número de vecto de interrupción</p>
</li>
<li>
<p>Columna X: Falta en la tabla.</p>
<div class="ulist">
<ul>
<li>
<p>El vector de 4 bytes: <strong>Es un puntero a la rutina de atención a la interrupción ISR</strong></p>
</li>
<li>
<p>La dirección es segmentada. Segmento:Offset. Dos bytes para el segmento y otros dos para el offset</p>
</li>
</ul>
</div>
</li>
<li>
<p>Direccionamiento:</p>
<div class="ulist">
<ul>
<li>
<p>El Registro IDTR apunta a la primera entrada de la tabla.</p>
</li>
<li>
<p>The IVT table is typically located at 0000:0000H, and is 400H bytes in size (<strong>4 bytes for each interrupt of 265 interruptions</strong>).</p>
</li>
<li>
<p>Observamos que podemos obtener la dirección relativa múltiplicando el número de interrupción x4.</p>
</li>
<li>
<p>Al vector 9 le corresponde el offset IVT 36, es decir, 0x24 &#8594; en forma segmentada 0000:0024h</p>
</li>
<li>
<p>El offset de la última entrada será = 4 x 0xFF = 0x400-4 =0x3FC</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Tipos de interrupciones</p>
<div class="ulist">
<ul>
<li>
<p>The first 32 vectors are reserved for the processor&#8217;s internal <em>exceptions</em> (0x00-0x1F)</p>
</li>
<li>
<p>Las interrupciones 0x20-0xFF son interrupciones <em>hadware</em> IRQ.</p>
</li>
<li>
<p>PIC</p>
<div class="ulist">
<ul>
<li>
<p>El controlador PIC es el encargado de mapear la señal IRQ a un vector de entrada a la tabla.</p>
</li>
<li>
<p>Periférico IRQ0 &#8594; PIC vector 0x20 &#8594; Tabla IVT puntero 0000:0080f (RAM) &#8594; llamada a la función ISR de atención al periférico IRQ0 (RAM)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_modo_protegido_tabla_idt">Modo Protegido: Tabla IDT</h5>
<div class="ulist">
<ul>
<li>
<p>En las plataformas con S.O. una vez finalizadas las operaciones en modo real el bootloader finaliza la carga del sistema operativo y la cpu se configura en modo protegido no pudiendo el usuario: ejecutar módulos del S.O como los drivers, acceder a cualquier región de la memoria física, registros privilegiados, instrucciones privilegiadas,&#8230;&#8203;</p>
</li>
<li>
<p>El S.O. configura la tabla de descripción de interrupciones IDT con la misma función que la IVT pero distinto contenido.</p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Interrupt_descriptor_table">Interrupt Descriptor Table IDT</a></p>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/ditaa/svg/eNp1k11vmzAUhu_zK460m0wTWoB0zW4mJaFMXORjTaJeu-ZArTAbGUKZ1B8_G2NsVa0vUCI9r3nOyZtZlpzhUBQNtvAG2f4MX0CfN0iwoZLVLRN8Frjz7ZPPn53Zol-oM16qv4B9AetYjvD8DxYGWjootNAjNig7zA2xckRkif0ug4y3KOWtbg22dVhssY1Ecq0F4y3M1Zjx1wENPbGlRQ8dyqISrwN4GEFP7m66U9x43oAkvETAniLmmMN8c7jskzHmGf-wsYx3pGI5iJoKtYD5JYlG2hO_n9aEHaMIXLRAOsIq8lypzNM6O39P9dNEI2-Q1RQVNw0X5FaZzUTeFD8ttRW1FBSbRkhosPyLakWi0_vkJuTNsH4_w_l0MpCnvrHQabxNu9dS_ZLcaMSe7HaCW0KvgRVwzrHnnFj4N3KUpFK3ihap7qif8IQfbOJISn8Tseebfli2pZMMp872q3tIjxdQ2xHSYE4vnFq7rljJhznoC9KrAZ1VOJV3R-gL4-hjTiycynvKdgmklSAt42VwHFr8oPpm_p061vcutgzUI303T-8R0UIRqSYuCoAcC8aHWgEEvyB7_PMfn6YRHw==" alt="Diagram">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>El contenido depende del kernel del S.O.</p>
</li>
<li>
<p>Primera columna: offset a la rutina de antención a interrupción ISR</p>
</li>
<li>
<p>Segunda columna: número del vector de interrupción.</p>
</li>
<li>
<p>tipos de interrupción</p>
<div class="ulist">
<ul>
<li>
<p>0-0x1F: <em>exceptions ERROR</em> y NMI</p>
</li>
<li>
<p>0x20-0x2F: INT maskable: IRQ0-----IRQ15</p>
</li>
<li>
<p>0x30-0xFF: <em>exceptions SW</em></p>
</li>
<li>
<p>0x80</p>
<div class="ulist">
<ul>
<li>
<p>isa x86-64: <em>syscall</em></p>
</li>
<li>
<p>isa x86: <em>int 0x80</em></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>¿A que rutina apunta el vector 0x0E? &#8594; Page Fault</p>
</li>
<li>
<p>Descripción de las Entradas</p>
<div class="ulist">
<ul>
<li>
<p>IDTR: registro que apunta a la primera entrada de la tabla</p>
</li>
<li>
<p>Cada entrada son 8 bytes que intel llama gates.</p>
</li>
<li>
<p>Contiene un selector de segmento que identifica un descriptor de segmento de la tabla de descriptores de segmentos (ver segmentación intel)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_irq">IRQ</h5>
<div class="ulist">
<ul>
<li>
<p>XT-PIC  interrupts use a pair of Intel  8259  programmable interrupt controllers (PIC)</p>
<div class="ulist">
<ul>
<li>
<p>PIC configurado por el kernel <strong>Linux</strong> : <a href="https://www.oreilly.com/library/view/understanding-the-linux/0596002130/ch04s06.html">Understanding the Linux Kernel, Second Edition by Marco Cesati, Daniel P. Bovet</a></p>
</li>
<li>
<p>Example XT-PIC IRQ Assignment , <a href="http://www.intel.co.jp/content/dam/www/public/us/en/documents/white-papers/msg-signaled-interrupts-paper.pdf">intel interrupts paper</a>: Esta configuración es un ejemplo, es decir, el SO puede <strong>reprogramarla</strong> y variar su configuración.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sh">IRQ 	Interrupt Hardware Device <span class="o">(</span>vector de la tabla<span class="o">)</span>
0 	32 Timer
1 	33 Keyboard
2 	34 PIC Cascade
3 	35 Second Serial Port <span class="o">(</span>COM2<span class="o">)</span>
4 	36 First Serial Port <span class="o">(</span>COM 1<span class="o">)</span>
5 	37 &lt;Free&gt;
6 	38 Floppy Disk
7 	39 &lt;Free&gt;
8 	40 System Clock
9 	41 &lt;Free&gt;
10 	42 Network Interface Card<span class="o">(</span>NIC<span class="o">)</span>
11 	43 USB Port, and Sound Card
12 	44 Mouse <span class="o">(</span>PS2<span class="o">)</span>
13 	45 Math Co-Processor
14 	46 IDE Channel 1
15 	47 IDE Channel 2

Note: Linux<span class="k">*</span> requires IRQ 0, 2, and 13 to be as shown.</code></pre>
</div>
</div>
</li>
<li>
<p>Master 8259 (PC compatible)</p>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/ditaa/svg/eNp1jl8LgjAUR9_9FBd6jGhuWvpomiD90UJ6N5sgiBOVSPDD13WDSeB9ORw4G7_okUJcFB3vYYTomsIKeb9NDHiXt2XTl6I2NvrWC1w4g3wIoQTwRviJM1F5EqUysHTgIk3lJz48Rda-ZOXoykNS5Q61XQ-6KntzyEXdt6KqeCvf-PrNAcmU-_GFwhZhTSGbbfSRlg5NGTIZzrYGSFv5OUmpLGY7j8id8rASTTP8T2SziSFyrz80v8n-YcU=" alt="Diagram">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Segunda columna: número de interrupción en el PIC</p>
</li>
<li>
<p>Tercera columna: número de interrupción IRQ</p>
</li>
<li>
<p>Primera columna: offset de esa entrada respecto de la primera entrada. Número de Vector.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Slave 8259</p>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/ditaa/svg/eNp9zj0PgjAQBuDdX3GJozFp-RCcYZBBjQTdCRRtJC1pa8LAj9d-JHQAb3lzyXOXt3hUcO06SRRMUFwq2OosbyZzIhtBB0U52-zn2a3kymzQiHCGQM8EaEyQztTtZZVZEM0A6zy6_c5qKemTkda6dHaBToyWXTa70Di86HKvWGRcYPcz_0gCDWdK8L4nwmqvZWx06HStXj88CN4QKbnTXteD0ZHdT7VooaXy7f0HbG-83om5if_cBF-f2XJW" alt="Diagram">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Segunda columna: número de interrupción en el PIC</p>
</li>
<li>
<p>Tercera columna: número de interrupción IRQ</p>
</li>
<li>
<p>Primera columna: offset de esa entrada respecto de la primera entrada. Número de Vector.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_linux">Linux</h5>
<div class="ulist">
<ul>
<li>
<p>Interrupciones configuradas por el kernel : <code>cat /proc/interrupts</code></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_lineas_compartidas">Lineas compartidas</h5>
<div class="ulist">
<ul>
<li>
<p><a href="https://nptel.ac.in/courses/Webcourse-contents/IIT-%20Guwahati/comp_org_arc/web/module06_io/lect_03_intr/lect_03.htm" class="bare">https://nptel.ac.in/courses/Webcourse-contents/IIT-%20Guwahati/comp_org_arc/web/module06_io/lect_03_intr/lect_03.htm</a></p>
</li>
<li>
<p>Si una línea de interrupción está compartida por varios dispositivos, cuando uno de los dispositivos envía la señal de interrupción por la línea común, la CPU puede identificar el dispositivo que solicita la interrupción de varias maneras:</p>
<div class="ulist">
<ul>
<li>
<p>sondeo por software a cada miembro de la línea</p>
</li>
<li>
<p>la línea de concesión de la CPU hacia los dispositivos colocados en modo daisy-chain (se pasan la concesión entre ellos, de uno en uno), cuando la concesión llegue al miembro que solicita, este devuelve su identificación.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_acceso_directo_a_memoria_dma">8.10. Acceso Directo a Memoria DMA</h3>
<div class="sect3">
<h4 id="_funcionalidad">8.10.1. Funcionalidad</h4>
<div class="ulist">
<ul>
<li>
<p>Realizar las transferencias de datos liberando así a la CPU</p>
</li>
<li>
<p>Aplicación: Transferencias de datos entre el disco duro y la memoria principal</p>
</li>
<li>
<p>Unidad: DMAC (DMA Controller)</p>
<div class="ulist">
<ul>
<li>
<p>Puede tener varios canales DMA: cada canal se ocupa de la transferencia de un periférico.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_transferencias">8.10.2. Transferencias</h4>
<div class="ulist">
<ul>
<li>
<p>Modo ráfaga</p>
<div class="ulist">
<ul>
<li>
<p>Una vez que el DMAC toma el control del bus del sistema no lo cede hasta que la transferencia de todo el bloque es completada</p>
</li>
<li>
<p>Mientras el bus del sistema está ocupado por el DMAC la CPU puede operar con la memoria caché.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Modo robo de ciclo</p>
<div class="ulist">
<ul>
<li>
<p>El DMAC devuelve el control del bus del sistema a la CPU cada vez que transfiere una palabra.</p>
</li>
<li>
<p>El bus es compartido en el tiempo: útil en sistemas críticos en tiempo real</p>
</li>
</ul>
</div>
</li>
<li>
<p>Modo transparente</p>
<div class="ulist">
<ul>
<li>
<p>El DMAC únicamente se adueña del bus cuando está libre y no lo necesita la CPU.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_sincronización">8.10.3. Sincronización</h4>
<div class="ulist">
<ul>
<li>
<p>La CPU puede iniciar una operación DMA en los límites del ciclo de bus de lectura o escritura. Por lo tanto se puede iniciar una operación DMA durante el ciclo de instrucción .</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_operación_del_controlador_dma">8.10.4. Operación del controlador DMA</h4>
<div class="sect4">
<h5 id="_secuencia_de_pasos_a_nivel_alto">Secuencia de pasos a nivel alto</h5>
<div class="ulist">
<ul>
<li>
<p>Cuando un proceso realiza una llamada <em>read</em>, el driver le asigna una región de memoria principal (DMA buffer) y genera la señales hw para solicitar la transferencia de datos al DMA buffer. El proceso queda en estado <em>sleep</em>.</p>
</li>
<li>
<p>El DMAC transfiere los datos al buffer DMA y activa una señal de interrupción cuando finaliza</p>
</li>
<li>
<p>El gestor de interrupciones ubica los datos del buffer al lugar definitivo, avisa de interrupción atendida y despierta al proceso, el cual ya puede leer los datos de la memoria principal.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_secuencia_de_pasos_a_nivel_bajo">Secuencia de pasos a nivel bajo</h5>
<div class="ulist">
<ul>
<li>
<p>Tres parámetros a programar:</p>
<div class="ulist">
<ul>
<li>
<p>dirección inicial de MPrincipal del bloque de datos a transferir: AR</p>
</li>
<li>
<p>Número de datos a transferir: WC</p>
</li>
<li>
<p>Modo de transferencia</p>
</li>
</ul>
</div>
</li>
<li>
<p>Pasos</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>La <em>CPU</em> durante el arranque de la computadora inicializa el DMAC programando los parámetros.</p>
</li>
<li>
<p>El <em>controlador del periférico</em> solicita su servicios.</p>
</li>
<li>
<p>El <em>periférico</em> realiza una petición de DMA al DMAC (DMA Controller): <em>DMA Request</em>.</p>
</li>
<li>
<p>El DMAC le responde con una señal de aceptación</p>
</li>
<li>
<p>El DMAC activa la línea de petición de DMA a la <em>CPU</em>: <em>Bus Request</em></p>
</li>
<li>
<p>Al final del <em>ciclo del bus</em> en curso, el procesador pone las líneas del bus del sistema en alta impedancia y activa la sesión de DMA: <em>Bus Grant</em></p>
</li>
<li>
<p>El DMAC asume el <em>control del bus del sistema</em></p>
</li>
<li>
<p>El dispositivo de E/S transmite una nueva palabra de datos al registro intermedio de datos del DMAC (un pequeño <em>buffer</em> en el DMAC)</p>
</li>
<li>
<p>El DMAC ejecuta un ciclo de escritura en memoria para transferir el contenido del registro intermedio a la posición M[AR].</p>
</li>
<li>
<p>El DMAC decrementa WC e incrementa AR.</p>
</li>
<li>
<p>El DMAC libera el bus y desactiva la línea de petición de DMA.</p>
</li>
<li>
<p>El DMAC compara WC con 0:</p>
</li>
<li>
<p>Si WC &gt; 0, se repite desde el paso 2.</p>
</li>
<li>
<p>Si WC = 0, el DMAC se detiene y envía una petición de interrupción al procesador.</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_problemas_de_coherencia_en_la_memoria_cache">8.10.5. Problemas de coherencia en la memoria cache</h4>
<div class="ulist">
<ul>
<li>
<p>El controlador DMA al transferir datos entre el periférico y la memoria Principal provoca que las líneas de la memoria caché no sean copia de los bloques de la memoria principal. Será necesario que la controladora de la caché actualice la memoria caché después de una operación DMA.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_buses_2">8.11. Buses</h3>
<div class="ulist">
<ul>
<li>
<p>La arquitectura i/o ha ido evolucionando en dos direcciones</p>
<div class="ulist">
<ul>
<li>
<p>incremento del ancho de banda de los buses</p>
</li>
<li>
<p>integración de los controladores i/o en un único chip</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_isa_2">8.11.1. ISA</h4>
<div class="imageblock text-center">
<div class="content">
<img src="./images/io/isa_8086.png" alt="isa 8086">
</div>
<div class="title">Figure 44. Arquitectura Bus ISA</div>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/io/isa_8086_interfaz.png" alt="isa 8086 interfaz">
</div>
<div class="title">Figure 45. Interfaz Bus ISA</div>
</div>
</div>
<div class="sect3">
<h4 id="_pci">8.11.2. PCI</h4>
<div class="imageblock text-center">
<div class="content">
<img src="./images/io/pci_80x86.png" alt="pci 80x86">
</div>
<div class="title">Figure 46. Arquitectura Bus PCI</div>
</div>
</div>
<div class="sect3">
<h4 id="_north_south_bridge">8.11.3. North-South Bridge</h4>
<div class="imageblock text-center">
<div class="content">
<img src="./images/io/north_south_bridge.png" alt="north south bridge">
</div>
<div class="title">Figure 47. North and South Bridges</div>
</div>
</div>
<div class="sect3">
<h4 id="_chipset_x58">8.11.4. Chipset x58</h4>
<div class="ulist">
<ul>
<li>
<p><a href="https://en.wikipedia.org/wiki/Intel_X58" class="bare">https://en.wikipedia.org/wiki/Intel_X58</a></p>
</li>
<li>
<p>PCH: Platform Controller Hub</p>
</li>
<li>
<p>FSB: Front Side Bus</p>
</li>
<li>
<p>BSB: Back Side Bus</p>
</li>
<li>
<p>FDI: Flexible Display Interface (para CPU que integran la controladora gráfica)</p>
</li>
<li>
<p>DMI: Direct Media Interface</p>
</li>
<li>
<p>ICH: i/o Controller Hub</p>
</li>
<li>
<p>IOH: i/o Hub</p>
</li>
</ul>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/io/x58blockdiagram_corei7.jpg" alt="x58blockdiagram corei7">
</div>
<div class="title">Figure 48. corei7 x58 chipset: año 2008</div>
</div>
<div class="paragraph">
<p>Chipsets supporting LGA 1366, LGA 2011, and LGA 2011-v3 CPUs.: X58 (2008), X79 (2011), X99 (2014).</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_programacion_de_rutinas_de_entradasalida">8.12. Programacion  de rutinas de entrada/salida</h3>
<div class="sect3">
<h4 id="_software_jerarquico_del_sistema_operativo">8.12.1. Software jerarquico del sistema operativo</h4>
<div class="ulist">
<ul>
<li>
<p>El driver o controlador sw es el nivel más bajo de la estructura sw: depende fuertemente del hardware de la computadora: programación en lenguaje C o ensamblador.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_instruction_set_architecture">8.12.2. Instruction Set Architecture</h4>
<div class="ulist">
<ul>
<li>
<p>I/O access</p>
<div class="ulist">
<ul>
<li>
<p>OUTx : Sends a byte (or word or dword) on a I/O location. Traditional names are <em>outb</em>, <em>outw</em> and <em>outl</em> respectively. The "a" modifier enforces <em>val</em> to be placed in the eax register before the asm command is issued and "Nd" allows for one-byte constant values to be assembled as constants, freeing the edx register for other cases.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="k">static</span> <span class="kr">inline</span>
<span class="kt">void</span> <span class="nf">outb</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">port</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">val</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span> <span class="s">"outb %0, %1"</span>
                  <span class="o">:</span> <span class="o">:</span> <span class="s">"a"</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="s">"Nd"</span><span class="p">(</span><span class="n">port</span><span class="p">)</span> <span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>El programa fuente en C incluye lenguaje ASM: Programa fuente en C con inline-asm.</p>
</li>
<li>
<p>%0 hace referencia a la primera variable "a", %i hace referencia a la i-nésima variable.</p>
</li>
</ul>
</div>
</li>
<li>
<p>INx : Receives a byte (or word or dword) from an I/O location. Traditional names are <em>inb</em>, <em>inw</em> and <em>inl</em> respectively.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="k">static</span> <span class="kr">inline</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">inb</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">port</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ret</span><span class="p">;</span>
    <span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span> <span class="s">"inb %1, %0"</span>
                  <span class="o">:</span> <span class="s">"=a"</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="o">:</span> <span class="s">"Nd"</span><span class="p">(</span><span class="n">port</span><span class="p">)</span> <span class="p">);</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>The register I/O instructions IN (input from I/O port) and OUT (output to I/O port) move data between I/O ports
and the EAX register (32-bit I/O), the AX register (16-bit I/O), or the AL (8-bit I/O) register. The address of the I/O
port can be given with an immediate value or a value in the DX register.</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_intel_manual">Intel Manual</h5>
<div class="ulist">
<ul>
<li>
<p>This instruction is only useful for accessing I/O ports located in the processor’s I/O address space. See Chapter 16 or 14, “Input/Output,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for more infor-mation on accessing I/O ports in the I/O address space.</p>
</li>
<li>
<p>I/O ports can be mapped so that they appear in the I/O address space or the physical-memory address space (memory mapped I/O) or both.</p>
</li>
<li>
<p><strong>memory-mapped</strong>:</p>
<div class="ulist">
<ul>
<li>
<p>mediante una línea del bus de control se especifica si la dirección es de memoria principal o port i/o, en algún procesador mediante el M/IO# pin.</p>
</li>
<li>
<p>When using memory-mapped I/O, caching of the address space mapped for I/O operations must be prevented</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>I/O mapped</strong></p>
<div class="ulist">
<ul>
<li>
<p>i/o devices don&#8217;t collide with memory, as they use a different <em>address space</em>, with different instructions to read and write values to addresses (ports). CPU  decode the memory-I/O bus transaction instructions to select I/O ports These devices cannot be addressed using machine code instructions that targets memory. What is happening is that there are two different signals: <em>MREQ</em> and <em>IOREQ</em>. The first one is asserted on every memory instruction, the second one, on every I/O instruction. So this code&#8230;&#8203;</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">MOV</span> <span class="n">DX</span><span class="p">,</span><span class="mi">1234</span><span class="n">h</span>
<span class="n">MOV</span> <span class="n">AL</span><span class="p">,[</span><span class="n">DX</span><span class="p">]</span>    <span class="p">;</span><span class="n">reads</span> <span class="n">memory</span> <span class="n">address</span> <span class="mi">1234</span><span class="n">h</span> <span class="p">(</span><span class="n">memory</span> <span class="n">address</span> <span class="n">space</span><span class="p">)</span>
<span class="n">IN</span> <span class="n">AL</span><span class="p">,</span><span class="n">DX</span>       <span class="p">;</span><span class="n">reads</span> <span class="n">I</span><span class="o">/</span><span class="n">O</span> <span class="n">port</span> <span class="mi">1234</span><span class="n">h</span> <span class="p">(</span><span class="n">I</span><span class="o">/</span><span class="n">O</span> <span class="n">address</span> <span class="n">space</span><span class="p">)</span></code></pre>
</div>
</div>
</li>
<li>
<p>The I/O device at port 1234h is connected to the system bus so that it is enabled only if the address is 1234h, RD (Read Data) is asserted and IOREQ is asserted.</p>
</li>
<li>
<p>(64K) individually addressable 8-bit I/O ports</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Protection</strong></p>
<div class="ulist">
<ul>
<li>
<p>Port Mapped</p>
<div class="ulist">
<ul>
<li>
<p>Here, kernel and the device drivers are allowed to perform I/O, while less privileged device drivers and application programs are denied access to the I/O address space. Application programs must then make <em>calls</em> to the operating system to perform I/O.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Memory mapped</p>
<div class="ulist">
<ul>
<li>
<p>the normal segmentation and paging protection affect the i/o port access.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_programación_del_controlador_de_interrupciones_programable">8.12.3. Programación del Controlador de Interrupciones Programable</h4>
<div class="ulist">
<ul>
<li>
<p><a href="http://www.superfrink.net/athenaeum/OS-FAQ/os-faq-pics.html">programación del pic</a></p>
<div class="ulist">
<ul>
<li>
<p>Mapeo del <a href="http://wiki.osdev.org/8259_PIC">PIC</a></p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="cm">/* remap the PIC controller interrupts to our vectors
   rather than the 8 + 70 as mapped by default */</span>

<span class="cp">#define	PIC1		0x20
#define	PIC2		0xA0
#define	PIC1_COMMAND	PIC1
#define	PIC1_DATA	(PIC1+1)
#define	PIC2_COMMAND	PIC2
#define	PIC2_DATA	(PIC2+1)
#define	PIC_EOI		0x20
</span>
<span class="cp">#define	ICW1_ICW4	0x01		</span><span class="cm">/* ICW4 (not) needed */</span><span class="cp">
#define	ICW1_SINGLE	0x02		</span><span class="cm">/* Single (cascade) mode */</span><span class="cp">
#define	ICW1_INTERVAL4	0x04		</span><span class="cm">/* Call address interval 4 (8) */</span><span class="cp">
#define	ICW1_LEVEL	0x08		</span><span class="cm">/* Level triggered (edge) mode */</span><span class="cp">
#define	ICW1_INIT	0x10		</span><span class="cm">/* Initialization - required! */</span><span class="cp">
</span>
<span class="cp">#define	ICW4_8086	0x01		</span><span class="cm">/* 8086/88 (MCS-80/85) mode */</span><span class="cp">
#define	ICW4_AUTO	0x02		</span><span class="cm">/* Auto (normal) EOI */</span><span class="cp">
#define	ICW4_BUF_SLAVE	0x08		</span><span class="cm">/* Buffered mode/slave */</span><span class="cp">
#define	ICW4_BUF_MASTER	0x0C		</span><span class="cm">/* Buffered mode/master */</span><span class="cp">
#define	ICW4_SFNM	0x10		</span><span class="cm">/* Special fully nested (not) */</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">remap_pics</span><span class="p">(</span><span class="kt">int</span> <span class="n">pic1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pic2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">UCHAR</span>	<span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">;</span>

	<span class="n">a1</span><span class="o">=</span><span class="n">inb</span><span class="p">(</span><span class="n">PIC1_DATA</span><span class="p">);</span>
	<span class="n">a2</span><span class="o">=</span><span class="n">inb</span><span class="p">(</span><span class="n">PIC2_DATA</span><span class="p">);</span>

	<span class="n">outb</span><span class="p">(</span><span class="n">PIC1_COMMAND</span><span class="p">,</span> <span class="n">ICW1_INIT</span><span class="o">+</span><span class="n">ICW1_ICW4</span><span class="p">);</span>
	<span class="n">io_wait</span><span class="p">();</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">PIC2_COMMAND</span><span class="p">,</span> <span class="n">ICW1_INIT</span><span class="o">+</span><span class="n">ICW1_ICW4</span><span class="p">);</span>
	<span class="n">io_wait</span><span class="p">();</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">PIC1_DATA</span><span class="p">,</span> <span class="n">pic1</span><span class="p">);</span>
	<span class="n">io_wait</span><span class="p">();</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">PIC2_DATA</span><span class="p">,</span> <span class="n">pic2</span><span class="p">);</span>
	<span class="n">io_wait</span><span class="p">();</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">PIC1_DATA</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">io_wait</span><span class="p">();</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">PIC2_DATA</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">io_wait</span><span class="p">();</span>

	<span class="n">outb</span><span class="p">(</span><span class="n">PIC1_DATA</span><span class="p">,</span> <span class="n">ICW4_8086</span><span class="p">);</span>
	<span class="n">io_wait</span><span class="p">();</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">PIC2_DATA</span><span class="p">,</span> <span class="n">ICW4_8086</span><span class="p">);</span>
	<span class="n">io_wait</span><span class="p">();</span>

	<span class="n">outb</span><span class="p">(</span><span class="n">PIC1_DATA</span><span class="p">,</span> <span class="n">a1</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">PIC2_DATA</span><span class="p">,</span> <span class="n">a2</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_driver_del_teclado">8.12.4. Driver del Teclado</h4>
<div class="ulist">
<ul>
<li>
<p>Fijarse cómo se programa teniendo en cuenta el mecanismo de atención a las interrupciones.</p>
</li>
<li>
<p>Buscar el código fuente de un kernel sencillo.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_paralell_port">8.12.5. paralell port</h4>
<div class="sect4">
<h5 id="_desde_espacio_de_usuario">Desde Espacio de Usuario</h5>
<div class="ulist">
<ul>
<li>
<p>Es necesario realizar llamadas al sistema ya que no podemos acceder desde el espacio de usuario directamente al HW</p>
</li>
<li>
<p><a href="http://es.wikipedia.org/wiki/Direcciones_base_de_entrada/salida">Direcciones base de los puertos</a></p>
</li>
<li>
<p>Acceso a un puerto en linux desde el espacio de usuario</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="cm">/* led_bloq_mayus.c: very simple example of port I/O
 *
 * This code active LED keyboard CAP, just a port write, a pause,
 * and a port read. Compile with `gcc -O2 -o led_bloq_mayus led_bloq_mayus.c',
 * and run as root with `sudo ./led_bloq_mayus'.
 */</span>

<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/io.h&gt;</span><span class="cp">
</span>
<span class="cp">#define BASEPORT 0x0060 </span><span class="cm">/* keyboard */</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
        <span class="cm">/* Get access to the ports */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ioperm</span><span class="p">(</span><span class="n">BASEPORT</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span><span class="n">perror</span><span class="p">(</span><span class="s">"ioperm"</span><span class="p">);</span> <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n\t\t</span><span class="s"> Port -&gt; registro status: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">inb</span><span class="p">(</span><span class="n">BASEPORT</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>

        <span class="cm">/* Set the data signals (D0-7) of the port to all low (0) */</span>
        <span class="n">outb</span><span class="p">(</span><span class="mh">0xED</span><span class="p">,</span> <span class="n">BASEPORT</span><span class="p">);</span>

        <span class="cm">/* Sleep for a while (100 ms) */</span>
        <span class="n">usleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s"> </span><span class="se">\t\t</span><span class="s">Activa el LED de la tecla BLOQ MAYUS </span><span class="se">\n</span><span class="s"> "</span><span class="p">);</span>
        <span class="n">outb</span><span class="p">(</span><span class="mh">0x07</span><span class="p">,</span> <span class="n">BASEPORT</span><span class="p">);</span>

        <span class="n">usleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>

        <span class="cm">/* We don't need the ports anymore */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ioperm</span><span class="p">(</span><span class="n">BASEPORT</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span><span class="n">perror</span><span class="p">(</span><span class="s">"ioperm"</span><span class="p">);</span> <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://tldp.org/HOWTO/IO-Port-Programming-2.html" class="bare">http://tldp.org/HOWTO/IO-Port-Programming-2.html</a></p>
</li>
<li>
<p>man ioperm</p>
</li>
<li>
<p>man inb</p>
</li>
<li>
<p><code>cat /proc/ioports</code></p>
</li>
</ul>
</div>
</li>
<li>
<p><a href="http://opensourceforu.efytimes.com/2011/07/accessing-x86-specific-io-mapped-hardware-in-linux/" class="bare">http://opensourceforu.efytimes.com/2011/07/accessing-x86-specific-io-mapped-hardware-in-linux/</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_serial_communication_rs_232">8.12.6. Serial communication RS-232</h4>
<div class="ulist">
<ul>
<li>
<p><a href="http://deans-avr-tutorials.googlecode.com/svn/trunk/InterruptUSART/Output/InterruptUSART.pdf">tutorial</a></p>
<div class="ulist">
<ul>
<li>
<p>Tarjeta Avr Atmega 8bits &#8594; Pej Arduino One</p>
</li>
<li>
<p>Dos casos: Polling i/o e interrupt-driven i/o</p>
</li>
</ul>
</div>
</li>
<li>
<p>Puerto UART (RS-232)</p>
<div class="ulist">
<ul>
<li>
<p>Conector físico</p>
</li>
<li>
<p>Comunicación semiduplex entre dos terminales: DTE (PC) y DCE (Arduino)</p>
</li>
<li>
<p>Señales Tx Rx</p>
</li>
<li>
<p>Registros del puerto</p>
<div class="ulist">
<ul>
<li>
<p>Control</p>
</li>
<li>
<p>Estado</p>
</li>
<li>
<p>Datos Rx y Tx: UDR</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Programación</p>
<div class="ulist">
<ul>
<li>
<p>Librería</p>
</li>
<li>
<p>Cross toolchain</p>
</li>
<li>
<p>Algoritmo: Diagrama de flujo</p>
<div class="ulist">
<ul>
<li>
<p>Casos Polling y Interruption</p>
</li>
</ul>
</div>
</li>
<li>
<p>Estructura modular: dos módulos</p>
</li>
<li>
<p>Símbolos</p>
<div class="ulist">
<ul>
<li>
<p>Buffer de datos i/o</p>
</li>
<li>
<p>Nombre del vector de interrupción</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ejercicios_2">8.13. Ejercicios</h3>
<div class="ulist">
<ul>
<li>
<p>Capítulo 7 del libro de texto William Stalling.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="paragraph nav-footer">
<p>← Previous: <a href="_procesador_central.html">Procesador Central</a> | ↑ Up: <a href="_ii_unidades_básicas_procesador_central_unidad_de_memoria_mecanismos_entradasalida.html">II Unidades Básicas: Procesador Central, Unidad de Memoria, Mecanismos Entrada/Salida.</a> | ⌂ Home: <a href="eecc_book.html">Estructura de Computadores  (240306)</a> | Next: <a href="_unidad_de_memoria.html">Unidad de Memoria</a> →</p>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2022-09-05 10:43:18 +0200
</div>
</div>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]],
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },
  TeX: { equationNumbers: { autoNumber: "none" } }
})
MathJax.Hub.Register.StartupHook("AsciiMath Jax Ready", function () {
  MathJax.InputJax.AsciiMath.postfilterHooks.Add(function (data, node) {
    if ((node = data.script.parentNode) && (node = node.parentNode) && node.classList.contains("stemblock")) {
      data.math.root.display = "block"
    }
    return data
  })
})
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
</body>
</html>