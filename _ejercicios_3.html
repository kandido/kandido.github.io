<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.17">
<meta name="keywords" content="computer, architecture">
<meta name="author" content="Cándido Aramburu">
<title>Estructura de Computadores  (240306)</title>
<style>
@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";
@import "https://cdn.jsdelivr.net/gh/asciidoctor/asciidoctor@2.0/data/stylesheets/asciidoctor-default.css";



h1, h2, h3, h4, h5, h6, #toctitle,
.sidebarblock > .content > .title {
  color: rgba(221, 72, 20, 0.8);
}



</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
pre.rouge table td { padding: 5px; }
pre.rouge table pre { margin: 0; }
pre.rouge .cm {
  color: #999988;
  font-style: italic;
}
pre.rouge .cp {
  color: #999999;
  font-weight: bold;
}
pre.rouge .c1 {
  color: #999988;
  font-style: italic;
}
pre.rouge .cs {
  color: #999999;
  font-weight: bold;
  font-style: italic;
}
pre.rouge .c, pre.rouge .ch, pre.rouge .cd, pre.rouge .cpf {
  color: #999988;
  font-style: italic;
}
pre.rouge .err {
  color: #a61717;
  background-color: #e3d2d2;
}
pre.rouge .gd {
  color: #000000;
  background-color: #ffdddd;
}
pre.rouge .ge {
  color: #000000;
  font-style: italic;
}
pre.rouge .gr {
  color: #aa0000;
}
pre.rouge .gh {
  color: #999999;
}
pre.rouge .gi {
  color: #000000;
  background-color: #ddffdd;
}
pre.rouge .go {
  color: #888888;
}
pre.rouge .gp {
  color: #555555;
}
pre.rouge .gs {
  font-weight: bold;
}
pre.rouge .gu {
  color: #aaaaaa;
}
pre.rouge .gt {
  color: #aa0000;
}
pre.rouge .kc {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kd {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kn {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kp {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kr {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kt {
  color: #445588;
  font-weight: bold;
}
pre.rouge .k, pre.rouge .kv {
  color: #000000;
  font-weight: bold;
}
pre.rouge .mf {
  color: #009999;
}
pre.rouge .mh {
  color: #009999;
}
pre.rouge .il {
  color: #009999;
}
pre.rouge .mi {
  color: #009999;
}
pre.rouge .mo {
  color: #009999;
}
pre.rouge .m, pre.rouge .mb, pre.rouge .mx {
  color: #009999;
}
pre.rouge .sa {
  color: #000000;
  font-weight: bold;
}
pre.rouge .sb {
  color: #d14;
}
pre.rouge .sc {
  color: #d14;
}
pre.rouge .sd {
  color: #d14;
}
pre.rouge .s2 {
  color: #d14;
}
pre.rouge .se {
  color: #d14;
}
pre.rouge .sh {
  color: #d14;
}
pre.rouge .si {
  color: #d14;
}
pre.rouge .sx {
  color: #d14;
}
pre.rouge .sr {
  color: #009926;
}
pre.rouge .s1 {
  color: #d14;
}
pre.rouge .ss {
  color: #990073;
}
pre.rouge .s, pre.rouge .dl {
  color: #d14;
}
pre.rouge .na {
  color: #008080;
}
pre.rouge .bp {
  color: #999999;
}
pre.rouge .nb {
  color: #0086B3;
}
pre.rouge .nc {
  color: #445588;
  font-weight: bold;
}
pre.rouge .no {
  color: #008080;
}
pre.rouge .nd {
  color: #3c5d5d;
  font-weight: bold;
}
pre.rouge .ni {
  color: #800080;
}
pre.rouge .ne {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nf, pre.rouge .fm {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nl {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nn {
  color: #555555;
}
pre.rouge .nt {
  color: #000080;
}
pre.rouge .vc {
  color: #008080;
}
pre.rouge .vg {
  color: #008080;
}
pre.rouge .vi {
  color: #008080;
}
pre.rouge .nv, pre.rouge .vm {
  color: #008080;
}
pre.rouge .ow {
  color: #000000;
  font-weight: bold;
}
pre.rouge .o {
  color: #000000;
  font-weight: bold;
}
pre.rouge .w {
  color: #bbbbbb;
}
pre.rouge {
  background-color: #f8f8f8;
}
</style>
<!-- Change some CSS.
<style>
.imageblock{
  &.text-center > .title {
    text-align: center !important;
  }
}
</style>

-->

<style type="text/css"> .imageblock > .title { text-align: center; } </style>

<style>.toc-current{font-weight: bold;} .toc-root{font-family: "Open Sans","DejaVu Sans",sans-serif;
                       font-size: 0.9em;} #content{display: flex; flex-direction: column; flex: 1 1 auto;}
             .nav-footer{text-align: center; margin-top: auto;}
             .nav-footer > p > a {white-space: nowrap;}</style>
</head>
<body id="_ejercicios_3" class="book">
<div id="header">
<h1>Estructura de Computadores  (240306)</h1>
<div class="details">
<span id="author" class="author">Cándido Aramburu</span><br>
<span id="email" class="email"><a href="mailto:candido@unavarra.es">candido@unavarra.es</a></span><br>
<span id="revdate">2022-09-29</span>
</div>
<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<p><span class="toc-root"><a href="eecc_book.html">Estructura de Computadores  (240306)</a></span></p><ul class="sectlevel0">
<li><a href="_i_arquitectura_del_repertorio_de_instrucciones_isa_computadora_von_neumann_datos_instrucciones_programación.html">I Arquitectura del Repertorio de Instrucciones (ISA): computadora von Neumann, datos, instrucciones, programación.</a>
</li>
<li><a href="_ii_unidades_básicas_procesador_central_unidad_de_memoria_mecanismos_entradasalida.html">II Unidades Básicas: Procesador Central, Unidad de Memoria, Mecanismos Entrada/Salida.</a>
</li>
<li><a href="_iii_ejercicios_de_teoría.html">III Ejercicios de Teoría</a>
<ul class="sectlevel1">
<li><a href="_ejercicios_3.html"><span class="toc-current">10. Ejercicios</span></a>
<ul class="sectlevel2">
<li><a href="_ejercicios_3.html#_arquitectura_von_neumann_3">10.1. Arquitectura von Neumann</a>
<ul class="sectlevel3">
<li><a href="_ejercicios_3.html#_computadoras_ias_eniac">10.1.1. Computadoras: IAS, ENIAC, ..</a>
</li>
<li><a href="_ejercicios_3.html#_interconexión_cpu_memoria">10.1.2. Interconexión CPU-Memoria</a>
</li>
</ul>
</li>
<li><a href="_ejercicios_3.html#_representación_de_datos">10.2. Representación de Datos</a>
</li>
<li><a href="_ejercicios_3.html#_operaciones_aritméticas_2">10.3. Operaciones Aritméticas</a>
</li>
<li><a href="_ejercicios_3.html#_operaciones_lógicas">10.4. Operaciones Lógicas</a>
</li>
<li><a href="_ejercicios_3.html#_representación_de_las_instrucciones_2">10.5. Representación de las Instrucciones</a>
</li>
<li><a href="_ejercicios_3.html#_programación_asm">10.6. Programación asm</a>
<ul class="sectlevel3">
<li><a href="_ejercicios_3.html#_datos">10.6.1. Datos</a>
</li>
<li><a href="_ejercicios_3.html#_modos_de_direccionamiento_2">10.6.2. Modos de Direccionamiento</a>
</li>
<li><a href="_ejercicios_3.html#_aritmética">10.6.3. Aritmética</a>
</li>
<li><a href="_ejercicios_3.html#_saltos_2">10.6.4. Saltos</a>
</li>
<li><a href="_ejercicios_3.html#_if_then_else">10.6.5. If-Then-Else</a>
</li>
<li><a href="_ejercicios_3.html#_do_while_loops">10.6.6. Do-While Loops</a>
</li>
</ul>
</li>
<li><a href="_ejercicios_3.html#_lenguaje_de_programación_c">10.7. Lenguaje de Programación C</a>
<ul class="sectlevel3">
<li><a href="_ejercicios_3.html#_punteros">10.7.1. Punteros</a>
</li>
</ul>
</li>
<li><a href="_ejercicios_3.html#_capitulo_4_memoria_cache">10.8. Capitulo 4: Memoria Cache</a>
</li>
<li><a href="_ejercicios_3.html#_capitulo_5_memoria_sincrona_dinamica_ram_sdram">10.9. Capitulo 5: Memoria Sincrona Dinamica RAM (SDRAM)</a>
</li>
<li><a href="_ejercicios_3.html#_capitulo_7_sistemas_entradasalida">10.10. Capitulo 7: Sistemas Entrada/Salida</a>
</li>
<li><a href="_ejercicios_3.html#_capitulo_8_operating_system">10.11. Capitulo 8: Operating System</a>
</li>
<li><a href="_ejercicios_3.html#_capitulo_12_processor_structure_and_function_capitulo_14_en_9ªed">10.12. Capitulo 12: Processor Structure and Function (Capitulo 14 en 9ªEd)</a>
</li>
<li><a href="_ejercicios_3.html#_capitulo_13_reduces_instruction_set_computer_capítulo_15_en_9ªed">10.13. Capitulo 13: Reduces Instruction Set Computer (Capítulo 15 en 9ªEd)</a>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="_iv_autoevaluación_teoría.html">IV Autoevaluación Teoría</a>
</li>
<li><a href="_v_guiones_de_prácticas_programación_ensamblador_x86.html">V Guiones de Prácticas: Programación Ensamblador x86</a>
</li>
<li><a href="_vi_hojas_de_referencia_rápida.html">VI Hojas de Referencia Rápida</a>
</li>
<li><a href="_vii_autoevaluación_prácticas.html">VII Autoevaluación Prácticas</a>
</li>
<li><a href="_viii_apéndices.html">VIII Apéndices</a>
</li>
<li><a href="_ix_bibliografía.html">IX Bibliografía</a>
</li>
<li><a href="_x_glosario.html">X Glosario</a>
</li>
<li><a href="_xi_colofón.html">XI Colofón</a>
</li>
<li><a href="_index.html">Index</a>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_ejercicios_3">10. Ejercicios</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_arquitectura_von_neumann_3">10.1. Arquitectura von Neumann</h3>
<div class="sect3">
<h4 id="_computadoras_ias_eniac">10.1.1. Computadoras: IAS, ENIAC, ..</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>You are to write an IAS program to compute the results of the following equation.
 Y = Sum{X} para X=1 hasta X=N. Assume that the result of the computation does not arithmetic overflow and that X, Y,
and N are positive integers with N &gt; 1. Note: The IAS did not have assembly language only machine language.</p>
<div class="olist loweralpha">
<ol class="loweralpha">
<li>
<p>Use the equation <strong>Sum(Y)= N(N+1)/2</strong> when writing the IAS program. Comentar los conceptos de: datos, instrucciones, memoria principal, registros, secciones, operación, operando, campo de operaciones, campo de operando, dirección de memoria, contenido de memoria, referencia al operando, operando implicito, direccionamiento del operando, direccionamiento directo del operando, código binario, código hexadecimal, código de operación, código del campo de operando. Ejecutar el programa fuente con el emulador IASSIm.</p>
<div class="ulist">
<ul>
<li>
<p>Desarrollo:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="nasm"><span class="c1">; Suma de los primeros N numeros enteros. Y=N(N+1)/2</span>
<span class="c1">; CPU IAS</span>
<span class="c1">; lenguaje ensamblador: simaulador IASSim</span>
<span class="c1">; Ejercicio 2.1 del libro de William Stalling, Estructura de Computadores</span>


<span class="c1">; El algoritmo que seguimos es : primero la suma N+1, a continuación la multiplicación N(N+1) y finalmente la división. Cada resultado se guarda en la memoria principal si fuera necesario.</span>

<span class="c1">; Describimos el programa en 4 lenguajes: lenguaje ensamblador iassim, lenguaje máquina binario, lenguaje RTL y lenguaje ensamblador WStalling</span>

<span class="c1">; SECCION DE INSTRUCCIONES</span>
 <span class="nf">S</span><span class="p">(</span><span class="nv">x</span><span class="p">)</span><span class="o">-&gt;</span><span class="nv">Ac</span><span class="o">+</span> <span class="nv">n</span>    <span class="c1">;        01 n   ;        AC    &lt;- M[n]      ;LOAD   M(n)</span>
 <span class="nf">S</span><span class="p">(</span><span class="nv">x</span><span class="p">)</span><span class="o">-&gt;</span><span class="nb">Ah</span><span class="o">+</span> <span class="nv">uno</span>  <span class="c1">;        05 uno ;        AC    &lt;- AC+1      ;ADD    M(uno)</span>
 <span class="nf">At</span><span class="o">-&gt;</span><span class="nv">S</span><span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="nv">y</span>     <span class="c1">;        11 y   ;        M[y]  &lt;- AC        ;STORE  M(y)</span>
 <span class="nf">S</span><span class="p">(</span><span class="nv">x</span><span class="p">)</span><span class="o">-&gt;</span><span class="nv">R</span> <span class="nv">y</span>      <span class="c1">;        09 y   ;        AR    &lt;- M[y]      ;LOAD   MQ,M(y)</span>
 <span class="nf">S</span><span class="p">(</span><span class="nv">x</span><span class="p">)</span><span class="o">*</span><span class="nv">R</span><span class="o">-&gt;</span><span class="nv">A</span> <span class="nv">n</span>    <span class="c1">;        0B n   ;        AC:AR &lt;- AR*M[n]   ;MUL    M(n)</span>
 <span class="nf">R</span><span class="o">-&gt;</span><span class="nv">A</span>           <span class="c1">;        0A     ;        AC    &lt;- AR        ;LOAD   MQ</span>
 <span class="nf">A</span><span class="o">/</span><span class="nv">S</span><span class="p">(</span><span class="nv">x</span><span class="p">)</span><span class="o">-&gt;</span><span class="nv">R</span> <span class="nv">dos</span>  <span class="c1">;        0C 2   ;        AR    &lt;- AC/2      ;DIV    M(dos)</span>
 <span class="nf">R</span><span class="o">-&gt;</span><span class="nv">A</span>           <span class="c1">;        0A     ;        AC    &lt;- AR        ;LOAD   MQ</span>
 <span class="nf">At</span><span class="o">-&gt;</span><span class="nv">S</span><span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="nv">y</span>     <span class="c1">;        11 y   ;        M[y]  &lt;- AC        ;STORE  y</span>
 <span class="nf">halt</span>
<span class="c1">; como el número de instrucciones  es par no es necesaria la directiva .empty</span>


<span class="c1">; SECCION DE DATOS</span>
<span class="c1">; Declaracion e inicializacion de variables</span>
<span class="nl">y:</span>     <span class="nf">.data</span> <span class="mi">0</span>  <span class="c1">;resultado</span>

<span class="c1">; Declaracion de las Constantes</span>
<span class="nl">n:</span>    <span class="nf">.data</span> <span class="mi">5</span>   <span class="c1">;parametro N</span>
<span class="nl">uno:</span>  <span class="nf">.data</span> <span class="mi">1</span>
<span class="nl">dos:</span>  <span class="nf">.data</span> <span class="mi">2</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Do it the “hard way” without using the equation from part (a): \(\sum_{i=1}^{5}i\)</p>
<div class="ulist">
<ul>
<li>
<p>Desarrollo:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="nasm"><span class="c1">; adds up the values n+...+3+2+1(+0) in a loop and stores</span>
<span class="c1">; the sum in memory at the location labeled "sum"</span>

<span class="nl">loop:</span>   <span class="nf">S</span><span class="p">(</span><span class="nv">x</span><span class="p">)</span><span class="o">-&gt;</span><span class="nv">Ac</span><span class="o">+</span>  <span class="nv">n</span>    <span class="c1">;load n into AC</span>
        <span class="nf">Cc</span><span class="o">-&gt;</span><span class="nv">S</span><span class="p">(</span><span class="nv">x</span><span class="p">)</span>   <span class="nv">pos</span>  <span class="c1">;if AC &gt;= 0, jump to pos</span>
        <span class="nf">halt</span>            <span class="c1">;otherwise done</span>
        <span class="nf">.empty</span>          <span class="c1">;a 20-bit 0</span>
<span class="nl">pos:</span>    <span class="nf">S</span><span class="p">(</span><span class="nv">x</span><span class="p">)</span><span class="o">-&gt;</span><span class="nb">Ah</span><span class="o">+</span>  <span class="nv">sum</span>  <span class="c1">;add n to the sum</span>
        <span class="nf">At</span><span class="o">-&gt;</span><span class="nv">S</span><span class="p">(</span><span class="nv">x</span><span class="p">)</span>   <span class="nv">sum</span>  <span class="c1">;put total back at sum</span>
        <span class="nf">S</span><span class="p">(</span><span class="nv">x</span><span class="p">)</span><span class="o">-&gt;</span><span class="nv">Ac</span><span class="o">+</span>  <span class="nv">n</span>    <span class="c1">;load n into AC</span>
        <span class="nf">S</span><span class="p">(</span><span class="nv">x</span><span class="p">)</span><span class="o">-&gt;</span><span class="nb">Ah</span><span class="o">-</span>  <span class="nv">one</span>  <span class="c1">;decrement n</span>
        <span class="nf">At</span><span class="o">-&gt;</span><span class="nv">S</span><span class="p">(</span><span class="nv">x</span><span class="p">)</span>   <span class="nv">n</span>    <span class="c1">;store decremented n</span>
        <span class="nf">Cu</span><span class="o">-&gt;</span><span class="nv">S</span><span class="p">(</span><span class="nv">x</span><span class="p">)</span>   <span class="nv">loop</span> <span class="c1">;go back and do it again</span>

<span class="nl">n:</span>     <span class="nf">.data</span> <span class="mi">5</span>  <span class="c1">;will loop 6 times total</span>
<span class="nl">one:</span>   <span class="nf">.data</span> <span class="mi">1</span>  <span class="c1">;constant for decrementing n</span>
<span class="nl">sum:</span>   <span class="nf">.data</span> <span class="mi">0</span>  <span class="c1">;where the running/final total is kept</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>On the IAS, what would the machine code instruction look like to load the contents of memory address 2 to the accumulator? How many trips to memory does the CPU need to make to complete this instruction during the instruction cycle?</p>
<div class="ulist">
<ul>
<li>
<p>Desarrollo:</p>
<div class="ulist">
<ul>
<li>
<p>0x01002: Código de Operación 01 y referencia al operando 002</p>
</li>
<li>
<p>Dos accesos a la memoria principal: captura de la instrucción y captura del operando</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>On the IAS, describe in English the process that the CPU must undertake to <strong>read</strong> a value from memory and to <strong>write</strong> a value to memory in terms of what is put into the MAR, MBR, address bus, data bus, and control bus.</p>
<div class="ulist">
<ul>
<li>
<p>Desarrollo:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sh">Lectura
MAR         &lt;- address
Address Bus &lt;- MAR
Control Bus &lt;- Read
Data Bus    &lt;- Data
MBR         &lt;- Data Bus

Escritura
MAR         &lt;- address
Data Bus    &lt;- MBR
Control Bus &lt;- Write</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>A esta descripción del flujo de información se le denomina ruta de datos de la CPU.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Given the memory contents of the IAS computer shown below,</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sh">Address Contents
08A 010FA110FB
08B 010FA0F08D
08C 020FA110FB</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>show the assembly language code for the program, starting at address 08A. Explain what this program does.</p>
</li>
<li>
<p>Desarrollo:</p>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Address</th>
<th class="tableblock halign-left valign-top">Contents</th>
<th class="tableblock halign-left valign-top" colspan="2">RTL</th>
<th class="tableblock halign-left valign-top" colspan="2">Instructions</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">08A</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">010FA110FB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">AC&#8592;M[0FA]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">M[0FB]&#8592;AC</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LOAD  M[0FA]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">STORE M[0FB]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">08B</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">010FA0F08D</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">AC&#8592;M[0FA]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">AC&gt;0:PC &#8592; 0x08D(0:19)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LOAD  M[0FA]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JMP   +M[08D(0:19)]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">08C</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">020FA110FB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">AC&#8592;-M[0FA]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">M[0FB]&#8592;AC</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LOAD -M[0FA]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">STORE M[0FB]</p></td>
</tr>
</tbody>
</table>
<div class="ulist">
<ul>
<li>
<p>Contents: instrucción izda 010FA (Cod Op 01 Address 0FA) e instrucción dcha 110FB -</p>
</li>
<li>
<p>A este proceso inverso a ensamblar (lenguaje ensamblador &#8594; código binario) se le denomina desensamblar (código binario &#8594; lenguaje ensamblador)</p>
</li>
</ul>
</div>
</li>
<li>
<p>El programa realiza la siguiente función:</p>
<div class="ulist">
<ul>
<li>
<p>Si el contenido de 0x0FA es positivo copia el contenido de memoria de la posición 0x0FA a la posición 0xFB y salta a la posición 0x08D, dejando en el acumulador el contenido de 0xFA. Si el contenido de 0x0FA es negativo  copia el contenido de memoria de la posición 0x0FA a la posición 0xFB cambiado de signo y salta a la posición 0x08D, dejando en el acumulador el contenido de 0xFA en positivo, es decir, el módulo.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Indicate the width, in bits, of each data path (e.g., between AC and ALU) of IAS microarchitecture.</p>
<div class="ulist">
<ul>
<li>
<p>Desarrollo:</p>
<div class="ulist">
<ul>
<li>
<p>AC, AR y MBR  40 bits</p>
</li>
<li>
<p>IBR 20 bits</p>
</li>
<li>
<p>MAR y PC 12 bits</p>
</li>
<li>
<p>IR 8 bits</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Considerar una computadora con las siguientes instrucciones:</p>
<table class="tableblock frame-all grid-all" style="width: 50%;">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Código de Operación</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Descripción</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0001</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Load AC from memory</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0010</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Store AC to memory</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0101</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Add to AC from memory</code></p></td>
</tr>
</tbody>
</table>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Describir las fases de los ciclos de instrucción de la CPU al ejecutar dicho programa teniendo en cuenta la siguiente figura:</p>
<div class="imageblock text-center">
<div class="content">
<img src="./images/ejercicios/ciclo_instruccion_1.png" alt="ciclo instruccion 1">
</div>
<div class="title">Figure 69. Ciclos de Instrucción</div>
</div>
</li>
<li>
<p>¿Cuál es el formato de instrucciones? ¿ Cuál es el tamaño de los registros contador de programa y registro de instrucciones? ¿Cuál es el tamaño del bus de datos y del bus de direcciones?</p>
</li>
</ol>
</div>
</li>
<li>
<p>The ENIAC was a <strong>decimal machine</strong>, where a register was represented by a ring of 10 vacuum tubes. At any time, only one vacuum tube was in the ON state, representing one of the 10 digits. Assuming that ENIAC had the capability to have multiple vacuum tubes in the ON and OFF state simultaneously, why is this representation “wasteful” and what range of integer values could we represent using the 10 vacuum tubes?</p>
<div class="ulist">
<ul>
<li>
<p>Desarrollo: Con 10 tubos únicamente podemos representar los digitos 0-9</p>
</li>
</ul>
</div>
</li>
<li>
<p>A benchmark program is run on a 40 MHz processor. The executed program consists
of 100,000 instruction executions, with the following instruction mix and clock cycle
count:</p>
<table class="tableblock frame-all grid-all" style="width: 80%;">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Instruction_Type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Instruction_Count</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cycles_per_Instruction</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Integer_arithmetic</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">45,000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">data_transfer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">32,000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Floating_point</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">15,000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Control_transfer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
</tr>
</tbody>
</table>
<div class="ulist">
<ul>
<li>
<p>Determine the effective CPI, MIPS rate, and execution time for this program.</p>
</li>
<li>
<p>Desarrollo:</p>
<div class="ulist">
<ul>
<li>
<p>Reloj de la CPU</p>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/ditaa/svg/eNpTUICBEAVbBUP9NC4bXSzAjotLARVog8W1KRdFN7gGiaRIdLgYXEaC6DAPCmoYrI2asrWR0iJFolwApsyDIA==" alt="Diagram">
</div>
</div>
</li>
<li>
<p>T=1/f= 25ns: ciclo del reloj de la CPU: duración mínima de una microoperación.</p>
</li>
<li>
<p>CPI: ciclos por instrucción: valor medio = 1*(45/100)+2*(32/100)+2*(15/100)+2*(8/100)=0,45+0,64+0,30+0,16=1.55 cpi</p>
</li>
<li>
<p>MIPS: Millones de Inst. por seg: (1/CPI)(inst/ciclo)* F_clock(ciclos/seg)*10<sup>-6</sup>=(1/1.55)*40*10<sup>6</sup>*10<sup>-6</sup>=25.8 mips</p>
</li>
<li>
<p>T=(1/MIPS)(seg/millones de instr)*100.000*10<sup>-6</sup>=3.87ms</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_interconexión_cpu_memoria">10.1.2. Interconexión CPU-Memoria</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Consider a hypothetical microprocessor generating a 16-bit address (for example, assume
that the program counter and the address registers are 16 bits wide) and having
a 16-bit data bus.</p>
<div class="olist loweralpha">
<ol class="loweralpha">
<li>
<p>What is the maximum memory address space that the processor can access directly
if it is connected to a “16-bit memory”?</p>
</li>
<li>
<p>What is the maximum memory address space that the processor can access directly
if it is connected to an “8-bit memory”?</p>
</li>
<li>
<p>What architectural features will allow this microprocessor to access a separate
“I/O space”?
many 8-bit I/O ports can the microprocessor support? How many 16-bit I/O
ports? Explain.</p>
<div class="ulist">
<ul>
<li>
<p>Tener en cuenta que:</p>
<div class="ulist">
<ul>
<li>
<p>Espacio de  direcciones: conjunto de direcciones de un mismo bus de direcciones. La capacidad se expresa en BYTES.</p>
</li>
<li>
<p>El Espacio Memoria Principal y el Espacio Controlador E/S son espacios <strong>diferentes</strong>. Comparten el <strong>mismo bus de direcciones</strong> del bus del sistema pero hay una señal de control que activa la conexión con la memoria principal o con el controlador E/S.</p>
</li>
<li>
<p>"16 bit memory": 16 bits word size . Data bus de 16 bits</p>
</li>
<li>
<p>"8 bit memory": 8 bits word size . Data bus de 16 bits</p>
</li>
<li>
<p>I/O port number: numero de puertos del controlador E/S. Cada puerto para un periférico. Se diferencia el puerto de entrada del puerto de salida. 8 bit I/O port es un puerto con un data buffer de 8 bits y un 16 bit I/O port es un puerto con un data buffer de 16 bits.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Desarrollo:</p>
<div class="ulist">
<ul>
<li>
<p>Dibujar el esquema de buses que visualice:</p>
<div class="ulist">
<ul>
<li>
<p>las interconexiones entre periféricos, puertos, controlador E/S, memoria principal, CPU, buses indicando el modo de operación con cada uno de los buses.</p>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/ditaa/svg/eNrj4uKq4dLDAgEmDwLV" alt="Diagram">
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>a)2<sup>16</sup>Bytes. 64KB. En el bus de datos se transfieren datos de dos bytes.</p>
</li>
<li>
<p>b)2<sup>16</sup>Bytes. 64KB. En el bus de datos se transfieren datos de un byte.</p>
</li>
<li>
<p>c)En el bus del sistema hace falta una señal de control : señal I/O</p>
</li>
<li>
<p>d) 2<sup>8</sup>= Direccionamiento de 256 puertos de entrada y 256 puertos de salida en el controlador E/S independientemente del tamaño del buffer I/O si es de 8 bits o 16 bits.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>Consider a 32-bit microprocessor, with a 16-bit external data bus, driven by an  8-MHz input clock. Assume that this microprocessor has a bus cycle whose minimum duration equals four input clock cycles. What is the maximum data transfer rate across the bus that this microprocessor can sustain, in bytes/s? To increase its performance, would it be better to make its external data bus 32 bits or to double the external clock frequency supplied to the microprocessor? State any other assumptions you make, and explain. Hint: Determine the number of bytes that can be transferred per bus cycle.</p>
<div class="ulist">
<ul>
<li>
<p>Desarrollo:</p>
<div class="ulist">
<ul>
<li>
<p>32-bit CPU : tamaño de los registros internos de la CPU. Bus de datos local (interno) de la CPU</p>
</li>
<li>
<p>16-bit external data bus: bus de datos del sistema</p>
</li>
<li>
<p>CPU input clock: 8MHz</p>
</li>
<li>
<p>bus cycle: ciclo del bus del sistema: duración 4 veces el de la CPU : 2 MHz.</p>
</li>
<li>
<p>a) Data transfer rate: teóricamente número de datos en la secuencia continua de una transferencia cada <em>bus cycle</em> durante 1 segundo: 2MTransferencias/s. Cada transferencia el bus de datos transfiere 16 bits, es decir, 2 bytes = 2M/s*2B = 4MB/s</p>
</li>
<li>
<p>b) Doblar el ancho del bus de datos, dobla el ancho de banda &#8594; 8MB/s</p>
</li>
<li>
<p>c) Doblar la frecuencia de reloj reduce proporcionalmente el ciclo de bus y dobla el ancho de banda &#8594; 8MB/s</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Consider two microprocessors having 8- and 16-bit-wide external data buses, respectively. The two processors are identical otherwise and their bus cycles take just as long.</p>
<div class="olist loweralpha">
<ol class="loweralpha">
<li>
<p>Suppose all instructions and operands are two bytes long. By what factor do the
maximum data transfer rates differ?</p>
</li>
<li>
<p>Repeat assuming that half of the operands and instructions are one byte long.</p>
<div class="ulist">
<ul>
<li>
<p>Desarrollo:</p>
<div class="ulist">
<ul>
<li>
<p>a) CPU1 de 8 bits tiene un ancho de banda mitad (50%) respecto de CPU2 de 16 bits</p>
</li>
<li>
<p>b1) CPU1: 50% de 2 bytes a 2 ciclos de bus por cada 2 bytes y el otro 50% de 1 byte en 1 ciclo por byte =2ciclos*50%+1ciclo*50%=1.5ciclos</p>
</li>
<li>
<p>b2) CPU2: 50% de 2 bytes a 1 ciclo de bus por cada 2 bytes y el otro 50% de 1 byte a 1 ciclo de bus (unicamente se puede acceder a una instrucción o un dato en cada ciclo de bus)=1ciclo*50%+1ciclos*50%=0.5+0.5=1ciclos</p>
</li>
<li>
<p>b) según b1 y b2 la CPU1 tiene un ancho de banda 150% menor que la CPU2, es decir, el 66.6% del CPU2.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>A microprocessor has an increment memory direct instruction, which adds 1 to the value in a memory location. The instruction has five stages: fetch opcode (four bus clock cycles), fetch operand address (three cycles), fetch operand (three cycles), add 1 to operand (three cycles), and store operand (three cycles).</p>
<div class="olist loweralpha">
<ol class="loweralpha">
<li>
<p>By what amount (in percent) will the duration of the instruction increase if we
have to insert two bus wait states in each memory read and memory write
operation?</p>
</li>
<li>
<p>Repeat assuming that the increment operation takes 13 cycles instead of 3 cycles.</p>
<div class="ulist">
<ul>
<li>
<p>Desarrollo:</p>
<div class="ulist">
<ul>
<li>
<p>instruction cycle: 4+3+3+3+3= 16ciclos</p>
</li>
<li>
<p>a) accesos a memoria en las 3 etapas fetch y en la etapa store &#8594; incremento de 2*4 ciclos de espera &#8594; incremento de 8/16 &#8594; un incremento del 50%</p>
</li>
<li>
<p>b) instruction cycle:4+3+3+13+3= 26ciclos &#8594; incremento del ciclo de instruccion en un  8/26 &#8594; incremento en 34%</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>The Intel 8088 microprocessor has a read bus timing similar to that of Figure 3.19, but requires four processor clock cycles. The valid data is on the bus for an amount of time that extends into the fourth processor clock cycle. Assume a processor clock rate of 8 MHz.</p>
<div class="imageblock text-center">
<div class="content">
<img src="./images/ejercicios/memoria_rw_sync.png" alt="memoria rw sync">
</div>
<div class="title">Figure 70. Cronograma de una operación Read/Write de la Memoria Principal</div>
</div>
<div class="olist loweralpha">
<ol class="loweralpha">
<li>
<p>What is the maximum data transfer rate?</p>
</li>
<li>
<p>Repeat but assume the need to insert one wait state per byte transferred.</p>
<div class="ulist">
<ul>
<li>
<p>Desarrollo:</p>
<div class="ulist">
<ul>
<li>
<p>8088: bus data: 1 byte</p>
</li>
<li>
<p>read time : 4 cpu cycles</p>
</li>
<li>
<p>data valid: 1 processor clock cycle. El cuarto ciclo del read time.</p>
</li>
<li>
<p>cpu clock: 8MHz</p>
</li>
<li>
<p>a) 4 ciclos por transferencia. 8MHz/4ciclos = 2MT/s = 1 byte por transferencia &#8594; 2MB/s</p>
</li>
<li>
<p>b) cada transferencia está un ciclo sin transferir (4,1) &#8594; throughput = 4/5 del máximo &#8594; (4/5)*2MB/s&#8594;1.6MB/s</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>The Intel 8086 is a 16-bit processor similar in many ways to the 8-bit 8088. The 8086 uses a 16-bit bus that can transfer 2 bytes at a time, provided that the lower-order byte has an even address. However, the 8086 allows both even- and odd-aligned word operands. If an odd-aligned word is referenced, two memory cycles, each consisting of four bus cycles, are required to transfer the word. Consider an instruction
on the 8086 that involves two 16-bit operands. How long does it take to fetch the operands? Give the range of possible answers. Assume a clocking rate of 4 MHz and no wait states</p>
<div class="ulist">
<ul>
<li>
<p>Desarrollo:</p>
<div class="ulist">
<ul>
<li>
<p>8086: bus data: 2 bytes</p>
</li>
<li>
<p>intel : little endian: el LSB byte se guarda en la dirección menor y el MSB byte en la dirección superior.</p>
</li>
<li>
<p>alineación del dato par requiere 1 ciclo de memoria.</p>
</li>
<li>
<p>palabras con alineación impar requieren 2 ciclos de memoria. Cada ciclo de memoria son 4 ciclos de bus.</p>
</li>
<li>
<p>instrucción de 2 operandos de 2 bytes cada uno. CPU clock de 4MHz &#8594; 0.250 microsegundos &#8594; 250 ns</p>
</li>
<li>
<p>a) los dos operandos tienen alineación par</p>
<div class="ulist">
<ul>
<li>
<p>1 ciclo de memoria cada operando: 2 ciclos de memoria: 8 ciclos de bus &#8594; 2 microsegundos</p>
</li>
</ul>
</div>
</li>
<li>
<p>b) un operando tiene alineación par y el otro impar</p>
<div class="ulist">
<ul>
<li>
<p>1 ciclo de memoria el par y 2 ciclos el impar: 3 ciclos de memoria: 12 ciclos de bus &#8594; 3 microsegundos</p>
</li>
</ul>
</div>
</li>
<li>
<p>c) los dos operandos tienen alineación impar</p>
<div class="ulist">
<ul>
<li>
<p>2 ciclos cada operando: 4 ciclos de memoria: 16 ciclos de bus &#8594; 4 microsegundos.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Consider a 32-bit microprocessor whose bus cycle is the same duration as that of a 16-bit microprocessor. Assume that, on average, 20% of the operands and instructions are 32 bits long, 40% are 16 bits long, and 40% are only 8 bits long. Calculate the improvement achieved when fetching instructions and operands with the 32-bit microprocessor.</p>
<div class="ulist">
<ul>
<li>
<p>Desarrollo</p>
<div class="ulist">
<ul>
<li>
<p>En cada flanco positivo del ciclo de bus se realiza una transferencia entre memoria y CPU. La cpu de 16 bits realiza una transferencia de 2 bytes o menos y el de 32 bits una transferencia de 4 bytes o menos.</p>
</li>
<li>
<p>Media ciclos (CPU 16 bits)= 0.2x(2ciclos para las dos transferencias de 2 bytes cada una)+0.4x1+0.4x1=1.2 ciclos de media</p>
</li>
<li>
<p>Media ciclos (CPU 32 bits)= 0.2x1+0.4x1+0.4x1=1ciclo de media</p>
</li>
<li>
<p>Mejora de (1.2-1) sobre 1.2 = (1.2-1)/1.2=17%</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_representación_de_datos">10.2. Representación de Datos</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Representar el número decimal 1197 en las bases:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Hexadecimal</p>
<div class="listingblock">
<div class="content">
<pre>Divisiones sucesivas por 16
0x4AD</pre>
</div>
</div>
</li>
<li>
<p>octal:</p>
<div class="listingblock">
<div class="content">
<pre>Divisiones sucesivas por 8
0o2255</pre>
</div>
</div>
</li>
<li>
<p>binaria:</p>
<div class="listingblock">
<div class="content">
<pre>Divisiones sucesivas por 2
0b10010101101</pre>
</div>
</div>
</li>
<li>
<p>Representar el número 0x4AD en base binaria y base octal mediante una conversión directa, sin calcular su valor.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Representar el número -1197 en base binaria y hexadecimal y en formato:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Signo-magnitud:  0b110010101101 &#8594; 0xCAD</p>
</li>
<li>
<p>Complemento a 2: 0b101101010011 &#8594; 0xB53</p>
</li>
</ol>
</div>
</li>
<li>
<p>Calcular el rango de los números enteros de 8 bits en complemento a 2. (2<sup>7</sup>-1,-2<sup>7</sup>)</p>
</li>
<li>
<p>Utilizar notación hexadecimal:</p>
<div class="olist loweralpha">
<ol class="loweralpha">
<li>
<p>Representar el valor 23 en el formato BCD..</p>
<div class="ulist">
<ul>
<li>
<p>En el formato Binary Code Decimal (BCD) cada  dígito decimal se expande independientemente en su código binario de 4 bits</p>
</li>
<li>
<p>2&#8594;0010 ; 3&#8594;0011 ; 23 &#8594; 0010-0011</p>
</li>
</ul>
</div>
</li>
<li>
<p>The ASCII characters 23</p>
<div class="ulist">
<ul>
<li>
<p>0x32-0x33 &#8594; 0011-0010-0011-0011</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>Escribir el caracter a con acento (á) en el código universal UTF-8 (hexadecimal) y en el código Unicode.</p>
</li>
<li>
<p>For each of the following packed decimal numbers, show the decimal value</p>
<div class="olist loweralpha">
<ol class="loweralpha">
<li>
<p>0111 0011 0000 1001</p>
<div class="ulist">
<ul>
<li>
<p>7309</p>
</li>
</ul>
</div>
</li>
<li>
<p>0101 1000 0010</p>
<div class="ulist">
<ul>
<li>
<p>582</p>
</li>
</ul>
</div>
</li>
<li>
<p>0100 1010 0110</p>
<div class="ulist">
<ul>
<li>
<p>No es posible ya que 1010 corresponde al valor 10 que no tiene un digito decimal sino dos.</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>(NO hacer) Another representation of binary integers that is sometimes encountered is ones complement. Positive integers are represented in the same way as sign magnitude.A negative integer is represented by taking the Boolean complement of each bit of the corresponding positive number. Note: Ones complement arithmetic disappeared from hardware in the 1960s, but still survives checksum calculations for the Internet Protocol (IP) and the Transmission Control Protocol (TCP).</p>
<div class="olist loweralpha">
<ol class="loweralpha">
<li>
<p>Provide a definition of ones complement numbers using a weighted sum of bits.</p>
<div class="ulist">
<ul>
<li>
<p>Poner ejemplos de conversión con n=3 bits</p>
<div class="ulist">
<ul>
<li>
<p>000&#8594;111 (luego el cero tiene dos representaciones), <em>+1</em>: 001&#8594; <em>-1</em>:110, <em>+2</em>:010&#8594;'-2':101, <em>+1</em>:011&#8594;'-3':100</p>
</li>
</ul>
</div>
</li>
<li>
<p>positivos con n bits&#8594; \(\sum_{i=0}^{n-1}b_i 2^i\).</p>
</li>
<li>
<p>negativos con n bits</p>
<div class="ulist">
<ul>
<li>
<p>Tenemos en cuenta que complemento a dos = complemento_a_1 <em>+</em> 1</p>
</li>
<li>
<p>el complemento a dos con n bits de X se puede calcular como la resta binaria 2<sup>n</sup> (en binario) - X : por ejemplo con 3 bits el complemento a dos de <em>+1</em> es 1000-1=111</p>
</li>
<li>
<p>el complemento a 1 es el complemento a 2 menos 1 &#8594; 2<sup>n</sup> -X -1. Por ejemplo con 3 bits el complemento a uno de <em>+1</em> 1000-1-1 = 110</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>What is the range of numbers that can be represented in ones complement with n bits?</p>
<div class="ulist">
<ul>
<li>
<p>El máximo positivo &#8594; <em>011__1</em> :  2<sup>n</sup>-1</p>
</li>
<li>
<p>El máximo negativo &#8594; <em>100__0</em> : -(2<sup>n</sup>-1)</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>Representar 0.56789 en binario utilizando multiplicaciones sucesivas</p>
<div class="listingblock">
<div class="content">
<pre>0.56789 * 2 = 1.13578 = 1 + 0.13578 -&gt; 1, bit de la posición -1
0.13578 * 2 = 0.27156 -&gt; 0, bit de la posición -2
0.27156 * 2 = 0.54312 -&gt; 0, bit de la posición -3
0.54312 * 2 = 1.08624 = 1 + 0.08624 -&gt; 1, bit de la posición -4</pre>
</div>
</div>
</li>
<li>
<p>Representar 0.0625 en binario sin utilizar multiplicaciones sucesivas.</p>
<div class="ulist">
<ul>
<li>
<p>0.0625 = M*2<sup>E</sup> tal que E es un entero</p>
</li>
<li>
<p>log_dos(0.0625) =  log_dos(M)+E</p>
</li>
<li>
<p>-4 = log_dos(M)+E &#8594; E=-4 y log_dos(M)=0 &#8594; M=1</p>
</li>
</ul>
</div>
</li>
<li>
<p>Representar el número real 1234.56789 en base binaria:</p>
<div class="ulist">
<ul>
<li>
<p>En formato coma fija</p>
<div class="listingblock">
<div class="content">
<pre>Parte Entera: 1234 : 10011010010
Parte Fracción: 0.6789: 0.10010001011000010
Número 12345.6789: 10011010010.10010001011000010</pre>
</div>
</div>
</li>
<li>
<p>En notación científica: 1.001101001010010001011000010*2+10</p>
</li>
<li>
<p>En precisión simple punto flotante:</p>
<div class="listingblock">
<div class="content">
<pre>Campo signo: + : 0
Campo Exponente (8 bits): 10+127 = 137 = 10001001
Campo fracción mantisa (23 bits)= 00110100101001000101100</pre>
</div>
</div>
</li>
<li>
<p>En precisión doble punto flotante:</p>
<div class="listingblock">
<div class="content">
<pre>Campo signo: + : 0
Campo Exponente (11 bits): 10+1023 = 1033 = 10000001001
Campo fracción mantisa (52 bits) = 001101001010010001011000010__0</pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Codificar el número entero 3 en single precision FP</p>
<div class="ulist">
<ul>
<li>
<p>3 = 11 = 1.1 2<sup>1</sup></p>
<div class="ulist">
<ul>
<li>
<p>S=0, E=1+127=128, Mn=0.1</p>
</li>
<li>
<p>0-1000-0000-1000-0000-ceros</p>
</li>
<li>
<p>No es necesario redondear</p>
</li>
<li>
<p>Resultado= 0x40400000</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Representar el número natural 123456789 en precisión simple Punto Flotante (IEEE-754)</p>
<div class="ulist">
<ul>
<li>
<p>123456789 = 0x075BCD15 = 111-0101-1011-1100-1101-0001-0101 = 1.11010110111100110100010101*2<sup>+26</sup></p>
</li>
<li>
<p>Redondear= 1.11010110111100110100011*2<sup>+26</sup></p>
<div class="ulist">
<ul>
<li>
<p>Campo Signo= 0</p>
</li>
<li>
<p>Campo Exp= 26+127=153=10011001</p>
</li>
<li>
<p>Campo fracción Mantisa=0.11010110111100110100011</p>
</li>
<li>
<p>Resultado 0x4CEB79A3</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Float Point:</p>
<div class="olist loweralpha">
<ol class="loweralpha">
<li>
<p>Consider a fixed-point representation using decimal digits, in which the implied radix point can be in any position (e.g., to the right of the least significant digit, to the right of the most significant digit, and so on). How many decimal digits are needed to represent the approximations of both Planck’s (6.63 x 10<sup>-27</sup>) constant and Avogadro’s number (6.02 x 10<sup>23</sup>) The implied radix point must be in the same position for both numbers.</p>
<div class="ulist">
<ul>
<li>
<p>para el número de planck hace falta correr la coma 27 posiciones  a la izda más los dos digitos a la derecha (63)  &#8594; fracción de 27 dígitos</p>
</li>
<li>
<p>para el número de avogrado hace falta correr la coma 23 posiciones a la dcha más el dígito de la izda (7) &#8594; parte entera de 24 dígitos</p>
</li>
<li>
<p>para los dos 29+24=53 dígitos</p>
</li>
</ul>
</div>
</li>
<li>
<p>Now consider a decimal floating-point format with the exponent stored in a biased representation with a bias of 50. A normalized representation is assumed. How many decimal digits are needed to represent these constants in this floating point format?</p>
<div class="ulist">
<ul>
<li>
<p>planck &#8594; 0.63× 10<sup>-26</sup> &#8594; 0.63x 10<sup>-26+50</sup>&#8594; 0.63x 10<sup>+24</sup></p>
</li>
<li>
<p>avogrado &#8594;  0.602 x 10<sup>24</sup> &#8594; 0.602 x 10<sup>24+50</sup> &#8594; 0.602 x 10<sup>74</sup></p>
</li>
<li>
<p>para los dos hacen falta = 3 dígitos fraccíon y 2 dígitos para el exponente.</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>Any floating-point representation used in a computer can represent only certain real numbers exactly; all others must be approximated. If Ap is the stored value approximating the real value A, then the relative error, r, is expressed as r=(A-Ap)/A .Represent the decimal quantity <em>+0.4</em> in the following floating-point format: base=2 exponent: biased, 4 bits; significand, 7 bits.What is the relative error?</p>
<div class="ulist">
<ul>
<li>
<p>En binario coma fija</p>
<div class="ulist">
<ul>
<li>
<p>0.4x2=0.8 &#8594;0</p>
</li>
<li>
<p>0.8x2=1.6 &#8594;1</p>
</li>
<li>
<p>0.6x2=1.2 &#8594;1</p>
</li>
<li>
<p>0.2x2=0.4 &#8594;0</p>
</li>
<li>
<p>0.4x2 &#8594; otra vez 0110, luego es un número periódico &#8594; 0.0110-0110-0110-período</p>
</li>
<li>
<p>normalizado 1.10-0110-0110-etc x 2<sup>-1</sup> &#8594; se representa la fracción 10-0110-0110-</p>
</li>
<li>
<p>con fracción de 7 bits 1001100</p>
</li>
<li>
<p>Valor del número  aproximado 1.1001100 x 2<sup>-1</sup> = 110011 x 2<sup>-6</sup> = (32+16+2+1)x2<sup>-6</sup>=51/64=.796875</p>
</li>
<li>
<p>Error=(0.8-0.796875)/0.8=.003906250=0.4%</p>
</li>
<li>
<p>En exceso de 4 bits. Con el número excedido el rango es (0,15). El exceso es la mitad de combinaciones -1=16/2-1=7, luego se pueden representar los exponentes (-7,8).</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Representar el número Pi en coma flotante IEEE de simple y doble precisión</p>
<div class="ulist">
<ul>
<li>
<p>SOLUCION:</p>
</li>
<li>
<p>Formato decimal:  3.1415926535897932384626433832795028841968</p>
</li>
<li>
<p>Binario Coma fija : 11.001001000011111101101010100010001000010110100011000010001101001100010011000110011000101000101110000000110111</p>
</li>
<li>
<p>Hexadecimal Coma fija:   0011.0010-0100-0011-1111-0110-1010-1000-1000-1000-0101-1010-0011-0000-1000-1101-0011-0001-0011-0001-1001-1000-1010-0010-1110-0000-0011-0111</p>
<div class="ulist">
<ul>
<li>
<p>3.243F6A8885A308D313198A2E03E</p>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/ditaa/svg/eNqVjzEOgkAURHtO8UrNZhNYCi1stdPGE3yXTdwEFgMUFnslC-MRuJhALMDY-LqZ-fmZgYyJ7cV3LQtM_u3ttKaTSvpnjQuMcYLSSs9ZqpmfEM8R9vcbisxsIHJoxFrfvwJHCZ1vBU51U8W_3uYZeTqrjTH8Iv1M6B-h8NZRuHLcwCpFKGXQjbNXWSfTtRoqvgHF-T_n" alt="IEEE-754 precisión simple (32 bits)">
</div>
<div class="title">Figure 71. IEEE-754 precisión simple (32 bits)</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>v = s × 2^e × m</p>
<div class="ulist">
<ul>
<li>
<p>Notación científica con la mantisa normalizada y su parte fracción  truncada a 23 bits y redondeada:</p>
</li>
<li>
<p><em>+ (1 + 0.10010010000111111011011) * 2<sup>+1</sup></em></p>
</li>
</ul>
</div>
</li>
<li>
<p>Campos:</p>
<div class="ulist">
<ul>
<li>
<p>Signo : positivo --&#8594;  0  --&#8594; 1 bit</p>
</li>
<li>
<p>Exponente:+1</p>
</li>
<li>
<p>Exponente desplazado <em>+ 127 = +1+127 = 128 &#8594; 10000000 &#8594; 8 bits</em></p>
</li>
<li>
<p>Mantisa normalizada:1 <em>+</em> 0.10010010000111111011011</p>
<div class="ulist">
<ul>
<li>
<p>Fracción de la mantisa normalizada: 10010010000111111011011 &#8594; 23 bits</p>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/ditaa/svg/eNpT0NbV1oUBBAsNaHMp1BjUGBpAgEKNApAJQUACDAzAqIZLgVjzjA0VjA0UgMDIGEQYKWABBgDzBRtp" alt="Formato IEEE-754  precisión simple">
</div>
<div class="title">Figure 72. Formato IEEE-754  precisión simple</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Resultado= 0x40490fdb</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_operaciones_aritméticas_2">10.3. Operaciones Aritméticas</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Sumar en binario puro</p>
<div class="ulist">
<ul>
<li>
<p>10011011+00011011  SOLUCION: = 10110110</p>
</li>
<li>
<p>0x3A1F+0xF4E1  SOLUCION: = 0x12f00</p>
</li>
<li>
<p>10011011+10011011  SOLUCION: = 100110110</p>
</li>
</ul>
</div>
</li>
<li>
<p>Sumar en complemento a 2 : 50+23</p>
<div class="ulist">
<ul>
<li>
<p>Realizar las operaciones en código binario  SOLUCION: = 0110010+0010111 = 01001001</p>
</li>
<li>
<p>Realizar las operaciones en código hexadecimal  SOLUCION: = 0x32+0x17 = 0x49</p>
</li>
</ul>
</div>
</li>
<li>
<p>Representar el valor -66 en complemento a 2</p>
<div class="ulist">
<ul>
<li>
<p>SOLUCION: <em>+66</em> = 01000010 &#8594; -66 = 10111101+1 = 10111110</p>
</li>
</ul>
</div>
</li>
<li>
<p>Resta en complemento a 2 : 33-66</p>
<div class="ulist">
<ul>
<li>
<p>Realizar las operaciones en código binario:  SOLUCION: 0100001+10111110=1011111</p>
</li>
<li>
<p>Realizar las operaciones en código hexadecimal:  SOLUCION: 0x21+0xBE=0xDF</p>
</li>
</ul>
</div>
</li>
<li>
<p>Representar en hexadecimal el mayor número en módulo que se puede representar en complemento a 2 con 16 bits</p>
<div class="ulist">
<ul>
<li>
<p>SOLUCION: 1000-0000-0000-0000 = 0x8000</p>
</li>
</ul>
</div>
</li>
<li>
<p>Sumar en complemento a 2 con 16 bits 0x8000+0x8000</p>
<div class="ulist">
<ul>
<li>
<p>SOLUCION: 0x8000+0x8000=0x0000</p>
</li>
</ul>
</div>
</li>
<li>
<p>Restar en binario puro 0110010 - 0010111</p>
<div class="ulist">
<ul>
<li>
<p>SOLUCION:</p>
<div class="listingblock">
<div class="content">
<pre>  0110010  &lt;- minuendo
  0010111  &lt;- sustraendo
    1111   &lt;- llevadas
  *******
  0011011</pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Restar en hexadecimal 0x32-0x17</p>
<div class="listingblock">
<div class="content">
<pre>   0x32  &lt;- minuendo
   0x17  &lt;- sustraendo
     1   &lt;- llevadas
  *****
   0x1B</pre>
</div>
</div>
</li>
<li>
<p>Multiplicación</p>
<div class="ulist">
<ul>
<li>
<p>¿A qué equivale en base binaria multiplicar por una potencia de 2 positiva 2<sup>n</sup>? :</p>
<div class="ulist">
<ul>
<li>
<p>SOLUCION:</p>
</li>
<li>
<p>en un número real mover la coma n posiciones hacia la dcha</p>
</li>
<li>
<p>en un número entero añadir n ceros a la dcha</p>
</li>
<li>
<p>en un registro es desplazar los bits n posiciones hacia la izda e introducir n ceros por la dcha</p>
</li>
</ul>
</div>
</li>
<li>
<p>¿A qué equivale en base binaria multiplicar por una potencia de 2 negativa 2<sup>-n</sup>? :</p>
<div class="ulist">
<ul>
<li>
<p>SOLUCION:</p>
</li>
<li>
<p>en un número real mover la coma n posiciones hacia la izda</p>
</li>
<li>
<p>en un número entero añadir n ceros a la izda</p>
</li>
<li>
<p>en un registro es desplazar los bits n posiciones hacia la dcha e introducir n ceros por la izda</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Realizar la multiplicación de los siguientes números naturales:</p>
<div class="ulist">
<ul>
<li>
<p>1010*1010</p>
</li>
<li>
<p>1010*1111</p>
</li>
<li>
<p>SOLUCION:</p>
<div class="listingblock">
<div class="content">
<pre>                1010            1010
              x 1010          x 1111
            ********        ********
                0000            1010
               1010            1010
              0000            1010
             1010            1010
            ********        ********
             1100100        10010110</pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_operaciones_lógicas">10.4. Operaciones Lógicas</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Realizar las operaciones lógicas &#195;, &#195;+1, A+B, A&#183;B, A&#8853;B siendo A=10101010 y B=11110000</p>
<div class="ulist">
<ul>
<li>
<p>SOLUCION:</p>
</li>
<li>
<p>A+B &#8594; A|B &#8594; AVB</p>
</li>
<li>
<p>A&#183;B  &#8594;  A&amp;B &#8594; A&#8743;B</p>
</li>
<li>
<p>&#195;        = 01010101</p>
</li>
<li>
<p>&#195;+1      = 01010110</p>
</li>
<li>
<p>A+B           = 11111010</p>
</li>
<li>
<p>A&#183;B      = 10100000</p>
</li>
<li>
<p>A&#8853;B     = 01011010</p>
</li>
</ul>
</div>
</li>
<li>
<p>Dado un operando de 20 bits, indicar la operación lógica a realizar para: (expresar la operación con los operandos en código hexadecimal)</p>
<div class="ulist">
<ul>
<li>
<p>Set el bit 7 (posición 7ª)</p>
<div class="ulist">
<ul>
<li>
<p>SOLUCION: 20 bits son 5 dígitos hex &#8594; Operando | 0x00080</p>
</li>
</ul>
</div>
</li>
<li>
<p>Clear el bit 15</p>
<div class="ulist">
<ul>
<li>
<p>SOLUCION: Operando &amp; 0xF7FFF</p>
</li>
</ul>
</div>
</li>
<li>
<p>Toogle el bit 19</p>
<div class="ulist">
<ul>
<li>
<p>SOLUCION:Operando &#8853; 0x8000</p>
</li>
</ul>
</div>
</li>
<li>
<p>Set toda la palabra</p>
<div class="ulist">
<ul>
<li>
<p>SOLUCION: Operando | 0xFFFF</p>
</li>
</ul>
</div>
</li>
<li>
<p>Clear toda la palabra</p>
<div class="ulist">
<ul>
<li>
<p>SOLUCION:Operando &#8853; Operando ó Operando &amp; 0x00000</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Dadas las operaciones lógicas SAR X,n (shift arithmetic right X, n), SLR X,n (shift logic right X,n) , SAL X,n (shift arithmetic left X, n) y SLL X,n (shift logic left X, n) donde X es el operando, xxR significa derecha, xxL significa izquierda y n es el número de posiciones a desplazar. Realizar las siguientes operaciones con el operando A=10101010: SAR A,4, SLR A,4, SAL A, 4 y SLL A,4 de forma manual,  mediante un programa en lenguaje C y también mediante el depurador GDB.</p>
<div class="ulist">
<ul>
<li>
<p>SAR A,4 = 11111010</p>
</li>
<li>
<p>SLR A,4 = 00001010</p>
</li>
<li>
<p>SAL A,4 = 10101111</p>
</li>
<li>
<p>SLL A,4 = 10100000</p>
</li>
</ul>
</div>
</li>
<li>
<p>Realizar manualmente la multiplicación A&#183;2<sup>2</sup> y A&#183;2<sup>-2</sup> donde A=10101010 primero aritméticamente y después mediante operaciones lógicas.</p>
<div class="ulist">
<ul>
<li>
<p>A&#183;2<sup>2</sup>  = 1010101000</p>
</li>
<li>
<p>A&#183;2<sup>-2</sup> = 101010.10</p>
</li>
<li>
<p>Con operaciones lógicas la operación A&#183;2<sup>2</sup></p>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>Doblar el tamaño de A &#8594; D:A &#8592; 0000000001010101</p>
</li>
<li>
<p>desplazar SLL D:A,2  &#8594; D:A &#8592; 0000000101010100</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_representación_de_las_instrucciones_2">10.5. Representación de las Instrucciones</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Sea un computador con palabras de 32 bits. La CPU tiene 64 instrucciones diferentes (operaciones) de un operando, 32 registros de propósito general de 32 bits y posibilidad de direccionamiento directo a registro (el campo de operando es directamente el registro) o indirecto con desplazamiento a registro-base. a)Diseñar el formato de instrucción para este computador. Se debe especificar un registro para las direcciones de memoria  y un valor del desplazamiento, además del modo de direccionamiento y código de operación. b)¿Cuál es el máximo valor del desplazamiento (el desplaz. es un número en C2)?</p>
<div class="ulist">
<ul>
<li>
<p>SOLUCION</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Formato</p>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>Palabra de 32 bits &#8594; Registros de propósito general de 32 bits y Registro de Instrucción IR de 32 bits</p>
</div>
<div class="paragraph">
<p>Formato de instrucciones con una estructura en 4 campos: código de operación, modo de direccionamiento,
campo de operando (registro o registro con desplazamiento)</p>
</div>
<div class="paragraph">
<p>1º Campo: código de operación: 64 instrucciones : 2<sup>6</sup>  &#8594; 6 bits</p>
</div>
<div class="paragraph">
<p>2º Campo: modo de direccionamiento: 2 tipos: 2<sup>1</sup>        &#8594; 1 bit</p>
</div>
<div class="paragraph">
<p>3º Campo: registro: 32 registros: 2<sup>5</sup>                   &#8594; 5 bits</p>
</div>
<div class="paragraph">
<p>4º Campo: Desplazamiento nº entero: (32-(6+1+5))bits	&#8594; 20 bits</p>
</div>
</div>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/ditaa/svg/eNrT1oUDbV0sQJurRsE5P0VPwb9AT6HGvyC1KDEvJV9BIyg1PbO4pChfU6GGS5ugGVwE1RCQId5BCk6JxamaWGVcUosLchKrEnMzU_NKiHI5Ca4CAOcfSxw=" alt="Diagram">
</div>
</div>
</li>
<li>
<p>Desplazamiento de 20 bits</p>
<div class="ulist">
<ul>
<li>
<p>En complemento a 2: El valor Positivo máximo 0111-1111-1111-1111-1111 de valor <em>2<sup>19</sup>-1</em> y el valor Negativo mínimo 1000-0000-0000-0000-0000 que cambiado de signo es el 0-1000-0000-0000-0000-0000 de valor <em>+2<sup>19</sup></em>, por lo que el rango es [<em>+2<sup>19</sup>-1</em>,<em>-2<sup>19</sup></em>] &#8594; [+524287,-524288]</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Un computador con palabras de 24 bits posee 16 instrucciones diferentes de un operando, 8 registros  de propósito general, y 3 modos de direccionamiento (directo a registro, indirecto con registro e indirecto con desplazamiento a registro-base)</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Diseñar un formato de instrucción para este computador. Debe especificar el código de operación, el modo de direccionamiento, un registro y un desplazamiento.</p>
<div class="ulist">
<ul>
<li>
<p>SOLUCION:</p>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>Word Size = 24 &#8594; Registros de Propósito general de 24 bits y el registro de instrucción IR también de 24 bits</p>
</div>
<div class="paragraph">
<p>4 campos en el formato de instruccioń:</p>
</div>
<div class="paragraph">
<p>+</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/ditaa/svg/eNrj0taFAyQmGsCjSJurRsE5P0VPwb9AT6HGNz8lXyElVSElsyg1OTkzPy8xNzM1ryRfoUYhKDU9s7ikCMR0SS0uyEmsgsrVcFHuBgAUwS6w" alt="Diagram">
</div>
</div>
<div class="paragraph">
<p>1º Campo: código de operación: 16 instrucciones : 2<sup>4</sup>  &#8594; 4 bits</p>
</div>
<div class="paragraph">
<p>2º Campo: modo de direccionamiento: 3 tipos: 2<sup>2</sup>	&#8594; 2 bit para 3 tipos (Directo Reg, Indirecto Reg e Indirecto RegyDesp)</p>
</div>
<div class="paragraph">
<p>3º Campo: registro: 8 registros: 2<sup>3</sup>			&#8594; 3 bits</p>
</div>
<div class="paragraph">
<p>4º Campo: Desplazamiento nº entero: (24-(4+2+3))bits	&#8594; 15 bits</p>
</div>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>¿Cuál es el rango de valores del desplazamiento en magnitud?, ¿y en C2?</p>
<div class="ulist">
<ul>
<li>
<p>Formato Magnitud: Mínimo el cero y el máximo 111-1111-1111-1111 = 2<sup>15</sup>-1 = 32768</p>
</li>
<li>
<p>Complemento a 2: Positivo máximo 0111-1111-1111-1111-1111 de valor <em>2<sup>14</sup>-1</em> y Negativo mínimo 100-0000-0000-0000  que cambiado de signo es el 0100-0000-0000-0000 de valor <em>+2<sup>14</sup></em>, por lo que el rango es [<em>+2<sup>14</sup>-1</em>,<em>-2<sup>14</sup></em>] &#8594; [+16383,-16384]</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>Un computador tiene un formato de instrucción de 11 bits donde el campo de operando es de 4 bits. ¿Es posible codificar en este formato 5 instrucciones de dos operandos, 45 de un operando y 48 sin operando?. Justificar la respuesta.</p>
<div class="ulist">
<ul>
<li>
<p>SOLUCION</p>
</li>
<li>
<p>3 tipos de formatos</p>
<div class="ulist">
<ul>
<li>
<p>Tipo 1: campo tipo - Cod. Op. - Op1 - Op2</p>
<div class="ulist">
<ul>
<li>
<p>2 bits - x bits - 4 bits - 4 bits &#8594; x=11-(2+4+4)= 1 bit &#8594; Máximo de 2 instrucciones &lt; 5 instrucciones &#8594; No es posible</p>
</li>
</ul>
</div>
</li>
<li>
<p>Tipo 2: campo tipo - Cod. Op. - Op</p>
<div class="ulist">
<ul>
<li>
<p>2 bits - y bits - 4 bits  &#8594; y=11-(2+4)= 5 bits &#8594; Máximo de 32 instrucciones &lt; 45 instrucciones &#8594; No es posible</p>
</li>
</ul>
</div>
</li>
<li>
<p>Tipo 3: campo tipo - Cod. Op.</p>
<div class="ulist">
<ul>
<li>
<p>2 bits - z bits   &#8594; 48 instrucciones</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Alternativa: 3 Registros IR , uno para cada tipo</p>
<div class="ulist">
<ul>
<li>
<p>Sin campo de tipo : 5+45+48=98 instrucciones &#8594; 2<sup>7</sup> &#8594; 7 bits &#8594; la instrucción tipo 1 ocuparía 7+4+4=15 bits &gt; 11 &#8594; No es posible</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Un computador de 16 bits de ancho de palabra (instrucciones, palabra de memoria, registros) y 8 registros, tiene el siguiente repertorio de instrucciones:</p>
<div class="ulist">
<ul>
<li>
<p>14 instrucciones de referencia de un solo operando en memoria, con direccionamiento directo e indirecto de memoria</p>
</li>
<li>
<p>31 instrucciones con dos operandos con los modos de direccionamiento directo e indirecto de registro.</p>
</li>
<li>
<p>32 instrucciones sin operando explícito.</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Especificar la codificación de las instrucciones.</p>
</li>
<li>
<p>Especificar la zona de memoria alcanzable en cada tipo de direccionamiento y rango posible de valores de los operandos (en C’2).</p>
</li>
</ol>
</div>
</li>
<li>
<p>SOLUCION</p>
<div class="ulist">
<ul>
<li>
<p>Word Size = 16 &#8594; Registros de Propósito general de 16 bits</p>
</li>
<li>
<p>Repertorio con 3 tipos de formatos</p>
</li>
<li>
<p>1º Tipo: Tipo-Cod.Op.-Modo Direc-Op1 &#8594; 14 instrucciones (2<sup>4</sup>), Bits:2-4-1-x &#8594; x=16-(2+4+1)=9bits</p>
</li>
<li>
<p>2º Tipo: Tipo-Cod.Op.-Modo Direc1-Op1-Modo Direc2-Op2 &#8594; 31 instrucciones (2<sup>5</sup>) Bits:2-5-1-x-1-x &#8594; x=(16-(2+5+2))/2=3bits</p>
</li>
<li>
<p>3º Tipo: Tipo-Cod.Op. &#8594; 32 instrucciones (2<sup>5</sup>) Bits:2-5 &#8594; 7 bits ocupados de los 16.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Un computador basado en el  procesador de Motorola M68000 presenta los siguientes contenidos en registro y memoria:</p>
<table class="tableblock frame-all grid-all" style="width: 50%;">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">REGISTROS</th>
<th class="tableblock halign-center valign-top"></th>
<th class="tableblock halign-center valign-top">MEMORIA</th>
<th class="tableblock halign-center valign-top"></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">Registro</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Contenido</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Dirección</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Contenido</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">A1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">100</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">99</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">104</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">A2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">100</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">108</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">101</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">106</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">102</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">107</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">&#8230;&#8203;</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">&#8230;&#8203;</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">&#8230;&#8203;</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">&#8230;&#8203;</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">199</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">100</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">34</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">201</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">96</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">202</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">201</p></td>
</tr>
</tbody>
</table>
<div class="ulist">
<ul>
<li>
<p>Si el contenido del desplazamiento de la instrucción en ejecución es desp=99 ¿Cuál seria el valor del operando (de tamaño byte) con los siguientes modos de direccionamientos?.</p>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>Directo de memoria o absoluto (dirección = desplazamiento).</p>
</li>
<li>
<p>Directo de registro con A1.</p>
</li>
<li>
<p>Indirecto de registro con A1.</p>
</li>
<li>
<p>Indirecto con desplazamiento con registro base A1</p>
</li>
<li>
<p>Indirecto con desplazamiento con registro base A2.</p>
</li>
<li>
<p>Indirecto con desplazamiento con registro base A1 e indexado con A2.</p>
</li>
<li>
<p>Indirecto de registro con predecremento con A1.</p>
</li>
</ol>
</div>
</li>
<li>
<p>SOLUCION:</p>
<div class="listingblock">
<div class="content">
<pre>Directo de memoria o absoluto (dirección = desplazamiento) -&gt; M[99]=104
NOTA: El linker resuelve la dirección absoluta del operando especificando un desplazamiento respecto de un registro que apunta al inicio del segmento o sección de instrucciones. De esta forma el campo de operando es más corto que poniendo la dirección absoluta.

Directo de registro con A1. -&gt; R[A1]=100
Indirecto de registro con A1. -&gt; M[A1]=M[100]=108
Indirecto con desplazamiento con registro base A1 -&gt; M[A1+99]=M[199]=100
Indirecto con desplazamiento con registro base A2.-&gt; M[A2+99]=M[101]=106
Indirecto con desplazamiento con registro base A1 e indexado con A2.-&gt; M[A1+99+A2]=M[100+99+2]=M[201]=96
Indirecto de registro con predecremento con A1.-&gt; M[A1-1]=M[100-1]=104</pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Un computador presenta los siguientes contenidos de los registros y  la memoria:</p>
<table class="tableblock frame-all grid-all" style="width: 50%;">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">REGISTROS</th>
<th class="tableblock halign-center valign-top"></th>
<th class="tableblock halign-center valign-top">MEMORIA</th>
<th class="tableblock halign-center valign-top"></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">Registro</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Contenido</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Dirección</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Contenido</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">R1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">99</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">96</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">100</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">R2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">6</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">97</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">102</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">98</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">101</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">99</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">104</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">100</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">108</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">101</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">106</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">102</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">107</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">103</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">109</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">104</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">110</p></td>
</tr>
</tbody>
</table>
<div class="ulist">
<ul>
<li>
<p>Si el contenido del desplazamiento de la instrucción en ejecución es 96 ¿Cuál seria el valor del operando con los siguientes direccionamientos?.</p>
<div class="literalblock">
<div class="content">
<pre>a)Directo de memoria (dir = desp).
b)Indirecto de memoria (dir memoria = desp).
c)Directo de registro con R1.
d)Indirecto de registro con R1.
e)Indirecto con desplazamiento con registro base R2</pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Se tiene un computador con un ancho de palabra de 32 bits y con un banco de registros de 32 registros de 32 bits. El computador tiene 64 instrucciones diferentes y los siguientes modos de direccionamiento: directo de memoria, indirecto de memoria e indirecto con desplazamiento a registro-base.</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Diseñar los dos formatos de las instrucciones de dos operandos sabiendo que siempre un operando está en memoria y otro en registro.</p>
<div class="ulist">
<ul>
<li>
<p>SOLUCION:</p>
<div class="ulist">
<ul>
<li>
<p>CodOp/Modo/Memoria_fuente/Registro_destino</p>
<div class="ulist">
<ul>
<li>
<p>CodOp=2<sup>6</sup>=64 instrucciones</p>
</li>
<li>
<p>Modo: directo o indirecto:2<sup>1</sup></p>
</li>
<li>
<p>Memoria=x bits de direcciones</p>
</li>
<li>
<p>Reg=2<sup>5</sup>=32 registros &#8594; 5 bits</p>
</li>
<li>
<p>Total IR =32 bits &#8594; Memoria=32-(6+1+5)=32-12=20 bits</p>
</li>
</ul>
</div>
</li>
<li>
<p>CodOp/Desplazamiento-Registro_fuente/Registro_destino</p>
<div class="ulist">
<ul>
<li>
<p>CodOp=2<sup>6</sup>=64 instrucciones</p>
</li>
<li>
<p>Desplazamiento= x bits de direcciones</p>
</li>
<li>
<p>Reg_base=2<sup>5</sup>=32 registros &#8594; 5 bits</p>
</li>
<li>
<p>Registro=2<sup>5</sup>=32 registros &#8594; 5 bits</p>
</li>
<li>
<p>Total=32 bits &#8594; Desplazamiento=32-(6+5+5)=16 bits</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Si cada dirección de memoria especifica un byte ¿qué zona de memoria se puede acceder con cada uno de los modos de direccionamiento?</p>
<div class="ulist">
<ul>
<li>
<p>SOLUCION</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>Consideremos cuatro arquitectura de procesador: acumulador, pila, memoria-memoria y registro-registro con 16 registros. Para las cuatro arquitectura se tienen los siguientes datos comunes:</p>
<div class="ulist">
<ul>
<li>
<p>El código de operación es siempre 1 byte</p>
</li>
<li>
<p>Todas las direcciones de memoria son 2 bytes</p>
</li>
<li>
<p>Todos los datos son 4 bytes</p>
</li>
<li>
<p>Todas las instrucciones tienen una longitud igual a un numero entero de bytes</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Escribir de forma genérica los programas en lenguaje ensamblador de cada una de las arquitecturas para realizar la siguiente operación; A=B+C. Para cada programa, calcular el tráfico con  memoria  y  el  tamaño  del  código. ¿Cuál es mas eficiente?.</p>
</li>
<li>
<p>Escribir los cuatro programas ensamblador  para  la  siguiente  secuencia de operaciones A=B+C ; B=A+C ; D=A-B Calcular el   trafico con memoria y el tamaño del código. ¿Cuál es más eficiente?.</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Considerando que en un procesador cada  búsqueda de instrucción y cada acceso a un  operando consumen un ciclo y teniendo en  cuenta para 3 programas los siguientes datos en millones de  referencias.</p>
<table class="tableblock frame-all grid-all" style="width: 50%;">
<colgroup>
<col style="width: 50%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6668%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top"></th>
<th class="tableblock halign-center valign-top">TEX</th>
<th class="tableblock halign-center valign-top">Spice</th>
<th class="tableblock halign-center valign-top">C</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">Arquitectura R-R</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">Referencias de datos</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">5.4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4.9</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1.4</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">Palabras de instr.</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">14</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">18.9</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3.9</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">Arquitectura M-M</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">Referencias a datos</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">12.4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">10.5</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4.1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">Palabras de instr</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7.5</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">8.4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2.4</p></td>
</tr>
</tbody>
</table>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Calcular el porcentajes de accesos a  memoria que se realizan para buscar  instrucciones de los tres programas para  la arquitectura R-R y para la arquitectura  M-M.</p>
</li>
<li>
<p>¿Cuál es la relación de accesos totales  entre ambas arquitecturas?</p>
</li>
</ol>
</div>
</li>
<li>
<p>Para la arquitectura M68000 de Motorola de 32 bits, mostrar el contenido de todos los registros y  posiciones de memoria afectadas (sin incluir  el PC) por la  ejecución de cada una de las  instrucciones, suponiendo que partimos  siempre de las condiciones iniciales  siguientes:</p>
<table class="tableblock frame-all grid-all" style="width: 50%;">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Instrucciones:</th>
<th class="tableblock halign-center valign-top"></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">a. CLR.L</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">-(A1)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">b.  CLR.W</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">D2</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">c.  MOVE.W</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">$1204,D1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">d.  MOVE.W</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">#$1204,D1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">e.  MOVE.B</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">(A2)+,$1200</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">f.  MOVE.L</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">D1,-(A2)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">g.  MOVE.L</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">(A1)+,D2</p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all" style="width: 50%;">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Condiciones iniciales:</th>
<th class="tableblock halign-center valign-top"></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">REGISTROS</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">MEMORIA</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">A1:00001202</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0011FE:7777</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">A2:00001204</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">001200:1111</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">D1:01020304</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">001202:2222</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">D2:F0F1F2F3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">001204:3388</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">001206:4444</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">001208:5555</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">00120A:6666</p></td>
</tr>
</tbody>
</table>
<div class="ulist">
<ul>
<li>
<p>Sufijos &#8594; Long=4 bytes, Word=2Bytes, Byte=1Byte</p>
</li>
<li>
<p>El incremento o decremento de la dirección efectiva se escala con el tamaño del operando</p>
</li>
<li>
<p>SOLUCION</p>
<div class="listingblock">
<div class="content">
<pre>CLR.L -(A1) :
	Clear operando long
	Predecremento del registro A1 seguido de indirección
	A1&lt;-A1-4 ;(A1-4=0x1202-0x4=0x11FE) A1:000011FE
        M[A1]&lt;-0,M[A1+1]&lt;-0,M[A1+2]&lt;-0,M[A1+3]&lt;-0  M[0011FE]:0000 M[001200]:0000
CLR.W D2 :
	Clear operando Word
	D2(15:0)&lt;-0 ; D2:F0F10000
MOVE.W  $1204,D1
	Copiar 2bytes de Op_fuente (Dir. Directo) en Op_destino (Registro)
	D1(15:0)&lt;-M[0x1204] ;(M[0x1204]=3388); D1:01023388
MOVE.W  #$1204,D1
	Copiar 2bytes de Op_fuente (Dir. Inmediato) en Op_destino (Registro)
	D1(15:0)&lt;-0x1204 ; (D1:01021204)
MOVE.B  (A2)+,$1200
	Copiar 1byte Op_fuente (indirecto con postincremento), Op_destino (Directo)
        0x1200&lt;-M[A2][LSB] ;(M[A2][LSB]=M[A2+1]=M[1205]=88) ; M[1200]:1188
        A2&lt;-A2+1 ;(A2+1=0x1204+0x1=0x1205) ; A2:00001205
MOVE.L  D1,-(A2)
        Copiar 4bytes Op_fuente(Registro) a Op_destino(indirecto con predecremento)
	A2&lt;-A2-4 ;(A2-4=0x1204-0x4=0x1200) A2:00001200
        M[A2+3]&lt;-D1(7:0),M[A2+2]&lt;-D1(15:8),M[A2+1]&lt;-D1(23:16),M[A2]&lt;-D1(31:24)  ; M[001200]:01020304
MOVE.L  (A1)+,D2
        Copiar 4bytes Op_fuente(Indirecto con postincremento) a Op_destino(Registro)
        D2(7:0)&lt;-M[A1+3] ; D2(15:8)&lt;-M[A1+2]; D2(23:16)&lt;-M[A1+1]; D2(31:24)&lt;-M[A1] ; D2:11112222
	A1&lt;-A1+4; (A1=0x1202+0x4=0x1206) A1:00001206</pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Mostrar el contenido de todos los registros  y posiciones de memoria afectadas (sin  incluir el PC) por la ejecución de cada una  de las instrucciones, suponiendo que  partimos siempre de las condiciones iniciales  especificadas:</p>
<table class="tableblock frame-all grid-all" style="width: 70%;">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Instrucciones:</th>
<th class="tableblock halign-center valign-top">a. MOVE.W -(A1),A3</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">b. CLR.B  -11(A2)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">c. MOVE.W  (A4)+,-100(A1,D5.W)</p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all" style="width: 50%;">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Condiciones iniciales:</th>
<th class="tableblock halign-center valign-top"></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">REGISTROS</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">MEMORIA</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">A1:00001504</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">001500:1234</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">A2:00001510</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">001502:5678</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">A3:11122233</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">001504:9ABC</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">A4:00001506</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">001506:EF11</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">D5:FA000064</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">001508:2233</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">00150A:4455</p></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Para la arquitectura M68000-32 de Motorola, suponiendo que se dan las siguientes  condiciones iniciales, mostrar el contenido  de todos los registros y posiciones de  memoria afectadas (incluyendo el PC) por la ejecución de cada una de las instrucciones.  Suponer, además, que las instrucciones  están en posiciones consecutivas de  memoria, a partir de la dirección $2000, y que se ejecutan en secuencia.</p>
<table class="tableblock frame-all grid-all" style="width: 50%;">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Condiciones iniciales:</th>
<th class="tableblock halign-center valign-top"></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">REGISTROS</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">MEMORIA</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">A1:00001504</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">001500:1234</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">A2:00001510</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">001502:5678</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">A4:00001506</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">001504:9ABC</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">D3:11122233</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">001506:EF11</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">D5:FA000070</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">001508:2233</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">D6:AB00FF9B</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">00150A:4455</p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all" style="width: 70%;">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Instrucciones:</th>
<th class="tableblock halign-center valign-top">CLR.B  -(A4)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">MOVE.L  -124(A2, D5.W), -(A1)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">MOVE.W  $64(A4,D6.W), D3</p></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Comparar los computadores de 1, 2 y 3 direcciones escribiendo los programas para calcular la expresión X= (A+B*C)/(D-E*F) siendo los repertorios de cada uno de ellos los siguientes:</p>
<div class="listingblock">
<div class="content">
<pre>0 Address 	1 Address 	2 Address 		3 Address
PUSH M 	 	LOAD M 		MOVE X,Y ;(X&lt;-Y)	MOVE X,Y ;(X&lt;-Y)
POP M 		STORE M 	ADD X,Y  ;(X &lt;- X+Y)	ADD X,Y ;(X &lt;- Y+Z)
ADD 		ADD M 		SUB X,Y  ;(X &lt;- X-Y)	SUB X,Y ;(X &lt;- Y-Z)
SUB 		SUB M 		MUL X,Y  ;(X &lt;- X*Y)	MUL X,Y ;(X &lt;- Y*Z)
MUL 		MUL M 		DIV X,Y  ;(X &lt;- X/Y)	DIV X,Y ;(X &lt;- X/Y)
DIV 		DIV M</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>SOLUCION:</p>
<div class="listingblock">
<div class="content">
<pre>PUSH A      LOAD   E     MOV R0, E     MUL R0, E, F
PUSH B      MUL    F     MUL RO, F     SUB R0, D, R0
PUSH C      STORE  T     MOV R1, D     MUL R1, B, C
MUL         LOAD   D     SUB R1, R0    ADD R1, A, R1
ADD         SUB    T     MOV R0, B     DIV X, R0, R1
PUSH D      STORE  T     MOV R0, C
PUSH E      LOAD   B     ADD R0, A
PUSH F      MUL    C     DIV R0, R1
MUL         ADD    A     MOV X,  R0
SUB         DIV    T
DIV         STO    X
POP X</pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>If the last operation performed on a computer with an 8-bit word was an addition in which the two operands were 00000010 and 00000011, what would be the value of the following flags?</p>
<div class="ulist">
<ul>
<li>
<p>Carry</p>
</li>
<li>
<p>Zero</p>
</li>
<li>
<p>Overflow</p>
</li>
<li>
<p>Sign</p>
</li>
<li>
<p>Even Parity</p>
</li>
<li>
<p>Half-Carry</p>
</li>
<li>
<p>SOLUCION:</p>
<div class="ulist">
<ul>
<li>
<p>0010+0011=0101 &#8594; No hay llevada en el MSB, el resultado no es cero, no hay overflow ya que no hay llevada, positivo, número de unos par,  no hay llevada en el bit de posición 3. Por lo que todos los flags desactivados excepto el de paridad par . El flag parity estará a 1.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p><a id="cmp_ejercicio"></a>The x86 Compare instruction (CMP) <strong>subtracts</strong> the source operand from the destination operand; it updates the status flags (C, P, A, Z, S, O) but does not alter either of the operands. The CMP instruction can be used to determine if the destination operand is greater than, equal to, or less than the source operand.Cuando se ejecuta CMP hay dos flags de overflow en el registro EFLAGS: el flag <strong>CF</strong> no hace la función de Carrier Flag sino la función de overflow flag si se comparan números sin signo. Si se comparan números con signo el flag de overlfow es <strong>OF</strong>.</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Suppose the two operands are treated as unsigned integers. Show which status flags are relevant to determine the relative size of the two integer and what values of the flags correspond to greater than, equal to, or less than.</p>
</li>
<li>
<p>Suppose the two operands are treated as twos complement signed integers. Show which status flags are relevant to determine the relative size of the two integer and what values of the flags correspond to greater than, equal to, or less than.</p>
</li>
<li>
<p>Cómo varían los flags de signo SF y overflow OF para operandos con signo de 1 byte: si el operando destino es 0x80 y el operando fuente es 0x7F; si el operando destino es 0x7F y el operando fuente 0x81.</p>
<div class="ulist">
<ul>
<li>
<p>SOLUCION:</p>
</li>
<li>
<p>Ver <a href="_programación_en_lenguaje_ensamblador_x86_construcciones_básicas_de_los_lenguajes_de_alto_nivel.html#CFR">Programación en Lenguaje Ensamblador (x86)</a>,</p>
</li>
<li>
<p>CMP &#8658; Dest - Source</p>
</li>
<li>
<p>a. Enteros sin signo</p>
<table class="tableblock frame-all grid-all" style="width: 80%;">
<caption class="title">Table 20. CMP/EFLAFS</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Caso</th>
<th class="tableblock halign-left valign-top">CF</th>
<th class="tableblock halign-left valign-top">PF</th>
<th class="tableblock halign-left valign-top">AF</th>
<th class="tableblock halign-left valign-top">ZF</th>
<th class="tableblock halign-left valign-top">SF</th>
<th class="tableblock halign-left valign-top">OF</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Dest&gt;Source</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Dest=Source</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Dest&lt;Source</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x</p></td>
</tr>
</tbody>
</table>
<div class="ulist">
<ul>
<li>
<p>CF es el flag de overflow.</p>
</li>
<li>
<p>Sin signo &#8594; para el caso Destino &gt; Fuente, la resta Destino - Fuente da lugar a   CF=0 y OF según la resta con signo. El flag de signo no vaŕía SF=X.</p>
</li>
<li>
<p>Sin signo &#8594; para el caso Destino &lt; Fuente, la resta Destino - Fuente da lugar a   CF=1 y OF según la resta con signo. El flag de signo no varía SF=X.</p>
</li>
</ul>
</div>
</li>
<li>
<p>b. Enteros con signo</p>
<table class="tableblock frame-all grid-all" style="width: 80%;">
<caption class="title">Table 21. CMP/EFLAFS</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Caso</th>
<th class="tableblock halign-left valign-top">CF</th>
<th class="tableblock halign-left valign-top">PF</th>
<th class="tableblock halign-left valign-top">AF</th>
<th class="tableblock halign-left valign-top">ZF</th>
<th class="tableblock halign-left valign-top">SF</th>
<th class="tableblock halign-left valign-top">OF</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Dest&gt;Source</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Dest=Source</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Dest&lt;Source</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0**</p></td>
</tr>
</tbody>
</table>
<div class="ulist">
<ul>
<li>
<p>OF es el flag de overflow.</p>
</li>
<li>
<p>Con signo &#8594; para el caso Destino &gt; Fuente, la resta Destino - Fuente da lugar a  CF según la resta sin signo. SF=0 ó 1. OF=SF</p>
</li>
<li>
<p>Con signo &#8594; para el caso Destino &lt; Fuente, la resta Destino - Fuente da lugar a  CF según la resta sin signo. SF=0 ó 1. OF&lt;&gt;SF</p>
</li>
<li>
<p>CONCLUSION</p>
<div class="listingblock">
<div class="content">
<pre> CMP realiza los dos casos simultaneamente (con signo y sin signo) por lo que afecta a los dos flags de overflow CF y OF
 para el caso Destino &gt; Fuente,  la resta Destino - Fuente da lugar a  SF=OF y CF=0
 para el caso Destino &lt; Fuente, la resta Destino - Fuente da lugar a  SF&lt;&gt;OF y CF=1</pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>Many microprocessor instruction SETS include an instruction that tests a condition and sets a destination operand if the condition is true. Examples include the <em>SETcc</em> on the x86 processor, the <em>Scc</em> on the Motorola MC68000 processor, and the <em>Scond</em> on the National NS32000 processor. <a href="http://www.felixcloutier.com/x86/">Manual Intel quick</a>: interpretar los nmemónicos y operando de la instrucción SETcc</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>There are a few differences among these instructions:</p>
<div class="ulist">
<ul>
<li>
<p>SETcc and Scc operate only on a byte, whereas Scond operates on byte, word, and doubleword operands.</p>
</li>
<li>
<p>SETcc and Scond set the operand to integer one if true and to zero if false. Scc sets the byte to all binary ones if true and all zeros if false. What are the relative advantages and disadvantages of these differences?</p>
</li>
</ul>
</div>
</li>
<li>
<p>None of these instructions set any of the condition code flags, and thus an explicit test of the result of the instruction is required to determine its value. Discuss whether condition codes should be set as a result of this instruction (test). <a href="http://www.felixcloutier.com/x86/">Manual Intel quick</a>: interpretar la instrucción TEST.</p>
</li>
<li>
<p>A simple IF statement such as <em>IF a &gt; b</em> THEN can be implemented using a numerical representation method, that is, making the <em>Boolean value</em> manifest, as opposed to a <em>flow of control</em> method, which represents the value of a Boolean expression by a point reached in the program. (Primero transcribir el lenguaje ASM del enunciado a lenguaje RTL). Interpretar las instrucciones: <a href="http://www.felixcloutier.com/x86/">Manual Intel quick</a>. A compiler might implement <em>IF a &gt; b THEN</em> with the following <strong>x86 code</strong>:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="nasm">        <span class="c1">; Sintaxis de Intel: Opeación Op_destino, Op_fuente</span>
        <span class="nf">SUB</span> <span class="nb">CX</span><span class="p">,</span> <span class="nb">CX</span> <span class="c1">;set register CX to 0</span>
        <span class="nf">MOV</span> <span class="nb">AX</span><span class="p">,</span> <span class="nv">B</span> <span class="c1">;move contents of location B to register AX</span>
        <span class="nf">CMP</span> <span class="nb">AX</span><span class="p">,</span> <span class="nv">A</span> <span class="c1">;compare contents of register AX and location A</span>

        <span class="nf">JLE</span> <span class="nv">TEST</span> <span class="c1">;jump if A &lt;= B</span>
        <span class="nf">INC</span> <span class="nb">CX</span> <span class="c1">;add 1 to contents of register CX</span>
<span class="nl">TEST:</span>   <span class="nf">JCXZ</span> <span class="nv">OUT</span> <span class="c1">;jump if contents of CX equal 0</span>

<span class="nl">THEN:</span>   <span class="nf">XXXXX</span>

<span class="nl">OUT:</span>    <span class="nf">XXXXX</span></code></pre>
</div>
</div>
</li>
<li>
<p>Now consider the high-level language statement, (Primero transcribir el lenguaje ASM del enunciado a lenguaje RTL):</p>
<div class="ulist">
<ul>
<li>
<p><em>A:=(B &gt; C) OR (D == F)</em> donde := significa asignación</p>
</li>
<li>
<p>A compiler might generate the following code:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="nasm">	<span class="nf">MOV</span> <span class="nb">EAX</span><span class="p">,</span> <span class="nv">B</span> <span class="c1">;move contents of location B to register EAX</span>
	<span class="nf">CMP</span> <span class="nb">EAX</span><span class="p">,</span> <span class="nv">C</span> <span class="c1">;compare contents of register EAX and location C</span>
	<span class="nf">MOV</span> <span class="nb">BL</span><span class="p">,</span> <span class="mi">0</span> <span class="c1">;0 represents false</span>
	<span class="nf">JLE</span> <span class="nv">N1</span> <span class="c1">;jump if (B &lt;= C)</span>
	<span class="nf">MOV</span> <span class="nb">BL</span><span class="p">,</span> <span class="mi">1</span> <span class="c1">;1 represents false</span>
<span class="nf">N1</span> 	<span class="nv">MOV</span> <span class="nb">EAX</span><span class="p">,</span> <span class="nv">D</span>
	<span class="nf">CMP</span> <span class="nb">EAX</span><span class="p">,</span> <span class="nv">F</span>
	<span class="nf">MOV</span> <span class="nb">BH</span><span class="p">,</span> <span class="mi">0</span>
	<span class="nf">JNE</span> <span class="nv">N2</span>
	<span class="nf">MOV</span> <span class="nb">BH</span><span class="p">,</span> <span class="mi">1</span>
<span class="nf">N2</span> 	<span class="nv">OR</span> <span class="nb">BL</span><span class="p">,</span> <span class="nb">BH</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>SOLUCION:</p>
</li>
<li>
<p>a. <code>JLE Op_destino</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>Salta si el ultimo resultado activa el banderín ZF=1 ó los banderines SF y OF son diferentes (SF&lt;&gt;OF)</p>
</li>
<li>
<p><code>CMP Op_destino_B,Op_fuente_A</code> &#8594; B-A &#8594; operandos con signo en complemento a dos</p>
<div class="ulist">
<ul>
<li>
<p>ZF=1 &#8594; B==A</p>
</li>
<li>
<p>SF &lt;&gt; OF</p>
</li>
<li>
<p>SF=1,OF=0 &#8594; B&lt;A</p>
</li>
<li>
<p>SF=0,OF=1 &#8594; B&gt;A</p>
</li>
</ul>
</div>
</li>
<li>
<p>Sustituir el salto <code>JLE Op_destino</code> por <code>SETcc</code></p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="nasm">        <span class="nf">SUB</span> <span class="nb">CX</span><span class="p">,</span> <span class="nb">CX</span> <span class="c1">;set register CX to 0</span>
        <span class="nf">MOV</span> <span class="nb">AX</span><span class="p">,</span> <span class="nv">B</span>  <span class="c1">;move contents of location B to register AX</span>
        <span class="nf">CMP</span> <span class="nb">AX</span><span class="p">,</span> <span class="nv">A</span>  <span class="c1">;compare contents of register AX and location A</span>

        <span class="nf">SETGT</span> <span class="nb">CX</span>   <span class="c1">;CX = (a GT b)</span>
<span class="nl">TEST:</span>	<span class="nf">JCXZ</span> <span class="nv">OUT</span>   <span class="c1">;jump if contents of CX equal 0</span>
<span class="nl">THEN:</span>   <span class="nf">XXXXXX</span>
<span class="nl">OUT:</span>    <span class="nf">XXXXXX</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>b.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="nasm"><span class="nf">MOV</span> <span class="nb">EAX</span><span class="p">,</span> <span class="nv">B</span> <span class="c1">; move from location B to register EAX</span>
<span class="nf">CMP</span> <span class="nb">EAX</span><span class="p">,</span> <span class="nv">C</span>
<span class="nf">SETG</span> <span class="nb">BL</span> <span class="c1">; Setcc SETGreater ;BL = 0/1 depending on result</span>
<span class="nf">MOV</span> <span class="nb">EAX</span><span class="p">,</span> <span class="nv">D</span>
<span class="nf">CMP</span> <span class="nb">EAX</span><span class="p">,</span> <span class="nv">F</span>
<span class="nf">MOV</span> <span class="nb">BH</span><span class="p">,</span> <span class="mi">0</span>
<span class="nf">SETE</span> <span class="nb">BH</span> <span class="c1">; Setcc SETEqual ;BH= 0 ó 1 dependiendo del resultado</span>
<span class="nf">OR</span> <span class="nb">BL</span><span class="p">,</span> <span class="nb">BH</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>En la estructura de datos siguiente, dibujar el layout de memoria little-endian, teniendo en cuenta que el compilador alinea los datos con direcciones múltiplo de 4 rellenando los huecos con ceros, y así minimizar el número de  transferencias entre la memoria y la CPU en la captura de los datos.</p>
<div class="ulist">
<ul>
<li>
<p>Declaración:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="kt">void</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">pad</span><span class="p">;</span> <span class="c1">//</span>
    <span class="kt">double</span> <span class="n">b</span><span class="p">;</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">c</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">d</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>
    <span class="kt">short</span> <span class="n">e</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">f</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">q</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
  <span class="p">}</span> <span class="n">s</span><span class="o">=</span><span class="p">{.</span><span class="n">a</span><span class="o">=</span><span class="mh">0x11121314</span><span class="p">,.</span><span class="n">pad</span><span class="o">=</span><span class="mi">0</span><span class="p">,.</span><span class="n">b</span><span class="o">=</span><span class="mh">0x2122232425262728</span><span class="p">,.</span><span class="n">d</span><span class="o">=</span><span class="p">{</span><span class="sc">'A'</span><span class="p">,</span><span class="sc">'B'</span><span class="p">,</span><span class="sc">'C'</span><span class="p">,</span><span class="sc">'D'</span><span class="p">,</span><span class="sc">'E'</span><span class="p">,</span><span class="sc">'F'</span><span class="p">,</span><span class="sc">'G'</span><span class="p">},.</span><span class="n">e</span><span class="o">=</span><span class="mh">0x5152</span><span class="p">,.</span><span class="n">f</span><span class="o">=</span><span class="mh">0x61626364</span><span class="p">,.</span><span class="n">q</span><span class="o">=</span><span class="s">"abc"</span><span class="p">};</span>
  <span class="n">s</span><span class="p">.</span><span class="n">c</span><span class="o">=&amp;</span><span class="n">s</span><span class="p">.</span><span class="n">e</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>SOLUCION Little Endian:</p>
<div class="listingblock">
<div class="content">
<pre>00: 14 13 12 11
04: xx xx xx xx
08: rr rr rr rr
0C: rr rr rr rr
10: aa aa aa aa
14: 41 42 43 44
18: 45 46 47 pp
1C: 52 51 pp pp
20: 64 63 62 61
24: 61 62 63 00</pre>
</div>
</div>
</li>
<li>
<p>xx: indeterminado</p>
</li>
<li>
<p>rr: código ieee-754 doble precisión</p>
</li>
<li>
<p>aa: dirección de la variable e con la que es inicializado el puntero c.</p>
</li>
<li>
<p>char q[4]="abc" : array de 4 elementos tipo carácter. Equivale a: char q[4]={<em>a</em>,<em>b</em>,<em>c</em>,NULL} donde el caracter NULL vale 00.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Para una arquitectura little endian el mapa de direcciones en memoria es el de la figura de abajo. Asociar la declaración de las estructuras s1 y s2 en lenguaje C y su inicialización con el mapa de direcciones indicando las direcciones en memoria de los elementos de las estructuras.</p>
</li>
</ol>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/ejercicios/little_endian.png" alt="little endian">
</div>
<div class="title">Figure 73. Little Endian</div>
</div>
<div class="olist loweralpha">
<ol class="loweralpha">
<li>
<p>declaración de la variable s1:  tipo estructura</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="k">struct</span> <span class="p">{</span>
<span class="kt">double</span> <span class="n">i</span><span class="p">;</span> <span class="c1">//0x1112131415161718 ; 8 bytes</span>
<span class="p">}</span> <span class="n">s1</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>SOLUCION:</p>
<div class="ulist">
<ul>
<li>
<p>MSB(i):0x11 en la dirección 0x03 y LSB(i):18 en la dirección de MSB-7</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>declaración de la variable s2:  tipo estructura</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="k">struct</span> <span class="p">{</span>
<span class="kt">int</span> <span class="n">i</span><span class="p">;</span> <span class="c1">//0x11121314 ; 4 bytes</span>
<span class="kt">int</span> <span class="n">j</span><span class="p">;</span> <span class="c1">//0x15161718</span>
<span class="p">}</span> <span class="n">s2</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>SOLUCION:</p>
</li>
<li>
<p>i:</p>
<div class="ulist">
<ul>
<li>
<p>MSB(i):0x11 en la dirección 0x03 y LSB(i) en la dirección 0x00</p>
</li>
</ul>
</div>
</li>
<li>
<p>j:</p>
<div class="ulist">
<ul>
<li>
<p>j se reservar secuencialmente a continuación de i, por lo que LSB(j) estará en la dirección 0x04 y MSB(j) en la dirección 0x07</p>
</li>
<li>
<p>0x04 : 18 17 16 15</p>
<div class="ulist">
<ul>
<li>
<p>Write a small program to determine the endianness of machine and report the results. Run the program on a computer available to you and turn in the output.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">integer</span><span class="p">;</span> <span class="cm">/*4 bytes*/</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
  <span class="n">integer</span> <span class="o">=</span> <span class="mh">0x30313233</span><span class="p">;</span> <span class="cm">/* ASCII for chars '0', '1', '2', '3' */</span>
  <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">integer</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="o">==</span><span class="sc">'0'</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">==</span><span class="sc">'1'</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">==</span><span class="sc">'2'</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span><span class="o">==</span><span class="sc">'3'</span><span class="p">)</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"This is a big endian machine.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="o">==</span><span class="sc">'3'</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">==</span><span class="sc">'2'</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">==</span><span class="sc">'1'</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span><span class="o">==</span><span class="sc">'0'</span><span class="p">)</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"This is a little endian machine.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>


    <span class="k">else</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"Error in logic to determine machine endian-ness.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>SOLUCION:</p>
<div class="ulist">
<ul>
<li>
<p>p apunta al primer byte de la variable integer, (p+1) al siguiente byte y así sucesivamente</p>
</li>
<li>
<p>si p apunta al caracter <em>0</em> significa que el MSB de integer se almacena en la dirección más baja &#8594; Big endian</p>
</li>
<li>
<p>si p apunta al caracter <em>3</em> significa que el MSB de integer se almacena en la dirección más alta &#8594; Little endian</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_programación_asm">10.6. Programación asm</h3>
<div class="ulist">
<ul>
<li>
<p><a href="_programación_en_lenguaje_ensamblador_x86_construcciones_básicas_de_los_lenguajes_de_alto_nivel.html#mnemonicos_basicos_explicados">Explicación breve del modus operandi de los códigos mnemónicos</a>. Para información más detallada ir al <a href="_programación_en_lenguaje_ensamblador_x86_construcciones_básicas_de_los_lenguajes_de_alto_nivel.html#repertorio_instruc_oper">Manual del Repertoriod e Instrucciones de INTEL</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_datos">10.6.1. Datos</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Interpretar las instrucciones siguientes de un programa en lenguaje ensamblador x86-64 describiéndolas en lenguaje RTL:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>mov da1,da4</p>
</li>
<li>
<p>mov $0xFF00FF00FF00FF00,%rax</p>
</li>
<li>
<p>mov $0xFF,%rsi</p>
</li>
<li>
<p>mov $da1,%rsp</p>
</li>
<li>
<p>lea da1,%rsp</p>
</li>
<li>
<p>mov da4,%ebx</p>
</li>
<li>
<p>movb da4,%ebx</p>
</li>
<li>
<p>movl da4,%ax</p>
</li>
<li>
<p>movw %ebx,da4</p>
</li>
<li>
<p>movw %ebx,da1</p>
<div class="ulist">
<ul>
<li>
<p>si la sección de datos  presenta el código siguiente:</p>
<div class="listingblock">
<div class="content">
<pre>	.data

da1:	.byte   0x0A
da2:	.2byte  0x0A0B
da4:	.4byte  0x0A0B0C0D
saludo:	.ascii  "hola"
lista:  .int    1,2,3,4,5</pre>
</div>
</div>
</li>
<li>
<p>SOLUCION</p>
<div class="listingblock">
<div class="content">
<pre>mov da1,da4
mov $0xFF00FF00FF00FF00,%rax
mov $0xFF,%rsi
mov $da1,%rsp
lea da1,%rsp
mov da4,%ebx
movb da4,%ebx
movl da4,%ax
movw %ebx,da4
movq %ebx,da4</pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_modos_de_direccionamiento_2">10.6.2. Modos de Direccionamiento</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Deducir la dirección efectiva del operando en las expresiones siguientes:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>$0</p>
</li>
<li>
<p>%rax</p>
</li>
<li>
<p>loop_exit</p>
</li>
<li>
<p>data_items(,%rdi,4)</p>
</li>
<li>
<p>(%rbx)</p>
</li>
<li>
<p>(%rbx,%rdi,4)</p>
<div class="ulist">
<ul>
<li>
<p>SOLUCIONES</p>
<div class="ulist">
<ul>
<li>
<p>$0		: inmediato : el operando está en la propia instrucción, es 0.</p>
</li>
<li>
<p>%rax 	: directo registro  . El operando está en el registro. Operando R[rax]</p>
</li>
<li>
<p>loop_exit   : directo memoria   . La etiqueta es la dirección efectiva del operando en memoria. Operando M[loop_exit]</p>
</li>
<li>
<p>data_items(,%rdi,4)  : indexado y desplazamiento inmediato. Dirección efectiva = data_item+4*RDI. Operando M[data_item+4*RDI]</p>
</li>
<li>
<p>(%rbx)  : Indirecto a registro . Dirección efectiva=RBX . Operando M[RBX]</p>
</li>
<li>
<p>(%rbx,%rdi,4) : indexado y desplazamiento en registro base. Dirección efectiva = RBX+4*RDI .Operando M[RBX+4*RDI]</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>Describir en lenguaje RTL el código</p>
<div class="listingblock">
<div class="content">
<pre>lea buffer,%eax
mov da2,(%eax)
mov da2,%bx
mov %bx, (%eax)
incw da2
lea  da2,%ebx
incw 2(%ebx)
mov $3,%esi
mov da2(,%esi,2),%ebx</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>SOLUCION:</p>
<div class="listingblock">
<div class="content">
<pre>lea buffer,%eax
mov da2,(%eax)
mov da2,%bx
mov %bx, (%eax)
incw da2
lea  da2,%ebx
incw 2(%ebx)
inc 2(%ebx)
mov $3,%esi
mov da2(,%esi,2),%ebx</pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_aritmética">10.6.3. Aritmética</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Suponer que los números enteros con signo x e y están almacenados en las posiciones 8 y 12 relativas al registro %ebp , y se desea almacenar en el top de la pila el producto x*y de 8 bytes, siendo el registro %esp (stack pointer) el puntero al top de la pila. a)Desarrollar el código ensamblador gas para la arquitectura i386 y b) dibujar el contenido de la pila sabiendo que la anchura de la pila es una palabra en la arquitectura i386 y suponiendo que el registro <em>ebp</em> y el puntero de pila <em>esp</em> están distanciados 4 palabras.</p>
<div class="ulist">
<ul>
<li>
<p>SOLUCION: Módulo asm:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">x</span> <span class="n">en</span> <span class="o">%</span><span class="n">ebp</span><span class="o">+</span><span class="mi">8</span><span class="p">,</span> <span class="n">y</span> <span class="n">en</span> <span class="o">%</span><span class="n">ebp</span><span class="o">+</span><span class="mi">12</span>

<span class="mi">1</span> <span class="n">movl</span> <span class="mi">12</span><span class="p">(</span><span class="o">%</span><span class="n">ebp</span><span class="p">),</span> <span class="o">%</span><span class="n">eax</span>
<span class="mi">2</span> <span class="n">imull</span> <span class="mi">8</span><span class="p">(</span><span class="o">%</span><span class="n">ebp</span><span class="p">)</span> 			<span class="p">;</span> <span class="n">EDX</span><span class="o">:</span><span class="n">EAX</span><span class="o">&lt;-</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="mi">63</span><span class="o">-</span><span class="mi">32</span><span class="o">:</span><span class="mi">31</span><span class="o">-</span><span class="mi">0</span><span class="p">]</span> <span class="p">;</span> <span class="n">imul</span><span class="o">:</span> <span class="n">multiplicaci</span><span class="err">ó</span><span class="n">n</span> <span class="n">de</span> <span class="n">enteros</span> <span class="n">con</span> <span class="n">signo</span>
<span class="mi">3</span> <span class="n">movl</span> <span class="o">%</span><span class="n">eax</span><span class="p">,</span> <span class="p">(</span><span class="o">%</span><span class="n">esp</span><span class="p">)</span> 			<span class="p">;</span> <span class="n">pila</span> <span class="o">&lt;-</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>
<span class="mi">4</span> <span class="n">movl</span> <span class="o">%</span><span class="n">edx</span><span class="p">,</span> <span class="mi">4</span><span class="p">(</span><span class="o">%</span><span class="n">esp</span><span class="p">)</span> 			<span class="p">;</span> <span class="n">pila</span> <span class="o">&lt;-</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="mi">63</span><span class="o">:</span><span class="mi">32</span><span class="p">]</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Pila: arquitectura i386 &#8594; x86-32 &#8594; palabra=4bytes. EL crecimiento de la pila es hacia direcciones de la memoria más bajas.</p>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/ditaa/svg/eNrFlE0LgkAQhu_-ijknC5YSIiJs6x4M0UXtFHUwNujQB-VBwR_fWhSkJpkbvbddZp55mZldxfUiSogXBjSGh0gYJDTw3FCBF9noJjAgLTJ-gfsRObUwFbVKrcK0XKtUhZXQqrI3zZBKM6XSiARaI3FdS3zHl1ex_LoikDPf7PY7fsiO4NKY0MClYr0kO8lHxVIfW9rqeW0jAH45PbeW4SihgP0ECxvgY2Cejy1gC2EmCoHG7AeWprqlT1Y1S6rxv3EMqshT0U5ATldFu4a6t32G52_aPmM93pQwIJrXaaAnzWzQ8gE00qAVX9I-GG6vv2hbSQbtCguaCSQ=" alt="Diagram">
</div>
</div>
</li>
<li>
<p>EBP: base pointer register: apunta al bottom de la pila</p>
</li>
<li>
<p>ESP: stack pointer register: apunta al top de la pila</p>
</li>
<li>
<p>La pila está ocupada desde la dirección bottom hasta la dirección top, donde la dirección top &lt; dirección bottom.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Suponer que los números enteros con signo x e y están almacenados en las posiciones 8 y 12 relativas al registro %ebp , y se desea almacenear en el top de la pila el producto x/y y también x mod y, siendo el registro %esp (stack pointer) el puntero al top de la pila. Desarrollar el código ensamblador gas para la arquitectura i386.</p>
<div class="ulist">
<ul>
<li>
<p>Solución: Módulo asm</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">x</span> <span class="n">en</span> <span class="n">ebp</span><span class="o">+</span><span class="mi">8</span><span class="p">,</span> <span class="n">y</span> <span class="n">en</span> <span class="n">ebp</span><span class="o">+</span><span class="mi">12</span>

<span class="mi">1</span> <span class="n">movl</span> <span class="mi">8</span><span class="p">(</span><span class="o">%</span><span class="n">ebp</span><span class="p">),</span> <span class="o">%</span><span class="n">edx</span>	<span class="p">;</span> <span class="n">edx</span><span class="o">&lt;-</span><span class="n">x</span>
<span class="mi">2</span> <span class="n">movl</span> <span class="o">%</span><span class="n">edx</span><span class="p">,</span> <span class="o">%</span><span class="n">eax</span>	<span class="p">;</span> <span class="n">copiar</span> <span class="n">x</span> <span class="n">en</span> <span class="n">eax</span>
<span class="mi">3</span> <span class="n">sarl</span> <span class="err">$</span><span class="mi">31</span><span class="p">,</span> <span class="o">%</span><span class="n">edx</span> 	<span class="p">;</span> <span class="n">edx</span> <span class="n">lo</span> <span class="n">lleno</span> <span class="n">con</span> <span class="n">el</span> <span class="n">bit</span> <span class="n">de</span> <span class="n">signo</span> <span class="n">de</span> <span class="n">x</span> <span class="p">,</span> <span class="n">ya</span> <span class="n">que</span> <span class="n">forma</span> <span class="n">parte</span> <span class="n">del</span> <span class="n">dividendo</span><span class="p">.</span>
                        <span class="p">;</span> <span class="n">edx</span><span class="o">:</span><span class="n">eax</span> <span class="o">&lt;-</span> <span class="n">x</span>
<span class="mi">4</span> <span class="n">idivl</span> <span class="mi">12</span><span class="p">(</span><span class="o">%</span><span class="n">ebp</span><span class="p">)</span>        <span class="p">;</span> <span class="n">EAX</span><span class="o">&lt;-</span><span class="n">Cociente</span><span class="p">{</span><span class="n">x</span><span class="o">/</span><span class="n">y</span><span class="p">}</span> <span class="p">,</span> <span class="n">EDX</span><span class="o">&lt;-</span><span class="n">Resto</span><span class="p">{</span><span class="n">x</span><span class="o">/</span><span class="n">y</span><span class="p">]}</span>
<span class="mi">5</span> <span class="n">movl</span> <span class="o">%</span><span class="n">eax</span><span class="p">,</span> <span class="mi">4</span><span class="p">(</span><span class="o">%</span><span class="n">esp</span><span class="p">)</span>    <span class="p">;</span> <span class="n">pila</span> <span class="o">&lt;-</span> <span class="n">Cociente</span><span class="p">{</span><span class="n">x</span><span class="o">/</span><span class="n">y</span><span class="p">}</span>
<span class="mi">6</span> <span class="n">movl</span> <span class="o">%</span><span class="n">edx</span><span class="p">,</span> <span class="p">(</span><span class="o">%</span><span class="n">esp</span><span class="p">)</span>     <span class="p">;</span> <span class="n">pila</span> <span class="o">&lt;-</span> <span class="n">x</span><span class="o">%</span><span class="n">y</span>  <span class="p">;</span> <span class="n">x</span><span class="o">%</span><span class="n">y</span> <span class="o">=</span> <span class="n">Resto</span><span class="p">{</span><span class="n">x</span><span class="o">/</span><span class="n">y</span><span class="p">}</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Mismo enunciado anterior pero utilizando la instrucción  de extensión de signo <code>cltd</code></p>
<div class="ulist">
<ul>
<li>
<p>Módulo asm</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">x</span> <span class="n">en</span> <span class="n">ebp</span><span class="o">+</span><span class="mi">8</span><span class="p">,</span> <span class="n">y</span> <span class="n">en</span> <span class="n">ebp</span><span class="o">+</span><span class="mi">12</span>

<span class="mi">1</span> <span class="n">movl</span> <span class="mi">8</span><span class="p">(</span><span class="o">%</span><span class="n">ebp</span><span class="p">),</span> <span class="o">%</span><span class="n">edx</span>	<span class="p">;</span> <span class="n">edx</span><span class="o">&lt;-</span><span class="n">x</span>
<span class="mi">2</span> <span class="n">movl</span> <span class="o">%</span><span class="n">edx</span><span class="p">,</span> <span class="o">%</span><span class="n">eax</span>	<span class="p">;</span> <span class="n">copiar</span> <span class="n">x</span> <span class="n">en</span> <span class="n">eax</span>
<span class="mi">3</span> <span class="n">cltd</span>			<span class="p">;</span> <span class="n">extiende</span> <span class="n">el</span> <span class="n">signo</span> <span class="n">del</span> <span class="n">operando</span> <span class="n">en</span> <span class="n">eax</span> <span class="n">a</span> <span class="n">edx</span>
<span class="mi">4</span> <span class="n">idivl</span> <span class="mi">12</span><span class="p">(</span><span class="o">%</span><span class="n">ebp</span><span class="p">)</span>        <span class="p">;</span> <span class="n">EAX</span><span class="o">&lt;-</span><span class="n">Cociente</span><span class="p">{</span><span class="n">x</span><span class="o">/</span><span class="n">y</span><span class="p">}</span> <span class="p">,</span> <span class="n">EDX</span><span class="o">&lt;-</span><span class="n">Resto</span><span class="p">{</span><span class="n">x</span><span class="o">/</span><span class="n">y</span><span class="p">]}</span>
<span class="mi">5</span> <span class="n">movl</span> <span class="o">%</span><span class="n">eax</span><span class="p">,</span> <span class="mi">4</span><span class="p">(</span><span class="o">%</span><span class="n">esp</span><span class="p">)</span>    <span class="p">;</span> <span class="n">pila</span> <span class="o">&lt;-</span> <span class="n">Cociente</span><span class="p">{</span><span class="n">x</span><span class="o">/</span><span class="n">y</span><span class="p">}</span>
<span class="mi">6</span> <span class="n">movl</span> <span class="o">%</span><span class="n">edx</span><span class="p">,</span> <span class="p">(</span><span class="o">%</span><span class="n">esp</span><span class="p">)</span>     <span class="p">;</span> <span class="n">pila</span> <span class="o">&lt;-</span> <span class="n">x</span><span class="o">%</span><span class="n">y</span>  <span class="p">;</span> <span class="n">x</span><span class="o">%</span><span class="n">y</span> <span class="o">=</span> <span class="n">Resto</span><span class="p">{</span><span class="n">x</span><span class="o">/</span><span class="n">y</span><span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Del módulo fuente en lenguaje C:</p>
<div class="ulist">
<ul>
<li>
<p>Deducir el tipo num_t del argumento del prototipo de la función store_prod</p>
</li>
<li>
<p>Interpretar el módulo ASM en lenguaje RTL</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">void</span> <span class="nf">store_prod</span><span class="p">(</span><span class="n">num_t</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">x</span><span class="p">,</span> <span class="n">num_t</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
<span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">dest</span> <span class="n">en</span> <span class="n">ebp</span><span class="o">+</span><span class="mi">8</span><span class="p">,</span> <span class="n">x</span> <span class="n">en</span> <span class="n">ebp</span><span class="o">+</span><span class="mi">12</span><span class="p">,</span> <span class="n">y</span> <span class="n">en</span> <span class="n">ebp</span><span class="o">+</span><span class="mi">16</span>

<span class="mi">1</span> <span class="n">movl</span> <span class="mi">12</span><span class="p">(</span><span class="o">%</span><span class="n">ebp</span><span class="p">),</span> <span class="o">%</span><span class="n">eax</span>
<span class="mi">2</span> <span class="n">movl</span> <span class="mi">20</span><span class="p">(</span><span class="o">%</span><span class="n">ebp</span><span class="p">),</span> <span class="o">%</span><span class="n">ecx</span>
<span class="mi">3</span> <span class="n">imull</span> <span class="o">%</span><span class="n">eax</span><span class="p">,</span> <span class="o">%</span><span class="n">ecx</span>
<span class="mi">4</span> <span class="n">mull</span> <span class="mi">16</span><span class="p">(</span><span class="o">%</span><span class="n">ebp</span><span class="p">)</span>
<span class="mi">5</span> <span class="n">leal</span> <span class="p">(</span><span class="o">%</span><span class="n">ecx</span><span class="p">,</span><span class="o">%</span><span class="n">edx</span><span class="p">),</span> <span class="o">%</span><span class="n">edx</span>
<span class="mi">6</span> <span class="n">movl</span> <span class="mi">8</span><span class="p">(</span><span class="o">%</span><span class="n">ebp</span><span class="p">),</span> <span class="o">%</span><span class="n">ecx</span>
<span class="mi">7</span> <span class="n">movl</span> <span class="o">%</span><span class="n">eax</span><span class="p">,</span> <span class="p">(</span><span class="o">%</span><span class="n">ecx</span><span class="p">)</span>
<span class="mi">8</span> <span class="n">movl</span> <span class="o">%</span><span class="n">edx</span><span class="p">,</span> <span class="mi">4</span><span class="p">(</span><span class="o">%</span><span class="n">ecx</span><span class="p">)</span></code></pre>
</div>
</div>
</li>
<li>
<p>SOLUCION:</p>
<div class="ulist">
<ul>
<li>
<p>El argumento dest está implementado en la dirección ebp+8</p>
</li>
<li>
<p>dest es un puntero a un objeto de tipo num_t</p>
</li>
<li>
<p>línea 6: carga ecx con el valor de dest</p>
</li>
<li>
<p>línea 7: carga eax en la dirección de memoria a la que apunta dest</p>
</li>
<li>
<p>línea 1: carga eax con la variable x que es de tipo sin signo, luego num_t es unsigned.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_saltos_2">10.6.4. Saltos</h4>
<div class="ulist">
<ul>
<li>
<p>Calcular las direcciones de salto en código máquina en el siguiente bloque de código ensamblador:</p>
<div class="ulist">
<ul>
<li>
<p>módulo fuente:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="mi">1</span> <span class="n">jle</span> <span class="p">.</span><span class="n">L2</span> <span class="k">if</span> <span class="o">&lt;=</span><span class="p">,</span> <span class="k">goto</span> <span class="n">dest2</span>
<span class="mi">2</span> <span class="p">.</span><span class="n">L5</span><span class="o">:</span> <span class="n">dest1</span><span class="o">:</span>
<span class="mi">3</span> <span class="n">movl</span> <span class="o">%</span><span class="n">edx</span><span class="p">,</span> <span class="o">%</span><span class="n">eax</span>
<span class="mi">4</span> <span class="n">sarl</span> <span class="o">%</span><span class="n">eax</span>
<span class="mi">5</span> <span class="n">subl</span> <span class="o">%</span><span class="n">eax</span><span class="p">,</span> <span class="o">%</span><span class="n">edx</span>
<span class="mi">6</span> <span class="n">leal</span> <span class="p">(</span><span class="o">%</span><span class="n">edx</span><span class="p">,</span><span class="o">%</span><span class="n">edx</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="o">%</span><span class="n">edx</span>
<span class="mi">7</span> <span class="n">testl</span> <span class="o">%</span><span class="n">edx</span><span class="p">,</span> <span class="o">%</span><span class="n">edx</span>
<span class="mi">8</span> <span class="n">jg</span> <span class="p">.</span><span class="n">L5</span> <span class="k">if</span> <span class="o">&gt;</span><span class="p">,</span> <span class="k">goto</span> <span class="n">dest1</span>
<span class="mi">9</span> <span class="p">.</span><span class="n">L2</span><span class="o">:</span> <span class="n">dest2</span><span class="o">:</span>
<span class="mi">10</span> <span class="n">movl</span> <span class="o">%</span><span class="n">edx</span><span class="p">,</span> <span class="o">%</span><span class="n">eax</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Módulo objeto reubicable :las posiciones de memoria son relativas a la dirección de referencia "silly" (dirección cero del módulo reubicable)</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="mi">1</span> 	<span class="mi">8</span><span class="o">:</span> <span class="mi">7</span><span class="n">e</span> <span class="mi">0</span><span class="n">d</span> <span class="n">jle</span> <span class="mi">17</span> <span class="o">&lt;</span><span class="n">silly</span><span class="o">+</span><span class="mh">0x17</span><span class="o">&gt;</span> <span class="n">Target</span> <span class="o">=</span> <span class="n">dest2</span>
<span class="mi">2</span> 	<span class="n">a</span><span class="o">:</span> <span class="mi">89</span> <span class="n">d0</span> <span class="n">mov</span> <span class="o">%</span><span class="n">edx</span><span class="p">,</span><span class="o">%</span><span class="n">eax</span> <span class="n">dest1</span><span class="o">:</span>
<span class="mi">3</span> 	<span class="n">c</span><span class="o">:</span> <span class="n">d1</span> <span class="n">f8</span> <span class="n">sar</span> <span class="o">%</span><span class="n">eax</span>
<span class="mi">4</span> 	<span class="n">e</span><span class="o">:</span> <span class="mi">29</span> <span class="n">c2</span> <span class="n">sub</span> <span class="o">%</span><span class="n">eax</span><span class="p">,</span><span class="o">%</span><span class="n">edx</span>
<span class="mi">5</span> 	<span class="mi">10</span><span class="o">:</span> <span class="mi">8</span><span class="n">d</span> <span class="mi">14</span> <span class="mi">52</span> <span class="n">lea</span> <span class="p">(</span><span class="o">%</span><span class="n">edx</span><span class="p">,</span><span class="o">%</span><span class="n">edx</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="o">%</span><span class="n">edx</span>
<span class="mi">6</span> 	<span class="mi">13</span><span class="o">:</span> <span class="mi">85</span> <span class="n">d2</span> <span class="n">test</span> <span class="o">%</span><span class="n">edx</span><span class="p">,</span><span class="o">%</span><span class="n">edx</span>
<span class="mi">7</span> 	<span class="mi">15</span><span class="o">:</span> <span class="mi">7</span><span class="n">f</span> <span class="n">f3</span> <span class="n">jg</span> <span class="n">a</span> <span class="o">&lt;</span><span class="n">silly</span><span class="o">+</span><span class="mh">0xa</span><span class="o">&gt;</span> <span class="n">Target</span> <span class="o">=</span> <span class="n">dest1</span>
<span class="mi">8</span> 	<span class="mi">17</span><span class="o">:</span> <span class="mi">89</span> <span class="n">d0</span> <span class="n">mov</span> <span class="o">%</span><span class="n">edx</span><span class="p">,</span><span class="o">%</span><span class="n">eax</span> <span class="n">dest2</span><span class="o">:</span></code></pre>
</div>
</div>
</li>
<li>
<p>Módulo objeto ejecutable : El linker ha resuelto las posiciones de memoria relativas del módulo objeto reubicable convirtiendolas en direcciones de memoria absolutas.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="mi">1</span> <span class="mi">804839</span><span class="n">c</span><span class="o">:</span> <span class="mi">7</span><span class="n">e</span> <span class="mi">0</span><span class="n">d</span> <span class="n">jle</span> <span class="mi">80483</span><span class="n">ab</span> <span class="o">&lt;</span><span class="n">silly</span><span class="o">+</span><span class="mh">0x17</span><span class="o">&gt;</span>
<span class="mi">2</span> <span class="mi">804839</span><span class="n">e</span><span class="o">:</span> <span class="mi">89</span> <span class="n">d0</span> <span class="n">mov</span> <span class="o">%</span><span class="n">edx</span><span class="p">,</span><span class="o">%</span><span class="n">eax</span>
<span class="mi">3</span> <span class="mi">80483</span><span class="n">a0</span><span class="o">:</span> <span class="n">d1</span> <span class="n">f8</span> <span class="n">sar</span> <span class="o">%</span><span class="n">eax</span>
<span class="mi">4</span> <span class="mi">80483</span><span class="n">a2</span><span class="o">:</span> <span class="mi">29</span> <span class="n">c2</span> <span class="n">sub</span> <span class="o">%</span><span class="n">eax</span><span class="p">,</span><span class="o">%</span><span class="n">edx</span>
<span class="mi">5</span> <span class="mi">80483</span><span class="n">a4</span><span class="o">:</span> <span class="mi">8</span><span class="n">d</span> <span class="mi">14</span> <span class="mi">52</span> <span class="n">lea</span> <span class="p">(</span><span class="o">%</span><span class="n">edx</span><span class="p">,</span><span class="o">%</span><span class="n">edx</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="o">%</span><span class="n">edx</span>
<span class="mi">6</span> <span class="mi">80483</span><span class="n">a7</span><span class="o">:</span> <span class="mi">85</span> <span class="n">d2</span> <span class="n">test</span> <span class="o">%</span><span class="n">edx</span><span class="p">,</span><span class="o">%</span><span class="n">edx</span>
<span class="mi">7</span> <span class="mi">80483</span><span class="n">a9</span><span class="o">:</span> <span class="mi">7</span><span class="n">f</span> <span class="n">f3</span> <span class="n">jg</span> <span class="mi">804839</span><span class="n">e</span> <span class="o">&lt;</span><span class="n">silly</span><span class="o">+</span><span class="mh">0xa</span><span class="o">&gt;</span>
<span class="mi">8</span> <span class="mi">80483</span><span class="n">ab</span><span class="o">:</span> <span class="mi">89</span> <span class="n">d0</span> <span class="n">mov</span> <span class="o">%</span><span class="n">edx</span><span class="p">,</span><span class="o">%</span><span class="n">eax</span></code></pre>
</div>
</div>
</li>
<li>
<p>SOLUCION:</p>
</li>
<li>
<p>los saltos están en las líneas 1 y 7 del código.</p>
</li>
<li>
<p>el operando del salto de la línea 1 es la dirección absoluta 80483ab etiquetada como dest2</p>
<div class="ulist">
<ul>
<li>
<p>Cuando se ejecuta la línea 1 el PC ó RIP apunta a la línea 2, es decir, 804839e</p>
</li>
<li>
<p>El salto será la resta 80483ab - 804839e = 0D</p>
</li>
</ul>
</div>
</li>
<li>
<p>el operando del salto de la línea 7 es la dirección 804839e etiquetada como dest1</p>
<div class="ulist">
<ul>
<li>
<p>El salto será la resta 804839e - 80483ab</p>
<div class="ulist">
<ul>
<li>
<p>Como la resta va a dar negativo invierto los operandos y después cambio el signo del resultado</p>
</li>
<li>
<p>80483ab - 804839e = 0D</p>
</li>
<li>
<p>El complemento a 2 de tamaño 1 byte de 0D es F2+1 = F3</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_if_then_else">10.6.5. If-Then-Else</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Relacionar un programa en lenguaje  C (Ref.  Randal194) y el programa equivalente  en lenguaje ensamblador mediante comentarios en el módulo fuente de bajo nivel:</p>
<div class="ulist">
<ul>
<li>
<p>Módulo C:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="n">Original</span> <span class="n">C</span> <span class="n">code</span>
<span class="mi">1</span> <span class="kt">int</span> <span class="nf">absdiff</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">2</span> <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">)</span>
<span class="mi">3</span> <span class="k">return</span> <span class="n">y</span> <span class="o">-</span> <span class="n">x</span><span class="p">;</span>
<span class="mi">4</span> <span class="k">else</span>
<span class="mi">5</span> <span class="k">return</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">;</span>
<span class="mi">6</span> <span class="p">}</span>

<span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="n">Equivalent</span> <span class="k">goto</span> <span class="n">version</span>
<span class="mi">1</span> <span class="kt">int</span> <span class="nf">gotodiff</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">2</span> <span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
<span class="mi">3</span> <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="n">y</span><span class="p">)</span>
<span class="mi">4</span> <span class="k">goto</span> <span class="n">x_ge_y</span><span class="p">;</span>
<span class="mi">5</span> <span class="n">result</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">x</span><span class="p">;</span>
<span class="mi">6</span> <span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
<span class="mi">7</span> <span class="n">x_ge_y</span><span class="o">:</span>
<span class="mi">8</span> <span class="n">result</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">;</span>
<span class="mi">9</span> <span class="n">done</span><span class="o">:</span>
<span class="mi">10</span> <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="mi">11</span> <span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>Módulo ASM:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="n">Generated</span> <span class="n">assembly</span> <span class="n">code</span>
<span class="n">x</span> <span class="n">at</span> <span class="o">%</span><span class="n">ebp</span><span class="o">+</span><span class="mi">8</span><span class="p">,</span> <span class="n">y</span> <span class="n">at</span> <span class="o">%</span><span class="n">ebp</span><span class="o">+</span><span class="mi">12</span>
<span class="mi">1</span> <span class="n">movl</span> <span class="mi">8</span><span class="p">(</span><span class="o">%</span><span class="n">ebp</span><span class="p">),</span> <span class="o">%</span><span class="n">edx</span> <span class="n">Get</span> <span class="n">x</span>
<span class="mi">2</span> <span class="n">movl</span> <span class="mi">12</span><span class="p">(</span><span class="o">%</span><span class="n">ebp</span><span class="p">),</span> <span class="o">%</span><span class="n">eax</span> <span class="n">Get</span> <span class="n">y</span>
<span class="mi">3</span> <span class="n">cmpl</span> <span class="o">%</span><span class="n">eax</span><span class="p">,</span> <span class="o">%</span><span class="n">edx</span> <span class="n">Compare</span> <span class="n">x</span><span class="o">:</span><span class="n">y</span>
<span class="mi">4</span> <span class="n">jge</span> <span class="p">.</span><span class="n">L2</span> <span class="k">if</span> <span class="o">&gt;=</span> <span class="k">goto</span> <span class="n">x_ge_y</span>
<span class="mi">5</span> <span class="n">subl</span> <span class="o">%</span><span class="n">edx</span><span class="p">,</span> <span class="o">%</span><span class="n">eax</span> <span class="n">Compute</span> <span class="n">result</span> <span class="o">=</span> <span class="n">y</span><span class="o">-</span><span class="n">x</span>
<span class="mi">6</span> <span class="n">jmp</span> <span class="p">.</span><span class="n">L3</span> <span class="n">Goto</span> <span class="n">done</span>
<span class="mi">7</span> <span class="p">.</span><span class="n">L2</span><span class="o">:</span> <span class="n">x_ge_y</span><span class="o">:</span>
<span class="mi">8</span> <span class="n">subl</span> <span class="o">%</span><span class="n">eax</span><span class="p">,</span> <span class="o">%</span><span class="n">edx</span> <span class="n">Compute</span> <span class="n">result</span> <span class="o">=</span> <span class="n">x</span><span class="o">-</span><span class="n">y</span>
<span class="mi">9</span> <span class="n">movl</span> <span class="o">%</span><span class="n">edx</span><span class="p">,</span> <span class="o">%</span><span class="n">eax</span> <span class="n">Set</span> <span class="n">result</span> <span class="n">as</span> <span class="k">return</span> <span class="n">value</span>
<span class="mi">10</span> <span class="p">.</span><span class="n">L3</span><span class="o">:</span> <span class="n">done</span><span class="o">:</span> <span class="n">Begin</span> <span class="n">completion</span> <span class="n">code</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_do_while_loops">10.6.6. Do-While Loops</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Relacionar un programa en lenguaje  C (Ref.  Randal199) y el programa equivalente  en lenguaje ensamblador mediante comentarios en el módulo fuente de bajo nivel:</p>
<div class="ulist">
<ul>
<li>
<p>Módulo C:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="mi">1</span> <span class="kt">int</span> <span class="nf">dw_loop</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">2</span> <span class="k">do</span> <span class="p">{</span>
<span class="mi">3</span> <span class="n">x</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
<span class="mi">4</span> <span class="n">y</span> <span class="o">*=</span> <span class="n">n</span><span class="p">;</span>
<span class="mi">5</span> <span class="n">n</span><span class="o">--</span><span class="p">;</span>
<span class="mi">6</span> <span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">));</span>
<span class="mi">7</span> <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="mi">8</span> <span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>Módulo ASM:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">x</span> <span class="n">at</span> <span class="o">%</span><span class="n">ebp</span><span class="o">+</span><span class="mi">8</span><span class="p">,</span> <span class="n">y</span> <span class="n">at</span> <span class="o">%</span><span class="n">ebp</span><span class="o">+</span><span class="mi">12</span><span class="p">,</span> <span class="n">n</span> <span class="n">at</span> <span class="o">%</span><span class="n">ebp</span><span class="o">+</span><span class="mi">16</span>

<span class="mi">1</span> <span class="n">movl</span> <span class="mi">8</span><span class="p">(</span><span class="o">%</span><span class="n">ebp</span><span class="p">),</span> <span class="o">%</span><span class="n">eax</span>
<span class="mi">2</span> <span class="n">movl</span> <span class="mi">12</span><span class="p">(</span><span class="o">%</span><span class="n">ebp</span><span class="p">),</span> <span class="o">%</span><span class="n">ecx</span>
<span class="mi">3</span> <span class="n">movl</span> <span class="mi">16</span><span class="p">(</span><span class="o">%</span><span class="n">ebp</span><span class="p">),</span> <span class="o">%</span><span class="n">edx</span>
<span class="mi">4</span> <span class="p">.</span><span class="n">L2</span><span class="o">:</span>
<span class="mi">5</span> <span class="n">addl</span> <span class="o">%</span><span class="n">edx</span><span class="p">,</span> <span class="o">%</span><span class="n">eax</span>
<span class="mi">6</span> <span class="n">imull</span> <span class="o">%</span><span class="n">edx</span><span class="p">,</span> <span class="o">%</span><span class="n">ecx</span>
<span class="mi">7</span> <span class="n">subl</span> <span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="o">%</span><span class="n">edx</span>
<span class="mi">8</span> <span class="n">testl</span> <span class="o">%</span><span class="n">edx</span><span class="p">,</span> <span class="o">%</span><span class="n">edx</span>
<span class="mi">9</span> <span class="n">jle</span> <span class="p">.</span><span class="n">L5</span>
<span class="mi">10</span> <span class="n">cmpl</span> <span class="o">%</span><span class="n">edx</span><span class="p">,</span> <span class="o">%</span><span class="n">ecx</span>
<span class="mi">11</span> <span class="n">jl</span> <span class="p">.</span><span class="n">L2</span>
<span class="mi">12</span> <span class="p">.</span><span class="n">L5</span><span class="o">:</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Write a goto version of the function (in C) that mimics how the assembly code program operates.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Relacionar un programa en lenguaje  C (Ref.  Randal201) y el programa equivalente  en lenguaje ensamblador mediante comentarios en el módulo fuente de bajo nivel:</p>
<div class="ulist">
<ul>
<li>
<p>Módulo C:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="mi">1</span> <span class="kt">int</span> <span class="n">loop_while</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="mi">2</span> <span class="p">{</span>
<span class="mi">3</span> <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="mi">4</span> <span class="k">while</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">5</span> <span class="n">result</span> <span class="o">*=</span> <span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">);</span>
<span class="mi">6</span> <span class="n">a</span><span class="o">++</span><span class="p">;</span>
<span class="mi">7</span> <span class="p">}</span>
<span class="mi">8</span> <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="mi">9</span> <span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>Ensamblaje: In generating the assembly code, gcc makes an interesting transformation that, in effect, introduces a new program variable. Register %edx is initialized on line 6 and updated within the loop on line 11. Describe how it relates to the
variables in the C code. Create a table of register usage for this function.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">a</span> <span class="n">at</span> <span class="o">%</span><span class="n">ebp</span><span class="o">+</span><span class="mi">8</span><span class="p">,</span> <span class="n">b</span> <span class="n">at</span> <span class="o">%</span><span class="n">ebp</span><span class="o">+</span><span class="mi">12</span>

<span class="mi">1</span> <span class="n">movl</span> <span class="mi">8</span><span class="p">(</span><span class="o">%</span><span class="n">ebp</span><span class="p">),</span> <span class="o">%</span><span class="n">ecx</span>
<span class="mi">2</span> <span class="n">movl</span> <span class="mi">12</span><span class="p">(</span><span class="o">%</span><span class="n">ebp</span><span class="p">),</span> <span class="o">%</span><span class="n">ebx</span>
<span class="mi">3</span> <span class="n">movl</span> <span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="o">%</span><span class="n">eax</span>
<span class="mi">4</span> <span class="n">cmpl</span> <span class="o">%</span><span class="n">ebx</span><span class="p">,</span> <span class="o">%</span><span class="n">ecx</span>
<span class="mi">5</span> <span class="n">jge</span> <span class="p">.</span><span class="n">L11</span>
<span class="mi">6</span> <span class="n">leal</span> <span class="p">(</span><span class="o">%</span><span class="n">ebx</span><span class="p">,</span><span class="o">%</span><span class="n">ecx</span><span class="p">),</span> <span class="o">%</span><span class="n">edx</span>
<span class="mi">7</span> <span class="n">movl</span> <span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="o">%</span><span class="n">eax</span>
<span class="mi">8</span> <span class="p">.</span><span class="n">L12</span><span class="o">:</span>
<span class="mi">9</span> <span class="n">imull</span> <span class="o">%</span><span class="n">edx</span><span class="p">,</span> <span class="o">%</span><span class="n">eax</span>
<span class="mi">10</span> <span class="n">addl</span> <span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="o">%</span><span class="n">ecx</span>
<span class="mi">11</span> <span class="n">addl</span> <span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="o">%</span><span class="n">edx</span>
<span class="mi">12</span> <span class="n">cmpl</span> <span class="o">%</span><span class="n">ecx</span><span class="p">,</span> <span class="o">%</span><span class="n">ebx</span>
<span class="mi">13</span> <span class="n">jg</span> <span class="p">.</span><span class="n">L12</span>
<span class="mi">14</span> <span class="p">.</span><span class="n">L11</span><span class="o">:</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Relacionar un programa en lenguaje  C (Ref.  Randal204) y el programa equivalente  en lenguaje ensamblador mediante comentarios en el módulo fuente de bajo nivel:</p>
<div class="ulist">
<ul>
<li>
<p>Módulo C:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="mi">1</span> <span class="kt">int</span> <span class="n">fact_for_goto</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="mi">2</span> <span class="p">{</span>
<span class="mi">3</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="mi">4</span> <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="mi">5</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">))</span>
<span class="mi">6</span> <span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
<span class="mi">7</span> <span class="n">loop</span><span class="o">:</span>
<span class="mi">8</span> <span class="n">result</span> <span class="o">*=</span> <span class="n">i</span><span class="p">;</span>
<span class="mi">9</span> <span class="n">i</span><span class="o">++</span><span class="p">;</span>
<span class="mi">10</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">)</span>
<span class="mi">11</span> <span class="k">goto</span> <span class="n">loop</span><span class="p">;</span>
<span class="mi">12</span> <span class="n">done</span><span class="o">:</span>
<span class="mi">13</span> <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="mi">14</span> <span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>Módulo asm</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="nl">Argument:</span> <span class="n">n</span> <span class="n">at</span> <span class="o">%</span><span class="n">ebp</span><span class="o">+</span><span class="mi">8</span>
<span class="n">Registers</span><span class="o">:</span> <span class="n">n</span> <span class="n">in</span> <span class="o">%</span><span class="n">ecx</span><span class="p">,</span> <span class="n">i</span> <span class="n">in</span> <span class="o">%</span><span class="n">edx</span><span class="p">,</span> <span class="n">result</span> <span class="n">in</span> <span class="o">%</span><span class="n">eax</span>

<span class="mi">1</span> <span class="n">movl</span> <span class="mi">8</span><span class="p">(</span><span class="o">%</span><span class="n">ebp</span><span class="p">),</span> <span class="o">%</span><span class="n">ecx</span> <span class="n">Get</span> <span class="n">n</span>
<span class="mi">2</span> <span class="n">movl</span> <span class="err">$</span><span class="mi">2</span><span class="p">,</span> <span class="o">%</span><span class="n">edx</span> <span class="n">Set</span> <span class="n">i</span> <span class="n">to</span> <span class="mi">2</span> <span class="p">(</span><span class="n">init</span><span class="p">)</span>
<span class="mi">3</span> <span class="n">movl</span> <span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="o">%</span><span class="n">eax</span> <span class="n">Set</span> <span class="n">result</span> <span class="n">to</span> <span class="mi">1</span>
<span class="mi">4</span> <span class="n">cmpl</span> <span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="o">%</span><span class="n">ecx</span> <span class="n">Compare</span> <span class="n">n</span><span class="o">:</span><span class="mi">1</span> <span class="p">(</span><span class="o">!</span><span class="n">test</span><span class="p">)</span>
<span class="mi">5</span> <span class="n">jle</span> <span class="p">.</span><span class="n">L14</span> <span class="n">If</span> <span class="o">&lt;=</span><span class="p">,</span> <span class="k">goto</span> <span class="n">done</span>
<span class="mi">6</span> <span class="p">.</span><span class="n">L17</span><span class="o">:</span> <span class="n">loop</span><span class="o">:</span>
<span class="mi">7</span> <span class="n">imull</span> <span class="o">%</span><span class="n">edx</span><span class="p">,</span> <span class="o">%</span><span class="n">eax</span> <span class="n">Compute</span> <span class="n">result</span> <span class="o">*=</span> <span class="n">i</span> <span class="p">(</span><span class="n">body</span><span class="p">)</span>
<span class="mi">8</span> <span class="n">addl</span> <span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="o">%</span><span class="n">edx</span> <span class="n">Increment</span> <span class="n">i</span> <span class="p">(</span><span class="n">update</span><span class="p">)</span>
<span class="mi">9</span> <span class="n">cmpl</span> <span class="o">%</span><span class="n">edx</span><span class="p">,</span> <span class="o">%</span><span class="n">ecx</span> <span class="n">Compare</span> <span class="n">n</span><span class="o">:</span><span class="n">i</span> <span class="p">(</span><span class="n">test</span><span class="p">)</span>
<span class="mi">10</span> <span class="n">jge</span> <span class="p">.</span><span class="n">L17</span> <span class="n">If</span> <span class="o">&gt;=</span><span class="p">,</span> <span class="k">goto</span> <span class="n">loop</span>
<span class="mi">11</span> <span class="p">.</span><span class="n">L14</span><span class="o">:</span> <span class="n">done</span><span class="o">:</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_lenguaje_de_programación_c">10.7. Lenguaje de Programación C</h3>
<div class="sect3">
<h4 id="_punteros">10.7.1. Punteros</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Editar y ejecutar el siguiente programa en lenguaje C interpretando el resultado sabiendo que lista es una "variable puntero" que apunta al elemento lista[0].</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>

  <span class="kt">int</span> <span class="n">lista</span><span class="p">[]</span><span class="o">=</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span>

  <span class="n">printf</span> <span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s"> **********ARRAY LISTA***********"</span><span class="p">);</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s"> *******lista es una VARIABLE PUNTERO*******"</span><span class="p">);</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s"> **la variable lista contiene la dirección de lista[0]*******</span><span class="se">\n\n</span><span class="s">"</span><span class="p">)</span> <span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s"> lista[0] = %d es el 1º elemento de lista </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">lista</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s"> lista = %p es la dirección del 1º elemento </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">lista</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s"> &amp;lista[0] = %p es la dirección del 1º elemento </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lista</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s"> *lista = %d equivale a lista[0] </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">lista</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s"> *&amp;lista = %p equivale a lista </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*&amp;</span><span class="n">lista</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s"> **&amp;lista = %d equivale a lista[0] </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">**&amp;</span><span class="n">lista</span><span class="p">);</span>

  <span class="n">printf</span> <span class="p">(</span><span class="s">"</span><span class="se">\n\n</span><span class="s"> *******ARITMETICA DE PUNTEROS*******"</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s"> *(lista+1) = %d equivale a lista[1] </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">lista</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s"> *(lista+4) = %d equivale a lista[4] </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">lista</span><span class="o">+</span><span class="mi">4</span><span class="p">));</span>

  <span class="n">printf</span> <span class="p">(</span><span class="s">"</span><span class="se">\n\n</span><span class="s"> *******CASTING*******"</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s"> (int *)lista = %p  </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">lista</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s"> *(int *)lista = %d </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">lista</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s"> *(int)lista+1 = %d </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">lista</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s"> *(int)lista+4 = %d </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">lista</span><span class="o">+</span><span class="mi">4</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s"> *((short *)lista+1) = %d . Ahora lista lo declaro con elementos de 2  bytes </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="p">((</span><span class="kt">short</span> <span class="o">*</span><span class="p">)</span><span class="n">lista</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>Al depurar con el depurador GDB un programa escrito en lenguaje ensamblador donde se ha declarado la directiva <code>lista: .int 1,2,3,4,5</code>, deducir las siguientes sentencias si la etiqueta lista es ensamblada como la dirección 0x55bf0000 y por lo tanto no es una variable puntero, sino que es el mismo puntero, es decir, la dirección del primer elemento del array lista. Indicar la relación entre el mapa de direcciones de memoria y el mapa de posiciones de elementos del array lista.</p>
<div class="listingblock">
<div class="content">
<pre>&amp;lista	: dirección de la "variable array" lista para el elemento de la posición 0  : 0x55bf0000
&amp;lista+1         	: 0x55bf0004 -&gt; dirección para el elemento de la posición 1.
(void *)&amp;lista+1  	: 0x55bf0001
(int  *)&amp;lista+1   	: 0x55bf0004
lista                	: 1 -&gt; equivale a lista[0]
(int)lista	       	: 1
(int *)&amp;lista		: 0x55bf0000
(int [5])lista		: {1,2,3,4,5}
*(int *)&amp;lista+1	: 2</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_capitulo_4_memoria_cache">10.8. Capitulo 4: Memoria Cache</h3>
<div class="ulist">
<ul>
<li>
<p>Ejemplo 4.2a Pg118. The system has a Cache memory of 64KB  and Main Memory of 16MB with a byte word size and four word block size. For a cache controller with direct mapping correspondence function search the main memory block addresses correspondences to cache memory 0x0CE7 number line .</p>
<div class="ulist">
<ul>
<li>
<p>Desarrollo:</p>
<div class="ulist">
<ul>
<li>
<p>Memoria principal: 16MB, byte word, 4 byte block.</p>
<div class="ulist">
<ul>
<li>
<p>16MB &#8594; 2<sup>24</sup> &#8594; 24 bits address bus</p>
</li>
</ul>
</div>
</li>
<li>
<p>Memoria cache: 64KB, 4 byte line, 16K lines.</p>
<div class="ulist">
<ul>
<li>
<p>16K &#8594; 2<sup>14</sup>&#8594; 14 bits campo de línea</p>
</li>
</ul>
</div>
</li>
<li>
<p>Direct mapping correspondence function: 0x0CE7 cache line</p>
</li>
<li>
<p>i=j mod m donde i es el número de línea, j el número de bloque y m el número de líneas de la caché.</p>
</li>
<li>
<p>la dirección de 24 bits se descompone en : etiqueta-línea-palabra</p>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/ditaa/svg/eNqz0UUGRiYKSZklxQgBOy5tXbxAm6smJDFdAQxqFHwy81IV8kpzk1KLahTC84tSgIKETbDR1bUAW2sHZOkamkCcAOQYQUQBW50lTA==" alt="Diagram">
</div>
</div>
</li>
<li>
<p>Cada tag agrupa 16K bloques &#8594; 16K bloquesx4bytes/bloquexnúmero de tags N=16MB &#8594; 2<sup>14</sup>x2<sup>2</sup>xN=2<sup>24</sup>bytes &#8594; N=2<sup>8</sup> Tags</p>
</li>
<li>
<p>0CE7 : 14 bits: 00-1100-1110-0111. Buscamos las direcciones de memoria asociadas a dicha línea.</p>
<div class="ulist">
<ul>
<li>
<p>Tag 0, 	Linea 0CE7, Palabra 0 	&#8594; 0000-0000-00-1100-1110-0111-00 = 0000-0000-0011-0011-1001-1100 &#8594; 00339C</p>
</li>
<li>
<p>Tag 1, 	Línea 0CE7, Palabra 0 	&#8594; cambia el primer dígito a 1 					&#8594; 01339C</p>
</li>
<li>
<p>Tag 255,	Línea 0CE7, Palabra 0 	&#8594; cambia el primer dígito a FF					&#8594; FF339C</p>
</li>
<li>
<p>Las direcciones de memoria son la dirección de la primera palabra de bloque en Memoria Principal.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>4.1 A set-associative cache consists of 64 lines, or slots, divided into four-line sets. Main memory contains 4K blocks of 128 words each. Show the format of main memory addresses.</p>
<div class="ulist">
<ul>
<li>
<p>Desarrollo:</p>
<div class="ulist">
<ul>
<li>
<p>Caché: 64 líneas de 128 palabras cada una agrupadas en sets de 4 líneas</p>
<div class="ulist">
<ul>
<li>
<p>128 palabras &#8594; 7 bits para direccionar la palabra dentro de la línea</p>
</li>
<li>
<p>16 sets &#8594; 2<sup>4</sup> &#8594; 4 bits para direccionar los sets dentro de la caché</p>
</li>
</ul>
</div>
</li>
<li>
<p>Main memory: 4Kblocks de 2<sup>7</sup>palabras</p>
<div class="ulist">
<ul>
<li>
<p>12 bits para direccionar un bloque</p>
</li>
<li>
<p>2<sup>19</sup> palabras&#8594;512Kpalabras &#8594; 19 bits para direccionar una palabras &#8594; ancho bus de direcciones</p>
</li>
</ul>
</div>
</li>
<li>
<p>set associative &#8594; i = j mod v donde v es el número de sets, j el bloque e i el set</p>
<div class="ulist">
<ul>
<li>
<p>Tag &#8594; código para diferenciar los bloques que van al mismo set.  bits Tag=bits totales - bits Set - bits Word=19-4-7=8 bits.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Tag/Set/Word &#8594; 19 address bits descompuestos en los 3 campos de 8/4/7 bits</p>
</li>
</ul>
</div>
</li>
<li>
<p>Sol:</p>
<div class="ulist">
<ul>
<li>
<p>Tag/Set/Word : 8/4/7</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>4.3 For the hexadecimal main memory addresses 111111, 666666,BBBBBB, show the following
information, in hexadecimal format:</p>
<div class="olist loweralpha">
<ol class="loweralpha">
<li>
<p>Tag, Line, and Word values for a direct-mapped cache, using the format of Figure 4.10</p>
</li>
<li>
<p>Tag and Word values for an associative cache, using the format of Figure 4.12</p>
</li>
<li>
<p>Tag, Set, and Word values for a two-way set-associative cache, using the format of Figure 4.15</p>
<div class="ulist">
<ul>
<li>
<p>Desarrollo:</p>
<div class="ulist">
<ul>
<li>
<p>a) Direct mapped Tag/Line/Word 		&#8594; 24 address bits descompuestos en los 3 campos de 8/14/2 bits</p>
<div class="ulist">
<ul>
<li>
<p>111111 = 0001-0001-0001-0001-0001-0001 = 00010001-00010001000100-01=0001-0001-00-0100-0100-0100-01=11-0444-1 &#8594; El 0 no se escribe en hex por la izda</p>
</li>
</ul>
</div>
</li>
<li>
<p>b) Full associative cache Tag/Word 		&#8594; 24 address bits descompuestos en los 2 campos de 22/2 bits</p>
<div class="ulist">
<ul>
<li>
<p>111111 = 0001-0001-0001-0001-0001-0001 = 0001000100010001000100-01=00-0100-0100-0100-0100-0100-01=044444-1 &#8594; El 0 no se escribe en hex por la izda</p>
</li>
</ul>
</div>
</li>
<li>
<p>c) Set associative cache Tag/Set/Word 	&#8594; 24 address bits descompuestos en los 3 campos de 9/13/2</p>
<div class="ulist">
<ul>
<li>
<p>111111 = 0001-0001-0001-0001-0001-0001 = 000100010-0010001000100-01=0-0010-0010-0-0100-0100-0100-01=022/0444/1-1 &#8594; El 0 no se escribe en hex por la izda</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Sol:</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</li>
</ul>
</div>
<table class="tableblock frame-ends grid-all" style="width: 80%;">
<caption class="title">Table 22. Direcciones</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Address</th>
<th class="tableblock halign-left valign-top">111111</th>
<th class="tableblock halign-left valign-top">666666</th>
<th class="tableblock halign-left valign-top">BBBBBB</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>a. Tag/Line/Word</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>11/444/1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>66/1999/2</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BB/2EEE/3</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>b. Tag/Word</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>44444/1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>199999/2</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>2EEEEE/3</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>c. Tag/Set/Word</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>22/444/1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CC/1999/2</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>177/EEE/3</code></p></td>
</tr>
</tbody>
</table>
<div class="ulist">
<ul>
<li>
<p>4.5 Consider a 32-bit microprocessor that has an on-chip 16-KByte four-way set-associative cache. Assume that the cache has a line size of four 32-bit words.</p>
<div class="olist loweralpha">
<ol class="loweralpha">
<li>
<p>Draw a block diagram of this cache showing its organization and how the different address fields are used to determine a cache hit/miss.</p>
</li>
<li>
<p>Where in the cache is the word from memory location ABCDE8F8 mapped</p>
<div class="ulist">
<ul>
<li>
<p>Desarrollo:</p>
<div class="ulist">
<ul>
<li>
<p>Memoria principal</p>
<div class="ulist">
<ul>
<li>
<p>no dice nada del bus externo, supongo el máximo de 32 bits &#8594; 2<sup>32</sup>Bytes &#8594; 4GB</p>
</li>
</ul>
</div>
</li>
<li>
<p>Cache on-chip: bus local: 32 bits data bus y address bus: Set associative de 4 líneas por set.</p>
<div class="ulist">
<ul>
<li>
<p>4 palabras de 4 bytes cada una por línea hacen un total de 16 bytes por línea (4 bits en el campo word). El código de 4 bits direcciona el primer byte de cada palabra (0x0 la palabra 0, 0x4 la palabra 1, 0x8 la palabra 2, 0xC la palabra 3)</p>
</li>
<li>
<p>El número de sets es capacidad total/bytes por set = 16KB / (4líneas/set)<strong>(4palabras/línea)</strong>(4bytes/palabra) = 16KB/64B = 2<sup>8</sup>=256 sets &#8594; 8bits</p>
</li>
<li>
<p>el número de bloques en cache es capacidad/bytes_por_línea= 16KB/(4palabras/línea)*(4bytes/palabra)=1Kbloques</p>
</li>
<li>
<p>los 1kbloques se asocian en sets de 4 líneas.</p>
</li>
<li>
<p>address bus=tag bits+set bits+word bits &#8594; 32=tag bits+8+4 &#8594; tag_bits=32-8-4=20 bits. El campo Tag distingue bloques dentro del mismo set.</p>
</li>
<li>
<p>¿que bloques van al mismo set? i = j mod v, donde i es el número de set al que va el bloque j, v es el número de sets. Es decir, 2^20 bloques están asocidos al mismo set por lo que han de compartir 4 líneas &#8594; 4 para 20.</p>
</li>
<li>
<p>Tag/Set/Word &#8594; 32 address bits descompuestos en los 3 campos de 20/8/4 bits</p>
</li>
</ul>
</div>
</li>
<li>
<p>a) Después de la descomposición tag/set/word se selecciona el set direccionado y se comparan los tags de las 4 líneas con el tag de la dirección absoluta. Son 4 comparadores, uno por vía. Al Comparador_1 irán la primera línea de cada set en que dividimos la memoria principal. 2<sup>32</sup> bytes los agrupo en sets de 16 palabras por set &#8594; la memoria principal queda dividida en 2<sup>8</sup> sets</p>
</li>
<li>
<p>b) Descomposición 20/8/4 de la dirección ABCD8F8&#8594; ABCD/8F/8 &#8594; 8F es el set 143 y el byte 8 es la palabra número 2.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Sol:
a&#8230;&#8203;   Descomposición: Tag/Set/Offset . 4 comparadores: 1 por cada vía del Set.
b&#8230;&#8203;   Set 143, cualquier línea, la doblepalabra número 2.</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>4.7 The Intel 80486 has an on-chip, unified cache. It contains 8 KBytes and has a four-way set-associative organization and a block length of four 32-bit words. The cache is organized into 128 sets. There is a single “line valid bit” and three bits, B0, B1, and B2
(the “LRU” bits), per line. On a cache miss, the 80486 reads a 16-byte line from main memory in a bus memory read burst.</p>
<div class="olist loweralpha">
<ol class="loweralpha">
<li>
<p>Draw a simplified diagram of the cache</p>
</li>
<li>
<p>show how the different fields of the address are interpreted.</p>
<div class="ulist">
<ul>
<li>
<p>Desarrollo:</p>
<div class="ulist">
<ul>
<li>
<p>Intel 80486 ( Pag 38,47,130) tiene un bus de memoria de 32 bits &#8594; address bus de 32 bits que direccionan 1 byte.</p>
</li>
<li>
<p>Caché: 8KB, set-associative de 4 vías, cada línea 4 palabras de 4 bytes (16 bytes con 4 bits), y 128 sets (7 bits)</p>
<div class="ulist">
<ul>
<li>
<p>4 palabras de 4 bytes cada una por línea hacen un total de 16 bytes por línea (4 bits en el campo word). El código de 4 bits direcciona el primer byte de cada palabra (0x0 la palabra 0, 0x4 la palabra 1, 0x8 la palabra 2, 0xC la palabra 3)</p>
</li>
</ul>
</div>
</li>
<li>
<p>Descomposición de los 32 bits : Tag/Set/Offset &#8594; 21/7/4</p>
</li>
<li>
<p>Además de los 32 bits es necesario añadir:</p>
<div class="ulist">
<ul>
<li>
<p>3 bits USO para indicar de las cuatro líneas quien es la MENOS recientemente utilizada, la de menor valor de los 8 posibles: 000-001-010-011-100-101-110-111</p>
</li>
<li>
<p>1 bit de validación que indica con el valor 1 que hace falta su actualización en MP antes de sobreescribir la línea &#8594; técnica de postescritura.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Línea: Valid/LRU/Tag/Set/Offset &#8594; 1/3/21/7/4</p>
</li>
</ul>
</div>
</li>
<li>
<p>Solución:
a.. Esquema Set associative
b.. Valid/LRU/Tag/Set/Offset &#8594; 1/3/21/7/4</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>4.15 Consider the following code:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">=</span><span class="mi">20</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
   <span class="k">for</span> <span class="p">(</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">=</span><span class="mi">10</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
         <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">j</span> <span class="p">;</span></code></pre>
</div>
</div>
<div class="olist loweralpha">
<ol class="loweralpha">
<li>
<p>Give one example of the spatial locality in the code.</p>
</li>
<li>
<p>Give one example of the temporal locality in the code.</p>
<div class="ulist">
<ul>
<li>
<p>Desarrollo</p>
<div class="ulist">
<ul>
<li>
<p>en el bucle interno siempre se repite la misma instrucción, siempre accedes a la misma dirección donde esta la instrucción &#8594; localidad espacial</p>
</li>
<li>
<p>en el bucle interno siempre se repite la misma instrucción, el futuro es el presente &#8594; localidad temporal</p>
</li>
<li>
<p>en el bucle interno con j=0 accedes al operando a[0] y en la siguiente iteracción se repite el mismo operando a[0] &#8594; localidad espacial y temporal.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>4.18 Consider a cache of 4 lines of 16 bytes each. Main memory is divided into blocks of
16 bytes each. That is, block 0 has bytes with addresses 0 through 15, and so on. Now
consider a program that accesses memory in the following sequence of addresses:</p>
<div class="literalblock">
<div class="content">
<pre>Once: 63 through 70
Loop ten times: 15 through 32; 80 through 95</pre>
</div>
</div>
<div class="olist loweralpha">
<ol class="loweralpha">
<li>
<p>Suppose the cache is organized as direct mapped. Memory blocks 0, 4, and so on are
assigned to line 1; blocks 1, 5, and so on to line 2; and so on. Compute the hit ratio.</p>
</li>
<li>
<p>Suppose the cache is organized as two-way set associative, with two sets of two
lines each. Even-numbered blocks are assigned to set 0 and odd-numbered blocks
are assigned to set 1. Compute the hit ratio for the two-way set-associative cache
using the least recently used replacement scheme.</p>
</li>
</ol>
</div>
</li>
<li>
<p>4.21 Consider a single-level cache with an access time of 2.5 ns, a line size of 64 bytes, and a
hit ratio of H = 0.95. Main memory uses a block transfer capability that has a firstword
(4 bytes) access time of 50 ns and an access time of 5 ns for each word thereafter.</p>
<div class="olist loweralpha">
<ol class="loweralpha">
<li>
<p>What is the access time when there is a cache miss? Assume that the cache waits
until the line has been fetched from main memory and then re-executes for a hit.</p>
</li>
<li>
<p>Suppose that increasing the line size to 128 bytes increases the H to 0.97. Does this
reduce the average memory access time?</p>
</li>
</ol>
</div>
</li>
<li>
<p>4.24 On the Motorola 68020 microprocessor, a cache access takes two clock cycles. Data
access from main memory over the bus to the processor takes three clock cycles in the
case of no wait state insertion; the data are delivered to the processor in parallel with
delivery to the cache.</p>
<div class="olist loweralpha">
<ol class="loweralpha">
<li>
<p>Calculate the effective length of a memory cycle given a hit ratio of 0.9 and a
clocking rate of 16.67 MHz.</p>
</li>
<li>
<p>Repeat the calculations assuming insertion of two wait states of one cycle each
per memory cycle.What conclusion can you draw from the results?</p>
</li>
</ol>
</div>
</li>
<li>
<p>4.27 For a system with two levels of cache, define Tc1 first-level cache access time; Tc2
second-level cache access time; Tm memory access time;H1 first-level cache hit
ratio;H2 combined first/second level cache hit ratio. Provide an equation for Ta for
a read operation.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_capitulo_5_memoria_sincrona_dinamica_ram_sdram">10.9. Capitulo 5: Memoria Sincrona Dinamica RAM (SDRAM)</h3>
<div class="ulist">
<ul>
<li>
<p>5.x La arquitectura de un computador Intel tiene un bus del sistema con una frecuencia de reloj de 100MHz, el ancho del bus de datos son 64 bits y el ancho del bus de direcciones de la placa base es de 48 bits.</p>
<div class="olist loweralpha">
<ol class="loweralpha">
<li>
<p>Calcular el ancho de banda del bus en transferencias/s y en bytes/s</p>
</li>
<li>
<p>Calcular la capacidad de memoria</p>
</li>
<li>
<p>Calcular el ciclo de memoria teniendo en cuenta que la latencia de la memoria DRAM son 10ns.</p>
<div class="ulist">
<ul>
<li>
<p>Desarrollo</p>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>100 x 10<sup>6</sup> ciclos/seg x 1Transferencia/ciclo = 100MT/s</p>
</li>
<li>
<p>bus de direcciones &#8594; 2<sup>48</sup> Words =  2<sup>8</sup> x 2<sup>40</sup> = 256 TWords = 2<sup>48</sup> x 2<sup>3</sup> Bytes = 2 x 2<sup>50</sup> = 2 petabytes</p>
</li>
<li>
<p>ciclo de memoria ideal (sin bus multiplexado, sin precarga, etc)= 1 Transferencia= latencia_memoria + latencia_bus_transferencia = 10ns + 1/(10<sup>8</sup>) = 10ns + 10ns = 20 ns</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>5.2 Consider a dynamic RAM that must be given a refresh cycle 64 times per ms. Each refresh operation requires 150 ns; a memory cycle requires 250 ns.What percentage of the memory’s total operating time must be given to refreshes?</p>
<div class="ulist">
<ul>
<li>
<p>Desarrollo</p>
<div class="ulist">
<ul>
<li>
<p>en 1 ms 64 refrescos de 150ns &#8594; 9600 ns refrescando</p>
</li>
<li>
<p>9600ns/1ms = 0.0096 = 1%</p>
</li>
</ul>
</div>
</li>
<li>
<p>Sol:</p>
<div class="olist loweralpha">
<ol class="loweralpha">
<li>
<p>1%</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>5.3 Figure 5.16 shows a simplified timing diagram for a DRAM read operation over a bus. The access time is considered to last from t1 to t2. Then there is a recharge time, lasting from t2 to t3, during which the DRAM chips will have to recharge before the processor can access them again.</p>
<div class="olist loweralpha">
<ol class="loweralpha">
<li>
<p>Assume that the access time is 60 ns and the recharge time is 40 ns.What is the memory cycle time? What is the maximum data rate this DRAM can sustain, assuming a 1-bit output?</p>
</li>
<li>
<p>Constructing a 32-bit wide memory system using these chips yields what data transfer rate?</p>
<div class="ulist">
<ul>
<li>
<p>Desarrollo:</p>
</li>
<li>
<p>t1&#8594;t2 : direccionamiento</p>
</li>
<li>
<p>t2&#8594;t3</p>
<div class="ulist">
<ul>
<li>
<p>acceso al dato</p>
</li>
<li>
<p>recarga del bus de direcciones a medio camino entre el 0 y el 1</p>
</li>
<li>
<p>60ns de latencia y 40 de precarga = 100 ns de ciclo de memoria entre 2 lecturas consecutivas</p>
<div class="ulist">
<ul>
<li>
<p>durante la precarga se realizaría el burst que puede ser mayor, menor o igual a la precarga</p>
</li>
</ul>
</div>
</li>
<li>
<p>El ciclo de bus de 100 ns son 1/100ns= 10MHz. Si transferimos un bit por ciclo de bus= 10Mbps</p>
</li>
<li>
<p>Si utilizamos 32 líneas en paralelo = 32 bits/transferencia x 10MT/s = 320Mbps = 40 MB/s</p>
</li>
</ul>
</div>
</li>
<li>
<p>Sol:</p>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>tcycle = 100ns. BW=10Mbps</p>
</li>
<li>
<p>40MB/s</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>5.4 Figure 5.6 indicates how to construct a module of chips that can store 1 MByte based on a group of four 256-Kbyte chips. Let’s say this module of chips is packaged as a single 1-Mbyte chip, where the word size is 1 byte. Give a high-level chip diagram of how to construct an 8-Mbyte computer memory using eight 1-Mbyte chips. Be sure to show the address lines in your diagram and what the address lines are used for.</p>
<div class="ulist">
<ul>
<li>
<p>Desarrollo:</p>
<div class="ulist">
<ul>
<li>
<p>Con 4 chips de 256Kbit creo un módulo-chip de 1Mb</p>
</li>
<li>
<p>Con 8 chips de 1Mb creo un módulo de 8Mb llevando distintos chip select a cada chip de 1Mb. Para seleccionar 1 chip de 8 necesito 3 bits de direcciones, por ejemplo los 3 bits de mayor posición. Para direccionar un bit de un chip 1Mb necesito un bus de direcciones de 20 bits. En total necesito un bus de 20+3=23 bits.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Sol:</p>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>8 chips x1 de capacidad 1M donde cada entrada chip-select es la salida de un decodificador de 3 líneas de dirección</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>5.5 On a typical Intel 8086-based system, connected via system bus to DRAM memory, for a read operation, RAS is activated by the trailing edge of the Address Enable signal (Figure 3.19). However, due to propagation and other delays, RAS does not go active until 50 ns after Address Enable returns to a low. Assume the latter occurs in the middle of the second half of state T1 (somewhat earlier than in Figure 3.19). Data are read by the processor at the end of T3. For timely presentation to the processor, however, data must be provided 60 ns earlier by memory. This interval accounts for propagation delays along the data paths (from memory to processor) and processor data hold time requirements. Assume a clocking rate of 10 MHz.</p>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>How fast (access time) should the DRAMs be if no wait states are to be inserted?</p>
</li>
<li>
<p>How many wait states do we have to insert per memory read operation if the access time of the DRAMs is 150 ns?</p>
<div class="ulist">
<ul>
<li>
<p>Desarrollo:</p>
<div class="ulist">
<ul>
<li>
<p>Ciclo de lectura</p>
<div class="ulist">
<ul>
<li>
<p>Load address - Address Enable (EA)- Address Command - Access Data</p>
</li>
<li>
<p>Trailing edge = fall edge = negative edge</p>
</li>
<li>
<p>AE fall = en la segunda mitad del ciclo T1. Instante 75ns</p>
</li>
<li>
<p>RAS = Read Command : Retardo de 50ns respecto de AE fall. Instante 75+50=125ns</p>
</li>
<li>
<p>La presentación del dato en el bus debe ser realizada con 60 ns de antelación a la carga del dato en la CPU la final del ciclo T3(300ns), es decir, 300ns-60ns=240ns</p>
</li>
<li>
<p>Reloj del bus del sistema = 10 MHz = 100 ns.</p>
<div class="olist upperalpha">
<ol class="upperalpha" type="A">
<li>
<p>Tiempo de acceso (desde la orden de lectura hasta volcar el dato la memoria) sin estados de espera = Tiempo de acceso mínimo impuesto por los retardos de la ruta de datos (CPU y bus): 240ns - 125ns = 115ns</p>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/ditaa/svg/eNpTUMAKDBSIAMYGBnnFXDgkbXRBIMQQRNpBOUbIHGMwB5d2sBpyOFzOOfnJ2egm6eqD2THkc7hwh4O5Kc5ggPgVn0fhbuRyTEkpSi0uVnDNS0zKSYU5HOGSGF1iARcxsadgiif2SPYBWnBzBaUmpmAKowJI-BL2F3EWQ4BjcnJqsUJIZm6qgkd-TgqYRYp-hHeRPO6SWJJIyDMYIAIOyPMJVpcokAQMDYEpE8wyIyquEXZiAyTZDo7_5MrknFQAEne0Hg==" alt="Diagram">
</div>
</div>
</li>
<li>
<p>Si la memoria DRAM tiene un tiempo de acceso 150ns, superior a un ciclo de bus, desde la orden de lectura la cpu debe de esperar dos ciclos de reloj, uno el propio ciclo de la orden de lectura y otro ciclo extra o ciclo de ESPERA. Por lo que 200ns son suficientes para superar los 150ns del tiempo de acceso. Si el ciclo de espera comienza después de los 115ns, tenemos 215ns que superan a los 150ns.</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Sol:</p>
</li>
</ul>
</div>
</li>
<li>
<p>115ns</p>
</li>
<li>
<p>1</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_capitulo_7_sistemas_entradasalida">10.10. Capitulo 7: Sistemas Entrada/Salida</h3>
<div class="ulist">
<ul>
<li>
<p>7.1 On a typical microprocessor, a distinct I/O address is used to refer to the I/O data registers and a distinct address for the control and status registers in an I/O controller for a given device. Such registers are referred to as ports. In the Intel 8088, two I/O instruction
formats are used. In one format, the 8-bit opcode specifies an I/O operation; this is followed by an 8-bit port address. Other I/O opcodes imply that the port address is in the 16-bit DX register. How many ports can the 8088 address in each I/O addressing mode? .</p>
<div class="ulist">
<ul>
<li>
<p>Desarrollo:</p>
<div class="ulist">
<ul>
<li>
<p>memory mapped i/o : se reservan direcciones RAM para i/o</p>
</li>
<li>
<p>controlador i/o: registros datos, estado y control : puerto</p>
</li>
<li>
<p>2 formatos</p>
<div class="ulist">
<ul>
<li>
<p>CodOP/Address(Dir Directo)  : 8bits/8bits</p>
</li>
<li>
<p>CodOP/DX Register(Dir Indirecto)  : 8bits/8bits &#8594; DX:16bits</p>
</li>
<li>
<p>Número de puertos : Directo &#8594; 2<sup>8</sup> e Indirecto &#8594; 2<sup>16</sup> &#8658; total= 256+65536=65792 ports</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Sol:</p>
<div class="ulist">
<ul>
<li>
<p>65792 puertos</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>7.2 A similar instruction format is used in the Zilog Z8000 microprocessor family. In this case, there is a direct port addressing capability, in which a 16-bit port address is part of the instruction, and an indirect port addressing capability, in which the instruction references one of the 16-bit general purpose registers, which contains the port address. How many ports can the Z8000 address in each I/O addressing mode?</p>
<div class="ulist">
<ul>
<li>
<p>Desarrollo</p>
<div class="ulist">
<ul>
<li>
<p>Modo directo: 2<sup>16</sup> = 64K = 65536 ports</p>
</li>
<li>
<p>Modo indirecto: 2<sup>16</sup> = 64 K = 65536 ports</p>
</li>
</ul>
</div>
</li>
<li>
<p>Sol</p>
<div class="ulist">
<ul>
<li>
<p>128K=131072 puertos</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>7.5 A system is based on an 8-bit microprocessor and has two I/O devices. The I/O controllers for this system use separate control and status registers. Both devices handle data on a 1-byte-at-a-time basis.The first device has two status lines and three control lines.The second device has three status lines and four control lines.</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>How many 8-bit I/O control module registers do we need for status reading and control of each device?</p>
</li>
<li>
<p>What is the total number of needed control module registers given that the first device is an output-only device?</p>
</li>
<li>
<p>How many distinct addresses are needed to control the two devices?</p>
<div class="ulist">
<ul>
<li>
<p>modelo: El controlador i/o de los perifericos tiene implementados los puertos que son la interfaz con el periférico. Los puertos son direccionables y estan formados por un banco de registros: registro de datos, registro de control, registro de estado.</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>Desarrollo:</p>
<div class="ulist">
<ul>
<li>
<p>buffer data de 8 bits: 2 puertos de datos (in,out) por cada periférico.</p>
</li>
<li>
<p>1 buffer status de lectura (registro de estado) y 1 buffer control de escritura (registro de control) por cada periférico</p>
</li>
<li>
<p>las líneas de estado y control no son líneas de direccionamiento,sino que serán líneas conectadas a sus respectivos puertos. Las líneas de estado a 1 registro de estado y las líneas de control a 1 registro de control.</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>: 1 registro de control y 1 registro de estado por cada periférico</p>
</li>
<li>
<p>: periférico A (1Data+1Status+1Control) y  periférico B (2Data+1Status+1Control) = 7 registros</p>
</li>
<li>
<p>: tantas direcciones como registros = 7 direcciones</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Sol:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>1 reg control y 1 reg estado</p>
</li>
<li>
<p>7 registros</p>
</li>
<li>
<p>7 direcciones</p>
</li>
</ol>
</div>
</li>
<li>
<p>7.6 For programmed I/O, Figure 7.5 indicates that the processor is stuck in a wait loop doing status checking of an I/O device. To increase efficiency, the I/O software could be written so that the processor periodically checks the status of the device. If the device is not ready, the processor can jump to other tasks. After some timed interval, the processor comes back to check status again.</p>
<div class="imageblock">
<div class="content">
<img src="./images/ejercicios/7-5.png" alt="7 5">
</div>
</div>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Consider the above scheme for outputting data one character at a time to a printer that operates at 10 characters per second (cps).What will happen if its status is scanned every 200 ms?</p>
</li>
<li>
<p>Next consider a keyboard with a single character buffer. On average, characters are entered at a rate of 10 cps. However, the time interval between two consecutive key depressions can be as short as 60 ms. At what frequency should the keyboard be scanned by the I/O program?</p>
</li>
</ol>
</div>
</li>
<li>
<p>Desarrollo:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>10cps &#8594; El periférico necesita transmitir 1 caracter cada 100ms y escribe en el puerto dicho dato. Si la CPU no salva el dato escrito por el periférico antes de cada escritura, los datos se pierden. Si la CPU consulta cada 200ms y el periférico escribe cada 100ms, cada dos datos uno se pierde. La solución sería aumentar el buffer de datos a dos carácteres o aumentar la frecuencia de consulta a períodos de 100ms.</p>
</li>
<li>
<p>La velocidad media es de 10cps pero la frecuencia máxima es de 60ms. La frecuencia de escaneo de la CPU tiene que ser como mínimo de 1/60ms &#8594; 16.66Hz</p>
</li>
</ol>
</div>
</li>
<li>
<p>7.10 Consider a system employing interrupt-driven I/O for a particular device that transfers data at an average of 8 KB/s on a continuous basis.</p>
<div class="olist loweralpha">
<ol class="loweralpha">
<li>
<p>Assume that interrupt processing takes about 100 us (i.e., the time to jump to the interrupt service routine (ISR), execute it, and return to the main program). Determine what fraction of processor time is consumed by this I/O device if it interrupts for every byte.</p>
</li>
<li>
<p>Now assume that the device has two 16-byte buffers and interrupts the processor when one of the buffers is full. Naturally, interrupt processing takes longer, because the ISR must transfer 16 bytes.While executing the ISR, the processor takes about 8 us for the transfer of each byte. Determine what fraction of processor time is consumed by this I/O device in this case.</p>
</li>
<li>
<p>Now assume that the processor is equipped with a block transfer I/O instruction such as that found on the Z8000.This permits the associated ISR to transfer each byte of a block in only 2 us. Determine what fraction of processor time is consumed by this I/O device in this case.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Desarrollo:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>8kB/s &#8594; T_int_rq=1/8KB/s=125us &#8594; fracción=100us/125us=80%</p>
</li>
<li>
<p>T_interrupt_service=100us(ISR+1byte)+15bytesx8us=220us &#8594; T_16=16x125us=2ms &#8594; fracción=220us/2000us=0.11=11%</p>
</li>
<li>
<p>T_int_serv=100us(ISR+1byte)+15bytesx2us=130us &#8594; fracción=130us/2000us=6.5%</p>
</li>
</ol>
</div>
</li>
<li>
<p>7.11 In virtually all systems that include DMA modules, DMA access to main memory is given higher priority than CPU access to main memory. Why?</p>
<div class="ulist">
<ul>
<li>
<p>Si el buffer de datos del DMAC se llena y no es leído, se perderían los datos.</p>
</li>
</ul>
</div>
</li>
<li>
<p>7.12 A DMA module is transferring characters to memory using cycle stealing, from a device transmitting at 9600 bps. The processor is fetching instructions at the rate of 1 million instructions per second (1 MIPS). Suponer que la CPU está continuamente capturando instrucciones (no captura datos). By how much will the processor be slowed down due to the DMA activity?</p>
<div class="ulist">
<ul>
<li>
<p>1MIPS &#8594; 1 instrucción cada microsegundo. Como la CPU está continuamente capturando instrucciones tendrá ocupado el bus durante 1 microsegundo para captar cada instrucción y completar el ciclo de instrucción, por lo que el ciclo del bus del sistema es 1us.</p>
</li>
<li>
<p>1 character = 8 bits</p>
</li>
<li>
<p>9600 bps &#8594; 1200 bytes/s &#8594; 1/1200 seg/byte =833us/byte &#8594; cada byte se transfiere por robo de ciclo. Se roba el bus del sistema cada 833us, es decir, cada 833 ciclos del bus del sistema.</p>
</li>
<li>
<p>El bus del sistema lo tiene el DMAC durante un ciclo, es decir, 1 us.</p>
</li>
<li>
<p>Cada 833 ciclos el DMAC roba 1 &#8594; 1/833 &#8594; 0.12%</p>
</li>
<li>
<p>1MIPSx(1-0.0012)=998800 instrucciones por segundo.</p>
</li>
</ul>
</div>
</li>
<li>
<p>7.13 Consider a system in which bus cycles takes 500 ns. Transfer of bus control in either direction, from processor to I/O device or viceversa, takes 250 ns. One of the I/O devices has a data transfer rate of 50 KB/s and employs DMA. Data are transferred one byte at a time.</p>
<div class="olist loweralpha">
<ol class="loweralpha">
<li>
<p>Suppose we employ DMA in a burst mode. That is, the DMA interface gains bus mastership prior to the start of a block transfer and maintains control of the bus until the whole block is transferred. For how long would the device tie up the bus when transferring a block of 128 bytes?</p>
</li>
<li>
<p>Repeat the calculation for cycle-stealing mode.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Desarrollo:</p>
<div class="ulist">
<ul>
<li>
<p>500ns dura el ciclo del bus del sistema</p>
</li>
<li>
<p>T<sub>tx</sub>=1/50KB=20us/B. El DMA  según recibe el dato del periférico lo transfiere a la memoria principal, transfiriendo datos a través del bus del sistema a la misma velocidad del periférico. Sólo tiene sentido en periféricos de alta velocidad.</p>
<div class="olist loweralpha">
<ol class="loweralpha">
<li>
<p>Modo ráfaga: T=t<sub>acceso_bus</sub>+t<sub>bus_io_transferencia_bloque</sub>+t<sub>liberar_bus</sub>=250ns+128x20us+250ns=2560us</p>
</li>
<li>
<p>Robo de ciclo T=128x(t<sub>acceso_bus</sub>+t<sub>bus_io_transferencia_byte</sub>+t<sub>liberar_bus</sub>)=128x(250ns+20us+250ns)=128x20.5us=2624us</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>7.16 A DMA controller serves four receive-only telecommunication links (one per DMA channel) having a speed of 64 Kbps each.</p>
<div class="olist loweralpha">
<ol class="loweralpha">
<li>
<p>Would you operate the controller in burst mode or in cycle-stealing mode?</p>
</li>
<li>
<p>What priority scheme would you employ for service of the DMA channels?</p>
</li>
</ol>
</div>
</li>
<li>
<p>Desarrollo:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Ahora el DMAC tendrá cuatro bufferes de datos y podría acceder al bus de la misma forma que con uno. Debido a que los enlaces de telecomunicaciones ocupan el canal de forma continua (voz o datos), todo el tiempo que dura la comunicaión, el modo ráfaga ocuparía el bus el 100% del tiempo. Por lo que seleccionamos el robo de ciclo.</p>
</li>
<li>
<p>Prioridad entre 4 clientes: misma prioridad ya que tienen la misma velocidad. Si tuviesen diferentes velocidades, tendría mayor velocidad el más rápido, el de mayor tráfico.</p>
</li>
</ol>
</div>
</li>
<li>
<p>7.17 A 32-bit computer has two selector channels and one multiplexor channel. Each selector channel supports two magnetic disk and two magnetic tape units. The multiplexor channel has two line printers, two card readers, and 10 VDT terminals connected to it. Assume the following transfer rates:</p>
<div class="ulist">
<ul>
<li>
<p>Disk drive 800 KBytes/s</p>
</li>
<li>
<p>Magnetic tape drive 200 KBytes/s</p>
</li>
<li>
<p>Line printer 6.6 KBytes/s</p>
</li>
<li>
<p>Card reader 1.2 KBytes/s</p>
</li>
<li>
<p>VDT 1 KBytes/s</p>
</li>
<li>
<p>Estimate the maximum aggregate I/O transfer rate in this system.</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Los dos canales selector tienen los mismos periféricos. Un canal selector está permanentemente asignado a sus periféricos y sólo puede dar servicio a uno de los periféricos asignados. El multiplexor en cambio da servicio a todos &#8594; Rate=800+800+2x6.6+2x1.2+10x1=1625.6KB/s</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>7.18 A computer consists of a processor and an <em>I/O device D</em> connected to <em>main memory M</em> via a shared bus with a data bus width of one word. The processor can execute a maximum of 10<sup>6</sup> instructions per second. An average instruction requires five machine cycles, three of which use the memory bus. A memory read or write operation uses one machine cycle. Suppose that the processor is continuously executing “background” programs that require 95% of its instruction execution rate but not any I/O instructions, es decir, el 5% son instrucciones I/O si utiliza mecanismo e/s por programa. Assume that one processor cycle equals one bus cycle. Now suppose the I/O device is to be used to transfer very large blocks of data between M and D.</p>
<div class="olist loweralpha">
<ol class="loweralpha">
<li>
<p>If programmed I/O is used and each one-word I/O transfer requires the processor to execute two instructions, estimate the maximum I/O data-transfer rate, in words per second, possible through D.</p>
</li>
<li>
<p>Estimate the same rate if DMA is used.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Desarrollo:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Mecanismo E/S por programa</p>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>La transferencia se realiza por programa y lo realiza la CPU. La transferencia de 1 palabra requiere la ejecución de dos instrucciones.</p>
</li>
<li>
<p>1 instrucción=3 ciclos máquina con el memory bus</p>
</li>
<li>
<p>Como el ciclo de bus equivale a un ciclo máquina &#8594; 3 ciclos de bus con el memory bus &#8594; La transferencia de una palabra requiere 3 ciclos de bus&#8594; En cada ciclo de bus se transfiere un tercio de la palabra.</p>
</li>
<li>
<p>Los programas en background requieren el 95% de instrucciones a la CPU, dejando el 5% de instrucciones para I/O</p>
</li>
<li>
<p>Del 5% de instrucciones i/o el 2.5% son transferencias ya que hacen falta dos instrucciones i/o por transferencia.</p>
</li>
<li>
<p>T_transfer(1word)= 0.025x10<sup>6</sup> instrucciones<sub>io</sub>/seg= 25000words/seg</p>
</li>
</ol>
</div>
</li>
<li>
<p>DMA:</p>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>Observamos el tiempo que la CPU no utiliza el bus del sistema= 5% de instrucciones (5 ciclos por instrucción) MÁS  el 95% de instrucciones (2ciclos por instrucción).</p>
</li>
<li>
<p>El 5% de ejecución de CPU, la CPU esta libre :10<sup>6</sup>(inst/seg)x0.05x5(ciclos/instr)= 250000 ciclos/seg de procesador que utiliza el DMA= 250000 ciclos/seg de i/o que utiliza el DMA</p>
</li>
<li>
<p>El 95% de ejecución de CPU, el DMA comparte bus del sistema=10<sup>6</sup>x0.95x2 ciclos libres de los 5 ciclos= 1900000 ciclos/seg de cpu= 1900000 ciclos/seg i/o</p>
</li>
<li>
<p>Total=1900000+250000=2.150.000 ciclos/seg bus i/o</p>
</li>
<li>
<p>Si en cada ciclo se puede realizar una transferencia, esa sería la velocidad máxima. La CPU no realiza la operación de acceso a memoria, la realiza el controlador de memoria.</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_capitulo_8_operating_system">10.11. Capitulo 8: Operating System</h3>
<div class="ulist">
<ul>
<li>
<p>8.3 A program computes the row sums Ci=Sum[aij] para j=1,n of an array A that is 100 by 100. Assume that the computer uses demand paging with a page size of 1000 words, and that the amount of main memory allotted for data is five page frames. Is there any difference in the page fault rate if A were stored in virtual memory by rows or columns? Explain.</p>
<div class="ulist">
<ul>
<li>
<p>Matriz A = 100x100 palabras = 10000 palabras</p>
</li>
<li>
<p>Memoria: 5 marcos de páginas : 5000 palabras</p>
</li>
<li>
<p>Proceso: 10000 palabras se dividirá en 10000/1000=10 páginas</p>
</li>
<li>
<p>Almacenamiento por <em>filas</em></p>
</li>
<li>
<p>1ª  página: a1_1,a1_2,..,a1_100,a2_1,..,a2_100,..,..,a10_1,..,a10_100 &#8594; diez filas</p>
</li>
<li>
<p>5ª  página: a41_1,..,..,a50_100</p>
</li>
<li>
<p>10ª página: a91_1 ,..,..,a100_100</p>
</li>
<li>
<p>xª  página: desde a10*(x-1)+1_1 hasta a10*x_1 &#8594; diez filas</p>
</li>
<li>
<p>Ejecución primera fila: C1=SUM[a1j] j=1,100</p>
<div class="ulist">
<ul>
<li>
<p>Demand Paging:</p>
<div class="ulist">
<ul>
<li>
<p>La MP está vacía, ningún marco de página inicializado, todas las páginas en disco, sin copia en los marcos de la MPrincipal.</p>
</li>
<li>
<p>captura de a11 &#8594; FAULT (no está en MP, está en disco)&#8594; copia 1ª página &#8594; obtiene C1</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Ejecución C2 &#8594; a21 sí está en la primera página &#8594; obtiene C2</p>
</li>
<li>
<p>Ejecución C3,..,C10 &#8594; ningún fault ya que están en la primera página</p>
</li>
<li>
<p>Ejecución C11 &#8594; FAULT &#8594; copio la 2ª página</p>
</li>
<li>
<p>Ejecución C21 &#8594; FAULT &#8594; copio la 3ª página</p>
</li>
<li>
<p>FAULTS: C1,C11,C21,..,C91</p>
</li>
<li>
<p>Cada vez que se ejecutan las 100 filas Ci se producen 10 Fallos</p>
</li>
<li>
<p>El resultado hubiese sido el mismo si en lugar de 5 páginas hubiese tenido una página si la política de reemplazo es la FIFO</p>
</li>
<li>
<p>se podrían utilizar 4 marcos de página con los mismos datos y realizar los reemplazos en el mismo marco.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Almacenamiento por <em>columnas</em> :</p>
<div class="ulist">
<ul>
<li>
<p>1ª  página: a1_1,a2_1,..,a100_1,a1_2,..,a100_2,..,..,a1_10,..,a100_10 &#8594; diez columnas</p>
</li>
<li>
<p>xª  página: desde a1_10*(x-1)+1 hasta a100_10*x &#8594; diez columnas</p>
<div class="ulist">
<ul>
<li>
<p>Ejecución 1ª fila: C1=SUM[a1j] j=1,100</p>
<div class="ulist">
<ul>
<li>
<p>necesito cargar las 100 columnas de la fila 1 &#8594; necesito 10 páginas con diez columnas por página &#8594; 10 FAULTS</p>
</li>
</ul>
</div>
</li>
<li>
<p>Ejecución nª fila: se necesitan 100 columnas que están distribuidas por páginas de 10 en 10 columnas. &#8594; hacen falta 10 páginas &#8594; 10 FAULTS</p>
</li>
</ul>
</div>
</li>
<li>
<p>Cada vez que se ejecutan las 100 filas Ci : 10 Faults por fila &#8594; 1000 FAULTS</p>
</li>
</ul>
</div>
</li>
<li>
<p>8.4 Consider a fixed partitioning scheme with equal-size partitions of 2<sup>16</sup> bytes and a total main memory size of 2<sup>24</sup> bytes. A process table is maintained that includes a pointer to a partition for each resident process. How many bits are required for the pointer?</p>
<div class="ulist">
<ul>
<li>
<p>Las tablas de descriptores están formadas por el índice y el contenido que en este caso es un puntero.</p>
</li>
<li>
<p>2<sup>24</sup>/2<sup>16</sup>=2<sup>8</sup> particiones de la memoria</p>
</li>
<li>
<p>Tamaño de 2<sup>16</sup> &#8594; direcciones que terminan en hexadecimal en 0000 &#8594; direcciones k*2<sup>16</sup>&#8594;0xnn0000</p>
</li>
<li>
<p>puntero: solo es necesario guardar los dos dígitos nn de mayor peso &#8594; 8 bits</p>
<div class="ulist">
<ul>
<li>
<p>luego se desplazan 16 bits a a la izda para tener la dirección base</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>8.6 Suppose the page table for the process currently executing on the processor looks like the following. All numbers are decimal, everything is numbered starting from zero, and all addresses are memory byte addresses. The page size is 1024 bytes.</p>
</li>
</ul>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/ejercicios/8_6.png" alt="VM">
</div>
<div class="title">Figure 74. VM</div>
</div>
<div class="ulist">
<ul>
<li>
<p>.</p>
<div class="olist loweralpha">
<ol class="loweralpha">
<li>
<p>Describe exactly how, in general, a virtual address generated by the CPU is translated into a physical main memory address.</p>
<div class="ulist">
<ul>
<li>
<p>La dirección virtual esta formada por los campos (VPN,VPO) &#8594; (base,offset). Mediante la tabla de paginas virtuales traducimos VPN en PPN. La dirección física es el par (PPN,PPO) donde el offset PPO=VPO</p>
</li>
<li>
<p>Para qué este cacheada la página virtual en la tabla de páginas virtuales el bit de validación tiene que valer 1.</p>
</li>
</ul>
</div>
</li>
<li>
<p>What physical address, if any, would each of the following virtual addresses correspond to? (Do not try to handle any page faults, if any.)</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>1052</p>
<div class="ulist">
<ul>
<li>
<p>VPN=Mod{1052/1024}=1 &#8594; Valid Bit=1 &#8594; PPN=7</p>
</li>
<li>
<p>VPO=Rest{1052/1024}=28</p>
</li>
<li>
<p>Dirección física = 7*1024+28=7196</p>
</li>
</ul>
</div>
</li>
<li>
<p>2221</p>
<div class="ulist">
<ul>
<li>
<p>VPN=Mod{2221/1024}=2 &#8594; Valid Bit=0</p>
</li>
<li>
<p>No hay copia de esa página por lo que no se puede realizar la traducción</p>
</li>
</ul>
</div>
</li>
<li>
<p>5499</p>
<div class="ulist">
<ul>
<li>
<p>VPN=Mod{5499/1024}=5 &#8594; Valid Bit=1 &#8594; PPN=0</p>
</li>
<li>
<p>VPO=Rest{1052/1024}=379</p>
</li>
<li>
<p>Dirección física = 0+379=379</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>8.8 A process references five pages, A, B, C, D, and E, in the following order: A; B; C; D; A; B; E; A; B; C; D; E .Assume that the replacement algorithm is first-in-first-out and find the number of page transfers during this sequence of references starting with an empty main memory with three page frames. Repeat for four page frames.</p>
<div class="olist loweralpha">
<ol class="loweralpha">
<li>
<p>MP &#8594; 3 marcos de página ; política FIFO</p>
<div class="ulist">
<ul>
<li>
<p>v/v/v; A&#8594; A/v/v ; B&#8594; A/B/v ; C&#8594; A/B/C; D&#8594; D/B/C; A&#8594; D/A/C; B&#8594; D/A/B; E&#8594; E/A/B ; A&#8594; E/A/B; B&#8594; E/A/B; C&#8594; E/C/B; D&#8594; E/C/D; E&#8594; E/C/D</p>
</li>
<li>
<p>10 Fallos</p>
</li>
</ul>
</div>
</li>
<li>
<p>MP &#8594; 4 marcos de página ; política FIFO</p>
<div class="ulist">
<ul>
<li>
<p>v/v/v/v; A&#8594; A/v/v/v ; B&#8594; A/B/v/v ; C&#8594; A/B/C/v; D&#8594;A/B/C/D; A&#8594;A/B/C/D; B&#8594;A/B/C/D; E&#8594;E/B/C/D; A&#8594;E/A/C/D; B&#8594;E/A/B/D; C&#8594;E/A/B/C; D&#8594;D/A/B/C; E&#8594;D/E/B/C</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>8.9 The following sequence of virtual page numbers is encountered in the course of execution on a computer with virtual memory: 3 4 2 6 4 7 1 3 2 6 3 5 1 2 3 Assume that a least recently used page replacement policy is adopted. Plot a graph of page hit ratio (fraction of page references in which the page is in main memory) as a function of main-memory page capacity n for 1&#8656; n&#8656;8. Assume that main memory is initially empty.</p>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/ditaa/svg/eNrj8ju0SyE3sSg5v1ihRsGtKDE5OfPw5jwFx-TM1KKS_OIaBWMFEwUjBTMgaa5gCOSB2MYKpkC2kYIxlwIIGIKIGgUYMIAxaiDSRviljZGkjfQNTeHSQGwCZpkg1MGsNEHSZExYE1QWqtkUSbMJXs1GcM1wz5ohaTbH0AwJKQWkkFJADilzJM0WKJqNCWu2IE8zAFeZUjc=" alt="Diagram">
</div>
</div>
</li>
<li>
<p>8.11 Suppose the program statement</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">];</span></code></pre>
</div>
</div>
</li>
<li>
<p>is executed in a memory with page size of 1000 words. Let n = 1000. Using a machine that has a full range of register-to-register instructions and employs index registers, write a hypothetical program to implement the foregoing statement. Then show the sequence of page references during execution.</p>
<div class="ulist">
<ul>
<li>
<p>En la memoria virtual estará tanto el código como los datos</p>
</li>
<li>
<p>Marcos de 1000 palabras.</p>
</li>
<li>
<p>Programa arquitectura load/store (espacio de direcciones virtual)</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c">            <span class="n">SECCION</span> <span class="n">CODIGO</span>
            <span class="n">Ri</span> <span class="o">&lt;-</span> <span class="mi">1</span>
            <span class="n">Ra</span> <span class="o">&lt;-</span> <span class="n">n</span>
<span class="n">loop_start</span><span class="o">:</span> <span class="n">R1</span> <span class="o">&lt;-</span> <span class="n">b</span><span class="p">[</span><span class="n">Ri</span><span class="p">]</span>
            <span class="n">R2</span> <span class="o">&lt;-</span> <span class="n">c</span><span class="p">[</span><span class="n">Ri</span><span class="p">]</span>
            <span class="n">R3</span> <span class="o">&lt;-</span> <span class="n">R1</span><span class="o">+</span><span class="n">R2</span>
            <span class="n">a</span><span class="p">[</span><span class="n">Ri</span><span class="p">]</span> <span class="o">&lt;-</span> <span class="n">R3</span>
            <span class="n">Flags</span> <span class="o">&lt;-</span> <span class="n">Ri</span><span class="o">&lt;</span><span class="n">Ra</span>
            <span class="n">Flags</span><span class="o">:</span><span class="n">PC</span> <span class="o">&lt;-</span> <span class="n">loop_start</span>
            <span class="n">CPU</span> <span class="o">&lt;-</span> <span class="n">halt</span>
            <span class="n">SECCION</span> <span class="n">DATOS</span> <span class="n">INICIALIZADOS</span>
<span class="n">uno</span><span class="o">:</span>        <span class="mi">1</span>
<span class="n">n</span><span class="o">:</span>          <span class="mi">1000</span>
<span class="n">a</span><span class="o">:</span>          <span class="n">array</span> <span class="n">a</span><span class="p">[</span><span class="mi">1000</span><span class="p">]</span>
<span class="n">b</span><span class="o">:</span>          <span class="n">array</span> <span class="n">b</span><span class="p">[</span><span class="mi">1000</span><span class="p">]</span>
<span class="n">c</span><span class="o">:</span>          <span class="n">array</span> <span class="n">c</span><span class="p">[</span><span class="mi">1000</span><span class="p">]</span></code></pre>
</div>
</div>
</li>
<li>
<p>Asignación del espacio virtual</p>
<div class="ulist">
<ul>
<li>
<p>Código en la página PV1</p>
</li>
<li>
<p>array A ocupa una página &#8594; PV2</p>
</li>
<li>
<p>array B ocupa una página &#8594; PV3</p>
</li>
<li>
<p>array C ocupa una página &#8594; PV4</p>
</li>
<li>
<p>uno y n en una página de tipo datos &#8594; PV5</p>
</li>
</ul>
</div>
</li>
<li>
<p>Ejecución</p>
<div class="ulist">
<ul>
<li>
<p>1515(131411211)<sup>1000</sup>11</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>8.13 Consider a computer system with both segmentation and paging. When a segment is in memory, some words are wasted on the last page. In addition, for a segment size s and a page size p, there are s/p page table entries. The smaller the page size, the less waste in the last page of the segment, but the larger the page table. What page size minimizes the total overhead?</p>
<div class="ulist">
<ul>
<li>
<p>Desarrollo:</p>
<div class="olist loweralpha">
<ol class="loweralpha">
<li>
<p>Número de páginas por segmento: tamaño del segmento/ tamaño de página = s/p</p>
</li>
<li>
<p>Cada segmento tiene su propia tabla de páginas</p>
</li>
<li>
<p>Si reducimos el tamaño de página se reduce la fragmentación interna pero se incrementa el número de entradas de la tabla de páginas.</p>
</li>
<li>
<p>El Total de palabras desperdiciadas (w) es el desperdicio debido a las últimas páginas de cada segmento más el tamaño de la tabla de págincas. El valor medio de la fragmentación interna de todos los segmentos es p/2 y el tamaño de la tabla de páginas es proporcional al número de entradas de la tabla s/p &#8594; w=p/2+s/p &#8594; dw/dp=1/2-s/p<sup>2</sup>=0 &#8594; p<sup>2</sup>=2s</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>8.14 A computer has a cache, main memory, and a disk used for virtual memory. If a referenced word is in the cache, 20 ns are required to access it. If it is in main memory but not in the cache, 60 ns are needed to load it into the cache, and then the reference is started again. If the word is not in main memory, 12 ms are required to fetch the word from disk, followed by 60 ns to copy it to the cache, and then the reference is started again. The cache hit ratio is 0.9 and the main-memory hit ratio is 0.6. What is the average time in ns required to access a referenced word on this system?</p>
<div class="ulist">
<ul>
<li>
<p>T=hit_cache*t_acc_ca+(1-hit_cache)<strong>hit_main</strong>(t_main_cache+t_acc_ca)+(1-hit_cache)<strong>(1-hit_main)</strong>(t_acc_disk_main+t_main_cache+t_acc_ca)=
= 0.9*20+0.1*0.6*(60+20)+0.1*0.4*(12000000+60+20)=480us</p>
</li>
</ul>
</div>
</li>
<li>
<p>8.15 Assume a task is divided into four equal-sized segments and that the system builds an eight-entry page descriptor table for each segment. Thus, the system has a combination of segmentation and paging. Assume also that the page size is 2 Kbytes.</p>
<div class="olist loweralpha">
<ol class="loweralpha">
<li>
<p>What is the maximum size of each segment?</p>
</li>
<li>
<p>What is the maximum logical address space for the task?</p>
</li>
<li>
<p>Assume that an element in physical location 00021ABC is accessed by this task. What is the format of the logical address that the task generates for it? What is the maximum physical address space for the system?</p>
<div class="ulist">
<ul>
<li>
<p>Desarrollo:</p>
<div class="olist upperalpha">
<ol class="upperalpha">
<li>
<p>Tabla de PAGINAS: 8 entradas : 8 paginas virtuales de 2KB &#8594; Segmento:8*2KB=16KB.</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>No dice nada pero &#8230;&#8203; La tabla de SEGMENTOS tendrá una entrada por segmento. Cada entrada de segmento apuntará a una tabla de página diferente. Una tabla de página por segmento.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Proceso: 4 segmentos &#8594; 4*16KB=64KB</p>
</li>
<li>
<p>Dirección lógica &#8594; Formato (Segmento,Pagina,VPO) &#8594; (4seg,8pag,2KB)&#8594; (2bits,3bits,11bits)&#8594; Dirección lógica de 16 bits</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Dirección física &#8594; 00021ABC &#8594; 8 digitos hex &#8594; 32 bits &#8594; 4GB</p>
</li>
<li>
<p>Marcos de página &#8594; 4GB/2KB &#8594; 2*2<sup>20</sup> marcos</p>
</li>
<li>
<p>00021ABC &#8594; 0000-0000-0000-0010-0001-1010-1011-1100 &#8594; marco/offset &#8594; 21/11 &#8594; 000000000000001000011 / 01010111100 &#8594; marco 67/ offset 700</p>
</li>
</ol>
</div>
</li>
<li>
<p>Traducción: El offset virtual y físico idénticos (11bits) &#8594; El segmento lógico (2bits) apunta a una tabla de páginas. La página virtual (3bits) es el offset de la tabla de páginas. Cada entrada de la tabla de páginas es un puntero a un marco de la memoria principal ( una dirección base de 21 bits). Se añadir la pregunta de inventarse la tabla de descripción de segmentos y las cuatro tablas de páginas de cada segmento. En este ejercicio la dirección lógica tendrá el offset  01010111100 y los 5 bits del par seg/página no se pueden saber ya que haría falta saber en que tabla y posición está el puntero al marco 67.</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>8.16 Assume a microprocessor capable of accessing up to 2<sup>32</sup> bytes of physical main memory. It implements one segmented logical address space of maximum size 2<sup>31</sup> bytes. Each instruction contains the whole two-part address. External memory management units (MMUs) are used, whose management scheme assigns contiguous blocks of physical memory of fixed size 2<sup>22</sup> bytes to segments. The starting physical address of a segment is always divisible by 1024. Show the detailed interconnection of the external mapping mechanism that converts logical addresses to physical addresses using the appropriate number of MMUs, and show the detailed internal structure of an MMU (assuming that each MMU contains a 128-entry directly mapped segment descriptor cache) and how each MMU is selected.</p>
<div class="ulist">
<ul>
<li>
<p>un espacio virtual segmentado de 2<sup>31</sup> bytes: no es el espacio virtual de cada segmento sino el de todos los segmentos.</p>
</li>
<li>
<p>dirección lógica con dos partes &#8594; (segmento,offset)</p>
</li>
<li>
<p>MP: Espacio de 2<sup>32</sup> bytes con Bloques de 2<sup>22</sup> bytes contiguos para cada segmento</p>
<div class="ulist">
<ul>
<li>
<p>offset de 22 bits</p>
</li>
<li>
<p>2<sup>31</sup>/2<sup>22</sup> = 2<sup>9</sup> segmentos en espacio virtual &#8594; 9 bits para el segmento en la dirección virtual y una tabla de segmentos con 512 entradas</p>
</li>
<li>
<p>Dirección lógica de 31 bits (9,22) &#8594; (seg,offset)</p>
</li>
</ul>
</div>
</li>
<li>
<p>MP: segmentos alineados en multiplos de 1K</p>
<div class="ulist">
<ul>
<li>
<p>segmento físico:los 10 bits de menor peso son cero y los 22 de mayor peso están en la <em>tabla de segmentos</em>.</p>
</li>
<li>
<p>Dirección física: segmento+offset</p>
</li>
</ul>
</div>
</li>
<li>
<p>MMU: <em>tabla de segmentos</em> de 128 entradas (2<sup>7</sup>)</p>
<div class="olist loweralpha">
<ol class="loweralpha">
<li>
<p>no tenemos una tabla con 512 entradas sino cuatro tablas de 128 cada una.</p>
</li>
<li>
<p>cantidad de MMUs: Si tenemos 2<sup>9</sup> segmentos en el espacio virtual y la MMU tiene una tabla de 2<sup>7</sup> necesitaremos 4 MMUs.</p>
</li>
<li>
<p>Traducción: espacio lógico (9,22)(seg,offset) en una dirección segmento+offset de 32 bits.</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>De los 9 bits de segmento virtual, dos bits seleccionaran la MMU y otros siete bits la entrada de la tabla de segmentos. (2,7,22)</p>
</li>
<li>
<p>los 9 bits de segmento lógico son el índice de la tabla de segmentos que contiene los 22 bits altos de un segmento físico.</p>
</li>
<li>
<p>El offset físico también tiene un tamaño de 22 bits</p>
</li>
<li>
<p>dirección física: dirección base múltiplo de 1K más offset de 22bits.</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>8.17 Consider a paged logical address space (composed of 32 pages of 2 Kbytes each) mapped into a 1-Mbyte physical memory space.</p>
<div class="olist loweralpha">
<ol class="loweralpha">
<li>
<p>What is the format of the processor’s logical address?</p>
</li>
<li>
<p>What is the length and width of the page table (disregarding the “access rights” bits)?</p>
</li>
<li>
<p>What is the effect on the page table if the physical memory space is reduced by half?</p>
<div class="ulist">
<ul>
<li>
<p>Desarrollo:</p>
</li>
<li>
<p>MP : 1MB con páginas de 2KB &#8594; 2<sup>20</sup>/2<sup>11</sup> = 2<sup>9</sup> marcos de página</p>
<div class="olist upperalpha">
<ol class="upperalpha">
<li>
<p>VPN/OFFSET &#8594; VPN:32 páginas supone 2<sup>5</sup>, 5 bits ; OFFSET:2KB supone 2<sup>11</sup>, 11bits</p>
</li>
<li>
<p>Tabla de páginas: longitud igual al número de paginas virtuales= 32 y anchura igual al puntero a uno de los 2<sup>9</sup> marcos, es decir, 9 bits.</p>
</li>
<li>
<p>Si se reduce la MP a la mitad, se reduce el número de marcos a la mitad también &#8594; 2<sup>8</sup> marcos de página &#8594; anchura de 8 bits.</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>Randal Capítulo 9: Figure 9.19 shows the formats of the virtual and physical addresses. Since each page is 26 =64 bytes, the low-order 6 bits of the virtual and physical addresses serve as the VPO and PPO respectively.The high-order 8 bits of the virtual address serve as the VPN. The high-order 6 bits of the physical address serve as the PPN. Figure 9.20 shows a snapshot of our little memory system, including the TLB (Figure 9.20(a)), a portion of the page table (Figure 9.20(b)), and the L1 cache (Figure 9.20(c)). Above the figures of the TLB and cache, we have also shown how the bits of the virtual and physical addresses are partitioned by the hardware as it accesses these devices.</p>
<div class="imageblock">
<div class="content">
<img src="./images/ejercicios/randal_9-19.png" alt="randal 9 19">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/ejercicios/randal_9-20.png" alt="randal 9 20">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Given this initial setup, let’s see what happens when the CPU executes a load instruction that reads the byte at address 0x03d4</p>
</li>
<li>
<p>Solución</p>
<div class="ulist">
<ul>
<li>
<p>TLBI:0x03</p>
</li>
<li>
<p>TLBT:0x3</p>
</li>
<li>
<p>VPN:0x0f</p>
</li>
<li>
<p>VPO:0x14</p>
</li>
<li>
<p>PPN=0x0D</p>
</li>
<li>
<p>physical address=0x354</p>
</li>
<li>
<p>CO=0x0</p>
</li>
<li>
<p>CI=0x5</p>
</li>
<li>
<p>CT=0x0D</p>
</li>
<li>
<p>Data=0x36</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_capitulo_12_processor_structure_and_function_capitulo_14_en_9ªed">10.12. Capitulo 12: Processor Structure and Function (Capitulo 14 en 9ªEd)</h3>
<div class="ulist">
<ul>
<li>
<p>12.1 a. If the last operation performed on a computer with an 8-bit word was an addition in which the two operands were 00000010 and 00000011, what would be the value of the following flags?</p>
<div class="ulist">
<ul>
<li>
<p>Carry</p>
</li>
<li>
<p>Zero</p>
</li>
<li>
<p>Overflow &#8594; Número con signo</p>
</li>
<li>
<p>Sign</p>
</li>
<li>
<p>Even Parity &#8594; Paridad PAR</p>
</li>
<li>
<p>Half-Carry</p>
</li>
<li>
<p>Desarrollo</p>
<div class="ulist">
<ul>
<li>
<p>0010+0011=0101 &#8594; No hay llevada en el MSB, el resultado no es cero, no hay overflow, positivo, número de unos PAR,  no hay llevada en el bit de posición 3. Por lo que todos los flags desactivados excepto el de paridad par . El flag parity estará a 1.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>12.3 A microprocessor is clocked at a rate of 5 GHz.</p>
<div class="olist loweralpha">
<ol class="loweralpha">
<li>
<p>How long is a clock cycle?</p>
</li>
<li>
<p>What is the duration of a particular type of machine instruction consisting of three clock cycles?</p>
<div class="ulist">
<ul>
<li>
<p>Desarrollo</p>
<div class="ulist">
<ul>
<li>
<p>a. T= 1/f = 1/(5*10<sup>9</sup>)=0.2ns</p>
</li>
<li>
<p>b.  3T= 3*0.2=0.6ns</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>12.4 A microprocessor provides an instruction capable of moving a string of bytes from one area of memory to another. The fetching and initial decoding of the instruction takes 10 clock cycles. Thereafter, it takes 15 clock cycles to transfer each byte. The microprocessor is clocked at a rate of 10 GHz.</p>
<div class="olist loweralpha">
<ol class="loweralpha">
<li>
<p>Determine the length of the instruction cycle for the case of a string of 64 bytes.</p>
</li>
<li>
<p>What is the worst-case delay for acknowledging an interrupt if the instruction is noninterruptible?</p>
</li>
<li>
<p>Repeat part (b) assuming the instruction can be interrupted at the beginning of each byte transfer</p>
<div class="ulist">
<ul>
<li>
<p>Desarrollo</p>
<div class="ulist">
<ul>
<li>
<p>a) IC=Instruction Cycle= FI+DI+CO+FO+EI+WO; FI+DI=10T ; CO+FO= 0 ; EI= 15T/byte ; WO=0 ; T=1/(10*10<sup>9</sup>))=0.1 ns; IC=(10+15*64)*T=970*0.1= 97ns</p>
</li>
<li>
<p>b) Justo nada más empezar la instrucción quedaría todo el ciclo para poder atender a la interrupción: 97 ns.</p>
</li>
<li>
<p>c) Si se interrumpe antes de la primera transfer tardaría 10T como mucho, y si se interrumpe durante las transferencias sería 15T. Por lo que es caso peor sería 15T=15*0.1=1.5ns</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>12.5 The Intel 8088 consists of a bus interface unit (BIU) and an execution unit (EU), which form a 2-stage pipeline. The BIU fetches instructions into a 4-byte instruction queue. The BIU also participates in address calculations, fetches operands, and writes results in memory as requested by the EU. If no such requests are outstanding and the bus is free, the BIU fills any vacancies in the instruction queue. When the EU completes execution of an instruction, it passes any results to the BIU (destined for memory or I/O) and proceeds to the next instruction. <a href="http://en.wikipedia.org/wiki/Intel_8088">wikipedia</a>:  the 8088 had an <strong>8-bit</strong> external data bus</p>
<div class="olist loweralpha">
<ol class="loweralpha">
<li>
<p>Suppose the tasks performed by the BIU and EU take about equal time. By what factor does pipelining improve the performance of the 8088? Ignore the effect of branch instructions.</p>
</li>
<li>
<p>Repeat the calculation assuming that the EU takes twice as long as the BIU.</p>
<div class="ulist">
<ul>
<li>
<p>Desarrollo</p>
<div class="ulist">
<ul>
<li>
<p>0. El micro 8088 tiene un bus de datos de 8bits. La unidad de ejecución comprende la ALU y los Registros. La BIU junto a la EU forman conjuntamente una CPU segmentada con dos unidades. La <em>prefetch instruction queue</em> es el buffer que almacena la siguiente instrucción a ejecutar.</p>
</li>
<li>
<p>a. Una etapa tarda x y la siguiente también x. La primera instrucción tarda en ejecutarse 2x y cada intervalo x sale una nueva por lo que la mejoría a partir de la segunda instrucción es de x/2x &#8658; En un ciclo de instrucción (duración 2x) salen instrucciones cada intervalo x, es decir, el doble.</p>
</li>
<li>
<p>b. x+2x=3x. A partir de la segunda instrucción tardan 2x. En un ciclo de instrucción 3x salen instrucciones cada 2x &#8658; (3x time  ciclo)/ (2x time/instrucción) = 1.5 veces más instrucciones por ciclo.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>12.6 Assume an 8088 is executing a program in which the probability of a program jump is 0.1. For simplicity, assume that all instructions are 2 bytes long. If the prefetch instruction queue is empty, the EU waits for the next instruction byte to be fetched and shifted to top of the queue.
When the EU executes a branch or jump instruction, it transfers control to a location corresponding to another set of sequential instructions.
Whenever this happens, the BIU automatically resets the queue and then begins to fetch instructions from this new location to refill the queue.</p>
<div class="olist loweralpha">
<ol class="loweralpha">
<li>
<p>What fraction of instruction fetch bus cycles is wasted?</p>
</li>
<li>
<p>Repeat if the instruction queue is 8 bytes long.</p>
<div class="ulist">
<ul>
<li>
<p>Buffer (de 4 bytes para dos instrucciones) &#8594; BIU &#8594; EU : Para leer una instrucción son necesarios <strong>DOS ciclos de bus</strong>, un bus de datos (1 byte) por ciclo de bus.</p>
</li>
<li>
<p>Desarrollo</p>
<div class="ulist">
<ul>
<li>
<p>0. Si no hay salto durante la ejecución de la instrucción N se captura la instrucción N+1.</p>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/ditaa/svg/eNpTUIABp1A3N9cgBSzAyTMUhe8ayqWLBLSROSB5XVSALsRV46dtpGGUVFmSWqwJZBvC2Qq6dgo1Cs6JBSWlRYkKQFUKUCHXrNTk0hKgUA1lNnMpEAA1hFUouOQXKzhnJucAqZRUBafSYoWCRKBzkyHOLlIozUtUyMwrLikqTU7OPLw5jwqWliG7nG4RBYkqY6SoMsIZVcYYUaVtWEOh7QA5nYTC" alt="Diagram">
</div>
</div>
</li>
<li>
<p>1. Si la ejecución de la instrucción N supone un salto de M instrucciones no se ejecutará la instrucción N+1 que espera en el buffer, sino que se debe ejecutar la instrucción N+M. Durante la ejecución de N NO se captura nada sino que se actualiza el Contador de Programa a N+M y en el siguiente ciclo de instruccióń se capturará N+M. Por lo que si hay salto, el ciclo de captura estará infrautilizado y será necesario vaciar el buffer de instrucciones.</p>
</li>
<li>
<p>Interpretación</p>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/ditaa/svg/eNrN1EFrwjAUAOB7f8U7Kq4He_Swg6IwmCKCu7-mT8jIEtckA6V_aaf9BP_YkkbbqsUxFbZ3EPteEpKPl0Rz1JhDRmAlwgo1AYIyOfoUaeN_3i29IWi7VpJAIDBcGxtG-ElcapNbxvjuS0InAcaZUNpXU6u7URRBFcPlZDJeQEsMn5Zt6fEyihvRa374enwcLak6omLW63eSdGNIdwuAWf0_foQCRvtjuVGwT41fiVnjUhD36025ua56qIkTAZSGcq5yKEsZCdAojLrjOf6VaFKpeLdK6EQ0ORMdBBbw1ellUddJ5dgBIDMWBd8iONb56J6mV5LezOkNp43OekHGscUwMJWpmaqoiuPduPIzltv8QLb7LJmGdrWiHDbVtd3z-gVDjzIl8NZTXN-S9xE89F4BNWfgqpvQDfpB0BUXJATJUi4Ncu7Z4yQzVa5MMryAKW3LB_DP-S4D_oowaRBWd_kcMQmp6iY7leK0Ba3kGWYeaKSkyZU4dN8D98_jOic3cwNUr3H7Gb4B652Bjw==" alt="Diagram">
</div>
</div>
</li>
<li>
<p>a. Cuando la BIU capta de la memoria principal N+1 y lo pone en cola detrás de N, se están desaprovechando los dos ciclos de bus que se necesitan para la captura de la instrucción M+1 que no se va a ejecutar. Lo mismo ocurre con la captura de N+2 de la memoria princiapl. Por lo tanto se malgastan los ciclos del bus del sistema de N+1 y N+2, es decir, 4 ciclos de bus.</p>
</li>
<li>
<p>El buffer de instrucción es de 4 bytes según el ejercicio anterior, por lo que es necesario "empujar" los 4 bytes de N+1 y N+2  para dejar pasar a la nueva instrucción N+M desde que es capturada de la memoria principal.</p>
</li>
<li>
<p>La captura de una instrucción no_jump supone 2 ciclos de bus bien utilizados, la instrucción estará en la cabeza del buffer cuando la vaya a ejecutar la CPU. La de una instrucción jump supone 2 ciclos bien utilizados en capturarla desde la memoria principal pero 4 ciclos mal utilizados en vaciar el buffer y desplazar la instrucción N+M desde la cola hasta la cabecera del buffer, mientras la cpu espera. De cada 100 instrucciones tendremos 100 instruccionesx2ciclos/instr bien utilizados y 10 instruccionesx4ciclos/instrucción mal utilizados&#8594; en total 240 ciclos &#8594; fracción de infrautilización= 40/240= 0.166= 17% del tiempo el bus no está siendo utilizado en operaciones fetch, la BIU está ocupado en vaciar el buffer.</p>
</li>
<li>
<p>b. Con una cola de 8 bytes &#8594; Total=100x2+10*8=280&#8594; ineficiencia=80/280=0.285=28.5%</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>12.7 Consider the timing diagram of Figures 12.10. Assume that there is only a two-stage pipeline (fetch, execute). Redraw the diagram to show how many time units are now needed for four instructions.</p>
<div class="ulist">
<ul>
<li>
<p>Desarrollo</p>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/ditaa/svg/eNpTUFBQ0MUJuICyCjUKhiDCCEQYgwgTEGEKJMDSeHR7GoIUuHkCCVdPLk8jBRiACxkroAC4uIkCJoBKAgDeGh5K" alt="Diagram">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Son necesarias 5 unidades de Tiempo</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>12.9 A pipelined processor has a clock rate of 2.5 GHz and executes a program with 1.5 million instructions. The pipeline has five stages, and instructions are issued at a rate of one per clock cycle. Ignore penalties due to branch instructions and outof-sequence executions.</p>
<div class="olist loweralpha">
<ol class="loweralpha">
<li>
<p>What is the speedup of this processor for this program compared to a nonpipelined processor, making the same assumptions used in Section 12.4?</p>
</li>
<li>
<p>What is throughput (in MIPS) of the pipelined processor?</p>
<div class="ulist">
<ul>
<li>
<p>Desarrollo</p>
<div class="ulist">
<ul>
<li>
<p>a. Duración Programa con N instrucciones, segmentación de k etapas de duración t cada una= 1ª instrucción más el resto = <em>k*t +(N-1)<strong>t = t</strong>(N+k-1) = para N&gt;&gt;k = t*(N-1)</em> . La relación sin_seg/con_seg = N*k*t / t(N+k-1) = Nk/(N+k-1) . Si N tiende a infinito &#8594; Nk/N=k=5</p>
</li>
<li>
<p>b. Throughput = instrucciones del programa/duración del programa= N/{t*(N+k-1)}=1/t</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>12.11 Consider an instruction sequence of length n that is streaming through the instruction pipeline. Let p be the probability of encountering a conditional or unconditional branch instruction, and let q be the probability that execution of a branch instruction I causes a jump to a nonconsecutive address. Assume that each such jump requires the pipeline to be cleared, destroying all ongoing instruction processing, when I emerges from the last stage. Revise Equations (12.1) and (12.2) to take these probabilities into account.</p>
<div class="ulist">
<ul>
<li>
<p>Desarrollo</p>
<div class="ulist">
<ul>
<li>
<p>Instrucciones cuya ejecución es un salto no consecutivo : pqn</p>
</li>
<li>
<p>Instrucciones cuya ejecución supone un no salto : (1-pq)n</p>
</li>
<li>
<p>T_programa=T_inst_salto+T_inst_nosalto = {pq*nkt}+{(1-pq)*(k+n-1)t}</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>12.13 Consider the state diagrams of Figure 12.28.</p>
<div class="olist loweralpha">
<ol class="loweralpha">
<li>
<p>Describe the behavior of each.</p>
</li>
<li>
<p>Compare these with the branch prediction state diagram in Section 12.4. Discuss the relative merits of each of the three approaches to branch prediction.</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><span class="image"><img src="./images/ejercicios/cpu_12-13.png" alt="cpu 12 13" title="Predicción de Salto"></span></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Predict taken: predicción de SI salto.</p>
</li>
<li>
<p>Diagrama A:</p>
<div class="ulist">
<ul>
<li>
<p>Cambio de predicción afirmativa a negativa:</p>
<div class="ulist">
<ul>
<li>
<p>Partiendo de predicción de salto SI &#8594; Dos "NO" consecutivos para cambiar la predicción a NO</p>
</li>
</ul>
</div>
</li>
<li>
<p>Cambio de predicción negativa a afirmativa:</p>
<div class="ulist">
<ul>
<li>
<p>Partiendo de predicción de salto NO &#8594; Un "SI"  para cambiar la predicción a SÍ</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Diagrama B:</p>
<div class="ulist">
<ul>
<li>
<p>Cambio de predicción afirmativa a negativa:</p>
<div class="ulist">
<ul>
<li>
<p>Partiendo de predicción de salto SI &#8594; Dos "NO" consecutivos para cambiar la predicción a NO</p>
</li>
</ul>
</div>
</li>
<li>
<p>Cambio de predicción negativa a afirmativa:</p>
<div class="ulist">
<ul>
<li>
<p>Partiendo de predicción de salto NO &#8594; Un "SI"  para cambiar la predicción a SÍ si previamente ha habido dos "NO SALTO" consecutivos</p>
</li>
<li>
<p>Partiendo de predicción de salto NO &#8594; Dos "SI"  para cambiar la predicción a SÍ si ha habido más de dos "NO SALTO" consecutivos</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>12.14 The Motorola 680x0 machines include the instruction <em>Decrement and Branch According to Condition</em>, which has the following form:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c">     <span class="n">DBcc</span> <span class="n">Dn</span><span class="p">,</span> <span class="n">displacement</span>

<span class="n">where</span> <span class="n">cc</span> <span class="n">is</span> <span class="n">one</span> <span class="n">of</span> <span class="n">the</span> <span class="n">testable</span> <span class="n">conditions</span><span class="p">,</span> <span class="n">Dn</span> <span class="n">is</span> <span class="n">a</span> <span class="n">general</span><span class="o">-</span><span class="n">purpose</span> <span class="k">register</span><span class="p">,</span> <span class="n">and</span> <span class="n">displacement</span>
<span class="n">specifies</span> <span class="n">the</span> <span class="n">target</span> <span class="n">address</span> <span class="n">relative</span> <span class="n">to</span> <span class="n">the</span> <span class="n">current</span> <span class="n">address</span><span class="p">.</span>

<span class="n">The</span> <span class="n">instruction</span> <span class="n">can</span> <span class="n">be</span> <span class="n">defined</span> <span class="n">as</span> <span class="n">follows</span><span class="o">:</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">cc</span> <span class="o">=</span> <span class="n">False</span><span class="p">)</span>
     <span class="n">then</span> <span class="n">begin</span>
     <span class="n">Dn</span> <span class="o">:=</span> <span class="p">(</span><span class="n">Dn</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
     <span class="k">if</span> <span class="n">Dn</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="n">then</span> <span class="n">PC</span> <span class="o">:=</span> <span class="p">(</span><span class="n">PC</span><span class="p">)</span> <span class="o">+</span> <span class="n">displacement</span> <span class="n">end</span>
   <span class="k">else</span> <span class="n">PC</span> <span class="o">:=</span> <span class="p">(</span><span class="n">PC</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>When the instruction is executed, the condition is first tested to determine whether the termination condition for the loop is satisfied. If so, no operation is performed and execution continues at the next instruction in sequence. If the condition is false, the specified data register is decremented and checked to see if it is less than zero. If it is less than zero, the loop is terminated and execution continues at the next instruction in sequence. Otherwise, the program branches to the specified location. Now consider the following assembly-language program fragment:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">AGAIN</span> <span class="n">CMPM</span><span class="p">.</span><span class="n">L</span> <span class="p">(</span><span class="n">A0</span><span class="p">)</span><span class="o">+</span><span class="p">,</span> <span class="p">(</span><span class="n">A1</span><span class="p">)</span><span class="o">+</span>
      <span class="n">DBNE</span> <span class="n">D1</span><span class="p">,</span> <span class="n">AGAIN</span>
      <span class="n">NOP</span></code></pre>
</div>
</div>
</li>
<li>
<p>Two strings addressed by A0 and A1 are compared for equality; the string pointers are incremented with each reference. D1 initially contains the number of longwords (4 bytes) to be compared.</p>
<div class="olist loweralpha">
<ol class="loweralpha">
<li>
<p>The initial contents of the registers are A0 = $00004000, A1 = $00005000 and D1 = $000000FF (the $ indicates hexadecimal notation). Memory between $4000 and $6000 is loaded with words $AAAA. If the foregoing program is run, specify the number of times the DBNE loop is executed and the contents of the three registers when the NOP instruction is reached.</p>
</li>
<li>
<p>Repeat (a), but now assume that memory between $4000 and $4FEE is loaded with $0000 and between $5000 and $6000 is loaded with $AAA.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Desarrollo:</p>
<div class="ulist">
<ul>
<li>
<p>La instrucción DBcc se emplea como control de los bucles una vez finalizada cada iteracción. La condicción cc hace referencia a la última operación antes de la instrucción DBcc, en este caso CMPM.L. Si la condición es verdadera &#8594; Fin de bucle y sigue la secuencia del programa. Si la condición es falsa decrementa el contador de iteraciones y salta al comienzo del bucle. Palabras tipo .L (Large) de 4 bytes. D1=0xFF. D1-1=0xFFFFFFFF. A0 puntero a string &#8594; (A0) indirección &#8594; (A0)+ incrementa el puntero en una palabra en cada ejecución.</p>
<div class="olist loweralpha">
<ol class="loweralpha">
<li>
<p>Los dos punteros apuntan a memoria cuyo contenido es $AAAA por lo tanto la comparación da como resultado EQUAL. La condición de la instrucción DBcc es NE, not equal, por lo tanto es FALSE  y sí se ejecuta el bucle.  Se ejecuta 0xFF+1 veces hasta llegar el contador D1=-1. Ultima dirección del puntero A0 &#8594; 0x4000+0xFFpalabras+1palabra=0x4000+4x(0xFF)bytes+4bytes &#8594;2<sup>2</sup>x(0xFF) equivale a desplazar 0xFF dos bits a la izda = 0x3FC &#8594; 0x4000+0x3FC+4=0x4400. Puntero A1 &#8594;  0x5000+0x3FC+4=0x5400.</p>
</li>
<li>
<p>Todas las comparaciones dan como resultado distinto de cero &#8594; NE &#8594; por lo tanto TRUE &#8594; Unicamente se ejecuta una iteracción. D1=0xFF-1=0xFE; A0=A0+1palabra=0x4004 y A1=0x5004</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>12.15 Redraw Figures 12.19c (14.21c), assuming that the conditional branch is not taken</p>
<div class="paragraph">
<p><span class="image"><img src="./images/ejercicios/14-21.png" alt="14 21"></span></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Desarrollo:</p>
<div class="ulist">
<ul>
<li>
<p>80486: 32 bits</p>
</li>
<li>
<p>Etapas del cauce (pipeline) de instrucciones: FE-D1-D2-Ex-WB.</p>
</li>
<li>
<p>Fetch: Captura de la instrucción</p>
</li>
<li>
<p>D1: Decodifico Cod.Op y Modo Direccionamiento</p>
</li>
<li>
<p>D2: Operaciones para el cálculo de la Dirección Efectiva del Operando</p>
</li>
<li>
<p>EX: Operaciones ALU y acceso a operandos</p>
</li>
<li>
<p>WB: EFLAGS, Resultados en Reg y Mem(Caché y MP)</p>
</li>
<li>
<p>Figura 12.19 b) La 1ª ins. en EX lee el operando de la memoria y la 2ª en D2 accede a memoria para leer del puntero la dirección del operando.</p>
</li>
<li>
<p>Figura 12.19 c) La instrucción CMP actualiza reg flags. La instrucción Jcc en D2 ya tiene la dirección de salto aunque actualiza el Contador de Programa en EX. La inst 3ª después de D2 de Jcc ya pueded ser capturada.</p>
</li>
<li>
<p>Sí salto:</p>
<div class="ulist">
<ul>
<li>
<p>La cpu realiza la captura de la 3ª instrucción (Fetch) inmediatamente despúes de la captura de la segunda pero dicha captura es errónea ya que ha capturado la siguiente en secuencia a la 2ª y no la instrucción target. La captura de la instrucción destino se ha de realizar cuando se conozca la dirección dónde se encuentra  dicha instrucción.</p>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/ditaa/svg/eNrj0tYFA7wUV40CGOCgwp2glJVjcklpYk5mVWKRgltOYnqxgq6dQvDhtQrFiTkl-VxEWaWAwyoXIySei5GVS2ZRanJy5uHNeQopqcUlmXn5MK3EWIPXbqygxi21JDkD012uEUg8sBorhcy84pKiUlTXAekcaDjgs4YYdwIA9V9dzA==" alt="Diagram">
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>No salto:</p>
<div class="ulist">
<ul>
<li>
<p>La CPU captura las 3 instrucciones en secuencia y no se equivoca en la 3ª ya que no hay salto.</p>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/ditaa/svg/eNrj0tYFA7wUV40CGOCgwp2glJVjcklpYk5mVWKRgltOYnqxgq6dgl--QnFiTkk-F1E2KeCwycUIiediZOWSWZSanJx5eHOeQkpqcUlmXj6KXVBjiLESzWaYA9xSS5IzMN3hGoHggZVYKWTmFZcUlUIdk5qnUJyaXJqal5yZiGYkMa4AANA0WHQ=" alt="Diagram">
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>12.16 Table 14.5 summarizes statistics from [MACD84] concerning branch behavior for various classes of applications. With the exception of type 1 branch behavior, there is no noticeable difference among the application classes. Determine the fraction of all branches that go to the branch target address for the scientific environment. Repeat for commercial and systems environments.</p>
<div class="paragraph">
<p><span class="image"><img src="./images/ejercicios/14-5.png" alt="14 5"></span></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Desarrollo:</p>
<div class="ulist">
<ul>
<li>
<p>tipo1=72.5 ; tipo2=9.8 ; tipo3=17.7</p>
<div class="ulist">
<ul>
<li>
<p>tipo1: hay 3 casos dentro del tipo1 (1/3 salta incondicional,1/3 salta condicional,1/3 no salta)</p>
</li>
<li>
<p>tipo2: 91%salta, el 9% no salta</p>
</li>
<li>
<p>tipo3: saltan todas</p>
</li>
</ul>
</div>
</li>
<li>
<p>Salto a destino= tipo1x[(0.2+0.4+0.35)x100/100+(43.2+24.3+32.5)x1/3]+
 tipo2x0.91+
 tipo3x100/100
=</p>
</li>
<li>
<p>Saltos to taget por aplicaciones</p>
<div class="ulist">
<ul>
<li>
<p>científica=tipo1x[(0.2 )x100/100+(43.2)x1/3]+ tipo2x0.91+tipo3x100/100=0.724&#8594; El 72% de los saltos de una aplicación científica son a destino.</p>
</li>
<li>
<p>comercial =tipo1x[(0.4 )x100/100+(24.3)x1/3]+ tipo2x0.91+tipo3x100/100=0.732</p>
</li>
<li>
<p>sistema   =tipo1x[(0.35)x100/100+(32.5)x1/3]+ tipo2x0.91+tipo3x100/100=0.756</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_capitulo_13_reduces_instruction_set_computer_capítulo_15_en_9ªed">10.13. Capitulo 13: Reduces Instruction Set Computer (Capítulo 15 en 9ªEd)</h3>
<div class="ulist">
<ul>
<li>
<p>13.3 We wish to determine the execution time for a given program using the various pipelining schemes discussed in Section 13.5. Let
N = number of executed instructions, J = number of jump instructions, D = number of memory accesses. For the simple sequential scheme (Figure 13.6a) for a RISC architecture, the execution time is 2N+D stages. Derive formulas for two-stage, three-stage, and four-stage pipelining.</p>
<div class="paragraph">
<p><span class="image"><img src="./images/ejercicios/15-6.png" alt="15 6"></span></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Desarrollo:</p>
<div class="ulist">
<ul>
<li>
<p>CAUCE SEGMENTADO: I &#8594; captación de la instrucción. E&#8594; operaciones ALU con Reg. u obtención de la dirección efectiva. D&#8594; Transferencia Mem &lt;&#8594; Reg.</p>
</li>
<li>
<p>Cada instrucción tiene por lo menos dos etapas: E e I. En cambio la etapa D no la tienen todas las instrucciones (sólo load y store entre reg y mem)</p>
<div class="olist loweralpha">
<ol class="loweralpha">
<li>
<p>Figura apartado a &#8594;T=Nx(t<sub>e</sub>+t<sub>i</sub>)+t<sub>d</sub>xD; si t<sub>i</sub>=t<sub>e</sub>=t<sub>d</sub>=t &#8594; T=[2N+D]t</p>
</li>
<li>
<p>Figura apartado b &#8594; Cauce segmentado &#8594; k=2 &#8594; Sin instrucciones de salto &#8594; T<sub>k,n</sub>=[k+(n-1)]t &#8594;  T<sub>2,n</sub>=[2+(N-1)]t .</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Sólo es posible un acceso a memoria en cada etapa.</p>
</li>
<li>
<p>I es una etapa, E y D forman una única etapa.</p>
</li>
<li>
<p>E e I se solapan &#8594; N etapas E|I</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c">     <span class="o">+-----+</span>
     <span class="o">|</span>  <span class="n">E</span>  <span class="o">|</span>
     <span class="o">+-----+</span>
     <span class="o">|</span>  <span class="n">I</span>  <span class="o">|</span>
     <span class="o">+-----+</span></code></pre>
</div>
</div>
</li>
<li>
<p>D no se solapa &#8594; D etapas</p>
</li>
<li>
<p>En la fase E de la instrucción Branch se calcula la dirección de salto por lo que la fase I de la instrucción destino no puede coincidir con dicha fase E. Se soluciona con un instrucción de no operación NOOP.</p>
</li>
<li>
<p>Los saltos originan un NOOP &#8594; una etapa de retardo más que añadir</p>
</li>
<li>
<p>T=(N+D+J)t</p>
</li>
</ol>
</div>
</li>
<li>
<p>Figura apartado c &#8594; k=3 etapas</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>En una etapa son posibles dos accesos a memoria.</p>
</li>
<li>
<p>La 2ª instrucción load carga el dato en el registro en la etapa D por lo que no puede coincidir con la ejecución de la instrucción suma.</p>
</li>
<li>
<p>D,E e I se solapan si no hay dependencia de datos</p>
</li>
<li>
<p>Si hay dependencias D no se solapa por lo que hay una fracción de las D instrucciones que hay que sumar.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c">     <span class="o">+-----+</span>
     <span class="o">|</span>  <span class="n">E</span>  <span class="o">|</span>
     <span class="o">+-----+</span>
     <span class="o">|</span>  <span class="n">I</span>  <span class="o">|</span>
     <span class="o">+-----+</span>
                    <span class="o">-&gt;</span> <span class="n">N</span><span class="o">+</span><span class="n">alfaxD</span>
     <span class="o">+-----+</span>
     <span class="o">|</span>  <span class="n">E</span>  <span class="o">|</span>
     <span class="o">+-----+</span>
     <span class="o">|</span>  <span class="n">I</span>  <span class="o">|</span>
     <span class="o">+-----+</span>
     <span class="o">|</span>  <span class="n">D</span>  <span class="o">|</span>
     <span class="o">+-----+</span></code></pre>
</div>
</div>
</li>
<li>
<p>T=(N+alfa*D+J)t &#8594; J noops</p>
</li>
</ol>
</div>
</li>
<li>
<p>Figura apartado d &#8594; k=4 etapas</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Dividimos E en E1 (lectura RPG) y E2 (ALU y escritura RPG)</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c">     <span class="o">+-----+</span>
     <span class="o">|</span>  <span class="n">D</span>  <span class="o">|</span>
     <span class="o">+-----+</span>
     <span class="o">|</span> <span class="n">E2</span>  <span class="o">|</span>
     <span class="o">+-----+</span>
     <span class="o">|</span> <span class="n">E1</span>  <span class="o">|</span>
     <span class="o">+-----+</span>
     <span class="o">|</span>  <span class="n">I</span>  <span class="o">|</span>
     <span class="o">+-----+</span></code></pre>
</div>
</div>
</li>
<li>
<p>El solape de D con dependencia de datos introduce un retardo y J otros dos según la figura.</p>
</li>
<li>
<p>T=(N+alfa*D+2J)t</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>13.4 Reorganize the code sequence in Figure 13.6d to reduce the number of NOOPs. Figura del ejercicio 13.3 d).</p>
<div class="paragraph">
<p><span class="image"><img src="./images/ejercicios/risc_pipelining_13-6.png" alt="risc pipelining 13 6" title="Diagrama de Tiempos.Segmentación de 4 Etapas"></span></p>
</div>
<div class="ulist">
<ul>
<li>
<p>La instrucción Branch la ejecutamos en la posición del 2º NOOP</p>
</li>
<li>
<p>Las dos instrucciones anteriores al salto (Add y Store) en lugar de los 2 NOOP después del salto Branch.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">Load</span> <span class="n">ra</span><span class="o">&lt;-</span><span class="n">M</span>
<span class="n">Load</span> <span class="n">rb</span><span class="o">&lt;-</span><span class="n">M</span>
<span class="n">Noop</span>
<span class="n">Branch</span> <span class="n">X</span>
<span class="n">Add</span>  <span class="n">rc</span><span class="o">&lt;-</span><span class="n">ra</span><span class="o">+</span><span class="n">rb</span>
<span class="n">Store</span> <span class="n">M</span><span class="o">&lt;-</span><span class="n">rc</span>
<span class="n">Next</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Mientras se ejecutan Add y Store se calcula la dirección X</p>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/ditaa/svg/eNpTUAADbV0wwE5xQdQo1CgoeEIoV0MIZQSmXCCCPvmJKQpFiTa6vjANeE1FMxy_HUouSkh2JCHZoUCCB4iySsEvP78Auw4yLMFhl5qrkRqQcipKzEvOUIjAq5d8W9EtV3I1VELyqGMKMCyTbXSLErWLkogxiIz4JCVQUNNTcEl-UaqCL9B5ySSYSS23wZ2o5qkGdhTUwRDKL7WihHTDsDsKAEoNlwA=" alt="Diagram">
</div>
</div>
</li>
<li>
<p>Dependencias: Una vez que se carga rb en la fase "D" ya se puede leer rb en "E1"</p>
</li>
<li>
<p>Dependencias: Una vez que se calcula X en &amp;E2&amp; ya se puede capturar la instrucción Next durante &amp;I&amp;</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>13.5 Consider the following code fragment in a high-level language:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="k">for</span> <span class="n">I</span> <span class="n">in</span> <span class="mi">1</span><span class="p">...</span><span class="mi">100</span> <span class="n">loop</span>
    <span class="n">S</span> <span class="err">←</span> <span class="n">S</span> <span class="o">+</span> <span class="n">Q</span><span class="p">(</span><span class="n">I</span><span class="p">).</span><span class="n">VAL</span>
<span class="n">end</span> <span class="n">loop</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
<li>
<p>Assume that Q is an array of 32-byte records and the VAL field is in the first 4 bytes of each record. Using x86 code, we can compile this program fragment as follows:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c">    <span class="n">MOV</span> <span class="n">ECX</span><span class="p">,</span><span class="mi">1</span> <span class="p">;</span><span class="n">use</span> <span class="k">register</span> <span class="n">ECX</span> <span class="n">to</span> <span class="n">hold</span> <span class="n">I</span>
<span class="n">LP</span><span class="o">:</span> <span class="n">IMUL</span> <span class="n">EAX</span><span class="p">,</span> <span class="n">ECX</span><span class="p">,</span> <span class="mi">32</span> <span class="p">;</span><span class="n">get</span> <span class="n">offset</span> <span class="n">in</span> <span class="n">EAX</span>
    <span class="n">MOV</span> <span class="n">EBX</span><span class="p">,</span> <span class="n">Q</span><span class="p">[</span><span class="n">EAX</span><span class="p">]</span> <span class="p">;</span><span class="n">load</span> <span class="n">VAL</span> <span class="n">field</span>
    <span class="n">ADD</span> <span class="n">S</span><span class="p">,</span> <span class="n">EBX</span> <span class="p">;</span><span class="n">add</span> <span class="n">to</span> <span class="n">S</span>
    <span class="n">INC</span> <span class="n">ECX</span> <span class="p">;</span><span class="n">increment</span> <span class="n">I</span>
    <span class="n">CMP</span> <span class="n">ECX</span><span class="p">,</span> <span class="mi">101</span> <span class="o">:</span><span class="n">compare</span> <span class="n">to</span> <span class="mi">101</span>
    <span class="n">JNE</span> <span class="n">LP</span> <span class="p">;</span><span class="n">loop</span> <span class="n">until</span> <span class="n">I</span> <span class="o">=</span> <span class="mi">100</span></code></pre>
</div>
</div>
</li>
<li>
<p>This program makes use of the IMUL instruction, which multiplies the second operand by the immediate value in the third operand and places the result in the first operand (see Problem 10.13). A RISC advocate would like to demonstrate that a clever compiler can eliminate unnecessarily complex instructions such as IMUL. Provide the demonstration by rewriting the above x86 program without using the IMUL instruction.</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Array Q: 100 registros (estructuras) de 32 bytes cada uno.</p>
</li>
<li>
<p>VAL field: primeros 4 bytes del registro.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span><span class="kt">int</span> <span class="n">VAL</span><span class="p">;....)</span> <span class="n">Data</span><span class="p">;</span>
<span class="n">Data</span> <span class="n">Q</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span></code></pre>
</div>
</div>
</li>
<li>
<p>Q(i).VAL : El campo VAL de cada registro Q(i)</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c">    <span class="cp">## El bucle suma los campos VAL de los 100 registros
</span>    <span class="n">MOV</span> <span class="n">ECX</span><span class="p">,</span><span class="mi">1</span> <span class="p">;</span><span class="n">use</span> <span class="k">register</span> <span class="n">ECX</span> <span class="n">to</span> <span class="n">hold</span> <span class="n">I</span> <span class="err">#</span><span class="n">Indice</span> <span class="n">de</span> <span class="n">registro</span> <span class="n">del</span> <span class="n">array</span> <span class="n">Q</span>
<span class="n">LP</span><span class="o">:</span> <span class="n">IMUL</span> <span class="n">EAX</span><span class="p">,</span> <span class="n">ECX</span><span class="p">,</span> <span class="mi">32</span> <span class="p">;</span><span class="n">get</span> <span class="n">offset</span> <span class="n">in</span> <span class="n">EAX</span>  <span class="err">#</span><span class="n">EAX</span><span class="o">:</span> <span class="n">direcci</span><span class="err">ó</span><span class="n">n</span> <span class="n">relativa</span> <span class="n">del</span> <span class="n">campo</span> <span class="n">VAL</span> <span class="n">del</span> <span class="n">registro</span> <span class="n">al</span> <span class="n">que</span> <span class="n">apunta</span> <span class="n">el</span> <span class="err">í</span><span class="n">ndice</span> <span class="n">ECX</span> <span class="n">del</span> <span class="n">array</span> <span class="n">Q</span>
                                          <span class="cp">#Cada 32 bytes un registro
</span>    <span class="n">MOV</span> <span class="n">EBX</span><span class="p">,</span> <span class="n">Q</span><span class="p">[</span><span class="n">EAX</span><span class="p">]</span> <span class="p">;</span><span class="n">load</span> <span class="n">VAL</span> <span class="n">field</span>       <span class="err">#</span><span class="n">Q</span> <span class="n">en</span> <span class="n">ensamblador</span> <span class="n">se</span> <span class="n">estructrua</span> <span class="n">en</span> <span class="n">bytes</span><span class="p">.</span> <span class="mi">100</span><span class="n">registrosx32bytes</span><span class="o">/</span><span class="n">registro</span><span class="o">=</span><span class="mi">3200</span><span class="n">registros</span>
    <span class="n">ADD</span> <span class="n">S</span><span class="p">,</span> <span class="n">EBX</span>      <span class="p">;</span><span class="n">add</span> <span class="n">to</span> <span class="n">S</span>             <span class="err">#</span><span class="n">Suma</span> <span class="n">de</span> <span class="n">los</span> <span class="mi">4</span> <span class="n">bytes</span> <span class="n">del</span> <span class="n">campo</span> <span class="n">VAL</span>
    <span class="n">INC</span> <span class="n">ECX</span>         <span class="p">;</span><span class="n">increment</span> <span class="n">I</span>          <span class="err">#</span><span class="n">siguiente</span> <span class="n">registro</span>
    <span class="n">CMP</span> <span class="n">ECX</span><span class="p">,</span> <span class="mi">101</span>    <span class="p">;</span><span class="n">compare</span> <span class="n">to</span> <span class="mi">101</span>       <span class="err">#</span><span class="n">ultimo</span><span class="o">+</span><span class="mi">1</span> <span class="n">registro</span><span class="o">?</span>
    <span class="n">JNE</span> <span class="n">LP</span>          <span class="p">;</span><span class="n">loop</span> <span class="n">until</span> <span class="n">I</span> <span class="o">=</span> <span class="mi">100</span>   <span class="err">#</span><span class="n">Siguiente</span> <span class="n">interacci</span><span class="err">ó</span><span class="n">n</span> <span class="n">si</span> <span class="n">no</span> <span class="n">ultimo</span></code></pre>
</div>
</div>
</li>
<li>
<p>Multiplicar por 2<sup>x</sup> equivale a un desplazamiento de x bits a la izda</p>
<div class="ulist">
<ul>
<li>
<p>Multiplicar por 32 &#8594; x2<sup>5</sup> &#8594; desplazar 5 bits a la izda : shl $5,%ecx</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>13.6 Consider the following loop:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">S</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="k">for</span> <span class="n">K</span> <span class="o">:=</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">100</span> <span class="k">do</span>
<span class="n">S</span> <span class="o">:=</span> <span class="n">S</span> <span class="o">-</span> <span class="n">K</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
<li>
<p>A straightforward translation of this into a <em>generic</em> assembly language would look something like this:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c">   <span class="n">LD</span> <span class="n">R1</span><span class="p">,</span> <span class="mi">0</span>          <span class="p">;</span><span class="n">keep</span> <span class="n">value</span> <span class="n">of</span> <span class="n">S</span> <span class="n">in</span> <span class="n">R1</span>
   <span class="n">LD</span> <span class="n">R2</span><span class="p">,</span><span class="mi">1</span>           <span class="p">;</span><span class="n">keep</span> <span class="n">value</span> <span class="n">of</span> <span class="n">K</span> <span class="n">in</span> <span class="n">R2</span>
<span class="n">LP</span> <span class="n">SUB</span> <span class="n">R1</span><span class="p">,</span> <span class="n">R1</span><span class="p">,</span> <span class="n">R2</span>    <span class="p">;</span><span class="n">S</span> <span class="o">:=</span> <span class="n">S</span> <span class="o">-</span> <span class="n">K</span>
   <span class="n">BEQ</span> <span class="n">R2</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">EXIT</span> <span class="p">;</span><span class="n">done</span> <span class="k">if</span> <span class="n">K</span> <span class="o">=</span> <span class="mi">100</span>          <span class="err">#</span><span class="n">Branch</span> <span class="n">EQual</span>
   <span class="n">ADD</span> <span class="n">R2</span><span class="p">,</span> <span class="n">R2</span><span class="p">,</span> <span class="mi">1</span>     <span class="p">;</span><span class="k">else</span> <span class="n">increment</span> <span class="n">K</span>
   <span class="n">JMP</span> <span class="n">LP</span>            <span class="p">;</span><span class="n">back</span> <span class="n">to</span> <span class="n">start</span> <span class="n">of</span> <span class="n">loop</span></code></pre>
</div>
</div>
</li>
<li>
<p>A compiler for a <em>RISC</em> machine will <em>introduce</em> delay slots into this code so that the processor can employ the <em>delayed branch mechanism</em>.The JMP instruction is easy to deal with, because this instruction is always followed by the SUB instruction; therefore, we can simply place a copy of the SUB instruction in the delay slot after the JMP. The BEQ presents a difficulty. We can’t leave the code as is, because the ADD instruction would then be executed one too many times. Therefore, a NOP instruction is needed. Show the resulting code.</p>
</li>
<li>
<p>Desarrollo:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Delayed Branch</p>
<div class="paragraph">
<p><span class="image"><img src="./images/ejercicios/15-7.png" alt="15 7"></span></p>
</div>
<div class="ulist">
<ul>
<li>
<p>La primera gráfica es un salto normal y las otras dos retardado. La última gráfica  supone una instrucción menos</p>
</li>
</ul>
</div>
</li>
<li>
<p>El programa presenta dos instrucciones de salto con retardo: BEQ y JMP</p>
</li>
<li>
<p>JMP LP</p>
<div class="ulist">
<ul>
<li>
<p>Salto incondicional. En el programa original se ejecutará el salto después de <code>SUB R1, R1, R2</code>. Solución:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c">   <span class="n">JMP</span> <span class="n">LP</span>            <span class="p">;</span><span class="n">back</span> <span class="n">to</span> <span class="n">start</span> <span class="n">of</span> <span class="n">loop</span>
   <span class="n">ADD</span> <span class="n">R2</span><span class="p">,</span> <span class="n">R2</span><span class="p">,</span> <span class="mi">1</span>     <span class="p">;</span><span class="k">else</span> <span class="n">increment</span> <span class="n">K</span></code></pre>
</div>
</div>
</li>
<li>
<p>De esta manera el salto se ejecuta después del <code>ADD R2, R2, 1</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>BEQ R2, 100, EXIT</p>
<div class="ulist">
<ul>
<li>
<p>Salto condicional</p>
</li>
<li>
<p>Si lo dejamos como está el salto será después del ADD R2, R2, 1. Solución:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c">   <span class="n">BEQ</span> <span class="n">R2</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">EXIT</span> <span class="p">;</span><span class="n">done</span> <span class="k">if</span> <span class="n">K</span> <span class="o">=</span> <span class="mi">100</span>          <span class="err">#</span><span class="n">Branch</span> <span class="n">EQual</span>
<span class="n">LP</span> <span class="n">SUB</span> <span class="n">R1</span><span class="p">,</span> <span class="n">R1</span><span class="p">,</span> <span class="n">R2</span>    <span class="p">;</span><span class="n">S</span> <span class="o">:=</span> <span class="n">S</span> <span class="o">-</span> <span class="n">K</span></code></pre>
</div>
</div>
</li>
<li>
<p>Ahora el salto condicional se realizará después de la resta SUB</p>
</li>
</ul>
</div>
</li>
<li>
<p>Solución 1ª:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c">   <span class="n">LD</span> <span class="n">R1</span><span class="p">,</span> <span class="mi">0</span>          <span class="p">;</span><span class="n">keep</span> <span class="n">value</span> <span class="n">of</span> <span class="n">S</span> <span class="n">in</span> <span class="n">R1</span>
   <span class="n">LD</span> <span class="n">R2</span><span class="p">,</span><span class="mi">1</span>           <span class="p">;</span><span class="n">keep</span> <span class="n">value</span> <span class="n">of</span> <span class="n">K</span> <span class="n">in</span> <span class="n">R2</span>
<span class="n">LP</span> <span class="n">BEQ</span> <span class="n">R2</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">EXIT</span> <span class="p">;</span><span class="n">done</span> <span class="k">if</span> <span class="n">K</span> <span class="o">=</span> <span class="mi">100</span>          <span class="err">#</span><span class="n">Branch</span> <span class="n">EQual</span>
   <span class="n">SUB</span> <span class="n">R1</span><span class="p">,</span> <span class="n">R1</span><span class="p">,</span> <span class="n">R2</span>    <span class="p">;</span><span class="n">S</span> <span class="o">:=</span> <span class="n">S</span> <span class="o">-</span> <span class="n">K</span>
   <span class="n">JMP</span> <span class="n">LP</span>            <span class="p">;</span><span class="n">back</span> <span class="n">to</span> <span class="n">start</span> <span class="n">of</span> <span class="n">loop</span>
   <span class="n">ADD</span> <span class="n">R2</span><span class="p">,</span> <span class="n">R2</span><span class="p">,</span> <span class="mi">1</span>     <span class="p">;</span><span class="k">else</span> <span class="n">increment</span> <span class="n">K</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Tiene el defecto de que si R2=100 se ejecuta también SUB modificando el valor final de R1 y R2</p>
</li>
</ul>
</div>
</li>
<li>
<p>Solución Definitiva:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c">   <span class="n">LD</span> <span class="n">R1</span><span class="p">,</span> <span class="mi">0</span>          <span class="p">;</span><span class="n">keep</span> <span class="n">value</span> <span class="n">of</span> <span class="n">S</span> <span class="n">in</span> <span class="n">R1</span>
   <span class="n">LD</span> <span class="n">R2</span><span class="p">,</span><span class="mi">1</span>           <span class="p">;</span><span class="n">keep</span> <span class="n">value</span> <span class="n">of</span> <span class="n">K</span> <span class="n">in</span> <span class="n">R2</span>
<span class="n">LP</span> <span class="n">BEQ</span> <span class="n">R2</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">EXIT</span> <span class="p">;</span><span class="n">done</span> <span class="k">if</span> <span class="n">K</span> <span class="o">=</span> <span class="mi">100</span>          <span class="err">#</span><span class="n">Branch</span> <span class="n">EQual</span>
   <span class="n">NOP</span>
   <span class="n">ADD</span> <span class="n">R2</span><span class="p">,</span> <span class="n">R2</span><span class="p">,</span> <span class="mi">1</span>     <span class="p">;</span><span class="k">else</span> <span class="n">increment</span> <span class="n">K</span>
   <span class="n">JMP</span> <span class="n">LP</span>            <span class="p">;</span><span class="n">back</span> <span class="n">to</span> <span class="n">start</span> <span class="n">of</span> <span class="n">loop</span>
   <span class="n">SUB</span> <span class="n">R1</span><span class="p">,</span> <span class="n">R1</span><span class="p">,</span> <span class="n">R2</span>    <span class="p">;</span><span class="n">S</span> <span class="o">:=</span> <span class="n">S</span> <span class="o">-</span> <span class="n">K</span></code></pre>
</div>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>13.7 A RISC machine may do both a mapping of symbolic registers to actual registers and a <em>rearrangement</em> of instructions for pipeline efficiency. An interesting question arises as to the order in which these two operations should be done. Consider the following program fragment:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"> <span class="n">LD</span> <span class="n">SR1</span><span class="p">,</span><span class="n">A</span>          <span class="p">;</span><span class="n">load</span> <span class="n">A</span> <span class="n">into</span> <span class="n">symbolic</span> <span class="k">register</span> <span class="mi">1</span>
 <span class="n">LD</span> <span class="n">SR2</span><span class="p">,</span> <span class="n">B</span>         <span class="p">;</span><span class="n">load</span> <span class="n">B</span> <span class="n">into</span> <span class="n">symbolic</span> <span class="k">register</span> <span class="mi">2</span>
 <span class="n">ADD</span> <span class="n">SR3</span><span class="p">,</span> <span class="n">SR1</span><span class="p">,</span> <span class="n">SR2</span> <span class="p">;</span><span class="n">add</span> <span class="n">contents</span> <span class="n">of</span> <span class="n">SR1</span> <span class="n">and</span> <span class="n">SR2</span> <span class="n">and</span> <span class="n">store</span> <span class="n">in</span> <span class="n">SR3</span>
 <span class="n">LD</span> <span class="n">SR4</span><span class="p">,</span> <span class="n">C</span>
 <span class="n">LD</span> <span class="n">SR5</span><span class="p">,</span><span class="n">D</span>
 <span class="n">ADD</span> <span class="n">SR6</span><span class="p">,</span> <span class="n">SR4</span><span class="p">,</span> <span class="n">SR5</span></code></pre>
</div>
</div>
<div class="olist loweralpha">
<ol class="loweralpha">
<li>
<p>First do the register mapping and then any possible instruction reordering. How many machine registers are used? Has there been any pipeline improvement?</p>
</li>
<li>
<p>Starting with the original program, now do instruction reordering and then any possible mapping. How many machine registers are used? Has there been any pipeline improvement?</p>
</li>
</ol>
</div>
</li>
<li>
<p>Desarrollo:
.</p>
</li>
<li>
<p>13.9 In many cases, common machine instructions that are not listed as part of the MIPS instruction set can be synthesized with a single MIPS instruction. Show this for the following:</p>
<div class="olist loweralpha">
<ol class="loweralpha">
<li>
<p>Register-to-register move</p>
</li>
<li>
<p>Increment, decrement</p>
</li>
<li>
<p>Complement</p>
</li>
<li>
<p>Negate</p>
</li>
<li>
<p>Clear</p>
</li>
</ol>
</div>
</li>
<li>
<p>13.11 SPARC is lacking a number of instructions commonly found on CISC machines.
Some of these are easily simulated using either register R0, which is always set to 0, or a constant operand. These simulated instructions are called pseudoinstructions and are recognized by the SPARC compiler. Show how to simulate the following pseudoinstructions, each with a single SPARC instruction. In all of these, src and dst refer to registers. (Hint: A store to R0 has no effect.)</p>
<div class="olist loweralpha">
<ol class="loweralpha">
<li>
<p>MOV src, dst</p>
</li>
<li>
<p>COMPARE src1, src2</p>
</li>
<li>
<p>TEST src1</p>
</li>
<li>
<p>NOT dst</p>
</li>
<li>
<p>NEG dst</p>
</li>
<li>
<p>INC dst</p>
</li>
<li>
<p>DEC dst</p>
</li>
<li>
<p>CLR dst</p>
</li>
<li>
<p>NOP</p>
</li>
</ol>
</div>
</li>
<li>
<p>13.12 Consider the following code fragment:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"> <span class="k">if</span> <span class="n">K</span> <span class="o">&gt;</span> <span class="mi">10</span>
   <span class="n">L</span> <span class="o">:=</span> <span class="n">K</span> <span class="o">+</span> <span class="mi">1</span>
 <span class="k">else</span>
   <span class="n">L</span> <span class="o">:=</span> <span class="n">K</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span></code></pre>
</div>
</div>
</li>
<li>
<p>A straightforward translation of this statement into SPARC assembler could take the following form:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c">    <span class="n">sethi</span> <span class="o">%</span><span class="n">hi</span><span class="p">(</span><span class="n">K</span><span class="p">),</span> <span class="o">%</span><span class="n">r8</span>        <span class="p">;</span><span class="n">load</span> <span class="n">high</span><span class="o">-</span><span class="n">order</span> <span class="mi">22</span> <span class="n">bits</span> <span class="n">of</span> <span class="n">address</span> <span class="n">of</span> <span class="n">location</span>
                         <span class="p">;</span><span class="n">K</span> <span class="n">into</span> <span class="k">register</span> <span class="n">r8</span>
    <span class="n">ld</span> <span class="p">[</span><span class="o">%</span><span class="n">r8</span> <span class="o">+</span> <span class="o">%</span><span class="n">lo</span><span class="p">(</span><span class="n">K</span><span class="p">)],</span> <span class="o">%</span><span class="n">r8</span>   <span class="p">;</span><span class="n">load</span> <span class="n">contents</span> <span class="n">of</span> <span class="n">location</span> <span class="n">K</span> <span class="n">into</span> <span class="n">r8</span>
    <span class="n">cmp</span> <span class="o">%</span><span class="n">r8</span><span class="p">,</span> <span class="mi">10</span>              <span class="p">;</span><span class="n">compare</span> <span class="n">contents</span> <span class="n">of</span> <span class="n">r8</span> <span class="n">with</span> <span class="mi">10</span>
    <span class="n">ble</span> <span class="n">L1</span>                   <span class="p">;</span><span class="n">branch</span> <span class="k">if</span> <span class="p">(</span><span class="n">r8</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">10</span>
    <span class="n">nop</span>
    <span class="n">sethi</span> <span class="o">%</span><span class="n">hi</span><span class="p">(</span><span class="n">K</span><span class="p">),</span> <span class="o">%</span><span class="n">r9</span>
    <span class="n">ld</span> <span class="p">[</span><span class="o">%</span><span class="n">r9</span> <span class="o">+</span> <span class="o">%</span><span class="n">lo</span><span class="p">(</span><span class="n">K</span><span class="p">)],</span> <span class="o">%</span><span class="n">r9</span>   <span class="p">;</span><span class="n">load</span> <span class="n">contents</span> <span class="n">of</span> <span class="n">location</span> <span class="n">K</span> <span class="n">into</span> <span class="n">r9</span>
    <span class="n">inc</span> <span class="o">%</span><span class="n">r9</span>                  <span class="p">;</span><span class="n">add</span> <span class="mi">1</span> <span class="n">to</span> <span class="p">(</span><span class="n">r9</span><span class="p">)</span>
    <span class="n">sethi</span> <span class="o">%</span><span class="n">hi</span><span class="p">(</span><span class="n">L</span><span class="p">),</span> <span class="o">%</span><span class="n">r10</span>
    <span class="n">st</span> <span class="o">%</span><span class="n">r9</span><span class="p">,</span> <span class="p">[</span><span class="o">%</span><span class="n">r10</span> <span class="o">+</span> <span class="o">%</span><span class="n">lo</span><span class="p">(</span><span class="n">L</span><span class="p">)]</span>  <span class="p">;</span><span class="n">store</span> <span class="p">(</span><span class="n">r9</span><span class="p">)</span> <span class="n">into</span> <span class="n">location</span> <span class="n">L</span>
    <span class="n">b</span> <span class="n">L2</span>
    <span class="n">nop</span>
<span class="n">L1</span><span class="o">:</span> <span class="n">sethi</span> <span class="o">%</span><span class="n">hi</span><span class="p">(</span><span class="n">K</span><span class="p">),</span> <span class="o">%</span><span class="n">r11</span>
    <span class="n">ld</span> <span class="p">[</span><span class="o">%</span><span class="n">r11</span> <span class="o">+</span> <span class="o">%</span><span class="n">lo</span><span class="p">(</span><span class="n">K</span><span class="p">)],</span> <span class="o">%</span><span class="n">r12</span> <span class="p">;</span><span class="n">load</span> <span class="n">contents</span> <span class="n">of</span> <span class="n">location</span> <span class="n">K</span> <span class="n">into</span> <span class="n">r12</span>
    <span class="n">dec</span> <span class="o">%</span><span class="n">r12</span>                 <span class="p">;</span><span class="n">subtract</span> <span class="mi">1</span> <span class="n">from</span> <span class="p">(</span><span class="n">r12</span><span class="p">)</span>
    <span class="n">sethi</span> <span class="o">%</span><span class="n">hi</span><span class="p">(</span><span class="n">L</span><span class="p">),</span> <span class="o">%</span><span class="n">r13</span>
    <span class="n">st</span> <span class="o">%</span><span class="n">r12</span><span class="p">,</span> <span class="p">[</span><span class="o">%</span><span class="n">r13</span> <span class="o">+</span> <span class="o">%</span><span class="n">lo</span><span class="p">(</span><span class="n">L</span><span class="p">)]</span> <span class="p">;</span><span class="n">store</span> <span class="p">(</span><span class="n">r12</span><span class="p">)</span> <span class="n">into</span> <span class="n">location</span> <span class="n">L</span>
<span class="n">L2</span><span class="o">:</span></code></pre>
</div>
</div>
</li>
<li>
<p>The code contains a nop after each branch instruction to permit delayed branch operation.</p>
<div class="olist loweralpha">
<ol class="loweralpha">
<li>
<p>Standard compiler optimizations that have nothing to do with RISC machines aregenerally effective in being able to perform two transformations on the foregoing code. Notice that two of the loads are unnecessary and that the two stores can be merged if the store is moved to a different place in the code. Show the programafter making these two changes.</p>
</li>
<li>
<p>It is now possible to perform some optimizations peculiar to SPARC. The nop after the ble can be replaced by moving another instruction into that delay slot and setting the annul bit on the ble instruction (expressed as ble,a L1). Show the program after this change.</p>
</li>
<li>
<p>There are now two unnecessary instructions. Remove these and show the resulting program</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="paragraph nav-footer">
<p>↑ Up: <a href="_iii_ejercicios_de_teoría.html">III Ejercicios de Teoría</a> | ⌂ Home: <a href="eecc_book.html">Estructura de Computadores  (240306)</a> | Next: <a href="_iv_autoevaluación_teoría.html">IV Autoevaluación Teoría</a> →</p>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2022-09-14 15:29:34 +0200
</div>
</div>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]],
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },
  TeX: { equationNumbers: { autoNumber: "none" } }
})
MathJax.Hub.Register.StartupHook("AsciiMath Jax Ready", function () {
  MathJax.InputJax.AsciiMath.postfilterHooks.Add(function (data, node) {
    if ((node = data.script.parentNode) && (node = node.parentNode) && node.classList.contains("stemblock")) {
      data.math.root.display = "block"
    }
    return data
  })
})
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
</body>
</html>