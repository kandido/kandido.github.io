<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.17">
<meta name="keywords" content="computer, architecture">
<meta name="author" content="Cándido Aramburu">
<title>Estructura de Computadores  (240306)</title>
<style>
@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";
@import "https://cdn.jsdelivr.net/gh/asciidoctor/asciidoctor@2.0/data/stylesheets/asciidoctor-default.css";



h1, h2, h3, h4, h5, h6, #toctitle,
.sidebarblock > .content > .title {
  color: rgba(221, 72, 20, 0.8);
}



</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<!-- Change some CSS.
<style>
.imageblock{
  &.text-center > .title {
    text-align: center !important;
  }
}
</style>

-->

<style type="text/css"> .imageblock > .title { text-align: center; } </style>

<style>.toc-current{font-weight: bold;} .toc-root{font-family: "Open Sans","DejaVu Sans",sans-serif;
                       font-size: 0.9em;} #content{display: flex; flex-direction: column; flex: 1 1 auto;}
             .nav-footer{text-align: center; margin-top: auto;}
             .nav-footer > p > a {white-space: nowrap;}</style>
</head>
<body id="_lenguajes_de_programación_para_sum1ton" class="book">
<div id="header">
<h1>Estructura de Computadores  (240306)</h1>
<div class="details">
<span id="author" class="author">Cándido Aramburu</span><br>
<span id="email" class="email"><a href="mailto:candido@unavarra.es">candido@unavarra.es</a></span><br>
<span id="revdate">2022-09-02</span>
</div>
<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<p><span class="toc-root"><a href="eecc_book.html">Estructura de Computadores  (240306)</a></span></p><ul class="sectlevel0">
<li><a href="_i_arquitectura_del_repertorio_de_instrucciones_isa_computadora_von_neumann_datos_instrucciones_programación.html">I Arquitectura del Repertorio de Instrucciones (ISA): computadora von Neumann, datos, instrucciones, programación.</a>
</li>
<li><a href="_ii_unidades_básicas_procesador_central_unidad_de_memoria_mecanismos_entradasalida.html">II Unidades Básicas: Procesador Central, Unidad de Memoria, Mecanismos Entrada/Salida.</a>
</li>
<li><a href="_iii_ejercicios_de_teoría.html">III Ejercicios de Teoría</a>
</li>
<li><a href="_iv_autoevaluación_teoría.html">IV Autoevaluación Teoría</a>
</li>
<li><a href="_v_guiones_de_prácticas_programación_ensamblador_x86.html">V Guiones de Prácticas: Programación Ensamblador x86</a>
</li>
<li><a href="_vi_hojas_de_referencia_rápida.html">VI Hojas de Referencia Rápida</a>
</li>
<li><a href="_vii_autoevaluación_prácticas.html">VII Autoevaluación Prácticas</a>
</li>
<li><a href="_viii_apéndices.html">VIII Apéndices</a>
<ul class="sectlevel1">
<li><a href="_programas_ensamblador_iassim.html">21. Programas ensamblador IASSim</a>
</li>
<li><a href="_simulador_iassim_2.html">22. Simulador IASSim</a>
</li>
<li><a href="_lenguajes_de_programación_para_sum1ton.html"><span class="toc-current">23. Lenguajes de programación para sum1toN</span></a>
<ul class="sectlevel2">
<li><a href="_lenguajes_de_programación_para_sum1ton.html#sum1toN_lang">23.1. Otros Lenguajes para sum1toN</a>
</li>
</ul>
</li>
<li><a href="_rtl_register_transfer_language.html">24. RTL Register Transfer Language</a>
</li>
<li><a href="_formato_de_instrucción_isa_intel_x86_64_2.html">25. Formato de Instrucción: ISA Intel x86-64</a>
</li>
<li><a href="_fpu_x87.html">26. FPU x87</a>
</li>
<li><a href="_pila.html">27. Pila</a>
</li>
<li><a href="_llamadas_al_sistema_operativo_2.html">28. Llamadas al Sistema Operativo</a>
</li>
<li><a href="_lenguaje_de_programación_c_2.html">29. Lenguaje de Programación C</a>
</li>
<li><a href="_apéndice_prácticas.html">30. Apéndice Prácticas</a>
</li>
<li><a href="_arquitectura_amd64_4.html">31. Arquitectura amd64</a>
</li>
<li><a href="_exámenes_de_cursos_anteriores.html">32. Exámenes de Cursos Anteriores</a>
</li>
<li><a href="_miaulario_videoconferencia.html">33. Miaulario: Videoconferencia</a>
</li>
</ul>
</li>
<li><a href="_ix_bibliografía.html">IX Bibliografía</a>
</li>
<li><a href="_x_glosario.html">X Glosario</a>
</li>
<li><a href="_xi_colofón.html">XI Colofón</a>
</li>
<li><a href="_index.html">Index</a>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_lenguajes_de_programación_para_sum1ton">23. Lenguajes de programación para sum1toN</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="sum1toN_lang">23.1. Otros Lenguajes para sum1toN</h3>
<div class="ulist">
<ul>
<li>
<p>Refs</p>
<div class="ulist">
<ul>
<li>
<p><a href="http://wiki.c2.com/?ArraySumInManyProgrammingLanguages" class="bare">http://wiki.c2.com/?ArraySumInManyProgrammingLanguages</a></p>
</li>
<li>
<p><a href="https://www.rosettacode.org/wiki/Sum_and_product_of_an_array#With_explicit_conversion" class="bare">https://www.rosettacode.org/wiki/Sum_and_product_of_an_array#With_explicit_conversion</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>Desarrollar el algoritmo sum1toN en :  Lisp, Python, Java, C, Pascal,  &#8230;&#8203;</p>
</li>
<li>
<p>elisp</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="lisp">(setq array [1 2 3 4 5])
(apply '+ (append array nil))
(apply '* (append array nil))</code></pre>
</div>
</div>
</li>
<li>
<p>Phyton</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="python">&gt;&gt;&gt; sum(range(5,0,-1))</code></pre>
</div>
</div>
</li>
<li>
<p>Java</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java">/* Programa Fuente: sum1toN.java

 compilación: javac sum1toN.java -&gt; genera el BYTECODE sum1toN.class
 ejecución   -&gt; java -cp . sum1toN  ; necesita el bytecode *.class y ejecutará el main de class

*/

public class sum1toN {
// método main encapsulado en la clase class, static para que main no pueda cambiar los atributos, publico para ser accesible.
    public static void main(String[] args) {
        System.out.println("Suma de Números enteros");
	int x=5, suma=0;

      while (x &gt;= 0 ) {
         System.out.print( x );
         System.out.print(",");
	 suma=suma+x;
	 x--;
      }
      System.out.print("\n");
      System.out.print("suma="+suma);
      System.out.print("\n");
    }
}</code></pre>
</div>
</div>
</li>
<li>
<p>C</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c">/*
  Programa:       sum1toN.c
  Descripción:    realiza la suma de la serie 1,2,3,...N
                  Es el programa en lenguaje C equivalente a sum1toN.ias de la máquina IAS de von Neumann
  Lenguaje:       C99
  Descripción:    Suma de los primeros 5 números naturales
  Entrada:        Definida en una variable
  Salida:         Sin salida
  Compilación:    gcc -m32 -g -o sum1toN sum1toN.c -&gt; -g: módulo binario depurable
                                                   -&gt; -m: módulo binario arquitectura x86-32 bits
  S.O:            GNU/linux 4.10 ubuntu 17.04 x86-64
  Librería:       /usr/lib/x86_64-linux-gnu/libc.so
  CPU:            Intel(R) Core(TM) i5-6300U CPU @ 3.0GHz
  Compilador:     gcc version 6.3
  Ensamblador:    GNU assembler version 2.28
  Linker/Loader:  GNU ld (GNU Binutils for Ubuntu) 2.28
  Asignatura:     Estructura de Computadores
  Fecha:          20/09/2017
  Autor:          Cándido Aramburu
*/

#include &lt;stdio.h&gt;  // cabecera de la librería de la función printf()

// función de entrada al programa
void  main (void)
{
  // Declaración de variables locales
  char suma=0;
  char n=0b101;
  // bucle
  while(n&gt;0){
    suma+=n;
    n--;
  }
 printf("\n La suma es = %d \n",suma);
}</code></pre>
</div>
</div>
</li>
<li>
<p>Lenguaje ensamblador INTEL y assembler nasm</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="nasm">;;; Programa: sum1toN.asm
;;; Descripción: realiza la suma de la serie 1,2,3,...N
;;; Lenguaje INTEL
;;; Assembler NASM

;;; nasm -hf -&gt; ayuda de la opción f
;;; Ensamblaje nasm -g -f elf  sum1toN.asm -o sum1toN.o
;;; linker -&gt; ld -m elf_i386    -o sum1toN sum1toN.o

	BITS 32	; cpu MODE
        ;;  Declaración de variables
        section .data

n:	dd 5	; 4 bytes

        global _start

        ;;  Comienzo del código
        section .text
_start:
        mov ecx,0 ; ECX implementa la variable suma
        mov edx,[n]  ; EDX implementa es un alias de la variable n
bucle:
        add ecx,edx
        sub edx,1
        jnz bucle

        mov ebx, ecx ; el argumento de salida al S.O. a través de EBX según convenio

        ;; salida
        mov eax,1  ; código de la llamada al sistema operativo: subrutina exit
        int 0x80     ; llamada al sistema operativo</code></pre>
</div>
</div>
</li>
<li>
<p>Lenguaje ensamblador ATT para la arquitectura x86-32</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="nasm">### Programa: sum.s
### Descripción: realiza la suma de la serie 1,2,3,...N
### gcc -m32 -g -nostartfiles -o sum1toN sum1toN.s
### Ensamblaje as --32 --gstabs fuente.s -o objeto.o
### linker -&gt; ld -melf_i386 -I/lib/i386-linux-gnu/ld-linux.so.2   -o ejecutable objeto.o -lc

        ##  Declaración de variables
        .section .data

n:	.int 5

        .global _start

        ##  Comienzo del código
        .section .text
_start:
        mov $0,%ecx # ECX implementa la variable suma
        mov n,%edx
bucle:
        add %edx,%ecx
        sub $1,%edx
        jnz bucle

        mov %ecx, %ebx # el argumento de salida al S.O. a través de EBX según convenio

        ## salida
        mov $1, %eax  # código de la llamada al sistema operativo: subrutina exit
        int $0x80     # llamada al sistema operativo


        .end</code></pre>
</div>
</div>
</li>
<li>
<p>Lenguaje ensamblador AT&amp;T para la arquitectura x86-64</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="nasm">	#### Programa: sum1toN.s
	### Descripción: realiza la suma de la serie 1,2,3,...N. La entrada se define en el propio programa y la salida se pasa al S.O.
	### Lenguaje: Lenguaje ensamblador de GNU para la arquitectura AMD64
	### gcc  -no-pie -g -nostartfiles -o sum1toN  sum1toN.s
	### Ensamblaje as  --gstabs sum1toN.s -o sum1toN.o
        ### linker -&gt; ld    -o sum1toN sum1toN.o
	##  Declaración de variables
	##  SECCION DE DATOS
	  .section .data

n:      .quad 5

	  .global _start

	  ##  Comienzo del código
	  ##  SECCION DE INSTRUCCIONES

	  .section .text
_start:
        movq $0,%rdi # RDI implementa la variable suma
        movq n,%rdx
bucle:
        add %rdx,%rdi
        sub $1,%rdx
        jnz bucle

        ## el argumento de salida al S.O. a través de RDI según convenio ABI AMD64
	## salida
          mov $60, %rax	# código de la llamada al sistema operativo: subrutina exit
	  syscall # llamada al sistema operativo para que ejecute la subrutina según el valor de RAX


	  .end</code></pre>
</div>
</div>
</li>
<li>
<p>ARM</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="armasm">/*      Programa: sum1toN.s
        Descripción: realiza la suma de la serie 1,2,3,...N
        Es el programa en lenguaje ARM equivalente a sum1toN.ias de la máquina IAS de von Neumann
        gcc  -g -nostartfiles -o sum1toN sum1toN.s
        Ensamblaje as  --gstabs sum1toN.s -o sum1toN.o
        linker -&gt; ld     -o sum1toN sum1toN.o
*/
        @  Declaración de variables
        .section .data
n:      .int 5

        .global _start

        @ Comienzo del código
        .section .text
_start:
        mov r0,#0       @ R0 implementa la variable suma
        ldr r2,=n       @ R1 implementa la variable n indirectamente
        ldr r1,[r2]
/* Direccionamiento directo:
        mov r1,n da error porque mov no admite direccionamiento a memoria directo.
                 mov admite direccionamiento inmediato si el literal de  32 bits no tiene repetición de ceros a izda y dcha
                 para convertirlo en un literal de 8 bits seguido de desplazamientos
        ldr r1,n Error: reubicación_interna (tipo OFFSET_IMM) no compuesta
                 Da error al intentar codificar un literal (dirección n) de 32 bits.
*/

bucle:
        add r0,r1
        subs  r1,#1
        bne bucle

        @r0 es el argumento de salida al S.O. a través de EBX según convenio

        /* exit syscall */
        mov r7, #1
        swi #0

        .end</code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="paragraph nav-footer">
<p>← Previous: <a href="_simulador_iassim_2.html">Simulador IASSim</a> | ↑ Up: <a href="_viii_apéndices.html">VIII Apéndices</a> | ⌂ Home: <a href="eecc_book.html">Estructura de Computadores  (240306)</a> | Next: <a href="_rtl_register_transfer_language.html">RTL Register Transfer Language</a> →</p>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2022-09-02 15:42:44 +0200
</div>
</div>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]],
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },
  TeX: { equationNumbers: { autoNumber: "none" } }
})
MathJax.Hub.Register.StartupHook("AsciiMath Jax Ready", function () {
  MathJax.InputJax.AsciiMath.postfilterHooks.Add(function (data, node) {
    if ((node = data.script.parentNode) && (node = node.parentNode) && node.classList.contains("stemblock")) {
      data.math.root.display = "block"
    }
    return data
  })
})
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
</body>
</html>