Operaciones Aritméticas y Lógicas 
=================================

:doctitle: Operaciones Aritméticas y Lógicas 


Introducción
------------


Objetivos
~~~~~~~~~

* Programación:
** Realizar operaciones aritméticas (suma,resta,multiplicación y división) con números enteros. 
* Análisis:
** Comprobar cómo afectan las operaciones lógicas y aritméticas a los flags del registro de estado EFLAGS
** Analizar el contenido de la memoria como números con signo, caracteres, arrays y strings: tipos y tamaños de los operandos numéricos y de los operandos alfanuméricos 
** Realizar la operación de desensamblaje para comprobar el lenguaje máquina del módulo ejecutable cargado en la memoria principal


Conceptos de Arquitectura
~~~~~~~~~~~~~~~~~~~~~~~~~

* La Unidad Aritmético-Lógica ALU sólo opera con números enteros almacenados en los registros de propósito general. Para operar con números reales es necesaria la unidad Float Process Unit FPU con los operandos almacenados en los registros específicos para números en coma flotante.


Módulos fuente
~~~~~~~~~~~~~~

*  *op_arit_log.s*


Requisitos
~~~~~~~~~~

* Teoría: representación de datos, operaciones aritméticas y lógicas, formato de instrucciones y repertorio  ISA de la arquitectura X86.
* Prácticas previas: 
** Introducción a la programación en lenguaje ensamblador AT&T x86-32
** Representación de los Datos


LEEME
-----

* Lectura del guión de prácticas  y del capítulo 3 del Libro Programming from the Ground-Up.
* <<prac_apu, Apuntes y Libro de Texto>>
* <<prac_doc_mem, Documentación Memoria>>: Contenido y Formato de la Memoria 
* <<prac_eval, Evaluación>>: sistema de evaluación
* <<prac_plat_des, Plataforma de Desarrollo>> : configuración de la computadora personal
* <<prac_prog,Programación>> : metodología

Cuestiones
----------

* <<prac_eval, "Autoevaluación de Prácticas">> opcional: <<prac_cues, Prácticas: Cuestionario>>




Registros internos de la CPU
----------------------------

* La arquitecura amd64 dispone de:
** 16 registros de propósito general (RPG) de 64 bits cada uno: rax,rbx,rcx,rdx,rsi,rdi,rsp, etc
** 1 registros de estado de 64 bits: rflags
* El acceso a los registros de propósito general puede ser 'parcial':
** Registro RAX: es un registro de 64 bits
** Registro EAX: son los 32 bits de menor peso de RAX
** Registro AX:  son los 16 bits de menor peso de RAX
** Registro AL:  son los  8 bits de menor peso de RAX
** Registro AH:  es el byte con los bits de las posiciones 8:15 de RAX
* En las <<registros_32, "Hojas de Referencia Rápida">> están representados todos los nombres de los difererentes grupos de bits de cada registro de propósito general.




Operaciones Aritméticas y Lógicas con Números Enteros con Signo
---------------------------------------------------------------

[[practica3:op_arit_log]]
Edición del Módulo fuente: op_arit_log.s
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* Descargar el módulo fuente "op_arit_log.s" de miaulario y añadir los comentarios apropiados.
+


----
### Programa:     op_arit_log.s
### Descripción: Emplear estructuras de datos con diferentes operaciones lógicas y aritméticas.
### Compilación: gcc -m32 -g -o op_arit_log op_arit_log.s
	
	## MACROS
	.equ SYS_EXIT,	1
	.equ SUCCESS,	0
	.equ N,		5

	## VARIABLES LOCALES
	
	
	## INSTRUCCIONES
	.global main
	.text
main:

	## RESET	

	xor  %eax,%eax
	xor  %ebx,%ebx
	xor  %ecx,%ecx
	xor  %edx,%edx
	xor  %esi,%esi
        xor  %edi,%edi
	

	## OPERACIONES ARITMETICAS con NUMEROS ENTEROS
	
	## add: suma
	mov $5,%eax
	mov $10,%ebx
	add %ebx,%eax

	##  sub: resta   <1>
	mov $5,%eax
	mov $10,%ebx
	sub %ebx,%eax
	

	##  imul: multiplicación entera "con signo": AX<- BL*AL  <2>
        movb $-3,%bl
	movb $5,%al
	imulb %bl

        ##  idiv: división "con signo" .   (AL=Cociente, AH=Resto) <- AX/(byte en registro o memoria)	  <3>  
	movw $5,%ax		#dividendo
	movb $3,%bl		#divisor
	idivb %bl	    # 5/3 = 1*3 + 2

        ## complemento a 2: equivalente a cambiar de signo negación
	negb %bl	    


	## Expresión N*(N+1)/2
	movw $N,%bx
	movw $(N+1),%ax
	imulw %bx		#imulw Op ; Op=word ; DX:AX<- AX*Op
	movw $2,%bx
	##  El resultado queda en AX y el resto DX=0 <4>
	idivw %bx		#idivw Op ; Op=word ; AX<-(DX:AX)/Op ; DX:=Resto
	

	## OPERACIONES LOGICAS

	mov $0xFFFF1F, %eax
        mov $0x0000F1, %ebx
	not %eax	# inversión
	and %ebx,%eax	# producto lógico
	or  %ebx,%eax	# suma lógica

        ## Complemento a 2 mediante operación lógica not()+1
	mov %ebx,%eax		
	not %eax
	inc %eax

	## Desplazamiento de bits <5> 
        shr $4,%eax		#desplazamiento lógico: bits a introduccir -> 0..
	sar $4,%eax		#desplazamiento aritmético: bits a introducir -> extensión del signo

	## SALIDA
	
	mov $SYS_EXIT, %eax	
	mov $SUCCESS,  %ebx
	int $0x80
	
	.end
----


<1> Instrucciones referenciadas en las cuestiones de autoevaluación 
<2>    "               "                  "               "
<3>    "               "                  "               "
<4>    "               "                  "               "
<5>    "               "                  "               "

Compilación
~~~~~~~~~~~

* Seguir los pasos de la <<compilacion_asm, compilación >> de un módulo en lenguaje ensamblador.
** El punto de entrada no es "_start".
** +gcc -m32 -g -o op_arit_log op_arit_log.s+

Ejecución
~~~~~~~~~

* +./op_arit_log+
* +echo $?+

Análisis del módulo fuente
~~~~~~~~~~~~~~~~~~~~~~~~~~

* Para la interpretación de las instrucciones add, sub, imul (integer multiplication), idiv (integer division) , neg, not, and, or, xor, shr, sar, consultar la tabla de operaciones de las <<rie, hojas de referencia rápida >>
* Las operaciones únicamente procesan el número de bits que indica el sufijo del mnemónico...aunque los registros "r-x" son de 64 bits.



Ejecución paso a paso
~~~~~~~~~~~~~~~~~~~~~

Observaciones
^^^^^^^^^^^^^

CAUTION: El depurador al visualizar el contenido de los registros: Unicamente visualiza el número de bytes del tamaño de los operandos..aunque los registros "r-x" son de 64 bits. Con números enteros con signo no visualiza los ceros de mayor peso, es decir, ni el signo ni la extensión de signo de los números positivos.


Operaciones
^^^^^^^^^^^

* Compilar el programa con la opción de generación de la tabla de símbolos requerida por el depurador y generar el módulo binario ejecutable:
** +gcc  -m32 -g  -o op_arit_log op_arit_log.s+ donde modulo_fuente se sustituye por el nombre del archivo que se desea compilar.
* Abrir el depurador GDB, cargar el módulo binario ejecutable y comprobar que se carga la tabla de símbolos junto al módulo binario ejecutable.
** +gdb+
** +file op_arit_log+
** +info sources+
* Configurar el fichero para el logging histórico de los comandos.
** +set trace-commands on+
** +set logging file op_arit_log_gdb_asm.txt+ 
** +set logging on+
** +shell ls -l op_arit_log_gdb_asm.txt+
* Activar un punto de ruptura en la instrucción de entrada al programa.
** +b _start+
* Ejecutar el programa deteniéndolo en la primera instrucción del programa.
** +run+


Operaciones aritméticas
^^^^^^^^^^^^^^^^^^^^^^^

* Comprobar los resultados de las operaciones aritméticas de suma, resta, multiplicación, división y negación de números enteros con signo

Operaciones lógicas
^^^^^^^^^^^^^^^^^^^

* Comprobar los resultados de las operaciones lógicas bitwise de negación, multiplicación, suma, or-exclusiva y desplazamiento. 


